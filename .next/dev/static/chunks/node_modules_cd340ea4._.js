(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/highcharts-react-official/dist/highcharts-react.min.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

!function(t, e) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = e(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)")) : "TURBOPACK unreachable";
}("undefined" != typeof self ? self : /*TURBOPACK member replacement*/ __turbopack_context__.e, function(t) {
    return function(t) {
        function e(n) {
            if (r[n]) return r[n].exports;
            var o = r[n] = {
                i: n,
                l: !1,
                exports: {}
            };
            return t[n].call(o.exports, o, o.exports, e), o.l = !0, o.exports;
        }
        var r = {};
        return e.m = t, e.c = r, e.d = function(t, r, n) {
            e.o(t, r) || Object.defineProperty(t, r, {
                configurable: !1,
                enumerable: !0,
                get: n
            });
        }, e.n = function(t) {
            var r = t && t.__esModule ? function() {
                return t.default;
            } : function() {
                return t;
            };
            return e.d(r, "a", r), r;
        }, e.o = function(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e);
        }, e.p = "", e(e.s = 0);
    }([
        function(t, e, r) {
            "use strict";
            function n() {
                return n = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : "TURBOPACK unreachable", n.apply(this, arguments);
            }
            function o(t) {
                return a(t) || i(t) || u(t) || c();
            }
            function c() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function u(t, e) {
                if (t) {
                    if ("string" == typeof t) return f(t, e);
                    var r = Object.prototype.toString.call(t).slice(8, -1);
                    return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? f(t, e) : void 0;
                }
            }
            function i(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
            }
            function a(t) {
                if (Array.isArray(t)) return f(t);
            }
            function f(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for(var r = 0, n = new Array(e); r < e; r++)n[r] = t[r];
                return n;
            }
            function s(t) {
                "@babel/helpers - typeof";
                return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t;
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                })(t);
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), r.d(e, "HighchartsReact", function() {
                return d;
            });
            var p = r(1), l = r.n(p), y = "undefined" != typeof window ? p.useLayoutEffect : p.useEffect, d = Object(p.memo)(Object(p.forwardRef)(function(t, e) {
                var r = Object(p.useRef)(), c = Object(p.useRef)(), u = Object(p.useRef)(t.constructorType), i = Object(p.useRef)(t.highcharts);
                return y(function() {
                    function e() {
                        var e = t.highcharts || "object" === ("undefined" == typeof window ? "undefined" : s(window)) && window.Highcharts, n = t.constructorType || "chart";
                        e ? e[n] ? t.options ? c.current = e[n](r.current, t.options, t.callback) : console.warn('The "options" property was not passed.') : console.warn('The "constructorType" property is incorrect or some required module is not imported.') : console.warn('The "highcharts" property was not passed.');
                    }
                    if (c.current) {
                        if (!1 !== t.allowChartUpdate) if (t.constructorType !== u.current || t.highcharts !== i.current) u.current = t.constructorType, i.current = t.highcharts, e();
                        else if (!t.immutable && c.current) {
                            var n;
                            (n = c.current).update.apply(n, [
                                t.options
                            ].concat(o(t.updateArgs || [
                                !0,
                                !0
                            ])));
                        } else e();
                    } else e();
                }, [
                    t.options,
                    t.allowChartUpdate,
                    t.updateArgs,
                    t.containerProps,
                    t.highcharts,
                    t.constructorType
                ]), y(function() {
                    return function() {
                        c.current && (c.current.destroy(), c.current = null);
                    };
                }, []), Object(p.useImperativeHandle)(e, function() {
                    return {
                        get chart () {
                            return c.current;
                        },
                        container: r
                    };
                }, []), l.a.createElement("div", n({}, t.containerProps, {
                    ref: r
                }));
            }));
            e.default = d;
        },
        function(e, r) {
            e.exports = t;
        }
    ]);
}); //# sourceMappingURL=highcharts-react.min.js.map
}),
"[project]/node_modules/highcharts/highstock.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

!/**
 * Highchart Stock v12.5.0 (2026-01-12)
 * @module highcharts/highstock
 *
 * (c) 2009-2026 Highsoft AS
 *
 * A commercial license may be required depending on use.
 * See www.highcharts.com/license
 */ function(t, e) {
    ("TURBOPACK compile-time truthy", 1) ? (t._Highcharts = e(), module.exports = t._Highcharts) : "TURBOPACK unreachable";
}("u" < typeof window ? /*TURBOPACK member replacement*/ __turbopack_context__.e : window, ()=>(()=>{
        "use strict";
        let t, e, i, s, o, r, a, n, h, l;
        var d, c, p, u, g, f, m, x, y, b, v, k, M, w, S, A, T, C, P, O, E, L, B, D, I, z, R, N, W, G, X, H, F, Y, j = {};
        j.d = (t, e)=>{
            for(var i in e)j.o(e, i) && !j.o(t, i) && Object.defineProperty(t, i, {
                enumerable: !0,
                get: e[i]
            });
        }, j.o = (t, e)=>Object.prototype.hasOwnProperty.call(t, e);
        var U = {};
        j.d(U, {
            default: ()=>gm
        }), (d = v || (v = {})).SVG_NS = "http://www.w3.org/2000/svg", d.product = "Highcharts", d.version = "12.5.0", d.win = "u" > typeof window ? window : {}, d.doc = d.win.document, d.svg = !!d.doc?.createElementNS?.(d.SVG_NS, "svg")?.createSVGRect, d.pageLang = d.doc?.documentElement?.closest("[lang]")?.lang, d.userAgent = d.win.navigator?.userAgent || "", d.isChrome = d.win.chrome, d.isFirefox = -1 !== d.userAgent.indexOf("Firefox"), d.isMS = /(edge|msie|trident)/i.test(d.userAgent) && !d.win.opera, d.isSafari = !d.isChrome && -1 !== d.userAgent.indexOf("Safari"), d.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(d.userAgent), d.isWebKit = -1 !== d.userAgent.indexOf("AppleWebKit"), d.deg2rad = 2 * Math.PI / 360, d.marginNames = [
            "plotTop",
            "marginRight",
            "marginBottom",
            "plotLeft"
        ], d.noop = function() {}, d.supportsPassiveEvents = function() {
            let t = !1;
            if (!d.isMS) {
                let e = Object.defineProperty({}, "passive", {
                    get: function() {
                        t = !0;
                    }
                });
                d.win.addEventListener && d.win.removeEventListener && (d.win.addEventListener("testPassive", d.noop, e), d.win.removeEventListener("testPassive", d.noop, e));
            }
            return t;
        }(), d.charts = [], d.composed = [], d.dateFormats = {}, d.seriesTypes = {}, d.symbolSizes = {}, d.chartCount = 0;
        let V = v, { charts: $, doc: _, win: Z } = V;
        function q(t, e, i, s) {
            let o = e ? "Highcharts error" : "Highcharts warning";
            32 === t && (t = `${o}: Deprecated member`);
            let r = ts(t), a = r ? `${o} #${t}: www.highcharts.com/errors/${t}/` : t.toString();
            if (void 0 !== s) {
                let t = "";
                r && (a += "?"), tu(s, function(e, i) {
                    t += `
 - ${i}: ${e}`, r && (a += encodeURI(i) + "=" + encodeURI(e));
                }), a += t;
            }
            tf(V, "displayError", {
                chart: i,
                code: t,
                message: a,
                params: s
            }, function() {
                if (e) throw Error(a);
                Z.console && -1 === q.messages.indexOf(a) && console.warn(a);
            }), q.messages.push(a);
        }
        function K(t, e) {
            return parseInt(t, e || 10);
        }
        function J(t) {
            return "string" == typeof t;
        }
        function Q(t) {
            let e = Object.prototype.toString.call(t);
            return "[object Array]" === e || "[object Array Iterator]" === e;
        }
        function tt(t, e) {
            return !!t && "object" == typeof t && (!e || !Q(t));
        }
        function te(t) {
            return tt(t) && "number" == typeof t.nodeType;
        }
        function ti(t) {
            let e = t?.constructor;
            return !!(tt(t, !0) && !te(t) && e?.name && "Object" !== e.name);
        }
        function ts(t) {
            return "number" == typeof t && !isNaN(t) && t < 1 / 0 && t > -1 / 0;
        }
        function to(t) {
            return null != t;
        }
        function tr(t, e, i) {
            let s, o = J(e) && !to(i), r = (e, i)=>{
                to(e) ? t.setAttribute(i, e) : o ? (s = t.getAttribute(i)) || "class" !== i || (s = t.getAttribute(i + "Name")) : t.removeAttribute(i);
            };
            return J(e) ? r(i, e) : tu(e, r), s;
        }
        function ta(t) {
            return Q(t) ? t : [
                t
            ];
        }
        function tn(t, e) {
            let i;
            for(i in t || (t = {}), e)t[i] = e[i];
            return t;
        }
        function th() {
            let t = arguments, e = t.length;
            for(let i = 0; i < e; i++){
                let e = t[i];
                if (null != e) return e;
            }
        }
        function tl(t, e) {
            tn(t.style, e);
        }
        function td(t) {
            return Math.pow(10, Math.floor(Math.log(t) / Math.LN10));
        }
        function tc(t, e) {
            return t > 1e14 ? t : parseFloat(t.toPrecision(e || 14));
        }
        (q || (q = {})).messages = [], Math.easeInOutSine = function(t) {
            return -.5 * (Math.cos(Math.PI * t) - 1);
        };
        let tp = Array.prototype.find ? function(t, e) {
            return t.find(e);
        } : function(t, e) {
            let i, s = t.length;
            for(i = 0; i < s; i++)if (e(t[i], i)) return t[i];
        };
        function tu(t, e, i) {
            for(let s in t)Object.hasOwnProperty.call(t, s) && e.call(i || t[s], t[s], s, t);
        }
        function tg(t, e, i) {
            function s(e, i) {
                let s = t.removeEventListener;
                s && s.call(t, e, i, !1);
            }
            function o(i) {
                let o, r;
                t.nodeName && (e ? (o = {})[e] = !0 : o = i, tu(o, function(t, e) {
                    if (i[e]) for(r = i[e].length; r--;)s(e, i[e][r].fn);
                }));
            }
            let r = "function" == typeof t && t.prototype || t;
            if (Object.hasOwnProperty.call(r, "hcEvents")) {
                let t = r.hcEvents;
                if (e) {
                    let r = t[e] || [];
                    i ? (t[e] = r.filter(function(t) {
                        return i !== t.fn;
                    }), s(e, i)) : (o(t), t[e] = []);
                } else o(t), delete r.hcEvents;
            }
        }
        function tf(t, e, i, s) {
            if (i = i || {}, _?.createEvent && (t.dispatchEvent || t.fireEvent && t !== V)) {
                let s = _.createEvent("Events");
                s.initEvent(e, !0, !0), i = tn(s, i), t.dispatchEvent ? t.dispatchEvent(i) : t.fireEvent(e, i);
            } else if (t.hcEvents) {
                i.target || tn(i, {
                    preventDefault: function() {
                        i.defaultPrevented = !0;
                    },
                    target: t,
                    type: e
                });
                let s = [], o = t, r = !1;
                for(; o.hcEvents;)Object.hasOwnProperty.call(o, "hcEvents") && o.hcEvents[e] && (s.length && (r = !0), s.unshift.apply(s, o.hcEvents[e])), o = Object.getPrototypeOf(o);
                r && s.sort((t, e)=>t.order - e.order), s.forEach((e)=>{
                    !1 === e.fn.call(t, i) && i.preventDefault();
                });
            }
            s && !i.defaultPrevented && s.call(t, i);
        }
        let tm = (a = Math.random().toString(36).substring(2, 9) + "-", n = 0, function() {
            return "highcharts-" + (t ? "" : a) + n++;
        });
        Z.jQuery && (Z.jQuery.fn.highcharts = function() {
            let t = [].slice.call(arguments);
            if (this[0]) return t[0] ? (new V[J(t[0]) ? t.shift() : "Chart"](this[0], t[0], t[1]), this) : $[tr(this[0], "data-highcharts-chart")];
        });
        let tx = {
            addEvent: function(t, e, i, s = {}) {
                let o = "function" == typeof t && t.prototype || t;
                Object.hasOwnProperty.call(o, "hcEvents") || (o.hcEvents = {});
                let r = o.hcEvents;
                V.Point && t instanceof V.Point && t.series && t.series.chart && (t.series.chart.runTrackerClick = !0);
                let a = t.addEventListener;
                a && a.call(t, e, i, !!V.supportsPassiveEvents && {
                    passive: void 0 === s.passive ? -1 !== e.indexOf("touch") : s.passive,
                    capture: !1
                }), r[e] || (r[e] = []);
                let n = {
                    fn: i,
                    order: "number" == typeof s.order ? s.order : 1 / 0
                };
                return r[e].push(n), r[e].sort((t, e)=>t.order - e.order), function() {
                    tg(t, e, i);
                };
            },
            arrayMax: function(t) {
                let e = t.length, i = t[0];
                for(; e--;)t[e] > i && (i = t[e]);
                return i;
            },
            arrayMin: function(t) {
                let e = t.length, i = t[0];
                for(; e--;)t[e] < i && (i = t[e]);
                return i;
            },
            attr: tr,
            clamp: function(t, e, i) {
                return t > e ? t < i ? t : i : e;
            },
            clearTimeout: function(t) {
                to(t) && clearTimeout(t);
            },
            correctFloat: tc,
            createElement: function(t, e, i, s, o) {
                let r = _.createElement(t);
                return e && tn(r, e), o && tl(r, {
                    padding: "0",
                    border: "none",
                    margin: "0"
                }), i && tl(r, i), s && s.appendChild(r), r;
            },
            crisp: function(t, e = 0, i) {
                let s = e % 2 / 2, o = i ? -1 : 1;
                return (Math.round(t * o - s) + s) * o;
            },
            css: tl,
            defined: to,
            destroyObjectProperties: function(t, e, i) {
                tu(t, function(s, o) {
                    s !== e && s?.destroy && s.destroy(), (s?.destroy || !i) && delete t[o];
                });
            },
            diffObjects: function(t, e, i, s) {
                let o = {};
                return !function t(e, o, r, a) {
                    let n = i ? o : e;
                    tu(e, function(i, h) {
                        if (!a && s && s.indexOf(h) > -1 && o[h]) {
                            i = ta(i), r[h] = [];
                            for(let e = 0; e < Math.max(i.length, o[h].length); e++)o[h][e] && (void 0 === i[e] ? r[h][e] = o[h][e] : (r[h][e] = {}, t(i[e], o[h][e], r[h][e], a + 1)));
                        } else tt(i, !0) && !i.nodeType ? (r[h] = Q(i) ? [] : {}, t(i, o[h] || {}, r[h], a + 1), 0 === Object.keys(r[h]).length && ("colorAxis" !== h || 0 !== a) && delete r[h]) : (e[h] !== o[h] || h in e && !(h in o)) && "__proto__" !== h && "constructor" !== h && (r[h] = n[h]);
                    });
                }(t, e, o, 0), o;
            },
            discardElement: function(t) {
                t?.parentElement?.removeChild(t);
            },
            erase: function(t, e) {
                let i = t.length;
                for(; i--;)if (t[i] === e) {
                    t.splice(i, 1);
                    break;
                }
            },
            error: q,
            extend: tn,
            extendClass: function(t, e) {
                let i = function() {};
                return i.prototype = new t, tn(i.prototype, e), i;
            },
            find: tp,
            fireEvent: tf,
            getAlignFactor: (t = "")=>({
                    center: .5,
                    right: 1,
                    middle: .5,
                    bottom: 1
                })[t] || 0,
            getClosestDistance: function(t, e) {
                let i, s, o, r, a = !e;
                return t.forEach((t)=>{
                    if (t.length > 1) for(r = s = t.length - 1; r > 0; r--)(o = t[r] - t[r - 1]) < 0 && !a ? (e?.(), e = void 0) : o && (void 0 === i || o < i) && (i = o);
                }), i;
            },
            getMagnitude: td,
            getNestedProperty: function(t, e) {
                let i = t.split(".");
                for(; i.length && to(e);){
                    let t = i.shift();
                    if (void 0 === t || "__proto__" === t) return;
                    if ("this" === t) {
                        let t;
                        return tt(e) && (t = e["@this"]), t ?? e;
                    }
                    let s = e[t.replace(/[\\'"]/g, "")];
                    if (!to(s) || "function" == typeof s || "number" == typeof s.nodeType || s === Z) return;
                    e = s;
                }
                return e;
            },
            getStyle: function t(e, i, s) {
                let o;
                if ("width" === i) {
                    let i = Math.min(e.offsetWidth, e.scrollWidth), s = e.getBoundingClientRect?.().width;
                    return s < i && s >= i - 1 && (i = Math.floor(s)), Math.max(0, i - (t(e, "padding-left", !0) || 0) - (t(e, "padding-right", !0) || 0));
                }
                if ("height" === i) return Math.max(0, Math.min(e.offsetHeight, e.scrollHeight) - (t(e, "padding-top", !0) || 0) - (t(e, "padding-bottom", !0) || 0));
                let r = Z.getComputedStyle(e, void 0);
                return r && (o = r.getPropertyValue(i), th(s, "opacity" !== i) && (o = K(o))), o;
            },
            insertItem: function(t, e) {
                let i, s = t.options.index, o = e.length;
                for(i = t.options.isInternal ? o : 0; i < o + 1; i++)if (!e[i] || ts(s) && s < th(e[i].options.index, e[i]._i) || e[i].options.isInternal) {
                    e.splice(i, 0, t);
                    break;
                }
                return i;
            },
            isArray: Q,
            isClass: ti,
            isDOMElement: te,
            isFunction: function(t) {
                return "function" == typeof t;
            },
            isNumber: ts,
            isObject: tt,
            isString: J,
            merge: function(t, ...e) {
                let i, s = [
                    t,
                    ...e
                ], o = {}, r = function(t, e) {
                    return "object" != typeof t && (t = {}), tu(e, function(i, s) {
                        "__proto__" !== s && "constructor" !== s && (!tt(i, !0) || ti(i) || te(i) ? t[s] = e[s] : t[s] = r(t[s] || {}, i));
                    }), t;
                };
                !0 === t && (o = s[1], s = Array.prototype.slice.call(s, 2));
                let a = s.length;
                for(i = 0; i < a; i++)o = r(o, s[i]);
                return o;
            },
            normalizeTickInterval: function(t, e, i, s, o) {
                let r, a = t;
                i = th(i, td(t));
                let n = t / i;
                for(!e && (e = o ? [
                    1,
                    1.2,
                    1.5,
                    2,
                    2.5,
                    3,
                    4,
                    5,
                    6,
                    8,
                    10
                ] : [
                    1,
                    2,
                    2.5,
                    5,
                    10
                ], !1 === s && (1 === i ? e = e.filter(function(t) {
                    return t % 1 == 0;
                }) : i <= .1 && (e = [
                    1 / i
                ]))), r = 0; r < e.length && (a = e[r], (!o || !(a * i >= t)) && (o || !(n <= (e[r] + (e[r + 1] || e[r])) / 2))); r++);
                return tc(a * i, -Math.round(Math.log(.001) / Math.LN10));
            },
            objectEach: tu,
            offset: function(t) {
                let e = _.documentElement, i = t.parentElement || t.parentNode ? t.getBoundingClientRect() : {
                    top: 0,
                    left: 0,
                    width: 0,
                    height: 0
                };
                return {
                    top: i.top + (Z.pageYOffset || e.scrollTop) - (e.clientTop || 0),
                    left: i.left + (Z.pageXOffset || e.scrollLeft) - (e.clientLeft || 0),
                    width: i.width,
                    height: i.height
                };
            },
            pad: function(t, e, i) {
                return Array((e || 2) + 1 - String(t).replace("-", "").length).join(i || "0") + t;
            },
            pick: th,
            pInt: K,
            pushUnique: function(t, e) {
                return 0 > t.indexOf(e) && !!t.push(e);
            },
            relativeLength: function(t, e, i) {
                return /%$/.test(t) ? e * parseFloat(t) / 100 + (i || 0) : parseFloat(t);
            },
            removeEvent: tg,
            replaceNested: function(t, ...e) {
                let i, s;
                do for (s of (i = t, e))t = t.replace(s[0], s[1]);
                while (t !== i)
                return t;
            },
            splat: ta,
            stableSort: function(t, e) {
                let i, s, o = t.length;
                for(s = 0; s < o; s++)t[s].safeI = s;
                for(t.sort(function(t, s) {
                    return 0 === (i = e(t, s)) ? t.safeI - s.safeI : i;
                }), s = 0; s < o; s++)delete t[s].safeI;
            },
            syncTimeout: function(t, e, i) {
                return e > 0 ? setTimeout(t, e, i) : (t.call(0, i), -1);
            },
            timeUnits: {
                millisecond: 1,
                second: 1e3,
                minute: 6e4,
                hour: 36e5,
                day: 864e5,
                week: 6048e5,
                month: 24192e5,
                year: 314496e5
            },
            ucfirst: function(t) {
                return J(t) ? t.substring(0, 1).toUpperCase() + t.substring(1) : String(t);
            },
            uniqueKey: tm,
            useSerialIds: function(e) {
                return t = th(e, t);
            },
            wrap: function(t, e, i) {
                let s = t[e];
                t[e] = function() {
                    let t = arguments, e = this;
                    return i.apply(this, [
                        function() {
                            return s.apply(e, arguments.length ? arguments : t);
                        }
                    ].concat([].slice.call(arguments)));
                };
            }
        }, { pageLang: ty, win: tb } = V, { defined: tv, error: tk, extend: tM, isNumber: tw, isObject: tS, isString: tA, merge: tT, objectEach: tC, pad: tP, splat: tO, timeUnits: tE, ucfirst: tL } = tx, tB = V.isSafari && tb.Intl && !tb.Intl.DateTimeFormat.prototype.formatRange, tD = class {
            constructor(t, e){
                this.options = {
                    timezone: "UTC"
                }, this.variableTimezone = !1, this.Date = tb.Date, this.update(t), this.lang = e;
            }
            update(t = {}) {
                this.dTLCache = {}, this.options = t = tT(!0, this.options, t);
                let { timezoneOffset: e, useUTC: i, locale: s } = t;
                this.Date = t.Date || tb.Date || Date;
                let o = t.timezone;
                tv(i) && (o = i ? "UTC" : void 0), e && e % 60 == 0 && (o = "Etc/GMT" + (e > 0 ? "+" : "") + e / 60), this.variableTimezone = "UTC" !== o && o?.indexOf("Etc/GMT") !== 0, this.timezone = o, this.lang && s && (this.lang.locale = s), [
                    "months",
                    "shortMonths",
                    "weekdays",
                    "shortWeekdays"
                ].forEach((t)=>{
                    let e = /months/i.test(t), i = /short/.test(t), s = {
                        timeZone: "UTC"
                    };
                    s[e ? "month" : "weekday"] = i ? "short" : "long", this[t] = (e ? [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ] : [
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ]).map((t)=>this.dateFormat(s, (e ? 31 : 1) * 24 * 36e5 * t));
                });
            }
            toParts(t) {
                let [e, i, s, o, r, a, n] = this.dateTimeFormat({
                    weekday: "narrow",
                    day: "numeric",
                    month: "numeric",
                    year: "numeric",
                    hour: "numeric",
                    minute: "numeric",
                    second: "numeric"
                }, t, "es").split(/(?:, | |\/|:)/g);
                return [
                    o,
                    s - 1,
                    i,
                    r,
                    a,
                    n,
                    Math.floor(Number(t) || 0) % 1e3,
                    "DLMXJVS".indexOf(e)
                ].map(Number);
            }
            dateTimeFormat(t, e, i = this.options.locale || ty) {
                let s = JSON.stringify(t) + i;
                tA(t) && (t = this.str2dtf(t));
                let o = this.dTLCache[s];
                if (!o) {
                    t.timeZone ?? (t.timeZone = this.timezone);
                    try {
                        o = new Intl.DateTimeFormat(i, t);
                    } catch (e) {
                        /Invalid time zone/i.test(e.message) ? (tk(34), t.timeZone = "UTC", o = new Intl.DateTimeFormat(i, t)) : tk(e.message, !1);
                    }
                }
                return this.dTLCache[s] = o, o?.format(e) || "";
            }
            str2dtf(t, e = {}) {
                let i = {
                    L: {
                        fractionalSecondDigits: 3
                    },
                    S: {
                        second: "2-digit"
                    },
                    M: {
                        minute: "numeric"
                    },
                    H: {
                        hour: "2-digit"
                    },
                    k: {
                        hour: "numeric"
                    },
                    E: {
                        weekday: "narrow"
                    },
                    a: {
                        weekday: "short"
                    },
                    A: {
                        weekday: "long"
                    },
                    d: {
                        day: "2-digit"
                    },
                    e: {
                        day: "numeric"
                    },
                    b: {
                        month: "short"
                    },
                    B: {
                        month: "long"
                    },
                    m: {
                        month: "2-digit"
                    },
                    o: {
                        month: "numeric"
                    },
                    y: {
                        year: "2-digit"
                    },
                    Y: {
                        year: "numeric"
                    }
                };
                return Object.keys(i).forEach((s)=>{
                    -1 !== t.indexOf(s) && tM(e, i[s]);
                }), e;
            }
            makeTime(t, e, i = 1, s = 0, o, r, a) {
                let n = this.Date.UTC(t, e, i, s, o || 0, r || 0, a || 0);
                if ("UTC" !== this.timezone) {
                    let t = this.getTimezoneOffset(n);
                    if (n += t, -1 !== [
                        2,
                        3,
                        8,
                        9,
                        10,
                        11
                    ].indexOf(e) && (s < 5 || s > 20)) {
                        let e = this.getTimezoneOffset(n);
                        t !== e ? n += e - t : t - 36e5 !== this.getTimezoneOffset(n - 36e5) || tB || (n -= 36e5);
                    }
                }
                return n;
            }
            parse(t) {
                if (!tA(t)) return t ?? void 0;
                let e = (t = t.replace(/\//g, "-").replace(/(GMT|UTC)/, "")).indexOf("Z") > -1 || /([+-][0-9]{2}):?[0-9]{2}$/.test(t), i = /^[0-9]{4}-[0-9]{2}(-[0-9]{2}|)$/.test(t);
                e || i || (t += "Z");
                let s = Date.parse(t);
                if (tw(s)) return s + (!e || i ? this.getTimezoneOffset(s) : 0);
            }
            getTimezoneOffset(t) {
                if ("UTC" !== this.timezone) {
                    let [e, i, s, o, r = 0] = this.dateTimeFormat({
                        timeZoneName: "shortOffset"
                    }, t, "en").split(/(GMT|:)/).map(Number), a = -(60 * (s + r / 60) * 6e4);
                    if (tw(a)) return a;
                }
                return 0;
            }
            dateFormat(t, e, i) {
                let s = this.lang;
                if (!tv(e) || isNaN(e)) return s?.invalidDate || "";
                if (tA(t = t ?? "%Y-%m-%d %H:%M:%S")) {
                    let i, o = /%\[([a-zA-Z]+)\]/g;
                    for(; i = o.exec(t);)t = t.replace(i[0], this.dateTimeFormat(i[1], e, s?.locale));
                }
                if (tA(t) && -1 !== t.indexOf("%")) {
                    let i = this, [o, r, a, n, h, l, d, c] = this.toParts(e), p = s?.weekdays || this.weekdays, u = s?.shortWeekdays || this.shortWeekdays, g = s?.months || this.months, f = s?.shortMonths || this.shortMonths;
                    tC(tM({
                        a: u ? u[c] : p[c].substr(0, 3),
                        A: p[c],
                        d: tP(a),
                        e: tP(a, 2, " "),
                        w: c,
                        v: s?.weekFrom ?? "",
                        b: f[r],
                        B: g[r],
                        m: tP(r + 1),
                        o: r + 1,
                        y: o.toString().substr(2, 2),
                        Y: o,
                        H: tP(n),
                        k: n,
                        I: tP(n % 12 || 12),
                        l: n % 12 || 12,
                        M: tP(h),
                        p: n < 12 ? "AM" : "PM",
                        P: n < 12 ? "am" : "pm",
                        S: tP(l),
                        L: tP(d, 3)
                    }, V.dateFormats), function(s, o) {
                        if (tA(t)) for(; -1 !== t.indexOf("%" + o);)t = t.replace("%" + o, "function" == typeof s ? s.call(i, e) : s);
                    });
                } else if (tS(t)) {
                    let i = (this.getTimezoneOffset(e) || 0) / 36e5, s = this.timezone || "Etc/GMT" + (i >= 0 ? "+" : "") + i, { prefix: o = "", suffix: r = "" } = t;
                    t = o + this.dateTimeFormat(tM({
                        timeZone: s
                    }, t), e) + r;
                }
                return i ? tL(t) : t;
            }
            resolveDTLFormat(t) {
                return tS(t, !0) ? tS(t, !0) && void 0 === t.main ? {
                    main: t
                } : t : {
                    main: (t = tO(t))[0],
                    from: t[1],
                    to: t[2]
                };
            }
            getDateFormat(t, e, i, s) {
                let o = this.dateFormat("%m-%d %H:%M:%S.%L", e), r = "01-01 00:00:00.000", a = {
                    millisecond: 15,
                    second: 12,
                    minute: 9,
                    hour: 6,
                    day: 3
                }, n = "millisecond", h = n;
                for(n in tE){
                    if (t && t === tE.week && +this.dateFormat("%w", e) === i && o.substr(6) === r.substr(6)) {
                        n = "week";
                        break;
                    }
                    if (t && tE[n] > t) {
                        n = h;
                        break;
                    }
                    if (a[n] && o.substr(a[n]) !== r.substr(a[n])) break;
                    "week" !== n && (h = n);
                }
                return this.resolveDTLFormat(s[n]).main;
            }
        }, { defined: tI, extend: tz, timeUnits: tR } = tx, tN = class extends tD {
            getTimeTicks(t, e, i, s) {
                let o = this, r = [], a = {}, { count: n = 1, unitRange: h } = t, [l, d, c, p, u, g] = o.toParts(e), f = (e || 0) % 1e3, m;
                if (s ?? (s = 1), tI(e)) {
                    if (f = h >= tR.second ? 0 : n * Math.floor(f / n), h >= tR.second && (g = h >= tR.minute ? 0 : n * Math.floor(g / n)), h >= tR.minute && (u = h >= tR.hour ? 0 : n * Math.floor(u / n)), h >= tR.hour && (p = h >= tR.day ? 0 : n * Math.floor(p / n)), h >= tR.day && (c = h >= tR.month ? 1 : Math.max(1, n * Math.floor(c / n))), h >= tR.month && (d = h >= tR.year ? 0 : n * Math.floor(d / n)), h >= tR.year && (l -= l % n), h === tR.week) {
                        n && (e = o.makeTime(l, d, c, p, u, g, f));
                        let t = this.dateTimeFormat({
                            timeZone: this.timezone,
                            weekday: "narrow"
                        }, e, "es"), i = "DLMXJVS".indexOf(t);
                        c += -i + s + (i < s ? -7 : 0);
                    }
                    e = o.makeTime(l, d, c, p, u, g, f), o.variableTimezone && tI(i) && (m = i - e > 4 * tR.month || o.getTimezoneOffset(e) !== o.getTimezoneOffset(i));
                    let t = e, x = 1;
                    for(; t < i;)r.push(t), h === tR.year ? t = o.makeTime(l + x * n, 0) : h === tR.month ? t = o.makeTime(l, d + x * n) : m && (h === tR.day || h === tR.week) ? t = o.makeTime(l, d, c + x * n * (h === tR.day ? 1 : 7)) : m && h === tR.hour && n > 1 ? t = o.makeTime(l, d, c, p + x * n) : t += h * n, x++;
                    r.push(t), h <= tR.hour && r.length < 1e4 && r.forEach((t)=>{
                        t % 18e5 == 0 && "000000000" === o.dateFormat("%H%M%S%L", t) && (a[t] = "day");
                    });
                }
                return r.info = tz(t, {
                    higherRanks: a,
                    totalRange: h * n
                }), r;
            }
        }, { isTouchDevice: tW } = V, { fireEvent: tG, merge: tX } = tx, tH = {
            colors: [
                "#2caffe",
                "#544fc5",
                "#00e272",
                "#fe6a35",
                "#6b8abc",
                "#d568fb",
                "#2ee0ca",
                "#fa4b42",
                "#feb56a",
                "#91e8e1"
            ],
            symbols: [
                "circle",
                "diamond",
                "square",
                "triangle",
                "triangle-down"
            ],
            lang: {
                weekFrom: "week from",
                chartTitle: "Chart title",
                locale: void 0,
                loading: "Loading...",
                months: void 0,
                seriesName: "Series {add index 1}",
                shortMonths: void 0,
                weekdays: void 0,
                numericSymbols: [
                    "k",
                    "M",
                    "G",
                    "T",
                    "P",
                    "E"
                ],
                pieSliceName: "Slice",
                resetZoom: "Reset zoom",
                yAxisTitle: "Values",
                resetZoomTitle: "Reset zoom level 1:1"
            },
            global: {
                buttonTheme: {
                    fill: "#f7f7f7",
                    padding: 8,
                    r: 2,
                    stroke: "#cccccc",
                    "stroke-width": 1,
                    style: {
                        color: "#333333",
                        cursor: "pointer",
                        fontSize: "0.8em",
                        fontWeight: "normal"
                    },
                    states: {
                        hover: {
                            fill: "#e6e6e6"
                        },
                        select: {
                            fill: "#e6e9ff",
                            style: {
                                color: "#000000",
                                fontWeight: "bold"
                            }
                        },
                        disabled: {
                            style: {
                                color: "#cccccc"
                            }
                        }
                    }
                }
            },
            time: {
                Date: void 0,
                timezone: "UTC",
                timezoneOffset: 0,
                useUTC: void 0
            },
            chart: {
                alignThresholds: !1,
                panning: {
                    enabled: !1,
                    type: "x"
                },
                styledMode: !1,
                borderRadius: 0,
                colorCount: 10,
                allowMutatingData: !0,
                ignoreHiddenSeries: !0,
                spacing: [
                    10,
                    10,
                    15,
                    10
                ],
                resetZoomButton: {
                    theme: {},
                    position: {}
                },
                reflow: !0,
                type: "line",
                zooming: {
                    singleTouch: !1,
                    resetButton: {
                        theme: {
                            zIndex: 6
                        },
                        position: {
                            align: "right",
                            x: -10,
                            y: 10
                        }
                    }
                },
                width: null,
                height: null,
                borderColor: "#334eff",
                backgroundColor: "#ffffff",
                plotBorderColor: "#cccccc"
            },
            title: {
                style: {
                    color: "#333333",
                    fontWeight: "bold"
                },
                text: "Chart title",
                margin: 15,
                minScale: .67
            },
            subtitle: {
                style: {
                    color: "#666666",
                    fontSize: "0.8em"
                },
                text: ""
            },
            caption: {
                margin: 15,
                style: {
                    color: "#666666",
                    fontSize: "0.8em"
                },
                text: "",
                align: "left",
                verticalAlign: "bottom"
            },
            plotOptions: {},
            legend: {
                enabled: !0,
                align: "center",
                alignColumns: !0,
                className: "highcharts-no-tooltip",
                events: {},
                layout: "horizontal",
                itemMarginBottom: 2,
                itemMarginTop: 2,
                labelFormatter: function() {
                    return this.name;
                },
                borderColor: "#999999",
                borderRadius: 0,
                navigation: {
                    style: {
                        fontSize: "0.8em"
                    },
                    activeColor: "#0022ff",
                    inactiveColor: "#cccccc"
                },
                itemStyle: {
                    color: "#333333",
                    cursor: "pointer",
                    fontSize: "0.8em",
                    textDecoration: "none",
                    textOverflow: "ellipsis"
                },
                itemHoverStyle: {
                    color: "#000000"
                },
                itemHiddenStyle: {
                    color: "#666666",
                    textDecoration: "line-through"
                },
                shadow: !1,
                itemCheckboxStyle: {
                    position: "absolute",
                    width: "13px",
                    height: "13px"
                },
                squareSymbol: !0,
                symbolPadding: 5,
                verticalAlign: "bottom",
                x: 0,
                y: 0,
                title: {
                    style: {
                        color: "#333333",
                        fontSize: "0.8em",
                        fontWeight: "bold"
                    }
                }
            },
            loading: {
                labelStyle: {
                    fontWeight: "bold",
                    position: "relative",
                    top: "45%"
                },
                style: {
                    position: "absolute",
                    backgroundColor: "#ffffff",
                    opacity: .5,
                    textAlign: "center"
                }
            },
            tooltip: {
                enabled: !0,
                animation: {
                    duration: 300,
                    easing: (t)=>Math.sqrt(1 - Math.pow(t - 1, 2))
                },
                borderRadius: 3,
                dateTimeLabelFormats: {
                    millisecond: "%[AebHMSL]",
                    second: "%[AebHMS]",
                    minute: "%[AebHM]",
                    hour: "%[AebHM]",
                    day: "%[AebY]",
                    week: "%v %[AebY]",
                    month: "%[BY]",
                    year: "%Y"
                },
                footerFormat: "",
                headerShape: "callout",
                hideDelay: 500,
                padding: 8,
                position: {
                    x: 0,
                    y: 3
                },
                shared: !1,
                snap: tW ? 25 : 10,
                headerFormat: '<span style="font-size: 0.8em">{ucfirst point.key}</span><br/>',
                pointFormat: '<span style="color:{point.color}">‚óè</span> {series.name}: <b>{point.y}</b><br/>',
                backgroundColor: "#ffffff",
                borderWidth: void 0,
                stickOnContact: !1,
                style: {
                    color: "#333333",
                    cursor: "default",
                    fontSize: "0.8em"
                },
                useHTML: !1
            },
            credits: {
                enabled: !0,
                href: "https://www.highcharts.com?credits",
                position: {
                    align: "right",
                    x: -10,
                    verticalAlign: "bottom",
                    y: -5
                },
                style: {
                    cursor: "pointer",
                    color: "#999999",
                    fontSize: "0.6em"
                },
                text: "Highcharts.com"
            }
        }, tF = new tN(tH.time, tH.lang), tY = {
            defaultOptions: tH,
            defaultTime: tF,
            getOptions: function() {
                return tH;
            },
            setOptions: function(t) {
                return tG(V, "setOptions", {
                    options: t
                }), tX(!0, tH, t), t.time && tF.update(tH.time), t.lang && "locale" in t.lang && tF.update({
                    locale: t.lang.locale
                }), t.lang?.chartTitle && (tH.title = {
                    ...tH.title,
                    text: t.lang.chartTitle
                }), tH;
            }
        }, { win: tj } = V, { isNumber: tU, isString: tV, merge: t$, pInt: t_, defined: tZ } = tx, tq = (t, e, i)=>`color-mix(in srgb,${t},${e} ${100 * i}%)`, tK = (t)=>tV(t) && !!t && "none" !== t;
        class tJ {
            static parse(t) {
                return t ? new tJ(t) : tJ.None;
            }
            constructor(t){
                let e, i, s, o;
                this.rgba = [
                    NaN,
                    NaN,
                    NaN,
                    NaN
                ], this.input = t;
                const r = V.Color;
                if (r && r !== tJ) return new r(t);
                if ("object" == typeof t && void 0 !== t.stops) this.stops = t.stops.map((t)=>new tJ(t[1]));
                else if ("string" == typeof t) for(this.input = t = tJ.names[t.toLowerCase()] || t, s = tJ.parsers.length; s-- && !i;)(e = (o = tJ.parsers[s]).regex.exec(t)) && (i = o.parse(e));
                i && (this.rgba = i);
            }
            get(t) {
                let e = this.input, i = this.rgba;
                if (this.output) return this.output;
                if ("object" == typeof e && void 0 !== this.stops) {
                    let i = t$(e);
                    return i.stops = [].slice.call(i.stops), this.stops.forEach((e, s)=>{
                        i.stops[s] = [
                            i.stops[s][0],
                            e.get(t)
                        ];
                    }), i;
                }
                return i && tU(i[0]) ? "rgb" !== t && (t || 1 !== i[3]) ? "a" === t ? `${i[3]}` : "rgba(" + i.join(",") + ")" : "rgb(" + i[0] + "," + i[1] + "," + i[2] + ")" : e;
            }
            brighten(t) {
                let e = this.rgba;
                if (this.stops) this.stops.forEach(function(e) {
                    e.brighten(t);
                });
                else if (tU(t) && 0 !== t) if (tU(e[0])) for(let i = 0; i < 3; i++)e[i] += t_(255 * t), e[i] < 0 && (e[i] = 0), e[i] > 255 && (e[i] = 255);
                else tJ.useColorMix && tK(this.input) && (this.output = tq(this.input, t > 0 ? "white" : "black", Math.abs(t)));
                return this;
            }
            setOpacity(t) {
                return this.rgba[3] = t, this;
            }
            tweenTo(t, e) {
                let i = this.rgba, s = t.rgba;
                if (!tU(i[0]) || !tU(s[0])) return tJ.useColorMix && tK(this.input) && tK(t.input) && e < .99 ? tq(this.input, t.input, e) : t.input || "none";
                let o = 1 !== s[3] || 1 !== i[3], r = (t, s)=>t + (i[s] - t) * (1 - e), a = s.slice(0, 3).map(r).map(Math.round);
                return o && a.push(r(s[3], 3)), (o ? "rgba(" : "rgb(") + a.join(",") + ")";
            }
        }
        tJ.names = {
            white: "#ffffff",
            black: "#000000"
        }, tJ.parsers = [
            {
                regex: /rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?(?:\.\d+)?)\s*\)/,
                parse: function(t) {
                    return [
                        t_(t[1]),
                        t_(t[2]),
                        t_(t[3]),
                        parseFloat(t[4], 10)
                    ];
                }
            },
            {
                regex: /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/,
                parse: function(t) {
                    return [
                        t_(t[1]),
                        t_(t[2]),
                        t_(t[3]),
                        1
                    ];
                }
            },
            {
                regex: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i,
                parse: function(t) {
                    return [
                        t_(t[1] + t[1], 16),
                        t_(t[2] + t[2], 16),
                        t_(t[3] + t[3], 16),
                        tZ(t[4]) ? t_(t[4] + t[4], 16) / 255 : 1
                    ];
                }
            },
            {
                regex: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i,
                parse: function(t) {
                    return [
                        t_(t[1], 16),
                        t_(t[2], 16),
                        t_(t[3], 16),
                        tZ(t[4]) ? t_(t[4], 16) / 255 : 1
                    ];
                }
            }
        ], tJ.useColorMix = tj.CSS?.supports("color", "color-mix(in srgb,red,blue 9%)"), tJ.None = new tJ("");
        let { parse: tQ } = tJ, { win: t0 } = V, { isNumber: t1, objectEach: t2 } = tx;
        class t3 {
            constructor(t, e, i){
                this.pos = NaN, this.options = e, this.elem = t, this.prop = i;
            }
            dSetter() {
                let t = this.paths, e = t?.[0], i = t?.[1], s = this.now || 0, o = [];
                if (1 !== s && e && i) if (e.length === i.length && s < 1) for(let t = 0; t < i.length; t++){
                    let r = e[t], a = i[t], n = [];
                    for(let t = 0; t < a.length; t++){
                        let e = r[t], i = a[t];
                        t1(e) && t1(i) && ("A" !== a[0] || 4 !== t && 5 !== t) ? n[t] = e + s * (i - e) : n[t] = i;
                    }
                    o.push(n);
                }
                else o = i;
                else o = this.toD || [];
                this.elem.attr("d", o, void 0, !0);
            }
            update() {
                let t = this.elem, e = this.prop, i = this.now, s = this.options.step;
                this[e + "Setter"] ? this[e + "Setter"]() : t.attr ? t.element && t.attr(e, i, null, !0) : t.style[e] = i + this.unit, s && s.call(t, i, this);
            }
            run(t, e, i) {
                let s = this, o = s.options, r = function(t) {
                    return !r.stopped && s.step(t);
                }, a = t0.requestAnimationFrame || function(t) {
                    setTimeout(t, 13);
                }, n = function() {
                    for(let t = 0; t < t3.timers.length; t++)t3.timers[t]() || t3.timers.splice(t--, 1);
                    t3.timers.length && a(n);
                };
                t !== e || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date, this.start = t, this.end = e, this.unit = i, this.now = this.start, this.pos = 0, r.elem = this.elem, r.prop = this.prop, r() && 1 === t3.timers.push(r) && a(n)) : (delete o.curAnim[this.prop], o.complete && 0 === Object.keys(o.curAnim).length && o.complete.call(this.elem));
            }
            step(t) {
                let e, i, s = +new Date, o = this.options, r = this.elem, a = o.complete, n = o.duration, h = o.curAnim;
                return r.attr && !r.element ? e = !1 : t || s >= n + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), h[this.prop] = !0, i = !0, t2(h, function(t) {
                    !0 !== t && (i = !1);
                }), i && a && a.call(r), e = !1) : (this.pos = o.easing((s - this.startTime) / n), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e = !0), e;
            }
            initPath(t, e, i) {
                let s = t.startX, o = t.endX, r = i.slice(), a = t.isArea, n = a ? 2 : 1, h = e && i.length > e.length && i.hasStackedCliffs, l, d, c, p, u = e?.slice();
                if (!u || h) return [
                    r,
                    r
                ];
                function g(t, e) {
                    for(; t.length < d;){
                        let i = t[0], s = e[d - t.length];
                        if (s && "M" === i[0] && ("C" === s[0] ? t[0] = [
                            "C",
                            i[1],
                            i[2],
                            i[1],
                            i[2],
                            i[1],
                            i[2]
                        ] : t[0] = [
                            "L",
                            i[1],
                            i[2]
                        ]), t.unshift(i), a) {
                            let e = t.pop();
                            t.push(t[t.length - 1], e);
                        }
                    }
                }
                function f(t) {
                    for(; t.length < d;){
                        let e = t[Math.floor(t.length / n) - 1].slice();
                        if ("C" === e[0] && (e[1] = e[5], e[2] = e[6]), a) {
                            let i = t[Math.floor(t.length / n)].slice();
                            t.splice(t.length / 2, 0, e, i);
                        } else t.push(e);
                    }
                }
                if (s && o && o.length) {
                    for(c = 0; c < s.length; c++)if (s[c] === o[0]) {
                        l = c;
                        break;
                    } else if (s[0] === o[o.length - s.length + c]) {
                        l = c, p = !0;
                        break;
                    } else if (s[s.length - 1] === o[o.length - s.length + c]) {
                        l = s.length - c;
                        break;
                    }
                    void 0 === l && (u = []);
                }
                return u.length && t1(l) && (d = r.length + l * n, p ? (g(u, r), f(r)) : (g(r, u), f(u))), [
                    u,
                    r
                ];
            }
            fillSetter() {
                t3.prototype.strokeSetter.apply(this, arguments);
            }
            strokeSetter() {
                this.elem.attr(this.prop, tQ(this.start).tweenTo(tQ(this.end), this.pos), void 0, !0);
            }
        }
        t3.timers = [];
        let { defined: t5, getStyle: t6, isArray: t9, isNumber: t4, isObject: t8, merge: t7, objectEach: et, pick: ee } = tx;
        function ei(t) {
            return t8(t) ? t7({
                duration: 500,
                defer: 0
            }, t) : {
                duration: 500 * !!t,
                defer: 0
            };
        }
        function es(t, e) {
            let i = t3.timers.length;
            for(; i--;)t3.timers[i].elem !== t || e && e !== t3.timers[i].prop || (t3.timers[i].stopped = !0);
        }
        let eo = {
            animate: function(t, e, i) {
                let s, o = "", r, a, n;
                t8(i) || (n = arguments, i = {
                    duration: n[2],
                    easing: n[3],
                    complete: n[4]
                }), t4(i.duration) || (i.duration = 400), i.easing = "function" == typeof i.easing ? i.easing : Math[i.easing] || Math.easeInOutSine, i.curAnim = t7(e), et(e, function(n, h) {
                    es(t, h), a = new t3(t, i, h), r = void 0, "d" === h && t9(e.d) ? (a.paths = a.initPath(t, t.pathArray, e.d), a.toD = e.d, s = 0, r = 1) : t.attr ? s = t.attr(h) : (s = parseFloat(t6(t, h)) || 0, "opacity" !== h && (o = "px")), r || (r = n), "string" == typeof r && r.match("px") && (r = r.replace(/px/g, "")), a.run(s, r, o);
                });
            },
            animObject: ei,
            getDeferredAnimation: function(t, e, i) {
                let s = ei(e), o = i ? [
                    i
                ] : t.series, r = 0, a = 0;
                return o.forEach((t)=>{
                    let i = ei(t.options.animation);
                    r = t8(e) && t5(e.defer) ? s.defer : Math.max(r, i.duration + i.defer), a = Math.min(s.duration, i.duration);
                }), t.renderer.forExport && (r = 0), {
                    defer: Math.max(0, r - a),
                    duration: Math.min(r, a)
                };
            },
            setAnimation: function(t, e) {
                e.renderer.globalAnimation = ee(t, e.options.chart.animation, !0);
            },
            stop: es
        }, { SVG_NS: er, win: ea } = V, { attr: en, createElement: eh, css: el, error: ed, isFunction: ec, isString: ep, objectEach: eu, splat: eg } = tx, { trustedTypes: ef } = ea, em = ef && ec(ef.createPolicy) && ef.createPolicy("highcharts", {
            createHTML: (t)=>t
        }), ex = em ? em.createHTML("") : "";
        class ey {
            static filterUserAttributes(t) {
                return eu(t, (e, i)=>{
                    let s = !0;
                    -1 === ey.allowedAttributes.indexOf(i) && (s = !1), -1 !== [
                        "background",
                        "dynsrc",
                        "href",
                        "lowsrc",
                        "src"
                    ].indexOf(i) && (s = ep(e) && ey.allowedReferences.some((t)=>0 === e.indexOf(t))), s || (ed(33, !1, void 0, {
                        "Invalid attribute in config": `${i}`
                    }), delete t[i]), ep(e) && t[i] && (t[i] = e.replace(/</g, "&lt;"));
                }), t;
            }
            static parseStyle(t) {
                return t.split(";").reduce((t, e)=>{
                    let i = e.split(":").map((t)=>t.trim()), s = i.shift();
                    return s && i.length && (t[s.replace(/-([a-z])/g, (t)=>t[1].toUpperCase())] = i.join(":")), t;
                }, {});
            }
            static setElementHTML(t, e) {
                t.innerHTML = ey.emptyHTML, e && new ey(e).addToDOM(t);
            }
            constructor(t){
                this.nodes = "string" == typeof t ? this.parseMarkup(t) : t;
            }
            addToDOM(t) {
                return function t(e, i) {
                    let s;
                    return eg(e).forEach(function(e) {
                        let o, r = e.tagName, a = e.textContent ? V.doc.createTextNode(e.textContent) : void 0, n = ey.bypassHTMLFiltering;
                        if (r) if ("#text" === r) o = a;
                        else if (-1 !== ey.allowedTags.indexOf(r) || n) {
                            let s = "svg" === r ? er : i.namespaceURI || er, h = V.doc.createElementNS(s, r), l = e.attributes || {};
                            eu(e, function(t, e) {
                                "tagName" !== e && "attributes" !== e && "children" !== e && "style" !== e && "textContent" !== e && (l[e] = t);
                            }), en(h, n ? l : ey.filterUserAttributes(l)), e.style && el(h, e.style), a && h.appendChild(a), t(e.children || [], h), o = h;
                        } else ed(33, !1, void 0, {
                            "Invalid tagName in config": r
                        });
                        o && i.appendChild(o), s = o;
                    }), s;
                }(this.nodes, t);
            }
            parseMarkup(t) {
                let e, i = [];
                t = t.trim().replace(/ style=(["'])/g, " data-style=$1");
                try {
                    e = new DOMParser().parseFromString(em ? em.createHTML(t) : t, "text/html");
                } catch  {}
                if (!e) {
                    let i = eh("div");
                    i.innerHTML = t, e = {
                        body: i
                    };
                }
                let s = (t, e)=>{
                    let i = t.nodeName.toLowerCase(), o = {
                        tagName: i
                    };
                    "#text" === i && (o.textContent = t.textContent || "");
                    let r = t.attributes;
                    if (r) {
                        let t = {};
                        [].forEach.call(r, (e)=>{
                            "data-style" === e.name ? o.style = ey.parseStyle(e.value) : t[e.name] = e.value;
                        }), o.attributes = t;
                    }
                    if (t.childNodes.length) {
                        let e = [];
                        [].forEach.call(t.childNodes, (t)=>{
                            s(t, e);
                        }), e.length && (o.children = e);
                    }
                    e.push(o);
                };
                return [].forEach.call(e.body.childNodes, (t)=>s(t, i)), i;
            }
        }
        ey.allowedAttributes = [
            "alt",
            "aria-controls",
            "aria-describedby",
            "aria-expanded",
            "aria-haspopup",
            "aria-hidden",
            "aria-label",
            "aria-labelledby",
            "aria-live",
            "aria-pressed",
            "aria-readonly",
            "aria-roledescription",
            "aria-selected",
            "class",
            "clip-path",
            "color",
            "colspan",
            "cx",
            "cy",
            "d",
            "disabled",
            "dx",
            "dy",
            "fill",
            "filterUnits",
            "flood-color",
            "flood-opacity",
            "height",
            "href",
            "id",
            "in",
            "in2",
            "markerHeight",
            "markerWidth",
            "offset",
            "opacity",
            "operator",
            "orient",
            "padding",
            "paddingLeft",
            "paddingRight",
            "patternUnits",
            "r",
            "radius",
            "refX",
            "refY",
            "result",
            "role",
            "rowspan",
            "scope",
            "slope",
            "src",
            "startOffset",
            "stdDeviation",
            "stroke-linecap",
            "stroke-width",
            "stroke",
            "style",
            "summary",
            "tabindex",
            "tableValues",
            "target",
            "text-align",
            "text-anchor",
            "textAnchor",
            "textLength",
            "title",
            "type",
            "valign",
            "width",
            "x",
            "x1",
            "x2",
            "xlink:href",
            "y",
            "y1",
            "y2",
            "zIndex"
        ], ey.allowedReferences = [
            "https://",
            "http://",
            "mailto:",
            "/",
            "../",
            "./",
            "#"
        ], ey.allowedTags = [
            "#text",
            "a",
            "abbr",
            "b",
            "br",
            "button",
            "caption",
            "circle",
            "clipPath",
            "code",
            "dd",
            "defs",
            "div",
            "dl",
            "dt",
            "em",
            "feComponentTransfer",
            "feComposite",
            "feDropShadow",
            "feFlood",
            "feFuncA",
            "feFuncB",
            "feFuncG",
            "feFuncR",
            "feGaussianBlur",
            "feMerge",
            "feMergeNode",
            "feMorphology",
            "feOffset",
            "filter",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "hr",
            "i",
            "img",
            "li",
            "linearGradient",
            "marker",
            "ol",
            "p",
            "path",
            "pattern",
            "pre",
            "rect",
            "small",
            "span",
            "stop",
            "strong",
            "style",
            "sub",
            "sup",
            "svg",
            "table",
            "tbody",
            "td",
            "text",
            "textPath",
            "th",
            "thead",
            "title",
            "tr",
            "tspan",
            "u",
            "ul"
        ], ey.emptyHTML = ex, ey.bypassHTMLFiltering = !1;
        let { defaultOptions: eb, defaultTime: ev } = tY, { pageLang: ek } = V, { extend: eM, getNestedProperty: ew, isArray: eS, isNumber: eA, isObject: eT, isString: eC, pick: eP, ucfirst: eO } = tx, eE = {
            add: (t, e)=>t + e,
            divide: (t, e)=>0 !== e ? t / e : "",
            eq: (t, e)=>t == e,
            each: function(t) {
                let e = arguments[arguments.length - 1];
                return !!eS(t) && t.map((i, s)=>eB(e.body, eM(eT(i) ? i : {
                        "@this": i
                    }, {
                        "@index": s,
                        "@first": 0 === s,
                        "@last": s === t.length - 1
                    }))).join("");
            },
            ge: (t, e)=>t >= e,
            gt: (t, e)=>t > e,
            if: (t)=>!!t,
            le: (t, e)=>t <= e,
            lt: (t, e)=>t < e,
            multiply: (t, e)=>t * e,
            ne: (t, e)=>t != e,
            subtract: (t, e)=>t - e,
            ucfirst: eO,
            unless: (t)=>!t
        }, eL = {};
        function eB(t = "", e, i) {
            let s = RegExp("\\{([\\p{L}\\d:\\.,;\\-\\/<>\\[\\]%_@+\"'‚Äô= #\\(\\)]+)\\}", "gu"), o = RegExp("\\(([\\p{L}\\d:\\.,;\\-\\/<>\\[\\]%_@+\"'= ]+)\\)", "gu"), r = [], a = /f$/, n = /\.(\d)/, h = i?.options?.lang || eb.lang, l = i?.time || ev, d = i?.numberFormatter || eD.bind(i), c = (t = "")=>{
                let i;
                return "true" === t || "false" !== t && ((i = Number(t)).toString() === t ? i : /^["'].+["']$/.test(t) ? t.slice(1, -1) : ew(t, e));
            }, p, u, g = 0, f;
            for(; null !== (p = s.exec(t));){
                let i = p, s = o.exec(p[1]);
                s && (p = s, f = !0), u?.isBlock || (u = {
                    ctx: e,
                    expression: p[1],
                    find: p[0],
                    isBlock: "#" === p[1].charAt(0),
                    start: p.index,
                    startInner: p.index + p[0].length,
                    length: p[0].length
                });
                let a = (u.isBlock ? i : p)[1].split(" ")[0].replace("#", "");
                eE[a] && (u.isBlock && a === u.fn && g++, u.fn || (u.fn = a));
                let n = "else" === p[1];
                if (u.isBlock && u.fn && (p[1] === `/${u.fn}` || n)) if (g) !n && g--;
                else {
                    let e = u.startInner, i = t.substr(e, p.index - e);
                    void 0 === u.body ? (u.body = i, u.startInner = p.index + p[0].length) : u.elseBody = i, u.find += i + p[0], n || (r.push(u), u = void 0);
                }
                else u.isBlock || r.push(u);
                if (s && !u?.isBlock) break;
            }
            return r.forEach((s)=>{
                let r, p, { body: u, elseBody: g, expression: f, fn: m } = s;
                if (m) {
                    let t = [
                        s
                    ], o = [], a = f.length, n = 0, h;
                    for(p = 0; p <= a; p++){
                        let t = f.charAt(p);
                        h || '"' !== t && "'" !== t ? h === t && (h = "") : h = t, h || " " !== t && p !== a || (o.push(f.substr(n, p - n)), n = p + 1);
                    }
                    for(p = eE[m].length; p--;)t.unshift(c(o[p + 1]));
                    r = eE[m].apply(e, t), s.isBlock && "boolean" == typeof r && (r = eB(r ? u : g, e, i));
                } else {
                    let t = /^["'].+["']$/.test(f) ? [
                        f
                    ] : f.split(":");
                    if (r = c(t.shift() || ""), t.length && "number" == typeof r) {
                        let e = t.join(":");
                        if (a.test(e)) {
                            let t = parseInt((e.match(n) || [
                                "",
                                "-1"
                            ])[1], 10);
                            null !== r && (r = d(r, t, h.decimalPoint, e.indexOf(",") > -1 ? h.thousandsSep : ""));
                        } else r = l.dateFormat(e, r);
                    }
                    o.lastIndex = 0, o.test(s.find) && eC(r) && (r = `"${r}"`);
                }
                t = t.replace(s.find, eP(r, ""));
            }), f ? eB(t, e, i) : t;
        }
        function eD(t, e, i, s) {
            e *= 1;
            let o, r, [a, n] = (t = +t || 0).toString().split("e").map(Number), h = this?.options?.lang || eb.lang, l = (t.toString().split(".")[1] || "").split("e")[0].length, d = e, c = {};
            i ?? (i = h.decimalPoint), s ?? (s = h.thousandsSep), -1 === e ? e = Math.min(l, 20) : eA(e) ? e && n < 0 && ((r = e + n) >= 0 ? (a = +a.toExponential(r).split("e")[0], e = r) : (a = Math.floor(a), t = e < 20 ? +(a * Math.pow(10, n)).toFixed(e) : 0, n = 0)) : e = 2, n && (e ?? (e = 2), t = a), eA(e) && e >= 0 && (c.minimumFractionDigits = e, c.maximumFractionDigits = e), "" === s && (c.useGrouping = !1);
            let p = s || i, u = p ? "en" : this?.locale || h.locale || ek, g = JSON.stringify(c) + u;
            return o = (eL[g] ?? (eL[g] = new Intl.NumberFormat(u, c))).format(t), p && (o = o.replace(/([,\.])/g, "_$1").replace(/_\,/g, s ?? ",").replace("_.", i ?? ".")), (e || 0 != +o) && (!(n < 0) || d) || (o = "0"), n && 0 != +o && (o += "e" + (n < 0 ? "" : "+") + n), o;
        }
        let eI = {
            dateFormat: function(t, e, i) {
                return ev.dateFormat(t, e, i);
            },
            format: eB,
            helpers: eE,
            numberFormat: eD
        };
        (c = k || (k = {})).rendererTypes = {}, c.getRendererType = function(t = h) {
            return c.rendererTypes[t] || c.rendererTypes[h];
        }, c.registerRendererType = function(t, e, i) {
            c.rendererTypes[t] = e, (!h || i) && (h = t, V.Renderer = e);
        };
        let ez = k, { clamp: eR, pick: eN, pushUnique: eW, stableSort: eG } = tx;
        (M || (M = {})).distribute = function t(e, i, s) {
            let o = e, r = o.reducedLen || i, a = (t, e)=>t.target - e.target, n = [], h = e.length, l = [], d = n.push, c, p, u, g = !0, f, m, x = 0, y;
            for(c = h; c--;)x += e[c].size;
            if (x > r) {
                for(eG(e, (t, e)=>(e.rank || 0) - (t.rank || 0)), u = (y = e[0].rank === e[e.length - 1].rank) ? h / 2 : -1, p = y ? u : h - 1; u && x > r;)f = e[c = Math.floor(p)], eW(l, c) && (x -= f.size), p += u, y && p >= e.length && (u /= 2, p = u);
                l.sort((t, e)=>e - t).forEach((t)=>d.apply(n, e.splice(t, 1)));
            }
            for(eG(e, a), e = e.map((t)=>({
                    size: t.size,
                    targets: [
                        t.target
                    ],
                    align: eN(t.align, .5)
                })); g;){
                for(c = e.length; c--;)f = e[c], m = (Math.min.apply(0, f.targets) + Math.max.apply(0, f.targets)) / 2, f.pos = eR(m - f.size * f.align, 0, i - f.size);
                for(c = e.length, g = !1; c--;)c > 0 && e[c - 1].pos + e[c - 1].size > e[c].pos && (e[c - 1].size += e[c].size, e[c - 1].targets = e[c - 1].targets.concat(e[c].targets), e[c - 1].align = .5, e[c - 1].pos + e[c - 1].size > i && (e[c - 1].pos = i - e[c - 1].size), e.splice(c, 1), g = !0);
            }
            return d.apply(o, n), c = 0, e.some((e)=>{
                let r = 0;
                return (e.targets || []).some(()=>(o[c].pos = e.pos + r, void 0 !== s && Math.abs(o[c].pos - o[c].target) > s) ? (o.slice(0, c + 1).forEach((t)=>delete t.pos), o.reducedLen = (o.reducedLen || i) - .1 * i, o.reducedLen > .1 * i && t(o, i, s), !0) : (r += o[c].size, c++, !1));
            }), eG(o, a), o;
        };
        let eX = M, { animate: eH, animObject: eF, stop: eY } = eo, { deg2rad: ej, doc: eU, svg: eV, SVG_NS: e$, win: e_, isFirefox: eZ } = V, { addEvent: eq, attr: eK, createElement: eJ, crisp: eQ, css: e0, defined: e1, erase: e2, extend: e3, fireEvent: e5, getAlignFactor: e6, isArray: e9, isFunction: e4, isNumber: e8, isObject: e7, isString: it, merge: ie, objectEach: ii, pick: is, pInt: io, pushUnique: ir, replaceNested: ia, syncTimeout: ih, uniqueKey: il } = tx;
        class id {
            _defaultGetter(t) {
                let e = is(this[t + "Value"], this[t], this.element ? this.element.getAttribute(t) : null, 0);
                return /^-?[\d\.]+$/.test(e) && (e = parseFloat(e)), e;
            }
            _defaultSetter(t, e, i) {
                i.setAttribute(e, t);
            }
            add(t) {
                let e, i = this.renderer, s = this.element;
                return t && (this.parentGroup = t), void 0 !== this.textStr && "text" === this.element.nodeName && i.buildText(this), this.added = !0, (!t || t.handleZ || this.zIndex) && (e = this.zIndexSetter()), e || (t ? t.element : i.box).appendChild(s), this.onAdd && this.onAdd(), this;
            }
            addClass(t, e) {
                let i = e ? "" : this.attr("class") || "";
                return (t = (t || "").split(/ /g).reduce(function(t, e) {
                    return -1 === i.indexOf(e) && t.push(e), t;
                }, i ? [
                    i
                ] : []).join(" ")) !== i && this.attr("class", t), this;
            }
            afterSetters() {
                this.doTransform && (this.updateTransform(), this.doTransform = !1);
            }
            align(t, e, i, s = !0) {
                let o = this.renderer, r = o.alignedObjects, a = !!t;
                t ? (this.alignOptions = t, this.alignByTranslate = e, this.alignTo = i) : (t = this.alignOptions || {}, e = this.alignByTranslate, i = this.alignTo);
                let n = !i || it(i) ? i || "renderer" : void 0;
                n && (a && ir(r, this), i = void 0);
                let h = is(i, o[n], o), l = (h.x || 0) + (t.x || 0) + ((h.width || 0) - (t.width || 0)) * e6(t.align), d = (h.y || 0) + (t.y || 0) + ((h.height || 0) - (t.height || 0)) * e6(t.verticalAlign), c = {};
                return t.align && (c["text-align"] = t.align), c[e ? "translateX" : "x"] = Math.round(l), c[e ? "translateY" : "y"] = Math.round(d), s && (this[this.placed ? "animate" : "attr"](c), this.placed = !0), this.alignAttr = c, this;
            }
            alignSetter(t) {
                let e = {
                    left: "start",
                    center: "middle",
                    right: "end"
                };
                e[t] && (this.alignValue = t, this.element.setAttribute("text-anchor", e[t]));
            }
            animate(t, e, i) {
                let s = eF(is(e, this.renderer.globalAnimation, !0)), o = s.defer;
                return eU.hidden && (s.duration = 0), 0 !== s.duration ? (i && (s.complete = i), ih(()=>{
                    this.element && eH(this, t, s);
                }, o)) : (this.attr(t, void 0, i || s.complete), ii(t, function(t, e) {
                    s.step && s.step.call(this, t, {
                        prop: e,
                        pos: 1,
                        elem: this
                    });
                }, this)), this;
            }
            applyTextOutline(t) {
                let e = this.element;
                -1 !== t.indexOf("contrast") && (t = t.replace(/contrast/g, this.renderer.getContrast(e.style.fill)));
                let i = t.indexOf(" "), s = t.substring(i + 1), o = t.substring(0, i);
                if (o && "none" !== o && V.svg) {
                    this.fakeTS = !0, o = o.replace(/(^[\d\.]+)(.*?)$/g, function(t, e, i) {
                        return 2 * Number(e) + i;
                    }), this.removeTextOutline();
                    let t = eU.createElementNS(e$, "tspan");
                    eK(t, {
                        class: "highcharts-text-outline",
                        fill: s,
                        stroke: s,
                        "stroke-width": o,
                        "stroke-linejoin": "round"
                    });
                    let i = e.querySelector("textPath") || e;
                    [].forEach.call(i.childNodes, (e)=>{
                        let i = e.cloneNode(!0);
                        i.removeAttribute && [
                            "fill",
                            "stroke",
                            "stroke-width",
                            "stroke"
                        ].forEach((t)=>i.removeAttribute(t)), t.appendChild(i);
                    });
                    let r = 0;
                    [].forEach.call(i.querySelectorAll("text tspan"), (t)=>{
                        r += Number(t.getAttribute("dy"));
                    });
                    let a = eU.createElementNS(e$, "tspan");
                    a.textContent = "‚Äã", eK(a, {
                        x: Number(e.getAttribute("x")),
                        dy: -r
                    }), t.appendChild(a), i.insertBefore(t, i.firstChild);
                }
            }
            attr(t, e, i, s) {
                let { element: o } = this, r = id.symbolCustomAttribs, a, n, h = this, l;
                return "string" == typeof t && void 0 !== e && (a = t, (t = {})[a] = e), "string" == typeof t ? h = (this[t + "Getter"] || this._defaultGetter).call(this, t, o) : (ii(t, function(e, i) {
                    l = !1, s || eY(this, i), this.symbolName && -1 !== r.indexOf(i) && (n || (this.symbolAttr(t), n = !0), l = !0), this.rotation && ("x" === i || "y" === i) && (this.doTransform = !0), l || (this[i + "Setter"] || this._defaultSetter).call(this, e, i, o);
                }, this), this.afterSetters()), i && i.call(this), h;
            }
            clip(t) {
                if (t && !t.clipPath) {
                    let e = il() + "-", i = this.renderer.createElement("clipPath").attr({
                        id: e
                    }).add(this.renderer.defs);
                    e3(t, {
                        clipPath: i,
                        id: e,
                        count: 0
                    }), t.add(i);
                }
                return this.attr("clip-path", t ? `url(${this.renderer.url}#${t.id})` : "none");
            }
            crisp(t, e) {
                e = Math.round(e || t.strokeWidth || 0);
                let i = t.x || this.x || 0, s = t.y || this.y || 0, o = (t.width || this.width || 0) + i, r = (t.height || this.height || 0) + s, a = eQ(i, e), n = eQ(s, e);
                return e3(t, {
                    x: a,
                    y: n,
                    width: eQ(o, e) - a,
                    height: eQ(r, e) - n
                }), e1(t.strokeWidth) && (t.strokeWidth = e), t;
            }
            complexColor(t, e, i) {
                let s = this.renderer, o, r, a, n, h, l, d, c, p, u, g = [], f;
                e5(this.renderer, "complexColor", {
                    args: arguments
                }, function() {
                    if (t.radialGradient ? r = "radialGradient" : t.linearGradient && (r = "linearGradient"), r) {
                        if (a = t[r], h = s.gradients, l = t.stops, p = i.radialReference, e9(a) && (t[r] = a = {
                            x1: a[0],
                            y1: a[1],
                            x2: a[2],
                            y2: a[3],
                            gradientUnits: "userSpaceOnUse"
                        }), "radialGradient" === r && p && !e1(a.gradientUnits) && (n = a, a = ie(a, s.getRadialAttr(p, n), {
                            gradientUnits: "userSpaceOnUse"
                        })), ii(a, function(t, e) {
                            "id" !== e && g.push(e, t);
                        }), ii(l, function(t) {
                            g.push(t);
                        }), h[g = g.join(",")]) u = h[g].attr("id");
                        else {
                            a.id = u = il();
                            let t = h[g] = s.createElement(r).attr(a).add(s.defs);
                            t.radAttr = n, t.stops = [], l.forEach(function(e) {
                                0 === e[1].indexOf("rgba") ? (d = (o = tJ.parse(e[1])).get("rgb"), c = o.get("a")) : (d = e[1], c = 1);
                                let i = s.createElement("stop").attr({
                                    offset: e[0],
                                    "stop-color": d,
                                    "stop-opacity": c
                                }).add(t);
                                t.stops.push(i);
                            });
                        }
                        f = "url(" + s.url + "#" + u + ")", i.setAttribute(e, f), i.gradient = g, t.toString = function() {
                            return f;
                        };
                    }
                });
            }
            css(t) {
                let e = this.styles, i = {}, s = this.element, o, r = !e;
                if (e && ii(t, function(t, s) {
                    e && e[s] !== t && (i[s] = t, r = !0);
                }), r) {
                    e && (t = e3(e, i)), null === t.width || "auto" === t.width ? delete this.textWidth : "text" === s.nodeName.toLowerCase() && t.width && (o = this.textWidth = io(t.width)), e3(this.styles, t), o && !eV && this.renderer.forExport && delete t.width;
                    let r = eZ && t.fontSize || null;
                    r && (e8(r) || /^\d+$/.test(r)) && (t.fontSize += "px");
                    let a = ie(t);
                    s.namespaceURI === this.SVG_NS && ([
                        "textOutline",
                        "textOverflow",
                        "whiteSpace",
                        "width"
                    ].forEach((t)=>a && delete a[t]), a.color && (a.fill = a.color, delete a.color)), e0(s, a);
                }
                return this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), t.textOutline && this.applyTextOutline(t.textOutline)), this;
            }
            dashstyleSetter(t) {
                let e, i = this["stroke-width"];
                if ("inherit" === i && (i = 1), t) {
                    let s = (t = t.toLowerCase()).replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
                    for(e = s.length; e--;)s[e] = "" + io(s[e]) * is(i, NaN);
                    t = s.join(",").replace(/NaN/g, "none"), this.element.setAttribute("stroke-dasharray", t);
                }
            }
            destroy() {
                let t = this, { element: e = {}, renderer: i, stops: s } = t, o = e.ownerSVGElement, r = "SPAN" === e.nodeName && t.parentGroup || void 0, a;
                if (e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null, eY(t), t.clipPath && o) {
                    let e = t.clipPath;
                    [].forEach.call(o.querySelectorAll("[clip-path],[CLIP-PATH]"), function(t) {
                        t.getAttribute("clip-path").indexOf(e.element.id) > -1 && t.removeAttribute("clip-path");
                    }), t.clipPath = e.destroy();
                }
                if (s) {
                    for (let t of s)t.destroy();
                    s.length = 0;
                }
                for(t.safeRemoveChild(e); r?.div && 0 === r.div.childNodes.length;)a = r.parentGroup, t.safeRemoveChild(r.div), delete r.div, r = a;
                t.alignOptions && e2(i.alignedObjects, t), ii(t, (e, i)=>{
                    (t[i]?.parentGroup === t || -1 !== [
                        "connector",
                        "foreignObject"
                    ].indexOf(i)) && t[i]?.destroy?.(), delete t[i];
                });
            }
            dSetter(t, e, i) {
                e9(t) && ("string" == typeof t[0] && (t = this.renderer.pathToSegments(t)), this.pathArray = t, t = t.reduce((t, e, i)=>e?.join ? (i ? t + " " : "") + e.join(" ") : (e || "").toString(), "")), /(NaN| {2}|^$)/.test(t) && (t = "M 0 0"), this[e] !== t && (i.setAttribute(e, t), this[e] = t);
            }
            fillSetter(t, e, i) {
                "string" == typeof t ? i.setAttribute(e, t) : t && this.complexColor(t, e, i);
            }
            hrefSetter(t, e, i) {
                i.setAttributeNS("http://www.w3.org/1999/xlink", e, t);
            }
            getBBox(t, e) {
                let i, s, o, { element: r, renderer: a, styles: n, textStr: h } = this, { cache: l, cacheKeys: d } = a, c = r.namespaceURI === this.SVG_NS, p = is(e, this.rotation, 0), u = a.styledMode ? r && id.prototype.getStyle.call(r, "font-size") : n.fontSize, g = this.getBBoxCacheKey([
                    a.rootFontSize,
                    this.textWidth,
                    this.alignValue,
                    n.fontWeight,
                    n.lineClamp,
                    n.textOverflow,
                    u,
                    p
                ]);
                if (g && !t && (i = l[g]), !i || i.polygon) {
                    if (c || a.forExport) {
                        try {
                            o = this.fakeTS && function(t) {
                                let e = r.querySelector(".highcharts-text-outline");
                                e && e0(e, {
                                    display: t
                                });
                            }, e4(o) && o("none"), i = r.getBBox ? e3({}, r.getBBox()) : {
                                width: r.offsetWidth,
                                height: r.offsetHeight,
                                x: 0,
                                y: 0
                            }, e4(o) && o("");
                        } catch  {}
                        (!i || i.width < 0) && (i = {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        });
                    } else i = this.htmlGetBBox();
                    s = i.height, c && (i.height = s = ({
                        "11px,17": 14,
                        "13px,20": 16
                    })[`${u || ""},${Math.round(s)}`] || s), p && (i = this.getRotatedBox(i, p));
                    let t = {
                        bBox: i
                    };
                    e5(this, "afterGetBBox", t), i = t.bBox;
                }
                if (g && ("" === h || i.height > 0)) {
                    for(; d.length > 250;)delete l[d.shift()];
                    l[g] || d.push(g), l[g] = i;
                }
                return i;
            }
            getBBoxCacheKey(t) {
                if (e1(this.textStr)) {
                    let e = "" + this.textStr;
                    return -1 === e.indexOf("<") && (e = e.replace(/\d/g, "0")), [
                        e,
                        ...t
                    ].join(",");
                }
            }
            getRotatedBox(t, e) {
                let { x: i, y: s, width: o, height: r } = t, { alignValue: a, translateY: n, rotationOriginX: h = 0, rotationOriginY: l = 0 } = this, d = e6(a), c = Number(this.element.getAttribute("y") || 0) - (n ? 0 : s), p = e * ej, u = (e - 90) * ej, g = Math.cos(p), f = Math.sin(p), m = o * g, x = o * f, y = Math.cos(u), b = Math.sin(u), [[v, k], [M, w]] = [
                    h,
                    l
                ].map((t)=>[
                        t - t * g,
                        t * f
                    ]), S = i + d * (o - m) + v + w + c * y, A = S + m, T = A - r * y, C = T - m, P = s + c - d * x - k + M + c * b, O = P + x, E = O - r * b, L = E - x, B = Math.min(S, A, T, C), D = Math.min(P, O, E, L), I = Math.max(S, A, T, C) - B, z = Math.max(P, O, E, L) - D;
                return {
                    x: B,
                    y: D,
                    width: I,
                    height: z,
                    polygon: [
                        [
                            S,
                            P
                        ],
                        [
                            A,
                            O
                        ],
                        [
                            T,
                            E
                        ],
                        [
                            C,
                            L
                        ]
                    ]
                };
            }
            getStyle(t) {
                return e_.getComputedStyle(this.element || this, "").getPropertyValue(t);
            }
            hasClass(t) {
                return -1 !== ("" + this.attr("class")).split(" ").indexOf(t);
            }
            hide() {
                return this.attr({
                    visibility: "hidden"
                });
            }
            htmlGetBBox() {
                return {
                    height: 0,
                    width: 0,
                    x: 0,
                    y: 0
                };
            }
            constructor(t, e){
                this.onEvents = {}, this.opacity = 1, this.SVG_NS = e$, this.element = "span" === e || "body" === e ? eJ(e) : eU.createElementNS(this.SVG_NS, e), this.renderer = t, this.styles = {}, e5(this, "afterInit");
            }
            on(t, e) {
                let { onEvents: i } = this;
                return i[t] && i[t](), i[t] = eq(this.element, t, e), this;
            }
            opacitySetter(t, e, i) {
                let s = Number(Number(t).toFixed(3));
                this.opacity = s, i.setAttribute(e, s);
            }
            reAlign() {
                this.alignOptions?.width && "left" !== this.alignOptions.align && (this.alignOptions.width = this.getBBox().width, this.placed = !1, this.align());
            }
            removeClass(t) {
                return this.attr("class", ("" + this.attr("class")).replace(it(t) ? RegExp(`(^| )${t}( |$)`) : t, " ").replace(/ +/g, " ").trim());
            }
            removeTextOutline() {
                let t = this.element.querySelector("tspan.highcharts-text-outline");
                t && this.safeRemoveChild(t);
            }
            safeRemoveChild(t) {
                let e = t.parentNode;
                e && e.removeChild(t);
            }
            setRadialReference(t) {
                let e = this.element.gradient && this.renderer.gradients[this.element.gradient] || void 0;
                return this.element.radialReference = t, e?.radAttr && e.animate(this.renderer.getRadialAttr(t, e.radAttr)), this;
            }
            shadow(t) {
                let { renderer: e } = this, i = ie(this.parentGroup?.rotation === 90 ? {
                    offsetX: -1,
                    offsetY: -1
                } : {}, e7(t) ? t : {}), s = e.shadowDefinition(i);
                return this.attr({
                    filter: t ? `url(${e.url}#${s})` : "none"
                });
            }
            show(t = !0) {
                return this.attr({
                    visibility: t ? "inherit" : "visible"
                });
            }
            "stroke-widthSetter"(t, e, i) {
                this[e] = t, i.setAttribute(e, t);
            }
            strokeWidth() {
                if (!this.renderer.styledMode) return this["stroke-width"] || 0;
                let t = this.getStyle("stroke-width"), e = 0, i;
                return /px$/.test(t) ? e = io(t) : "" !== t && (eK(i = eU.createElementNS(e$, "rect"), {
                    width: t,
                    "stroke-width": 0
                }), this.element.parentNode.appendChild(i), e = i.getBBox().width, i.parentNode.removeChild(i)), e;
            }
            symbolAttr(t) {
                let e = this;
                id.symbolCustomAttribs.forEach(function(i) {
                    e[i] = is(t[i], e[i]);
                }), e.attr({
                    d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)
                });
            }
            textSetter(t) {
                t !== this.textStr && (delete this.textPxLength, this.textStr = t, this.added && this.renderer.buildText(this), this.reAlign());
            }
            titleSetter(t) {
                let e = this.element, i = e.getElementsByTagName("title")[0] || eU.createElementNS(this.SVG_NS, "title");
                e.insertBefore ? e.insertBefore(i, e.firstChild) : e.appendChild(i), i.textContent = ia(is(t, ""), [
                    /<[^>]*>/g,
                    ""
                ]).replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            }
            toFront() {
                let t = this.element;
                return t.parentNode.appendChild(t), this;
            }
            translate(t, e) {
                return this.attr({
                    translateX: t,
                    translateY: e
                });
            }
            updateTransform(t = "transform") {
                let { element: e, foreignObject: i, matrix: s, padding: o, rotation: r = 0, rotationOriginX: a, rotationOriginY: n, scaleX: h, scaleY: l, text: d, translateX: c = 0, translateY: p = 0 } = this, u = [
                    `translate(${c},${p})`
                ];
                e1(s) && u.push("matrix(" + s.join(",") + ")"), r && (u.push("rotate(" + r + " " + (a ?? e.getAttribute("x") ?? this.x ?? 0) + " " + (n ?? e.getAttribute("y") ?? this.y ?? 0) + ")"), d?.element.tagName !== "SPAN" || d?.foreignObject || d.attr({
                    rotation: r,
                    rotationOriginX: (a || 0) - o,
                    rotationOriginY: (n || 0) - o
                })), (e1(h) || e1(l)) && u.push(`scale(${h ?? 1} ${l ?? 1})`), u.length && !(d || this).textPath && (i?.element || e).setAttribute(t, u.join(" "));
            }
            visibilitySetter(t, e, i) {
                "inherit" === t ? i.removeAttribute(e) : this[e] !== t && i.setAttribute(e, t), this[e] = t;
            }
            xGetter(t) {
                return "circle" === this.element.nodeName && ("x" === t ? t = "cx" : "y" === t && (t = "cy")), this._defaultGetter(t);
            }
            zIndexSetter(t, e) {
                let i = this.renderer, s = this.parentGroup, o = (s || i).element || i.box, r = this.element, a = o === i.box, n, h, l, d = !1, c, p = this.added, u;
                if (e1(t) ? (r.setAttribute("data-z-index", t), t *= 1, this[e] === t && (p = !1)) : e1(this[e]) && r.removeAttribute("data-z-index"), this[e] = t, p) {
                    for((t = this.zIndex) && s && (s.handleZ = !0), u = (n = o.childNodes).length - 1; u >= 0 && !d; u--)c = !e1(l = (h = n[u]).getAttribute("data-z-index")), h !== r && (t < 0 && c && !a && !u ? (o.insertBefore(r, n[u]), d = !0) : (io(l) <= t || c && (!e1(t) || t >= 0)) && (o.insertBefore(r, n[u + 1]), d = !0));
                    d || (o.insertBefore(r, n[3 * !!a]), d = !0);
                }
                return d;
            }
        }
        id.symbolCustomAttribs = [
            "anchorX",
            "anchorY",
            "clockwise",
            "end",
            "height",
            "innerR",
            "r",
            "start",
            "width",
            "x",
            "y"
        ], id.prototype.strokeSetter = id.prototype.fillSetter, id.prototype.yGetter = id.prototype.xGetter, id.prototype.matrixSetter = id.prototype.rotationOriginXSetter = id.prototype.rotationOriginYSetter = id.prototype.rotationSetter = id.prototype.scaleXSetter = id.prototype.scaleYSetter = id.prototype.translateXSetter = id.prototype.translateYSetter = id.prototype.verticalAlignSetter = function(t, e) {
            this[e] = t, this.doTransform = !0;
        };
        let ic = id, { defined: ip, extend: iu, getAlignFactor: ig, isNumber: im, merge: ix, pick: iy, removeEvent: ib } = tx;
        class iv extends ic {
            constructor(t, e, i, s, o, r, a, n, h, l){
                let d;
                super(t, "g"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.doUpdate = !1, this.textStr = e, this.x = i, this.y = s, this.anchorX = r, this.anchorY = a, this.baseline = h, this.className = l, this.addClass("button" === l ? "highcharts-no-tooltip" : "highcharts-label"), l && this.addClass("highcharts-" + l), this.text = t.text(void 0, 0, 0, n).attr({
                    zIndex: 1
                }), "string" == typeof o && ((d = /^url\((.*?)\)$/.test(o)) || this.renderer.symbols[o]) && (this.symbolKey = o), this.bBox = iv.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = t.styledMode || d, this.deferredAttr = {}, this.alignFactor = 0;
            }
            alignSetter(t) {
                let e = ig(t);
                this.textAlign = t, e !== this.alignFactor && (this.alignFactor = e, this.bBox && im(this.xSetting) && this.attr({
                    x: this.xSetting
                }), this.updateTextPadding());
            }
            anchorXSetter(t, e) {
                this.anchorX = t, this.boxAttr(e, Math.round(t) - this.getCrispAdjust() - this.xSetting);
            }
            anchorYSetter(t, e) {
                this.anchorY = t, this.boxAttr(e, t - this.ySetting);
            }
            boxAttr(t, e) {
                this.box ? this.box.attr(t, e) : this.deferredAttr[t] = e;
            }
            css(t) {
                if (t) {
                    let e = {};
                    t = ix(t), iv.textProps.forEach((i)=>{
                        void 0 !== t[i] && (e[i] = t[i], delete t[i]);
                    }), this.text.css(e), "fontSize" in e || "fontWeight" in e || "width" in e ? this.updateTextPadding() : "textOverflow" in e && this.updateBoxSize();
                }
                return ic.prototype.css.call(this, t);
            }
            destroy() {
                ib(this.element, "mouseenter"), ib(this.element, "mouseleave"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), ic.prototype.destroy.call(this);
            }
            fillSetter(t, e) {
                t && (this.needsBox = !0), this.fill = t, this.boxAttr(e, t);
            }
            getBBox(t, e) {
                (this.textStr && 0 === this.bBox.width && 0 === this.bBox.height || this.rotation) && this.updateBoxSize();
                let { padding: i, height: s = 0, translateX: o = 0, translateY: r = 0, width: a = 0 } = this, n = iy(this.paddingLeft, i), h = e ?? (this.rotation || 0), l = {
                    width: a,
                    height: s,
                    x: o + this.bBox.x - n,
                    y: r + this.bBox.y - i + this.baselineOffset
                };
                return h && (l = this.getRotatedBox(l, h)), l;
            }
            getCrispAdjust() {
                return (this.renderer.styledMode && this.box ? this.box.strokeWidth() : this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
            }
            heightSetter(t) {
                this.heightSetting = t, this.doUpdate = !0;
            }
            afterSetters() {
                super.afterSetters(), this.doUpdate && (this.updateBoxSize(), this.doUpdate = !1);
            }
            onAdd() {
                this.text.add(this), this.attr({
                    text: iy(this.textStr, ""),
                    x: this.x || 0,
                    y: this.y || 0
                }), this.box && ip(this.anchorX) && this.attr({
                    anchorX: this.anchorX,
                    anchorY: this.anchorY
                });
            }
            paddingSetter(t, e) {
                im(t) ? t !== this[e] && (this[e] = t, this.updateTextPadding()) : this[e] = void 0;
            }
            rSetter(t, e) {
                this.boxAttr(e, t);
            }
            strokeSetter(t, e) {
                this.stroke = t, this.boxAttr(e, t);
            }
            "stroke-widthSetter"(t, e) {
                t && (this.needsBox = !0), this["stroke-width"] = t, this.boxAttr(e, t);
            }
            "text-alignSetter"(t) {
                this.textAlign = this["text-align"] = t, this.updateTextPadding();
            }
            textSetter(t) {
                void 0 !== t && this.text.attr({
                    text: t
                }), this.updateTextPadding(), this.reAlign();
            }
            updateBoxSize() {
                let t, e = this.text, i = {}, s = this.padding, o = this.bBox = (!im(this.widthSetting) || !im(this.heightSetting) || this.textAlign) && ip(e.textStr) ? e.getBBox(void 0, 0) : iv.emptyBBox;
                this.width = this.getPaddedWidth(), this.height = (this.heightSetting || o.height || 0) + 2 * s;
                let r = this.renderer.fontMetrics(e);
                if (this.baselineOffset = s + Math.min((this.text.firstLineMetrics || r).b, o.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - r.h) / 2), this.needsBox && !e.textPath) {
                    if (!this.box) {
                        let t = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
                        t.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), t.add(this);
                    }
                    i.x = t = this.getCrispAdjust(), i.y = (this.baseline ? -this.baselineOffset : 0) + t, i.width = Math.round(this.width), i.height = Math.round(this.height), this.box.attr(iu(i, this.deferredAttr)), this.deferredAttr = {};
                }
            }
            updateTextPadding() {
                let t = this.text, e = t.styles.textAlign || this.textAlign;
                if (!t.textPath) {
                    this.updateBoxSize();
                    let i = this.baseline ? 0 : this.baselineOffset, s = (this.paddingLeft ?? this.padding) + ig(e) * (this.widthSetting ?? this.bBox.width);
                    (s !== t.x || i !== t.y) && (t.attr({
                        align: e,
                        x: s
                    }), void 0 !== i && t.attr("y", i)), t.x = s, t.y = i;
                }
            }
            widthSetter(t) {
                this.widthSetting = im(t) ? t : void 0, this.doUpdate = !0;
            }
            getPaddedWidth() {
                let t = this.padding, e = iy(this.paddingLeft, t), i = iy(this.paddingRight, t);
                return (this.widthSetting || this.bBox.width || 0) + e + i;
            }
            xSetter(t) {
                this.x = t, this.alignFactor && (t -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0), this.anchorX && (this["forceAnimate:anchorX"] = !0), this.xSetting = Math.round(t), this.attr("translateX", this.xSetting);
            }
            ySetter(t) {
                this.anchorY && (this["forceAnimate:anchorY"] = !0), this.ySetting = this.y = Math.round(t), this.attr("translateY", this.ySetting);
            }
        }
        iv.emptyBBox = {
            width: 0,
            height: 0,
            x: 0,
            y: 0
        }, iv.textProps = [
            "color",
            "direction",
            "fontFamily",
            "fontSize",
            "fontStyle",
            "fontWeight",
            "lineClamp",
            "lineHeight",
            "textAlign",
            "textDecoration",
            "textOutline",
            "textOverflow",
            "whiteSpace",
            "width"
        ];
        let { defined: ik, isNumber: iM, pick: iw } = tx;
        function iS(t, e, i, s, o) {
            let r = [];
            if (o) {
                let a = o.start || 0, n = o.end || 0, h = iw(o.r, i), l = iw(o.r, s || i), d = 2e-4 / (o.borderRadius ? 1 : Math.max(h, 1)), c = Math.abs(n - a - 2 * Math.PI) < d;
                c && (a = Math.PI / 2, n = 2.5 * Math.PI - d);
                let p = o.innerR, u = iw(o.open, c), g = Math.cos(a), f = Math.sin(a), m = Math.cos(n), x = Math.sin(n), y = iw(o.longArc, n - a - Math.PI < d ? 0 : 1), b = [
                    "A",
                    h,
                    l,
                    0,
                    y,
                    iw(o.clockwise, 1),
                    t + h * m,
                    e + l * x
                ];
                b.params = {
                    start: a,
                    end: n,
                    cx: t,
                    cy: e
                }, r.push([
                    "M",
                    t + h * g,
                    e + l * f
                ], b), ik(p) && ((b = [
                    "A",
                    p,
                    p,
                    0,
                    y,
                    ik(o.clockwise) ? 1 - o.clockwise : 0,
                    t + p * g,
                    e + p * f
                ]).params = {
                    start: n,
                    end: a,
                    cx: t,
                    cy: e
                }, r.push(u ? [
                    "M",
                    t + p * m,
                    e + p * x
                ] : [
                    "L",
                    t + p * m,
                    e + p * x
                ], b)), u || r.push([
                    "Z"
                ]);
            }
            return r;
        }
        function iA(t, e, i, s, o) {
            return o?.r ? iT(t, e, i, s, o) : [
                [
                    "M",
                    t,
                    e
                ],
                [
                    "L",
                    t + i,
                    e
                ],
                [
                    "L",
                    t + i,
                    e + s
                ],
                [
                    "L",
                    t,
                    e + s
                ],
                [
                    "Z"
                ]
            ];
        }
        function iT(t, e, i, s, o) {
            let r = o?.r || 0;
            return [
                [
                    "M",
                    t + r,
                    e
                ],
                [
                    "L",
                    t + i - r,
                    e
                ],
                [
                    "A",
                    r,
                    r,
                    0,
                    0,
                    1,
                    t + i,
                    e + r
                ],
                [
                    "L",
                    t + i,
                    e + s - r
                ],
                [
                    "A",
                    r,
                    r,
                    0,
                    0,
                    1,
                    t + i - r,
                    e + s
                ],
                [
                    "L",
                    t + r,
                    e + s
                ],
                [
                    "A",
                    r,
                    r,
                    0,
                    0,
                    1,
                    t,
                    e + s - r
                ],
                [
                    "L",
                    t,
                    e + r
                ],
                [
                    "A",
                    r,
                    r,
                    0,
                    0,
                    1,
                    t + r,
                    e
                ],
                [
                    "Z"
                ]
            ];
        }
        let iC = {
            arc: iS,
            callout: function(t, e, i, s, o) {
                let r = Math.min(o?.r || 0, i, s), a = r + 6, n = o?.anchorX, h = o?.anchorY || 0, l = iT(t, e, i, s, {
                    r
                });
                if (!iM(n) || n < i && n > 0 && h < s && h > 0) return l;
                if (t + n > i - a) if (h > e + a && h < e + s - a) l.splice(3, 1, [
                    "L",
                    t + i,
                    h - 6
                ], [
                    "L",
                    t + i + 6,
                    h
                ], [
                    "L",
                    t + i,
                    h + 6
                ], [
                    "L",
                    t + i,
                    e + s - r
                ]);
                else if (n < i) {
                    let o = h < e + a, d = o ? e : e + s;
                    l.splice(o ? 2 : 5, 0, [
                        "L",
                        n,
                        h
                    ], [
                        "L",
                        t + i - r,
                        d
                    ]);
                } else l.splice(3, 1, [
                    "L",
                    t + i,
                    s / 2
                ], [
                    "L",
                    n,
                    h
                ], [
                    "L",
                    t + i,
                    s / 2
                ], [
                    "L",
                    t + i,
                    e + s - r
                ]);
                else if (t + n < a) if (h > e + a && h < e + s - a) l.splice(7, 1, [
                    "L",
                    t,
                    h + 6
                ], [
                    "L",
                    t - 6,
                    h
                ], [
                    "L",
                    t,
                    h - 6
                ], [
                    "L",
                    t,
                    e + r
                ]);
                else if (n > 0) {
                    let i = h < e + a, o = i ? e : e + s;
                    l.splice(i ? 1 : 6, 0, [
                        "L",
                        n,
                        h
                    ], [
                        "L",
                        t + r,
                        o
                    ]);
                } else l.splice(7, 1, [
                    "L",
                    t,
                    s / 2
                ], [
                    "L",
                    n,
                    h
                ], [
                    "L",
                    t,
                    s / 2
                ], [
                    "L",
                    t,
                    e + r
                ]);
                else h > s && n < i - a ? l.splice(5, 1, [
                    "L",
                    n + 6,
                    e + s
                ], [
                    "L",
                    n,
                    e + s + 6
                ], [
                    "L",
                    n - 6,
                    e + s
                ], [
                    "L",
                    t + r,
                    e + s
                ]) : h < 0 && n > a && l.splice(1, 1, [
                    "L",
                    n - 6,
                    e
                ], [
                    "L",
                    n,
                    e - 6
                ], [
                    "L",
                    n + 6,
                    e
                ], [
                    "L",
                    i - r,
                    e
                ]);
                return l;
            },
            circle: function(t, e, i, s) {
                return iS(t + i / 2, e + s / 2, i / 2, s / 2, {
                    start: .5 * Math.PI,
                    end: 2.5 * Math.PI,
                    open: !1
                });
            },
            diamond: function(t, e, i, s) {
                return [
                    [
                        "M",
                        t + i / 2,
                        e
                    ],
                    [
                        "L",
                        t + i,
                        e + s / 2
                    ],
                    [
                        "L",
                        t + i / 2,
                        e + s
                    ],
                    [
                        "L",
                        t,
                        e + s / 2
                    ],
                    [
                        "Z"
                    ]
                ];
            },
            rect: iA,
            roundedRect: iT,
            square: iA,
            triangle: function(t, e, i, s) {
                return [
                    [
                        "M",
                        t + i / 2,
                        e
                    ],
                    [
                        "L",
                        t + i,
                        e + s
                    ],
                    [
                        "L",
                        t,
                        e + s
                    ],
                    [
                        "Z"
                    ]
                ];
            },
            "triangle-down": function(t, e, i, s) {
                return [
                    [
                        "M",
                        t,
                        e
                    ],
                    [
                        "L",
                        t + i,
                        e
                    ],
                    [
                        "L",
                        t + i / 2,
                        e + s
                    ],
                    [
                        "Z"
                    ]
                ];
            }
        }, { doc: iP, SVG_NS: iO, win: iE } = V, { attr: iL, extend: iB, fireEvent: iD, isString: iI, objectEach: iz, pick: iR } = tx, iN = (t, e)=>t.substring(0, e) + "‚Ä¶", iW = class {
            constructor(t){
                const e = t.styles;
                this.renderer = t.renderer, this.svgElement = t, this.width = t.textWidth, this.textLineHeight = e?.lineHeight, this.textOutline = e?.textOutline, this.ellipsis = e?.textOverflow === "ellipsis", this.lineClamp = e?.lineClamp, this.noWrap = e?.whiteSpace === "nowrap";
            }
            buildSVG() {
                let t = this.svgElement, e = t.element, i = t.renderer, s = iR(t.textStr, "").toString(), o = -1 !== s.indexOf("<"), r = e.childNodes, a = !t.added && i.box, n = [
                    s,
                    this.ellipsis,
                    this.noWrap,
                    this.textLineHeight,
                    this.textOutline,
                    t.getStyle("font-size"),
                    t.styles.lineClamp,
                    this.width
                ].join(",");
                if (n !== t.textCache) {
                    t.textCache = n, delete t.actualWidth;
                    for(let t = r.length; t--;)e.removeChild(r[t]);
                    if (o || this.ellipsis || this.width || t.textPath || -1 !== s.indexOf(" ") && (!this.noWrap || /<br.*?>/g.test(s))) {
                        if ("" !== s) {
                            a && a.appendChild(e);
                            let i = new ey(s);
                            this.modifyTree(i.nodes), i.addToDOM(e), this.modifyDOM(), this.ellipsis && -1 !== (e.textContent || "").indexOf("‚Ä¶") && t.attr("title", this.unescapeEntities(t.textStr || "", [
                                "&lt;",
                                "&gt;"
                            ])), a && a.removeChild(e);
                        }
                    } else e.appendChild(iP.createTextNode(this.unescapeEntities(s)));
                    iI(this.textOutline) && t.applyTextOutline && t.applyTextOutline(this.textOutline);
                }
            }
            modifyDOM() {
                let t, e = this.svgElement, i = iL(e.element, "x");
                for(e.firstLineMetrics = void 0; t = e.element.firstChild;)if (/^[\s\u200B]*$/.test(t.textContent || " ")) e.element.removeChild(t);
                else break;
                [].forEach.call(e.element.querySelectorAll("tspan.highcharts-br"), (t, s)=>{
                    t.nextSibling && t.previousSibling && (0 === s && 1 === t.previousSibling.nodeType && (e.firstLineMetrics = e.renderer.fontMetrics(t.previousSibling)), iL(t, {
                        dy: this.getLineHeight(t.nextSibling),
                        x: i
                    }));
                });
                let s = this.width || 0;
                if (!s) return;
                let o = (t, o)=>{
                    let r = t.textContent || "", a = r.replace(/([^\^])-/g, "$1- ").split(" "), n = !this.noWrap && (a.length > 1 || e.element.childNodes.length > 1), h = this.getLineHeight(o), l = Math.max(0, s - .8 * h), d = 0, c = e.actualWidth;
                    if (n) {
                        let r = [], n = [];
                        for(; o.firstChild && o.firstChild !== t;)n.push(o.firstChild), o.removeChild(o.firstChild);
                        for(; a.length;)if (a.length && !this.noWrap && d > 0 && (r.push(t.textContent || ""), t.textContent = a.join(" ").replace(/- /g, "-")), this.truncate(t, void 0, a, 0 === d && c || 0, s, l, (t, e)=>a.slice(0, e).join(" ").replace(/- /g, "-")), c = e.actualWidth, d++, this.lineClamp && d >= this.lineClamp) {
                            a.length && (this.truncate(t, t.textContent || "", void 0, 0, s, l, iN), t.textContent = t.textContent?.replace("‚Ä¶", "") + "‚Ä¶");
                            break;
                        }
                        n.forEach((e)=>{
                            o.insertBefore(e, t);
                        }), r.forEach((e)=>{
                            o.insertBefore(iP.createTextNode(e), t);
                            let s = iP.createElementNS(iO, "tspan");
                            s.textContent = "‚Äã", iL(s, {
                                dy: h,
                                x: i
                            }), o.insertBefore(s, t);
                        });
                    } else this.ellipsis && r && this.truncate(t, r, void 0, 0, s, l, iN);
                }, r = (t)=>{
                    [].slice.call(t.childNodes).forEach((i)=>{
                        i.nodeType === iE.Node.TEXT_NODE ? o(i, t) : (-1 !== i.className.baseVal.indexOf("highcharts-br") && (e.actualWidth = 0), r(i));
                    });
                };
                r(e.element);
            }
            getLineHeight(t) {
                let e = t.nodeType === iE.Node.TEXT_NODE ? t.parentElement : t;
                return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e || this.svgElement.element).h;
            }
            modifyTree(t) {
                let e = (i, s)=>{
                    let { attributes: o = {}, children: r, style: a = {}, tagName: n } = i, h = this.renderer.styledMode;
                    if ("b" === n || "strong" === n ? h ? o.class = "highcharts-strong" : a.fontWeight = "bold" : ("i" === n || "em" === n) && (h ? o.class = "highcharts-emphasized" : a.fontStyle = "italic"), a?.color && (a.fill = a.color), "br" === n) {
                        o.class = "highcharts-br", i.textContent = "‚Äã";
                        let e = t[s + 1];
                        e?.textContent && (e.textContent = e.textContent.replace(/^ +/gm, ""));
                    } else "a" === n && r && r.some((t)=>"#text" === t.tagName) && (i.children = [
                        {
                            children: r,
                            tagName: "tspan"
                        }
                    ]);
                    "#text" !== n && "a" !== n && (i.tagName = "tspan"), iB(i, {
                        attributes: o,
                        style: a
                    }), r && r.filter((t)=>"#text" !== t.tagName).forEach(e);
                };
                t.forEach(e), iD(this.svgElement, "afterModifyTree", {
                    nodes: t
                });
            }
            truncate(t, e, i, s, o, r, a) {
                let n, h, l = this.svgElement, { rotation: d } = l, c = [], p = i && !s ? 1 : 0, u = (e || i || "").length, g = u;
                i || (o = r);
                let f = function(e, o) {
                    let r = o || e, a = t.parentNode;
                    if (a && void 0 === c[r] && a.getSubStringLength) try {
                        c[r] = s + a.getSubStringLength(0, i ? r + 1 : r);
                    } catch  {}
                    return c[r];
                };
                if (l.rotation = 0, s + (h = f(t.textContent.length)) > o) {
                    for(; p <= u;)g = Math.ceil((p + u) / 2), i && (n = a(i, g)), h = f(g, n && n.length - 1), p === u ? p = u + 1 : h > o ? u = g - 1 : p = g;
                    0 === u ? t.textContent = "" : e && u === e.length - 1 || (t.textContent = n || a(e || i, g)), this.ellipsis && h > o && this.truncate(t, t.textContent || "", void 0, 0, o, r, iN);
                }
                i && i.splice(0, g), l.actualWidth = h, l.rotation = d;
            }
            unescapeEntities(t, e) {
                return iz(this.renderer.escapes, function(i, s) {
                    e && -1 !== e.indexOf(i) || (t = t.toString().replace(RegExp(i, "g"), s));
                }), t;
            }
        }, { defaultOptions: iG } = tY, { charts: iX, deg2rad: iH, doc: iF, isFirefox: iY, isMS: ij, isWebKit: iU, noop: iV, SVG_NS: i$, symbolSizes: i_, win: iZ } = V, { addEvent: iq, attr: iK, createElement: iJ, crisp: iQ, css: i0, defined: i1, destroyObjectProperties: i2, extend: i3, isArray: i5, isNumber: i6, isObject: i9, isString: i4, merge: i8, pick: i7, pInt: st, replaceNested: se, uniqueKey: si } = tx;
        class ss {
            constructor(t, e, i, s, o, r, a){
                let n, h;
                this.x = 0, this.y = 0;
                const l = this.createElement("svg").attr({
                    version: "1.1",
                    class: "highcharts-root"
                }), d = l.element;
                a || l.css(this.getStyle(s || {})), t.appendChild(d), iK(t, "dir", "ltr"), -1 === t.innerHTML.indexOf("xmlns") && iK(d, "xmlns", this.SVG_NS), this.box = d, this.boxWrapper = l, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement("desc").add().element.appendChild(iF.createTextNode("Created with Highcharts 12.5.0")), this.defs = this.createElement("defs").add(), this.allowHTML = r, this.forExport = o, this.styledMode = a, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = l.getStyle("font-size"), this.setSize(e, i, !1), iY && t.getBoundingClientRect && ((n = function() {
                    i0(t, {
                        left: 0,
                        top: 0
                    }), h = t.getBoundingClientRect(), i0(t, {
                        left: Math.ceil(h.left) - h.left + "px",
                        top: Math.ceil(h.top) - h.top + "px"
                    });
                })(), this.unSubPixelFix = iq(iZ, "resize", n));
            }
            definition(t) {
                return new ey([
                    t
                ]).addToDOM(this.defs.element);
            }
            getReferenceURL() {
                if ((iY || iU) && iF.getElementsByTagName("base").length) {
                    if (!i1(e)) {
                        let t = si(), i = new ey([
                            {
                                tagName: "svg",
                                attributes: {
                                    width: 8,
                                    height: 8
                                },
                                children: [
                                    {
                                        tagName: "defs",
                                        children: [
                                            {
                                                tagName: "clipPath",
                                                attributes: {
                                                    id: t
                                                },
                                                children: [
                                                    {
                                                        tagName: "rect",
                                                        attributes: {
                                                            width: 4,
                                                            height: 4
                                                        }
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        tagName: "rect",
                                        attributes: {
                                            id: "hitme",
                                            width: 8,
                                            height: 8,
                                            "clip-path": `url(#${t})`,
                                            fill: "rgba(0,0,0,0.001)"
                                        }
                                    }
                                ]
                            }
                        ]).addToDOM(iF.body);
                        i0(i, {
                            position: "fixed",
                            top: 0,
                            left: 0,
                            zIndex: 9e5
                        });
                        let s = iF.elementFromPoint(6, 6);
                        e = s?.id === "hitme", iF.body.removeChild(i);
                    }
                    if (e) return se(iZ.location.href.split("#")[0], [
                        /<[^>]*>/g,
                        ""
                    ], [
                        /([\('\)])/g,
                        "\\$1"
                    ], [
                        / /g,
                        "%20"
                    ]);
                }
                return "";
            }
            getStyle(t) {
                return this.style = i3({
                    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif',
                    fontSize: "1rem"
                }, t), this.style;
            }
            setStyle(t) {
                this.boxWrapper.css(this.getStyle(t));
            }
            isHidden() {
                return !this.boxWrapper.getBBox().width;
            }
            destroy() {
                let t = this.defs;
                return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), i2(this.gradients || {}), this.gradients = null, this.defs = t.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;
            }
            createElement(t) {
                return new this.Element(this, t);
            }
            getRadialAttr(t, e) {
                return {
                    cx: t[0] - t[2] / 2 + (e.cx || 0) * t[2],
                    cy: t[1] - t[2] / 2 + (e.cy || 0) * t[2],
                    r: (e.r || 0) * t[2]
                };
            }
            shadowDefinition(t) {
                let e = [
                    `highcharts-drop-shadow-${this.chartIndex}`,
                    ...Object.keys(t).map((e)=>`${e}-${t[e]}`)
                ].join("-").toLowerCase().replace(/[^a-z\d\-]/g, ""), i = i8({
                    color: "#000000",
                    offsetX: 1,
                    offsetY: 1,
                    opacity: .15,
                    width: 5
                }, t);
                return this.defs.element.querySelector(`#${e}`) || this.definition({
                    tagName: "filter",
                    attributes: {
                        id: e,
                        filterUnits: i.filterUnits
                    },
                    children: this.getShadowFilterContent(i)
                }), e;
            }
            getShadowFilterContent(t) {
                return [
                    {
                        tagName: "feDropShadow",
                        attributes: {
                            dx: t.offsetX,
                            dy: t.offsetY,
                            "flood-color": t.color,
                            "flood-opacity": Math.min(5 * t.opacity, 1),
                            stdDeviation: t.width / 2
                        }
                    }
                ];
            }
            buildText(t) {
                new iW(t).buildSVG();
            }
            getContrast(t) {
                if ("transparent" === t) return "#000000";
                let e = tJ.parse(t).rgba, i = " clamp(0,calc(9e9*(0.5 - (0.2126*r + 0.7152*g + 0.0722*b))),1)";
                if (i6(e[0]) || !tJ.useColorMix) {
                    let t = e.map((t)=>{
                        let e = t / 255;
                        return e <= .04 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);
                    }), i = .2126 * t[0] + .7152 * t[1] + .0722 * t[2];
                    return 1.05 / (i + .05) > (i + .05) / .05 ? "#FFFFFF" : "#000000";
                }
                return "color(from " + t + " srgb" + i + i + i + ")";
            }
            button(t, e, i, s, o = {}, r, a, n, h, l) {
                let d = this.label(t, e, i, h, void 0, void 0, l, void 0, "button"), c = this.styledMode, p = arguments, u = 0;
                o = i8(iG.global.buttonTheme, o), c && (delete o.fill, delete o.stroke, delete o["stroke-width"]);
                let g = o.states || {}, f = o.style || {};
                delete o.states, delete o.style;
                let m = [
                    ey.filterUserAttributes(o)
                ], x = [
                    f
                ];
                return c || [
                    "hover",
                    "select",
                    "disabled"
                ].forEach((t, e)=>{
                    m.push(i8(m[0], ey.filterUserAttributes(p[e + 5] || g[t] || {}))), x.push(m[e + 1].style), delete m[e + 1].style;
                }), iq(d.element, ij ? "mouseover" : "mouseenter", function() {
                    3 !== u && d.setState(1);
                }), iq(d.element, ij ? "mouseout" : "mouseleave", function() {
                    3 !== u && d.setState(u);
                }), d.setState = (t = 0)=>{
                    if (1 !== t && (d.state = u = t), d.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + [
                        "normal",
                        "hover",
                        "pressed",
                        "disabled"
                    ][t]), !c) {
                        d.attr(m[t]);
                        let e = x[t];
                        i9(e) && d.css(e);
                    }
                }, d.attr(m[0]), !c && (d.css(i3({
                    cursor: "default"
                }, f)), l && d.text.css({
                    pointerEvents: "none"
                })), d.on("touchstart", (t)=>t.stopPropagation()).on("click", function(t) {
                    3 !== u && s?.call(d, t);
                });
            }
            crispLine(t, e) {
                let [i, s] = t;
                return i1(i[1]) && i[1] === s[1] && (i[1] = s[1] = iQ(i[1], e)), i1(i[2]) && i[2] === s[2] && (i[2] = s[2] = iQ(i[2], e)), t;
            }
            path(t) {
                let e = this.styledMode ? {} : {
                    fill: "none"
                };
                return i5(t) ? e.d = t : i9(t) && i3(e, t), this.createElement("path").attr(e);
            }
            circle(t, e, i) {
                let s = i9(t) ? t : void 0 === t ? {} : {
                    x: t,
                    y: e,
                    r: i
                }, o = this.createElement("circle");
                return o.xSetter = o.ySetter = function(t, e, i) {
                    i.setAttribute("c" + e, t);
                }, o.attr(s);
            }
            arc(t, e, i, s, o, r) {
                let a;
                i9(t) ? (e = (a = t).y, i = a.r, s = a.innerR, o = a.start, r = a.end, t = a.x) : a = {
                    innerR: s,
                    start: o,
                    end: r
                };
                let n = this.symbol("arc", t, e, i, i, a);
                return n.r = i, n;
            }
            rect(t, e, i, s, o, r) {
                let a = i9(t) ? t : void 0 === t ? {} : {
                    x: t,
                    y: e,
                    r: o,
                    width: Math.max(i || 0, 0),
                    height: Math.max(s || 0, 0)
                }, n = this.createElement("rect");
                return this.styledMode || (void 0 !== r && (a["stroke-width"] = r, i3(a, n.crisp(a))), a.fill = "none"), n.rSetter = function(t, e, i) {
                    n.r = t, iK(i, {
                        rx: t,
                        ry: t
                    });
                }, n.rGetter = function() {
                    return n.r || 0;
                }, n.attr(a);
            }
            roundedRect(t) {
                return this.symbol("roundedRect").attr(t);
            }
            setSize(t, e, i) {
                this.width = t, this.height = e, this.boxWrapper.animate({
                    width: t,
                    height: e
                }, {
                    step: function() {
                        this.attr({
                            viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                        });
                    },
                    duration: i7(i, !0) ? void 0 : 0
                }), this.alignElements();
            }
            g(t) {
                let e = this.createElement("g");
                return t ? e.attr({
                    class: "highcharts-" + t
                }) : e;
            }
            image(t, e, i, s, o, r) {
                let a = {
                    preserveAspectRatio: "none"
                };
                i6(e) && (a.x = e), i6(i) && (a.y = i), i6(s) && (a.width = s), i6(o) && (a.height = o);
                let n = this.createElement("image").attr(a), h = function(e) {
                    n.attr({
                        href: t
                    }), r.call(n, e);
                };
                if (r) {
                    n.attr({
                        href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
                    });
                    let e = new iZ.Image;
                    iq(e, "load", h), e.src = t, e.complete && h({});
                } else n.attr({
                    href: t
                });
                return n;
            }
            symbol(t, e, i, s, o, r) {
                let a, n, h, l, d = this, c = /^url\((.*?)\)$/, p = c.test(t), u = !p && (this.symbols[t] ? t : "circle"), g = u && this.symbols[u];
                if (g) "number" == typeof e && (n = g.call(this.symbols, e || 0, i || 0, s || 0, o || 0, r)), a = this.path(n), d.styledMode || a.attr("fill", "none"), i3(a, {
                    symbolName: u || void 0,
                    x: e,
                    y: i,
                    width: s,
                    height: o
                }), r && i3(a, r);
                else if (p) {
                    h = t.match(c)[1];
                    let s = a = this.image(h);
                    s.imgwidth = i7(r?.width, i_[h]?.width), s.imgheight = i7(r?.height, i_[h]?.height), l = (t)=>t.attr({
                            width: t.width,
                            height: t.height
                        }), [
                        "width",
                        "height"
                    ].forEach((t)=>{
                        s[`${t}Setter`] = function(t, e) {
                            this[e] = t;
                            let { alignByTranslate: i, element: s, width: o, height: a, imgwidth: n, imgheight: h } = this, l = "width" === e ? n : h, d = 1;
                            r && "within" === r.backgroundSize && o && a && n && h ? (d = Math.min(o / n, a / h), iK(s, {
                                width: Math.round(n * d),
                                height: Math.round(h * d)
                            })) : s && l && s.setAttribute(e, l), !i && n && h && this.translate(((o || 0) - n * d) / 2, ((a || 0) - h * d) / 2);
                        };
                    }), i1(e) && s.attr({
                        x: e,
                        y: i
                    }), s.isImg = !0, s.symbolUrl = t, i1(s.imgwidth) && i1(s.imgheight) ? l(s) : (s.attr({
                        width: 0,
                        height: 0
                    }), iJ("img", {
                        onload: function() {
                            let t = iX[d.chartIndex];
                            0 === this.width && (i0(this, {
                                position: "absolute",
                                top: "-999em"
                            }), iF.body.appendChild(this)), i_[h] = {
                                width: this.width,
                                height: this.height
                            }, s.imgwidth = this.width, s.imgheight = this.height, s.element && l(s), this.parentNode && this.parentNode.removeChild(this), d.imgCount--, d.imgCount || !t || t.hasLoaded || t.onload();
                        },
                        src: h
                    }), this.imgCount++);
                }
                return a;
            }
            clipRect(t, e, i, s) {
                return this.rect(t, e, i, s, 0);
            }
            text(t, e, i, s) {
                let o = {};
                if (s && (this.allowHTML || !this.forExport)) return this.html(t, e, i);
                o.x = Math.round(e || 0), i && (o.y = Math.round(i)), i1(t) && (o.text = t);
                let r = this.createElement("text").attr(o);
                return s && (!this.forExport || this.allowHTML) || (r.xSetter = function(t, e, i) {
                    let s = i.getElementsByTagName("tspan"), o = i.getAttribute(e);
                    for(let i = 0, r; i < s.length; i++)(r = s[i]).getAttribute(e) === o && r.setAttribute(e, t);
                    i.setAttribute(e, t);
                }), r;
            }
            fontMetrics(t) {
                let e = i6(t) ? t : st(ic.prototype.getStyle.call(t, "font-size") || 0), i = e < 24 ? e + 3 : Math.round(1.2 * e), s = Math.round(.8 * i);
                return {
                    h: i,
                    b: s,
                    f: e
                };
            }
            rotCorr(t, e, i) {
                let s = t;
                return e && i && (s = Math.max(s * Math.cos(e * iH), 4)), {
                    x: -t / 3 * Math.sin(e * iH),
                    y: s
                };
            }
            pathToSegments(t) {
                let e = [], i = [], s = {
                    A: 8,
                    C: 7,
                    H: 2,
                    L: 3,
                    M: 3,
                    Q: 5,
                    S: 5,
                    T: 3,
                    V: 2
                };
                for(let o = 0; o < t.length; o++)i4(i[0]) && i6(t[o]) && i.length === s[i[0].toUpperCase()] && t.splice(o, 0, i[0].replace("M", "L").replace("m", "l")), "string" == typeof t[o] && (i.length && e.push(i.slice(0)), i.length = 0), i.push(t[o]);
                return e.push(i.slice(0)), e;
            }
            label(t, e, i, s, o, r, a, n, h) {
                return new iv(this, t, e, i, s, o, r, a, n, h);
            }
            alignElements() {
                this.alignedObjects.forEach((t)=>t.align());
            }
        }
        i3(ss.prototype, {
            Element: ic,
            SVG_NS: i$,
            escapes: {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                "'": "&#39;",
                '"': "&quot;"
            },
            symbols: iC,
            draw: iV
        }), ez.registerRendererType("svg", ss, !0);
        let { composed: so, isFirefox: sr } = V, { attr: sa, css: sn, createElement: sh, defined: sl, extend: sd, getAlignFactor: sc, isNumber: sp, pInt: su, pushUnique: sg } = tx;
        function sf(t, e, i) {
            let s = this.div?.style;
            ic.prototype[`${e}Setter`].call(this, t, e, i), s && (i.style[e] = s[e] = t);
        }
        let sm = (t, e)=>{
            if (!t.div) {
                let i = sa(t.element, "class"), s = t.css, o = sh("div", i ? {
                    className: i
                } : void 0, {
                    position: "absolute",
                    left: `${t.translateX || 0}px`,
                    top: `${t.translateY || 0}px`,
                    ...t.styles,
                    display: t.display,
                    opacity: t.opacity,
                    visibility: t.visibility
                }, t.parentGroup?.div || e);
                t.classSetter = (t, e, i)=>{
                    i.setAttribute("class", t), o.className = t;
                }, t.translateXSetter = t.translateYSetter = (e, i)=>{
                    t[i] = e, o.style["translateX" === i ? "left" : "top"] = `${e}px`, t.doTransform = !0;
                }, t.scaleXSetter = t.scaleYSetter = (e, i)=>{
                    t[i] = e, t.doTransform = !0;
                }, t.opacitySetter = t.visibilitySetter = sf, t.css = (e)=>(s.call(t, e), e.cursor && (o.style.cursor = e.cursor), e.pointerEvents && (o.style.pointerEvents = e.pointerEvents), t), t.on = function() {
                    return ic.prototype.on.apply({
                        element: o,
                        onEvents: t.onEvents
                    }, arguments), t;
                }, t.div = o;
            }
            return t.div;
        };
        class sx extends ic {
            static compose(t) {
                sg(so, this.compose) && (t.prototype.html = function(t, e, i) {
                    return new sx(this, "span").attr({
                        text: t,
                        x: Math.round(e),
                        y: Math.round(i)
                    });
                });
            }
            constructor(t, e){
                super(t, e), sx.useForeignObject ? this.foreignObject = t.createElement("foreignObject").attr({
                    zIndex: 2
                }) : this.css({
                    position: "absolute",
                    ...t.styledMode ? {} : {
                        fontFamily: t.style.fontFamily,
                        fontSize: t.style.fontSize
                    }
                }), this.element.style.whiteSpace = "nowrap";
            }
            getSpanCorrection(t, e, i) {
                this.xCorr = -t * i, this.yCorr = -e;
            }
            css(t) {
                let e, { element: i } = this, s = "SPAN" === i.tagName && t && "width" in t, o = s && t.width;
                return s && (delete t.width, this.textWidth = su(o) || void 0, e = !0), t?.textOverflow === "ellipsis" && (t.overflow = "hidden", t.whiteSpace = "nowrap"), t?.lineClamp && (t.display = "-webkit-box", t.WebkitLineClamp = t.lineClamp, t.WebkitBoxOrient = "vertical", t.overflow = "hidden"), sp(Number(t?.fontSize)) && (t.fontSize += "px"), sd(this.styles, t), sn(i, t), e && this.updateTransform(), this;
            }
            htmlGetBBox() {
                let { element: t } = this;
                return {
                    x: t.offsetLeft,
                    y: t.offsetTop,
                    width: t.offsetWidth,
                    height: t.offsetHeight
                };
            }
            updateTransform() {
                if (!this.added) {
                    this.alignOnAdd = !0;
                    return;
                }
                let { element: t, foreignObject: e, oldTextWidth: i, renderer: s, rotation: o, rotationOriginX: r, rotationOriginY: a, scaleX: n, scaleY: h, styles: { display: l = "inline-block", whiteSpace: d }, textAlign: c = "left", textWidth: p, translateX: u = 0, translateY: g = 0, x: f = 0, y: m = 0 } = this, x = ()=>this.textPxLength ? this.textPxLength : (sn(t, {
                        width: "",
                        whiteSpace: d || "nowrap"
                    }), t.offsetWidth);
                if (e || sn(t, {
                    marginLeft: `${u}px`,
                    marginTop: `${g}px`
                }), "SPAN" === t.tagName) {
                    let u, g = [
                        o,
                        c,
                        t.innerHTML,
                        p,
                        this.textAlign
                    ].join(","), y = -(this.parentGroup?.padding * 1) || 0;
                    if (p !== i) {
                        let e = x(), r = p || 0, a = !s.styledMode && "" === t.style.textOverflow && t.style.webkitLineClamp;
                        (r > i || e > r || a) && (/[\-\s\u00AD]/.test(t.textContent || t.innerText) || "ellipsis" === t.style.textOverflow) && (sn(t, {
                            width: (o || n || e > r || a) && sp(p) ? p + "px" : "auto",
                            display: l,
                            whiteSpace: d || "normal"
                        }), this.oldTextWidth = p);
                    }
                    e && (sn(t, {
                        display: "inline-block",
                        verticalAlign: "top"
                    }), e.attr({
                        width: s.width,
                        height: s.height
                    })), g !== this.cTT && (u = s.fontMetrics(t).b, sl(o) && !e && (o !== (this.oldRotation || 0) || c !== this.oldAlign) && sn(t, {
                        transform: `rotate(${o}deg)`,
                        transformOrigin: `${y}% ${y}px`
                    }), this.getSpanCorrection(!sl(o) && !this.textWidth && this.textPxLength || t.offsetWidth, u, sc(c)));
                    let { xCorr: b = 0, yCorr: v = 0 } = this, k = {
                        left: `${f + b}px`,
                        top: `${m + v}px`,
                        textAlign: c,
                        transformOrigin: `${(r ?? f) - b - f - y}px ${(a ?? m) - v - m - y}px`
                    };
                    (n || h) && (k.transform = `scale(${n ?? 1},${h ?? 1})`), e ? (super.updateTransform(), sp(f) && sp(m) ? (e.attr({
                        x: f + b,
                        y: m + v,
                        width: t.offsetWidth + 3,
                        height: t.offsetHeight,
                        "transform-origin": t.getAttribute("transform-origin") || "0 0"
                    }), sn(t, {
                        display: l,
                        textAlign: c
                    })) : sr && e.attr({
                        width: 0,
                        height: 0
                    })) : sn(t, k), this.cTT = g, this.oldRotation = o, this.oldAlign = c;
                }
            }
            add(t) {
                let { foreignObject: e, renderer: i } = this, s = i.box.parentNode, o = [];
                if (e) e.add(t), super.add(i.createElement("body").attr({
                    xmlns: "http://www.w3.org/1999/xhtml"
                }).css({
                    background: "transparent",
                    margin: "0 3px 0 0"
                }).add(e));
                else {
                    let e;
                    if (this.parentGroup = t, t && !(e = t.div)) {
                        let i = t;
                        for(; i;)o.push(i), i = i.parentGroup;
                        for (let t of o.reverse())e = sm(t, s);
                    }
                    (e || s).appendChild(this.element);
                }
                return this.added = !0, this.alignOnAdd && this.updateTransform(), this;
            }
            textSetter(t) {
                t !== this.textStr && (delete this.bBox, delete this.oldTextWidth, ey.setElementHTML(this.element, t ?? ""), this.textStr = t, this.doTransform = !0);
            }
            alignSetter(t) {
                this.alignValue = this.textAlign = t, this.doTransform = !0;
            }
            xSetter(t, e) {
                this[e] = t, this.doTransform = !0;
            }
        }
        let sy = sx.prototype;
        sy.visibilitySetter = sy.opacitySetter = sf, sy.ySetter = sy.rotationSetter = sy.rotationOriginXSetter = sy.rotationOriginYSetter = sy.xSetter, (p = w || (w = {})).xAxis = {
            alignTicks: !0,
            allowDecimals: void 0,
            panningEnabled: !0,
            zIndex: 2,
            zoomEnabled: !0,
            dateTimeLabelFormats: {
                millisecond: {
                    main: "%[HMSL]",
                    range: !1
                },
                second: {
                    main: "%[HMS]",
                    range: !1
                },
                minute: {
                    main: "%[HM]",
                    range: !1
                },
                hour: {
                    main: "%[HM]",
                    range: !1
                },
                day: {
                    main: "%[eb]"
                },
                week: {
                    main: "%[eb]"
                },
                month: {
                    main: "%[bY]"
                },
                year: {
                    main: "%Y"
                }
            },
            endOnTick: !1,
            gridLineDashStyle: "Solid",
            gridZIndex: 1,
            labels: {
                autoRotationLimit: 80,
                distance: 15,
                enabled: !0,
                indentation: 10,
                overflow: "justify",
                reserveSpace: void 0,
                rotation: void 0,
                staggerLines: 0,
                step: 0,
                useHTML: !1,
                zIndex: 7,
                style: {
                    color: "#333333",
                    cursor: "default",
                    fontSize: "0.8em",
                    textOverflow: "ellipsis"
                }
            },
            maxPadding: .01,
            minorGridLineDashStyle: "Solid",
            minorTickLength: 2,
            minorTickPosition: "outside",
            minorTicksPerMajor: 5,
            minPadding: .01,
            offset: void 0,
            reversed: void 0,
            reversedStacks: !1,
            showEmpty: !0,
            showFirstLabel: !0,
            showLastLabel: !0,
            startOfWeek: 1,
            startOnTick: !1,
            tickLength: 10,
            tickmarkPlacement: "between",
            tickPixelInterval: 100,
            tickPosition: "outside",
            title: {
                align: "middle",
                useHTML: !1,
                x: 0,
                y: 0,
                style: {
                    color: "#666666",
                    fontSize: "0.8em"
                }
            },
            visible: !0,
            minorGridLineColor: "#f2f2f2",
            minorGridLineWidth: 1,
            minorTickColor: "#999999",
            lineColor: "#333333",
            lineWidth: 1,
            gridLineColor: "#e6e6e6",
            gridLineWidth: void 0,
            tickColor: "#333333"
        }, p.yAxis = {
            reversedStacks: !0,
            endOnTick: !0,
            maxPadding: .05,
            minPadding: .05,
            tickPixelInterval: 72,
            showLastLabel: !0,
            labels: {
                x: void 0
            },
            startOnTick: !0,
            title: {},
            stackLabels: {
                animation: {},
                allowOverlap: !1,
                enabled: !1,
                crop: !0,
                overflow: "justify",
                formatter: function() {
                    let { numberFormatter: t } = this.axis.chart;
                    return t(this.total || 0, -1);
                },
                style: {
                    color: "#000000",
                    fontSize: "0.7em",
                    fontWeight: "bold",
                    textOutline: "1px contrast"
                }
            },
            gridLineWidth: 1,
            lineWidth: 0
        };
        let sb = w, { addEvent: sv, isFunction: sk, objectEach: sM, removeEvent: sw } = tx;
        (S || (S = {})).registerEventOptions = function(t, e) {
            t.eventOptions = t.eventOptions || {}, sM(e.events, function(e, i) {
                t.eventOptions[i] !== e && (t.eventOptions[i] && (sw(t, i, t.eventOptions[i]), delete t.eventOptions[i]), sk(e) && (t.eventOptions[i] = e, sv(t, i, e, {
                    order: 0
                })));
            });
        };
        let sS = S, { deg2rad: sA } = V, { clamp: sT, correctFloat: sC, defined: sP, destroyObjectProperties: sO, extend: sE, fireEvent: sL, getAlignFactor: sB, isNumber: sD, merge: sI, objectEach: sz, pick: sR } = tx, sN = class {
            constructor(t, e, i, s, o){
                this.isNew = !0, this.isNewLabel = !0, this.axis = t, this.pos = e, this.type = i || "", this.parameters = o || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, sL(this, "init"), i || s || this.addLabel();
            }
            addLabel() {
                let t = this, e = t.axis, i = e.options, s = e.chart, o = e.categories, r = e.logarithmic, a = e.names, n = t.pos, h = sR(t.options?.labels, i.labels), l = e.tickPositions, d = n === l[0], c = n === l[l.length - 1], p = (!h.step || 1 === h.step) && 1 === e.tickInterval, u = l.info, g = t.label, f, m, x, y = this.parameters.category || (o ? sR(o[n], a[n], n) : n);
                r && sD(y) && (y = sC(r.lin2log(y))), e.dateTime && (u ? f = (m = s.time.resolveDTLFormat(i.dateTimeLabelFormats[!i.grid?.enabled && u.higherRanks[n] || u.unitName])).main : sD(y) && (f = e.dateTime.getXDateFormat(y, i.dateTimeLabelFormats || {}))), t.isFirst = d, t.isLast = c;
                let b = {
                    axis: e,
                    chart: s,
                    dateTimeLabelFormat: f,
                    isFirst: d,
                    isLast: c,
                    pos: n,
                    tick: t,
                    tickPositionInfo: u,
                    value: y
                };
                sL(this, "labelFormat", b);
                let v = (t)=>h.formatter ? h.formatter.call(t, t) : h.format ? (t.text = e.defaultLabelFormatter.call(t), eI.format(h.format, t, s)) : e.defaultLabelFormatter.call(t), k = v.call(b, b), M = m?.list;
                M ? t.shortenLabel = function() {
                    for(x = 0; x < M.length; x++)if (sE(b, {
                        dateTimeLabelFormat: M[x]
                    }), g.attr({
                        text: v.call(b, b)
                    }), g.getBBox().width < e.getSlotWidth(t) - 2 * (h.padding || 0)) return;
                    g.attr({
                        text: ""
                    });
                } : t.shortenLabel = void 0, p && e._addedPlotLB && t.moveLabel(k, h), sP(g) || t.movedLabel ? g && g.textStr !== k && !p && (!g.textWidth || h.style.width || g.styles.width || g.css({
                    width: null
                }), g.attr({
                    text: k
                }), g.textPxLength = g.getBBox().width) : (t.label = g = t.createLabel(k, h), t.rotation = 0);
            }
            createLabel(t, e, i) {
                let s = this.axis, { renderer: o, styledMode: r } = s.chart, a = e.style.whiteSpace, n = sP(t) && e.enabled ? o.text(t, i?.x, i?.y, e.useHTML).add(s.labelGroup) : void 0;
                return n && (r || n.css(sI(e.style)), n.textPxLength = n.getBBox().width, !r && a && n.css({
                    whiteSpace: a
                })), n;
            }
            destroy() {
                sO(this, this.axis);
            }
            getPosition(t, e, i, s) {
                let o = this.axis, r = o.chart, a = s && r.oldChartHeight || r.chartHeight, n = {
                    x: t ? sC(o.translate(e + i, void 0, void 0, s) + o.transB) : o.left + o.offset + (o.opposite ? (s && r.oldChartWidth || r.chartWidth) - o.right - o.left : 0),
                    y: t ? a - o.bottom + o.offset - (o.opposite ? o.height : 0) : sC(a - o.translate(e + i, void 0, void 0, s) - o.transB)
                };
                return n.y = sT(n.y, -1e9, 1e9), sL(this, "afterGetPosition", {
                    pos: n
                }), n;
            }
            getLabelPosition(t, e, i, s, o, r, a, n) {
                let h, l, d = this.axis, c = d.transA, p = d.isLinked && d.linkedParent ? d.linkedParent.reversed : d.reversed, u = d.staggerLines, g = d.tickRotCorr || {
                    x: 0,
                    y: 0
                }, f = s || d.reserveSpaceDefault ? 0 : -d.labelOffset * ("center" === d.labelAlign ? .5 : 1), m = o.distance, x = {};
                return h = 0 === d.side ? i.rotation ? -m : -i.getBBox().height : 2 === d.side ? g.y + m : Math.cos(i.rotation * sA) * (g.y - i.getBBox(!1, 0).height / 2), sP(o.y) && (h = 0 === d.side && d.horiz ? o.y + h : o.y), t = t + sR(o.x, [
                    0,
                    1,
                    0,
                    -1
                ][d.side] * m) + f + g.x - (r && s ? r * c * (p ? -1 : 1) : 0), e = e + h - (r && !s ? r * c * (p ? 1 : -1) : 0), u && (l = a / (n || 1) % u, d.opposite && (l = u - l - 1), e += l * (d.labelOffset / u)), x.x = t, x.y = Math.round(e), sL(this, "afterGetLabelPosition", {
                    pos: x,
                    tickmarkOffset: r,
                    index: a
                }), x;
            }
            getLabelSize() {
                return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
            }
            getMarkPath(t, e, i, s, o = !1, r) {
                return r.crispLine([
                    [
                        "M",
                        t,
                        e
                    ],
                    [
                        "L",
                        t + (o ? 0 : -i),
                        e + (o ? i : 0)
                    ]
                ], s);
            }
            handleOverflow(t) {
                let e = this.axis, i = e.options.labels, s = t.x, o = e.chart.chartWidth, r = e.chart.spacing, a = sR(e.labelLeft, Math.min(e.pos, r[3])), n = sR(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, o - r[1])), h = this.label, l = this.rotation, d = sB(e.labelAlign || h.attr("align")), c = h.getBBox().width, p = e.getSlotWidth(this), u = p, g = 1, f;
                l || "justify" !== i.overflow ? l < 0 && s - d * c < a ? f = Math.round(s / Math.cos(l * sA) - a) : l > 0 && s + d * c > n && (f = Math.round((o - s) / Math.cos(l * sA))) : (s - d * c < a ? u = t.x + u * (1 - d) - a : s + (1 - d) * c > n && (u = n - t.x + u * d, g = -1), (u = Math.min(p, u)) < p && "center" === e.labelAlign && (t.x += g * (p - u - d * (p - Math.min(c, u)))), (c > u || e.autoRotation && h?.styles?.width) && (f = u)), f && h && (this.shortenLabel ? this.shortenLabel() : h.css(sE({}, {
                    width: Math.floor(f) + "px",
                    lineClamp: +!e.isRadial
                })));
            }
            moveLabel(t, e) {
                let i = this, s = i.label, o = i.axis, r = !1, a;
                s && s.textStr === t ? (i.movedLabel = s, r = !0, delete i.label) : sz(o.ticks, function(e) {
                    r || e.isNew || e === i || !e.label || e.label.textStr !== t || (i.movedLabel = e.label, r = !0, e.labelPos = i.movedLabel.xy, delete e.label);
                }), !r && (i.labelPos || s) && (a = i.labelPos || s.xy, i.movedLabel = i.createLabel(t, e, a), i.movedLabel && i.movedLabel.attr({
                    opacity: 0
                }));
            }
            render(t, e, i) {
                let s = this.axis, o = s.horiz, r = this.pos, a = sR(this.tickmarkOffset, s.tickmarkOffset), n = this.getPosition(o, r, a, e), h = n.x, l = n.y, d = s.pos, c = d + s.len, p = o ? h : l, u = sR(i, this.label?.newOpacity, 1);
                !s.chart.polar && (sC(p) < d || p > c) && (i = 0), i ?? (i = 1), this.isActive = !0, this.renderGridLine(e, i), this.renderMark(n, i), this.renderLabel(n, e, u, t), this.isNew = !1, sL(this, "afterRender");
            }
            renderGridLine(t, e) {
                let i = this.axis, s = i.options, o = {}, r = this.pos, a = this.type, n = sR(this.tickmarkOffset, i.tickmarkOffset), h = i.chart.renderer, l = this.gridLine, d, c = s.gridLineWidth, p = s.gridLineColor, u = s.gridLineDashStyle;
                "minor" === this.type && (c = s.minorGridLineWidth, p = s.minorGridLineColor, u = s.minorGridLineDashStyle), l || (i.chart.styledMode || (o.stroke = p, o["stroke-width"] = c || 0, o.dashstyle = u), a || (o.zIndex = 1), t && (e = 0), this.gridLine = l = h.path().attr(o).addClass("highcharts-" + (a ? a + "-" : "") + "grid-line").add(i.gridGroup)), l && (d = i.getPlotLinePath({
                    value: r + n,
                    lineWidth: l.strokeWidth(),
                    force: "pass",
                    old: t,
                    acrossPanes: !1
                })) && l[t || this.isNew ? "attr" : "animate"]({
                    d: d,
                    opacity: e
                });
            }
            renderMark(t, e) {
                let i = this.axis, s = i.options, o = i.chart.renderer, r = this.type, a = i.tickSize(r ? r + "Tick" : "tick"), n = t.x, h = t.y, l = sR(s["minor" !== r ? "tickWidth" : "minorTickWidth"], !r && i.isXAxis ? 1 : 0), d = s["minor" !== r ? "tickColor" : "minorTickColor"], c = this.mark, p = !c;
                a && (i.opposite && (a[0] = -a[0]), !c && (this.mark = c = o.path().addClass("highcharts-" + (r ? r + "-" : "") + "tick").add(i.axisGroup), i.chart.styledMode || c.attr({
                    stroke: d,
                    "stroke-width": l
                })), c[p ? "attr" : "animate"]({
                    d: this.getMarkPath(n, h, a[0], c.strokeWidth(), i.horiz, o),
                    opacity: e
                }));
            }
            renderLabel(t, e, i, s) {
                let o = this.axis, r = o.horiz, a = o.options, n = this.label, h = a.labels, l = h.step, d = sR(this.tickmarkOffset, o.tickmarkOffset), c = t.x, p = t.y, u = !0;
                n && sD(c) && (n.xy = t = this.getLabelPosition(c, p, n, r, h, d, s, l), (!this.isFirst || this.isLast || a.showFirstLabel) && (!this.isLast || this.isFirst || a.showLastLabel) ? !r || h.step || h.rotation || e || 0 === i || this.handleOverflow(t) : u = !1, l && s % l && (u = !1), u && sD(t.y) ? (t.opacity = i, n[this.isNewLabel ? "attr" : "animate"](t).show(!0), this.isNewLabel = !1) : (n.hide(), this.isNewLabel = !0));
            }
            replaceMovedLabel() {
                let t = this.label, e = this.axis;
                t && !this.isNew && (t.animate({
                    opacity: 0
                }, void 0, t.destroy), delete this.label), e.isDirty = !0, this.label = this.movedLabel, delete this.movedLabel;
            }
        }, { animObject: sW } = eo, { xAxis: sG, yAxis: sX } = sb, { defaultOptions: sH } = tY, { registerEventOptions: sF } = sS, { deg2rad: sY } = V, { arrayMax: sj, arrayMin: sU, clamp: sV, correctFloat: s$, defined: s_, destroyObjectProperties: sZ, erase: sq, error: sK, extend: sJ, fireEvent: sQ, getClosestDistance: s0, insertItem: s1, isArray: s2, isNumber: s3, isString: s5, merge: s6, normalizeTickInterval: s9, objectEach: s4, pick: s8, relativeLength: s7, removeEvent: ot, splat: oe, syncTimeout: oi } = tx, os = (t, e)=>s9(e, void 0, void 0, s8(t.options.allowDecimals, e < .5 || void 0 !== t.tickAmount), !!t.tickAmount);
        sJ(sH, {
            xAxis: sG,
            yAxis: s6(sG, sX)
        });
        class oo {
            constructor(t, e, i){
                this.init(t, e, i);
            }
            init(t, e, i = this.coll) {
                let s = "xAxis" === i, o = this.isZAxis || (t.inverted ? !s : s);
                this.chart = t, this.horiz = o, this.isXAxis = s, this.coll = i, sQ(this, "init", {
                    userOptions: e
                }), this.opposite = s8(e.opposite, this.opposite), this.side = s8(e.side, this.side, o ? 2 * !this.opposite : this.opposite ? 1 : 3), this.setOptions(e);
                let r = this.options, a = r.labels;
                this.type ?? (this.type = r.type || "linear"), this.uniqueNames ?? (this.uniqueNames = r.uniqueNames ?? !0), sQ(this, "afterSetType"), this.userOptions = e, this.minPixelPadding = 0, this.reversed = s8(r.reversed, this.reversed), this.visible = r.visible, this.zoomEnabled = r.zoomEnabled, this.hasNames = "category" === this.type || !0 === r.categories, this.categories = s2(r.categories) && r.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = s_(r.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len ?? (this.len = 0), this.minRange = this.userMinRange = r.minRange || r.maxZoom, this.range = r.range, this.offset = r.offset || 0, this.max = void 0, this.min = void 0;
                let n = s8(r.crosshair, oe(t.options.tooltip.crosshairs)[+!s]);
                this.crosshair = !0 === n ? {} : n, -1 === t.axes.indexOf(this) && (s ? t.axes.splice(t.xAxis.length, 0, this) : t.axes.push(this), s1(this, t[this.coll])), t.orderItems(this.coll), this.series = this.series || [], t.inverted && !this.isZAxis && s && !s_(this.reversed) && (this.reversed = !0), this.labelRotation = s3(a.rotation) ? a.rotation : void 0, sF(this, r), sQ(this, "afterInit");
            }
            setOptions(t) {
                let e = this.horiz ? {
                    labels: {
                        autoRotation: [
                            -45
                        ],
                        padding: 3
                    },
                    margin: 15
                } : {
                    labels: {
                        padding: 1
                    },
                    title: {
                        rotation: 90 * this.side
                    }
                };
                this.options = s6(e, "yAxis" === this.coll ? {
                    title: {
                        text: this.chart.options.lang.yAxisTitle
                    }
                } : {}, sH[this.coll], t), sQ(this, "afterSetOptions", {
                    userOptions: t
                });
            }
            defaultLabelFormatter() {
                let t = this.axis, { numberFormatter: e } = this.chart, i = s3(this.value) ? this.value : NaN, s = t.chart.time, o = t.categories, r = this.dateTimeLabelFormat, a = sH.lang, n = a.numericSymbols, h = a.numericSymbolMagnitude || 1e3, l = t.logarithmic ? Math.abs(i) : t.tickInterval, d = n?.length, c, p;
                if (o) p = `${this.value}`;
                else if (r) p = s.dateFormat(r, i, !0);
                else if (d && n && l >= 1e3) for(; d-- && void 0 === p;)l >= (c = Math.pow(h, d + 1)) && 10 * i % c == 0 && null !== n[d] && 0 !== i && (p = e(i / c, -1) + n[d]);
                return void 0 === p && (p = Math.abs(i) >= 1e4 ? e(i, -1) : e(i, -1, void 0, "")), p;
            }
            getSeriesExtremes() {
                let t, e = this;
                sQ(this, "getSeriesExtremes", null, function() {
                    e.hasVisibleSeries = !1, e.dataMin = e.dataMax = e.threshold = void 0, e.softThreshold = !e.isXAxis, e.series.forEach((i)=>{
                        if (i.reserveSpace()) {
                            let s = i.options, o, r = s.threshold, a, n;
                            if (e.hasVisibleSeries = !0, e.positiveValuesOnly && 0 >= (r || 0) && (r = void 0), e.isXAxis) (o = i.getColumn("x")).length && (o = e.logarithmic ? o.filter((t)=>t > 0) : o, a = (t = i.getXExtremes(o)).min, n = t.max, s3(a) || a instanceof Date || (o = o.filter(s3), a = (t = i.getXExtremes(o)).min, n = t.max), o.length && (e.dataMin = Math.min(s8(e.dataMin, a), a), e.dataMax = Math.max(s8(e.dataMax, n), n)));
                            else {
                                let t = i.applyExtremes();
                                s3(t.dataMin) && (a = t.dataMin, e.dataMin = Math.min(s8(e.dataMin, a), a)), s3(t.dataMax) && (n = t.dataMax, e.dataMax = Math.max(s8(e.dataMax, n), n)), s_(r) && (e.threshold = r), (!s.softThreshold || e.positiveValuesOnly) && (e.softThreshold = !1);
                            }
                        }
                    });
                }), sQ(this, "afterGetSeriesExtremes");
            }
            translate(t, e, i, s, o, r) {
                let a = this.linkedParent || this, n = s && a.old ? a.old.min : a.min;
                if (!s3(n)) return NaN;
                let h = a.minPixelPadding, l = (a.isOrdinal || a.brokenAxis?.hasBreaks || a.logarithmic && o) && !!a.lin2val, d = 1, c = 0, p = s && a.old ? a.old.transA : a.transA, u = 0;
                return p || (p = a.transA), i && (d *= -1, c = a.len), a.reversed && (d *= -1, c -= d * (a.sector || a.len)), e ? (u = (t = t * d + c - h) / p + n, l && (u = a.lin2val(u))) : (l && (t = a.val2lin(t)), u = d * (t - n) * p + c + d * h + (s3(r) ? p * r : 0), a.isRadial || (u = s$(u))), u;
            }
            toPixels(t, e) {
                return this.translate(this.chart?.time.parse(t) ?? NaN, !1, !this.horiz, void 0, !0) + (e ? 0 : this.pos);
            }
            toValue(t, e) {
                return this.translate(t - (e ? 0 : this.pos), !0, !this.horiz, void 0, !0);
            }
            getPlotLinePath(t) {
                let e = this, i = e.chart, s = e.left, o = e.top, r = t.old, a = t.value, n = t.lineWidth, h = r && i.oldChartHeight || i.chartHeight, l = r && i.oldChartWidth || i.chartWidth, d = e.transB, c = t.translatedValue, p = t.force, u, g, f, m, x;
                function y(t, e, i) {
                    return "pass" !== p && (t < e || t > i) && (p ? t = sV(t, e, i) : x = !0), t;
                }
                let b = {
                    value: a,
                    lineWidth: n,
                    old: r,
                    force: p,
                    acrossPanes: t.acrossPanes,
                    translatedValue: c
                };
                return sQ(this, "getPlotLinePath", b, function(t) {
                    u = f = (c = sV(c = s8(c, e.translate(a, void 0, void 0, r)), -1e9, 1e9)) + d, g = m = h - c - d, s3(c) ? e.horiz ? (g = o, m = h - e.bottom + (e.options.isInternal ? 0 : i.scrollablePixelsY || 0), u = f = y(u, s, s + e.width)) : (u = s, f = l - e.right + (i.scrollablePixelsX || 0), g = m = y(g, o, o + e.height)) : (x = !0, p = !1), t.path = x && !p ? void 0 : i.renderer.crispLine([
                        [
                            "M",
                            u,
                            g
                        ],
                        [
                            "L",
                            f,
                            m
                        ]
                    ], n || 1);
                }), b.path;
            }
            getLinearTickPositions(t, e, i) {
                let s, o, r, a = s$(Math.floor(e / t) * t), n = s$(Math.ceil(i / t) * t), h = [];
                if (s$(a + t) === a && (r = 20), this.single) return [
                    e
                ];
                for(s = a; s <= n && (h.push(s), (s = s$(s + t, r)) !== o);)o = s;
                return h;
            }
            getMinorTickInterval() {
                let { minorTicks: t, minorTickInterval: e } = this.options;
                return !0 === t ? s8(e, "auto") : !1 !== t ? e : void 0;
            }
            getMinorTickPositions() {
                let t = this.options, e = this.tickPositions, i = this.minorTickInterval, s = this.pointRangePadding || 0, o = (this.min || 0) - s, r = (this.max || 0) + s, a = this.brokenAxis?.hasBreaks ? this.brokenAxis.unitLength : r - o, n = [], h;
                if (a && a / i < this.len / 3) {
                    let s = this.logarithmic;
                    if (s) this.paddedTicks.forEach(function(t, e, o) {
                        e && n.push.apply(n, s.getLogTickPositions(i, o[e - 1], o[e], !0));
                    });
                    else if (this.dateTime && "auto" === this.getMinorTickInterval()) n = n.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i), o, r, t.startOfWeek));
                    else for(h = o + (e[0] - o) % i; h <= r && h !== n[0]; h += i)n.push(h);
                }
                return 0 !== n.length && this.trimTicks(n), n;
            }
            adjustForMinRange() {
                let t = this.options, e = this.logarithmic, i = this.chart.time, { max: s, min: o, minRange: r } = this, a, n, h, l;
                this.isXAxis && void 0 === r && !e && (r = s_(t.min) || s_(t.max) || s_(t.floor) || s_(t.ceiling) ? null : Math.min(5 * (s0(this.series.map((t)=>{
                    let e = t.getColumn("x");
                    return t.xIncrement ? e.slice(0, 2) : e;
                })) || 0), this.dataMax - this.dataMin)), s3(s) && s3(o) && s3(r) && s - o < r && (n = this.dataMax - this.dataMin >= r, a = (r - s + o) / 2, h = [
                    o - a,
                    i.parse(t.min) ?? o - a
                ], n && (h[2] = e ? e.log2lin(this.dataMin) : this.dataMin), l = [
                    (o = sj(h)) + r,
                    i.parse(t.max) ?? o + r
                ], n && (l[2] = e ? e.log2lin(this.dataMax) : this.dataMax), (s = sU(l)) - o < r && (h[0] = s - r, h[1] = i.parse(t.min) ?? s - r, o = sj(h))), this.minRange = r, this.min = o, this.max = s;
            }
            getClosest() {
                let t, e;
                if (this.categories) e = 1;
                else {
                    let i = [];
                    this.series.forEach(function(t) {
                        let s = t.closestPointRange, o = t.getColumn("x");
                        1 === o.length ? i.push(o[0]) : t.sorted && s_(s) && t.reserveSpace() && (e = s_(e) ? Math.min(e, s) : s);
                    }), i.length && (i.sort((t, e)=>t - e), t = s0([
                        i
                    ]));
                }
                return t && e ? Math.min(t, e) : t || e;
            }
            nameToX(t) {
                let e = s2(this.options.categories), i = e ? this.categories : this.names, s = t.options.x, o;
                return t.series.requireSorting = !1, s_(s) || (s = this.uniqueNames && i ? e ? i.indexOf(t.name) : s8(i.keys[t.name], -1) : t.series.autoIncrement()), -1 === s ? !e && i && (o = i.length) : s3(s) && (o = s), void 0 !== o ? (this.names[o] = t.name, this.names.keys[t.name] = o) : t.x && (o = t.x), o;
            }
            updateNames() {
                let t = this, e = this.names;
                e.length > 0 && (Object.keys(e.keys).forEach(function(t) {
                    delete e.keys[t];
                }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach((e)=>{
                    e.xIncrement = null, (!e.points || e.isDirtyData) && (t.max = Math.max(t.max || 0, e.dataTable.rowCount - 1), e.processData(), e.generatePoints());
                    let i = e.getColumn("x").slice();
                    e.data.forEach((e, s)=>{
                        let o = i[s];
                        e?.options && void 0 !== e.name && void 0 !== (o = t.nameToX(e)) && o !== e.x && (i[s] = e.x = o);
                    }), e.dataTable.setColumn("x", i);
                }));
            }
            setAxisTranslation() {
                let t = this, e = t.max - t.min, i = t.linkedParent, s = !!t.categories, o = t.isXAxis, r = t.axisPointRange || 0, a, n = 0, h = 0, l, d = t.transA;
                (o || s || r) && (a = t.getClosest(), i ? (n = i.minPointOffset, h = i.pointRangePadding) : t.series.forEach(function(e) {
                    let i = s ? 1 : o ? s8(e.options.pointRange, a, 0) : t.axisPointRange || 0, l = e.options.pointPlacement;
                    if (r = Math.max(r, i), !t.single || s) {
                        let t = e.is("xrange") ? !o : o;
                        n = Math.max(n, t && s5(l) ? 0 : i / 2), h = Math.max(h, t && "on" === l ? 0 : i);
                    }
                }), l = t.ordinal?.slope && a ? t.ordinal.slope / a : 1, t.minPointOffset = n *= l, t.pointRangePadding = h *= l, t.pointRange = Math.min(r, t.single && s ? 1 : e), o && (t.closestPointRange = a)), t.translationSlope = t.transA = d = t.staticScale || t.len / (e + h || 1), t.transB = t.horiz ? t.left : t.bottom, t.minPixelPadding = d * n, sQ(this, "afterSetAxisTranslation");
            }
            minFromRange() {
                let { max: t, min: e } = this;
                return s3(t) && s3(e) && t - e || void 0;
            }
            setTickInterval(t) {
                let { categories: e, chart: i, dataMax: s, dataMin: o, dateTime: r, isXAxis: a, logarithmic: n, options: h, softThreshold: l } = this, d = i.time, c = s3(this.threshold) ? this.threshold : void 0, p = this.minRange || 0, { ceiling: u, floor: g, linkedTo: f, softMax: m, softMin: x } = h, y = s3(f) && i[this.coll]?.[f], b = h.tickPixelInterval, v = h.maxPadding, k = h.minPadding, M = 0, w, S = s3(h.tickInterval) && h.tickInterval >= 0 ? h.tickInterval : void 0, A, T, C, P;
                if (r || e || y || this.getTickAmount(), C = s8(this.userMin, d.parse(h.min)), P = s8(this.userMax, d.parse(h.max)), y ? (this.linkedParent = y, w = y.getExtremes(), this.min = s8(w.min, w.dataMin), this.max = s8(w.max, w.dataMax), this.type !== y.type && sK(11, !0, i)) : (l && s_(c) && s3(s) && s3(o) && (o >= c ? (A = c, k = 0) : s <= c && (T = c, v = 0)), this.min = s8(C, A, o), this.max = s8(P, T, s)), s3(this.max) && s3(this.min) && (n && (this.positiveValuesOnly && !t && 0 >= Math.min(this.min, s8(o, this.min)) && sK(10, !0, i), this.min = s$(n.log2lin(this.min), 16), this.max = s$(n.log2lin(this.max), 16)), this.range && s3(o) && (this.userMin = this.min = C = Math.max(o, this.minFromRange() || 0), this.userMax = P = this.max, this.range = void 0)), sQ(this, "foundExtremes"), this.adjustForMinRange(), s3(this.min) && s3(this.max)) {
                    if (!s3(this.userMin) && s3(x) && x < this.min && (this.min = C = x), !s3(this.userMax) && s3(m) && m > this.max && (this.max = P = m), e || this.axisPointRange || this.stacking?.usePercentage || y || (M = this.max - this.min) && (!s_(C) && k && (this.min -= M * k), !s_(P) && v && (this.max += M * v)), !s3(this.userMin) && s3(g) && (this.min = Math.max(this.min, g)), !s3(this.userMax) && s3(u) && (this.max = Math.min(this.max, u)), l && s3(o) && s3(s)) {
                        let t = c || 0;
                        !s_(C) && this.min < t && o >= t ? this.min = h.minRange ? Math.min(t, this.max - p) : t : !s_(P) && this.max > t && s <= t && (this.max = h.minRange ? Math.max(t, this.min + p) : t);
                    }
                    !i.polar && this.min > this.max && (s_(h.min) ? this.max = this.min : s_(h.max) && (this.min = this.max)), M = this.max - this.min;
                }
                if (this.min !== this.max && s3(this.min) && s3(this.max) ? y && !S && b === y.options.tickPixelInterval ? this.tickInterval = S = y.tickInterval : this.tickInterval = s8(S, this.tickAmount ? M / Math.max(this.tickAmount - 1, 1) : void 0, e ? 1 : M * b / Math.max(this.len, b)) : this.tickInterval = 1, a && !t) {
                    let t = this.min !== this.old?.min || this.max !== this.old?.max;
                    this.series.forEach(function(e) {
                        e.forceCrop = e.forceCropping?.(), e.processData(t);
                    }), sQ(this, "postProcessData", {
                        hasExtremesChanged: t
                    });
                }
                this.setAxisTranslation(), sQ(this, "initialAxisTranslation"), this.pointRange && !S && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
                let O = s8(h.minTickInterval, r && !this.series.some((t)=>!t.sorted) ? this.closestPointRange : 0);
                !S && O && this.tickInterval < O && (this.tickInterval = O), r || n || S || (this.tickInterval = os(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();
            }
            setTickPositions() {
                let t = this.options, e = t.tickPositions, i = t.tickPositioner, s = this.getMinorTickInterval(), o = !this.isPanning, r = o && t.startOnTick, a = o && t.endOnTick, n = [], h;
                if (this.tickmarkOffset = this.categories && "between" === t.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0, this.single = this.min === this.max && s_(this.min) && !this.tickAmount && (this.min % 1 == 0 || !1 !== t.allowDecimals), e) n = e.slice();
                else if (s3(this.min) && s3(this.max)) {
                    if (!this.ordinal?.positions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) n = [
                        this.min,
                        this.max
                    ], sK(19, !1, this.chart);
                    else if (this.dateTime) n = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t.units), this.min, this.max, t.startOfWeek, this.ordinal?.positions, this.closestPointRange, !0);
                    else if (this.logarithmic) n = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
                    else {
                        let t = this.tickInterval, e = t;
                        for(; e <= 2 * t;)if (n = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && n.length > this.tickAmount) this.tickInterval = os(this, e *= 1.1);
                        else break;
                    }
                    n.length > this.len && (n = [
                        n[0],
                        n[n.length - 1]
                    ])[0] === n[1] && (n.length = 1), i && (this.tickPositions = n, (h = i.apply(this, [
                        this.min,
                        this.max
                    ])) && (n = h));
                }
                this.tickPositions = n, this.minorTickInterval = "auto" === s && this.tickInterval ? this.tickInterval / t.minorTicksPerMajor : s, this.paddedTicks = n.slice(0), this.trimTicks(n, r, a), !this.isLinked && s3(this.min) && s3(this.max) && (this.single && n.length < 2 && !this.categories && !this.series.some((t)=>t.is("heatmap") && "between" === t.options.pointPlacement) && (this.min -= .5, this.max += .5), e || h || this.adjustTickAmount()), sQ(this, "afterSetTickPositions");
            }
            trimTicks(t, e, i) {
                let s = t[0], o = t[t.length - 1], r = !this.isOrdinal && this.minPointOffset || 0;
                if (sQ(this, "trimTicks"), !this.isLinked || !this.grid) {
                    if (e && s !== -1 / 0) this.min = s;
                    else for(; this.min - r > t[0];)t.shift();
                    if (i) this.max = o;
                    else for(; this.max + r < t[t.length - 1];)t.pop();
                    0 === t.length && s_(s) && !this.options.tickPositions && t.push((o + s) / 2);
                }
            }
            alignToOthers() {
                let t, e = this, i = e.chart, s = [
                    this
                ], o = e.options, r = i.options.chart, a = "yAxis" === this.coll && r.alignThresholds, n = [];
                if (e.thresholdAlignment = void 0, (!1 !== r.alignTicks && o.alignTicks || a) && !1 !== o.startOnTick && !1 !== o.endOnTick && !e.logarithmic) {
                    let o = (t)=>{
                        let { horiz: e, options: i } = t;
                        return [
                            e ? i.left : i.top,
                            i.width,
                            i.height,
                            i.pane
                        ].join(",");
                    }, r = o(this);
                    i[this.coll].forEach(function(i) {
                        let { series: a } = i;
                        a.length && a.some((t)=>t.visible) && i !== e && o(i) === r && (t = !0, s.push(i));
                    });
                }
                if (t && a) {
                    s.forEach((t)=>{
                        let i = t.getThresholdAlignment(e);
                        s3(i) && n.push(i);
                    });
                    let t = n.length > 1 ? n.reduce((t, e)=>t += e, 0) / n.length : void 0;
                    s.forEach((e)=>{
                        e.thresholdAlignment = t;
                    });
                }
                return t;
            }
            getThresholdAlignment(t) {
                if ((!s3(this.dataMin) || this !== t && this.series.some((t)=>t.isDirty || t.isDirtyData || t.xAxis?.isDirty)) && this.getSeriesExtremes(), s3(this.threshold)) {
                    let t = sV((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);
                    return this.options.reversed && (t = 1 - t), t;
                }
            }
            getTickAmount() {
                let t = this.options, e = t.tickPixelInterval, i = t.tickAmount;
                s_(t.tickInterval) || i || !(this.len < e) || this.isRadial || this.logarithmic || !t.startOnTick || !t.endOnTick || (i = 2), !i && this.alignToOthers() && (i = Math.ceil(this.len / e) + 1), i < 4 && (this.finalTickAmt = i, i = 5), this.tickAmount = i;
            }
            adjustTickAmount() {
                let t = this, { finalTickAmt: e, max: i, min: s, options: o, tickPositions: r, tickAmount: a, thresholdAlignment: n } = t, h = r?.length, l = s8(t.threshold, t.softThreshold ? 0 : null), d, c, p = t.tickInterval, u, g = ()=>r.push(s$(r[r.length - 1] + p)), f = ()=>r.unshift(s$(r[0] - p));
                if (s3(n) && (u = 0 === n ? 0 : 1 === n ? a - 1 : Math.round(sV(n * (a - 1), 1, a - 2)), o.reversed && (u = a - 1 - u)), t.hasData() && s3(s) && s3(i)) {
                    let n = ()=>{
                        t.transA *= (h - 1) / (a - 1), t.min = o.startOnTick ? r[0] : Math.min(s, r[0]), t.max = o.endOnTick ? r[r.length - 1] : Math.max(i, r[r.length - 1]);
                    };
                    if (s3(u) && s3(t.threshold)) {
                        for(; r[u] !== l || r.length !== a || r[0] > s || r[r.length - 1] < i;){
                            for(r.length = 0, r.push(t.threshold); r.length < a;)void 0 === r[u] || r[u] > t.threshold ? f() : g();
                            if (p > 8 * t.tickInterval) break;
                            p *= 2;
                        }
                        n();
                    } else if (h < a) {
                        for(; r.length < a;)r.length % 2 || s === l ? g() : f();
                        n();
                    }
                    if (s_(e)) {
                        for(c = d = r.length; c--;)(3 === e && c % 2 == 1 || e <= 2 && c > 0 && c < d - 1) && r.splice(c, 1);
                        t.finalTickAmt = void 0;
                    }
                }
            }
            setScale() {
                let { coll: t, stacking: e } = this, i = !1, s = !1;
                this.series.forEach((t)=>{
                    i = i || t.isDirtyData || t.isDirty, s = s || t.xAxis?.isDirty || !1;
                }), this.setAxisSize();
                let o = this.len !== this.old?.len;
                o || i || s || this.isLinked || this.forceRedraw || this.userMin !== this.old?.userMin || this.userMax !== this.old?.userMax || this.alignToOthers() ? (e && "yAxis" === t && e.buildStacks(), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e && "xAxis" === t && e.buildStacks(), this.isDirty || (this.isDirty = o || this.min !== this.old?.min || this.max !== this.old?.max)) : e && e.cleanStacks(), i && delete this.allExtremes, sQ(this, "afterSetScale");
            }
            setExtremes(t, e, i = !0, s, o) {
                let r = this.chart;
                this.series.forEach((t)=>{
                    delete t.kdTree;
                }), t = r.time.parse(t), e = r.time.parse(e), sQ(this, "setExtremes", o = sJ(o, {
                    min: t,
                    max: e
                }), (t)=>{
                    this.userMin = t.min, this.userMax = t.max, this.eventArgs = t, i && r.redraw(s);
                });
            }
            setAxisSize() {
                let t = this.chart, e = this.options, i = e.offsets || [
                    0,
                    0,
                    0,
                    0
                ], s = this.horiz, o = this.width = Math.round(s7(s8(e.width, t.plotWidth - i[3] + i[1]), t.plotWidth)), r = this.height = Math.round(s7(s8(e.height, t.plotHeight - i[0] + i[2]), t.plotHeight)), a = this.top = Math.round(s7(s8(e.top, t.plotTop + i[0]), t.plotHeight, t.plotTop)), n = this.left = Math.round(s7(s8(e.left, t.plotLeft + i[3]), t.plotWidth, t.plotLeft));
                this.bottom = t.chartHeight - r - a, this.right = t.chartWidth - o - n, this.len = Math.max(s ? o : r, 0), this.pos = s ? n : a;
            }
            getExtremes() {
                let t = this.logarithmic;
                return {
                    min: t ? s$(t.lin2log(this.min)) : this.min,
                    max: t ? s$(t.lin2log(this.max)) : this.max,
                    dataMin: this.dataMin,
                    dataMax: this.dataMax,
                    userMin: this.userMin,
                    userMax: this.userMax
                };
            }
            getThreshold(t) {
                let e = this.logarithmic, i = e ? e.lin2log(this.min) : this.min, s = e ? e.lin2log(this.max) : this.max;
                return null === t || t === -1 / 0 ? t = i : t === 1 / 0 ? t = s : i > t ? t = i : s < t && (t = s), this.translate(t, 0, 1, 0, 1);
            }
            autoLabelAlign(t) {
                let e = ((t - 90 * this.side) % 360 + 360) % 360, i = {
                    align: "center"
                };
                return sQ(this, "autoLabelAlign", i, function(t) {
                    e > 15 && e < 165 ? t.align = "right" : e > 195 && e < 345 && (t.align = "left");
                }), i.align;
            }
            tickSize(t) {
                let e = this.options, i = s8(e["tick" === t ? "tickWidth" : "minorTickWidth"], "tick" === t && this.isXAxis && !this.categories ? 1 : 0), s = e["tick" === t ? "tickLength" : "minorTickLength"], o;
                i && s && ("inside" === e[t + "Position"] && (s = -s), o = [
                    s,
                    i
                ]);
                let r = {
                    tickSize: o
                };
                return sQ(this, "afterTickSize", r), r.tickSize;
            }
            labelMetrics() {
                let t = this.chart.renderer, e = this.ticks, i = e[Object.keys(e)[0]] || {};
                return this.chart.renderer.fontMetrics(i.label || i.movedLabel || t.box);
            }
            unsquish() {
                let t = this.options.labels, e = t.padding || 0, i = this.horiz, s = this.tickInterval, o = this.len / ((+!!this.categories + this.max - this.min) / s), r = t.rotation, a = s$(.8 * this.labelMetrics().h), n = Math.max(this.max - this.min, 0), h = function(t) {
                    let i = (t + 2 * e) / (o || 1);
                    return (i = i > 1 ? Math.ceil(i) : 1) * s > n && t !== 1 / 0 && o !== 1 / 0 && n && (i = Math.ceil(n / s)), s$(i * s);
                }, l = s, d, c = Number.MAX_VALUE, p;
                if (i) {
                    if (!t.staggerLines && (s3(r) ? p = [
                        r
                    ] : o < t.autoRotationLimit && (p = t.autoRotation)), p) {
                        let t, e;
                        for (let i of p)(i === r || i && i >= -90 && i <= 90) && (e = (t = h(Math.abs(a / Math.sin(sY * i)))) + Math.abs(i / 360)) < c && (c = e, d = i, l = t);
                    }
                } else l = h(.75 * a);
                return this.autoRotation = p, this.labelRotation = s8(d, s3(r) ? r : 0), t.step ? s : l;
            }
            getSlotWidth(t) {
                let e = this.chart, i = this.horiz, s = this.options.labels, o = Math.max(this.tickPositions.length - !this.categories, 1), r = e.margin[3];
                if (t && s3(t.slotWidth)) return t.slotWidth;
                if (i && s.step < 2 && !this.isRadial) return s.rotation ? 0 : (this.staggerLines || 1) * this.len / o;
                if (!i) {
                    let t = s.style.width;
                    if (void 0 !== t) return parseInt(String(t), 10);
                    if (!this.opposite && r) return r - e.spacing[3];
                }
                return .33 * e.chartWidth;
            }
            renderUnsquish() {
                let t = this.chart, e = t.renderer, i = this.tickPositions, s = this.ticks, o = this.options.labels, r = o.style, a = this.horiz, n = this.getSlotWidth(), h = Math.max(1, Math.round(n - (a ? 2 * (o.padding || 0) : o.distance || 0))), l = {}, d = this.labelMetrics(), c = r.lineClamp, p, u = c ?? (Math.floor(this.len / (i.length * d.h)) || 1), g = 0;
                s5(o.rotation) || (l.rotation = o.rotation || 0), i.forEach(function(t) {
                    let e = s[t];
                    e.movedLabel && e.replaceMovedLabel();
                    let i = e.label?.textPxLength || 0;
                    i > g && (g = i);
                }), this.maxLabelLength = g, this.autoRotation ? g > h && g > d.h ? l.rotation = this.labelRotation : this.labelRotation = 0 : n && (p = h), l.rotation && (p = g > .5 * t.chartHeight ? .33 * t.chartHeight : g, c || (u = 1)), this.labelAlign = o.align || this.autoLabelAlign(this.labelRotation || 0), this.labelAlign && (l.align = this.labelAlign), i.forEach(function(t) {
                    let e = s[t], i = e?.label, o = r.width, a = {};
                    i && (i.attr(l), e.shortenLabel ? e.shortenLabel() : p && !o && "nowrap" !== r.whiteSpace && (p < (i.textPxLength || 0) || "SPAN" === i.element.tagName) ? i.css(sJ(a, {
                        width: `${p}px`,
                        lineClamp: u
                    })) : !i.styles.width || a.width || o || i.css({
                        width: "auto"
                    }), e.rotation = l.rotation);
                }, this), this.tickRotCorr = e.rotCorr(d.b, this.labelRotation || 0, 0 !== this.side);
            }
            hasData() {
                return this.series.some(function(t) {
                    return t.hasData();
                }) || this.options.showEmpty && s_(this.min) && s_(this.max);
            }
            addTitle(t) {
                let e, i = this.chart.renderer, s = this.horiz, o = this.opposite, r = this.options.title, a = this.chart.styledMode;
                this.axisTitle || ((e = r.textAlign) || (e = (s ? {
                    low: "left",
                    middle: "center",
                    high: "right"
                } : {
                    low: o ? "right" : "left",
                    middle: "center",
                    high: o ? "left" : "right"
                })[r.align]), this.axisTitle = i.text(r.text || "", 0, 0, r.useHTML).attr({
                    zIndex: 7,
                    rotation: r.rotation || 0,
                    align: e
                }).addClass("highcharts-axis-title"), a || this.axisTitle.css(s6(r.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0), a || r.style.width || this.isRadial || this.axisTitle.css({
                    width: this.len + "px"
                }), this.axisTitle[t ? "show" : "hide"](t);
            }
            generateTick(t) {
                let e = this.ticks;
                e[t] ? e[t].addLabel() : e[t] = new sN(this, t);
            }
            createGroups() {
                let { axisParent: t, chart: e, coll: i, options: s } = this, o = e.renderer, r = (e, r, a)=>o.g(e).attr({
                        zIndex: a
                    }).addClass(`highcharts-${i.toLowerCase()}${r} ` + (this.isRadial ? `highcharts-radial-axis${r} ` : "") + (s.className || "")).add(t);
                this.axisGroup || (this.gridGroup = r("grid", "-grid", s.gridZIndex), this.axisGroup = r("axis", "", s.zIndex), this.labelGroup = r("axis-labels", "-labels", s.labels.zIndex));
            }
            getOffset() {
                let t = this, { chart: e, horiz: i, options: s, side: o, ticks: r, tickPositions: a, coll: n } = t, h = e.inverted && !t.isZAxis ? [
                    1,
                    0,
                    3,
                    2
                ][o] : o, l = t.hasData(), d = s.title, c = s.labels, p = s3(s.crossing), u = e.axisOffset, g = e.clipOffset, f = [
                    -1,
                    1,
                    1,
                    -1
                ][o], m, x = 0, y, b = 0, v = 0, k, M;
                if (t.showAxis = m = l || s.showEmpty, t.staggerLines = t.horiz && c.staggerLines || void 0, t.createGroups(), l || t.isLinked ? (a.forEach(function(e) {
                    t.generateTick(e);
                }), t.renderUnsquish(), t.reserveSpaceDefault = 0 === o || 2 === o || ({
                    1: "left",
                    3: "right"
                })[o] === t.labelAlign, s8(c.reserveSpace, !p && null, "center" === t.labelAlign || null, t.reserveSpaceDefault) && a.forEach(function(t) {
                    v = Math.max(r[t].getLabelSize(), v);
                }), t.staggerLines && (v *= t.staggerLines), t.labelOffset = v * (t.opposite ? -1 : 1)) : s4(r, function(t, e) {
                    t.destroy(), delete r[e];
                }), d?.text && !1 !== d.enabled && (t.addTitle(m), m && !p && !1 !== d.reserveSpace && (t.titleOffset = x = t.axisTitle.getBBox()[i ? "height" : "width"], b = s_(y = d.offset) ? 0 : s8(d.margin, i ? 5 : 10))), t.renderLine(), t.offset = f * s8(s.offset, u[o] ? u[o] + (s.margin || 0) : 0), t.tickRotCorr = t.tickRotCorr || {
                    x: 0,
                    y: 0
                }, M = 0 === o ? -t.labelMetrics().h : 2 === o ? t.tickRotCorr.y : 0, k = Math.abs(v) + b, v && (k -= M, k += f * (i ? s8(c.y, t.tickRotCorr.y + f * c.distance) : s8(c.x, f * c.distance))), t.axisTitleMargin = s8(y, k), t.getMaxLabelDimensions && (t.maxLabelDimensions = t.getMaxLabelDimensions(r, a)), "colorAxis" !== n && g) {
                    let e = this.tickSize("tick");
                    u[o] = Math.max(u[o], (t.axisTitleMargin || 0) + x + f * t.offset, k, a?.length && e ? e[0] + f * t.offset : 0);
                    let i = !t.axisLine || s.offset ? 0 : t.axisLine.strokeWidth() / 2;
                    g[h] = Math.max(g[h], i);
                }
                sQ(this, "afterGetOffset");
            }
            getLinePath(t) {
                let e = this.chart, i = this.opposite, s = this.offset, o = this.horiz, r = this.left + (i ? this.width : 0) + s, a = e.chartHeight - this.bottom - (i ? this.height : 0) + s;
                return i && (t *= -1), e.renderer.crispLine([
                    [
                        "M",
                        o ? this.left : r,
                        o ? a : this.top
                    ],
                    [
                        "L",
                        o ? e.chartWidth - this.right : r,
                        o ? a : e.chartHeight - this.bottom
                    ]
                ], t);
            }
            renderLine() {
                !this.axisLine && (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
                    stroke: this.options.lineColor,
                    "stroke-width": this.options.lineWidth,
                    zIndex: 7
                }));
            }
            getTitlePosition(t) {
                let e = this.horiz, i = this.left, s = this.top, o = this.len, r = this.options.title, a = e ? i : s, n = this.opposite, h = this.offset, l = r.x, d = r.y, c = this.chart.renderer.fontMetrics(t), p = t ? Math.max(t.getBBox(!1, 0).height - c.h - 1, 0) : 0, u = {
                    low: a + (e ? 0 : o),
                    middle: a + o / 2,
                    high: a + (e ? o : 0)
                }[r.align], g = (e ? s + this.height : i) + (e ? 1 : -1) * (n ? -1 : 1) * (this.axisTitleMargin || 0) + [
                    -p,
                    p,
                    c.f,
                    -p
                ][this.side], f = {
                    x: e ? u + l : g + (n ? this.width : 0) + h + l,
                    y: e ? g + d - (n ? this.height : 0) + h : u + d
                };
                return sQ(this, "afterGetTitlePosition", {
                    titlePosition: f
                }), f;
            }
            renderMinorTick(t, e) {
                let i = this.minorTicks;
                i[t] || (i[t] = new sN(this, t, "minor")), e && i[t].isNew && i[t].render(null, !0), i[t].render(null, !1, 1);
            }
            renderTick(t, e, i) {
                let s = this.isLinked, o = this.ticks;
                (!s || t >= this.min && t <= this.max || this.grid?.isColumn) && (o[t] || (o[t] = new sN(this, t)), i && o[t].isNew && o[t].render(e, !0, -1), o[t].render(e));
            }
            render() {
                let t, e, i = this, s = i.chart, o = i.logarithmic, r = s.renderer, a = i.options, n = i.isLinked, h = i.tickPositions, l = i.axisTitle, d = i.ticks, c = i.minorTicks, p = i.alternateBands, u = a.stackLabels, g = a.alternateGridColor, f = a.crossing, m = i.tickmarkOffset, x = i.axisLine, y = i.showAxis, b = sW(r.globalAnimation);
                if (i.labelEdge.length = 0, i.overlap = !1, [
                    d,
                    c,
                    p
                ].forEach(function(t) {
                    s4(t, function(t) {
                        t.isActive = !1;
                    });
                }), s3(f)) {
                    let t = this.isXAxis ? s.yAxis[0] : s.xAxis[0], e = [
                        1,
                        -1,
                        -1,
                        1
                    ][this.side];
                    if (t) {
                        let s = t.toPixels(f, !0);
                        i.horiz && (s = t.len - s), i.offset = e * s;
                    }
                }
                if (i.hasData() || n) {
                    let r = i.chart.hasRendered && i.old && s3(i.old.min);
                    i.minorTickInterval && !i.categories && i.getMinorTickPositions().forEach(function(t) {
                        i.renderMinorTick(t, r);
                    }), h.length && (h.forEach(function(t, e) {
                        i.renderTick(t, e, r);
                    }), m && (0 === i.min || i.single) && (d[-1] || (d[-1] = new sN(i, -1, null, !0)), d[-1].render(-1))), g && h.forEach(function(r, a) {
                        e = void 0 !== h[a + 1] ? h[a + 1] + m : i.max - m, a % 2 == 0 && r < i.max && e <= i.max + (s.polar ? -m : m) && (p[r] || (p[r] = new V.PlotLineOrBand(i, {})), t = r + m, p[r].options = {
                            from: o ? o.lin2log(t) : t,
                            to: o ? o.lin2log(e) : e,
                            color: g,
                            className: "highcharts-alternate-grid"
                        }, p[r].render(), p[r].isActive = !0);
                    }), i._addedPlotLB || (i._addedPlotLB = !0, (a.plotLines || []).concat(a.plotBands || []).forEach(function(t) {
                        i.addPlotBandOrLine(t);
                    }));
                }
                [
                    d,
                    c,
                    p
                ].forEach(function(t) {
                    let e = [], i = b.duration;
                    s4(t, function(t, i) {
                        t.isActive || (t.render(i, !1, 0), t.isActive = !1, e.push(i));
                    }), oi(function() {
                        let i = e.length;
                        for(; i--;)t[e[i]] && !t[e[i]].isActive && (t[e[i]].destroy(), delete t[e[i]]);
                    }, t !== p && s.hasRendered && i ? i : 0);
                }), x && (x[x.isPlaced ? "animate" : "attr"]({
                    d: this.getLinePath(x.strokeWidth())
                }), x.isPlaced = !0, x[y ? "show" : "hide"](y)), l && y && (l[l.isNew ? "attr" : "animate"](i.getTitlePosition(l)), l.isNew = !1), u?.enabled && i.stacking && i.stacking.renderStackTotals(), i.old = {
                    len: i.len,
                    max: i.max,
                    min: i.min,
                    transA: i.transA,
                    userMax: i.userMax,
                    userMin: i.userMin
                }, i.isDirty = !1, sQ(this, "afterRender");
            }
            redraw() {
                this.visible && (this.render(), this.plotLinesAndBands.forEach(function(t) {
                    t.render();
                })), this.series.forEach(function(t) {
                    t.isDirty = !0;
                });
            }
            getKeepProps() {
                return this.keepProps || oo.keepProps;
            }
            destroy(t) {
                let e = this, i = e.plotLinesAndBands, s = this.eventOptions;
                if (sQ(this, "destroy", {
                    keepEvents: t
                }), t || ot(e), [
                    e.ticks,
                    e.minorTicks,
                    e.alternateBands
                ].forEach(function(t) {
                    sZ(t);
                }), i) {
                    let t = i.length;
                    for(; t--;)i[t].destroy();
                }
                for(let t in [
                    "axisLine",
                    "axisTitle",
                    "axisGroup",
                    "gridGroup",
                    "labelGroup",
                    "cross",
                    "scrollbar"
                ].forEach(function(t) {
                    e[t] && (e[t] = e[t].destroy());
                }), e.plotLinesAndBandsGroups)e.plotLinesAndBandsGroups[t] = e.plotLinesAndBandsGroups[t].destroy();
                s4(e, function(t, i) {
                    -1 === e.getKeepProps().indexOf(i) && delete e[i];
                }), this.eventOptions = s;
            }
            drawCrosshair(t, e) {
                let i = this.crosshair, s = i?.snap ?? !0, o = this.chart, r, a, n, h = this.cross, l;
                if (sQ(this, "drawCrosshair", {
                    e: t,
                    point: e
                }), t || (t = this.cross?.e), i && !1 !== (s_(e) || !s)) {
                    if (s ? s_(e) && (a = s8("colorAxis" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : a = t && (this.horiz ? t.chartX - this.pos : this.len - t.chartY + this.pos), s_(a) && (l = {
                        value: e && (this.isXAxis ? e.x : s8(e.stackY, e.y)),
                        translatedValue: a
                    }, o.polar && sJ(l, {
                        isCrosshair: !0,
                        chartX: t?.chartX,
                        chartY: t?.chartY,
                        point: e
                    }), r = this.getPlotLinePath(l) || null), !s_(r)) return void this.hideCrosshair();
                    n = this.categories && !this.isRadial, h || (this.cross = h = o.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (n ? "category " : "thin ") + (i.className || "")).attr({
                        zIndex: s8(i.zIndex, 2)
                    }).add(), !o.styledMode && (h.attr({
                        stroke: i.color || (n ? tJ.parse("#ccd3ff").setOpacity(.25).get() : "#cccccc"),
                        "stroke-width": s8(i.width, 1)
                    }).css({
                        "pointer-events": "none"
                    }), i.dashStyle && h.attr({
                        dashstyle: i.dashStyle
                    }))), h.show().attr({
                        d: r
                    }), n && !i.width && h.attr({
                        "stroke-width": this.transA
                    }), this.cross.e = t;
                } else this.hideCrosshair();
                sQ(this, "afterDrawCrosshair", {
                    e: t,
                    point: e
                });
            }
            hideCrosshair() {
                this.cross && this.cross.hide(), sQ(this, "afterHideCrosshair");
            }
            update(t, e) {
                let i = this.chart;
                t = s6(this.userOptions, t), this.destroy(!0), this.init(i, t), i.isDirtyBox = !0, s8(e, !0) && i.redraw();
            }
            remove(t) {
                let e = this.chart, i = this.coll, s = this.series, o = s.length;
                for(; o--;)s[o] && s[o].remove(!1);
                sq(e.axes, this), sq(e[i] || [], this), e.orderItems(i), this.destroy(), e.isDirtyBox = !0, s8(t, !0) && e.redraw();
            }
            setTitle(t, e) {
                this.update({
                    title: t
                }, e);
            }
            setCategories(t, e) {
                this.update({
                    categories: t
                }, e);
            }
        }
        oo.keepProps = [
            "coll",
            "extKey",
            "hcEvents",
            "len",
            "names",
            "series",
            "userMax",
            "userMin"
        ];
        let { addEvent: or, getMagnitude: oa, normalizeTickInterval: on, timeUnits: oh } = tx;
        !function(t) {
            function e() {
                return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
            }
            function i() {
                if ("datetime" !== this.type) {
                    this.dateTime = void 0;
                    return;
                }
                this.dateTime || (this.dateTime = new s(this));
            }
            t.compose = function(t) {
                return t.keepProps.includes("dateTime") || (t.keepProps.push("dateTime"), t.prototype.getTimeTicks = e, or(t, "afterSetType", i)), t;
            };
            class s {
                constructor(t){
                    this.axis = t;
                }
                normalizeTimeTickInterval(t, e) {
                    let i = e || [
                        [
                            "millisecond",
                            [
                                1,
                                2,
                                5,
                                10,
                                20,
                                25,
                                50,
                                100,
                                200,
                                500
                            ]
                        ],
                        [
                            "second",
                            [
                                1,
                                2,
                                5,
                                10,
                                15,
                                30
                            ]
                        ],
                        [
                            "minute",
                            [
                                1,
                                2,
                                5,
                                10,
                                15,
                                30
                            ]
                        ],
                        [
                            "hour",
                            [
                                1,
                                2,
                                3,
                                4,
                                6,
                                8,
                                12
                            ]
                        ],
                        [
                            "day",
                            [
                                1,
                                2
                            ]
                        ],
                        [
                            "week",
                            [
                                1,
                                2
                            ]
                        ],
                        [
                            "month",
                            [
                                1,
                                2,
                                3,
                                4,
                                6
                            ]
                        ],
                        [
                            "year",
                            null
                        ]
                    ], s = i[i.length - 1], o = oh[s[0]], r = s[1], a;
                    for(a = 0; a < i.length && (o = oh[(s = i[a])[0]], r = s[1], !i[a + 1] || !(t <= (o * r[r.length - 1] + oh[i[a + 1][0]]) / 2)); a++);
                    o === oh.year && t < 5 * o && (r = [
                        1,
                        2,
                        5
                    ]);
                    let n = on(t / o, r, "year" === s[0] ? Math.max(oa(t / o), 1) : 1);
                    return {
                        unitRange: o,
                        count: n,
                        unitName: s[0]
                    };
                }
                getXDateFormat(t, e) {
                    let { axis: i } = this, s = i.chart.time;
                    return i.closestPointRange ? s.getDateFormat(i.closestPointRange, t, i.options.startOfWeek, e) || s.resolveDTLFormat(e.year).main : s.resolveDTLFormat(e.day).main;
                }
            }
            t.Additions = s;
        }(A || (A = {}));
        let ol = A, { addEvent: od, normalizeTickInterval: oc, pick: op } = tx;
        !function(t) {
            function e() {
                "logarithmic" !== this.type ? this.logarithmic = void 0 : this.logarithmic ?? (this.logarithmic = new s(this));
            }
            function i() {
                let t = this.logarithmic;
                t && (this.lin2val = function(e) {
                    return t.lin2log(e);
                }, this.val2lin = function(e) {
                    return t.log2lin(e);
                });
            }
            t.compose = function(t) {
                return t.keepProps.includes("logarithmic") || (t.keepProps.push("logarithmic"), od(t, "afterSetType", e), od(t, "afterInit", i)), t;
            };
            class s {
                constructor(t){
                    this.axis = t;
                }
                getLogTickPositions(t, e, i, s) {
                    let o = this.axis, r = o.len, a = o.options, n = [];
                    if (s || (this.minorAutoInterval = void 0), t >= .5) t = Math.round(t), n = o.getLinearTickPositions(t, e, i);
                    else if (t >= .08) {
                        let o, r, a, h, l, d, c, p = Math.floor(e);
                        for(o = t > .3 ? [
                            1,
                            2,
                            4
                        ] : t > .15 ? [
                            1,
                            2,
                            4,
                            6,
                            8
                        ] : [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6,
                            7,
                            8,
                            9
                        ], r = p; r < i + 1 && !c; r++)for(a = 0, h = o.length; a < h && !c; a++)(l = this.log2lin(this.lin2log(r) * o[a])) > e && (!s || d <= i) && void 0 !== d && n.push(d), d > i && (c = !0), d = l;
                    } else {
                        let h = this.lin2log(e), l = this.lin2log(i), d = s ? o.getMinorTickInterval() : a.tickInterval, c = a.tickPixelInterval / (s ? 5 : 1), p = s ? r / o.tickPositions.length : r;
                        t = oc(t = op("auto" === d ? null : d, this.minorAutoInterval, (l - h) * c / (p || 1))), n = o.getLinearTickPositions(t, h, l).map(this.log2lin), s || (this.minorAutoInterval = t / 5);
                    }
                    return s || (o.tickInterval = t), n;
                }
                lin2log(t) {
                    return Math.pow(10, t);
                }
                log2lin(t) {
                    return Math.log(t) / Math.LN10;
                }
            }
            t.Additions = s;
        }(T || (T = {}));
        let ou = T, { erase: og, extend: of, isNumber: om } = tx;
        !function(t) {
            let e;
            function i(t) {
                return this.addPlotBandOrLine(t, "plotBands");
            }
            function s(t, i) {
                let s = this.userOptions, o = new e(this, t);
                if (this.visible && (o = o.render()), o) {
                    if (this._addedPlotLB || (this._addedPlotLB = !0, (s.plotLines || []).concat(s.plotBands || []).forEach((t)=>{
                        this.addPlotBandOrLine(t);
                    })), i) {
                        let e = s[i] || [];
                        e.push(t), s[i] = e;
                    }
                    this.plotLinesAndBands.push(o);
                }
                return o;
            }
            function o(t) {
                return this.addPlotBandOrLine(t, "plotLines");
            }
            function r(t, e, i) {
                i = i || this.options;
                let s = this.getPlotLinePath({
                    value: e,
                    force: !0,
                    acrossPanes: i.acrossPanes
                }), o = [], r = this.horiz, a = !om(this.min) || !om(this.max) || t < this.min && e < this.min || t > this.max && e > this.max, n = this.getPlotLinePath({
                    value: t,
                    force: !0,
                    acrossPanes: i.acrossPanes
                }), h, l = 1, d;
                if (n && s) for(a && (d = n.toString() === s.toString(), l = 0), h = 0; h < n.length; h += 2){
                    let t = n[h], e = n[h + 1], i = s[h], a = s[h + 1];
                    ("M" === t[0] || "L" === t[0]) && ("M" === e[0] || "L" === e[0]) && ("M" === i[0] || "L" === i[0]) && ("M" === a[0] || "L" === a[0]) && (r && i[1] === t[1] ? (i[1] += l, a[1] += l) : r || i[2] !== t[2] || (i[2] += l, a[2] += l), o.push([
                        "M",
                        t[1],
                        t[2]
                    ], [
                        "L",
                        e[1],
                        e[2]
                    ], [
                        "L",
                        a[1],
                        a[2]
                    ], [
                        "L",
                        i[1],
                        i[2]
                    ], [
                        "Z"
                    ])), o.isFlat = d;
                }
                return o;
            }
            function a(t) {
                this.removePlotBandOrLine(t);
            }
            function n(t) {
                let e = this.plotLinesAndBands, i = this.options, s = this.userOptions;
                if (e) {
                    let o = e.length;
                    for(; o--;)e[o].id === t && e[o].destroy();
                    [
                        i.plotLines || [],
                        s.plotLines || [],
                        i.plotBands || [],
                        s.plotBands || []
                    ].forEach(function(e) {
                        for(o = e.length; o--;)e[o]?.id === t && og(e, e[o]);
                    });
                }
            }
            function h(t) {
                this.removePlotBandOrLine(t);
            }
            t.compose = function(t, l) {
                let d = l.prototype;
                return d.addPlotBand || (e = t, of(d, {
                    addPlotBand: i,
                    addPlotLine: o,
                    addPlotBandOrLine: s,
                    getPlotBandPath: r,
                    removePlotBand: a,
                    removePlotLine: h,
                    removePlotBandOrLine: n
                })), l;
            };
        }(C || (C = {}));
        let ox = C, { addEvent: oy, arrayMax: ob, arrayMin: ov, defined: ok, destroyObjectProperties: oM, erase: ow, fireEvent: oS, merge: oA, objectEach: oT, pick: oC } = tx;
        class oP {
            static compose(t, e) {
                return oy(t, "afterInit", function() {
                    this.labelCollectors.push(()=>{
                        let t = [];
                        for (let e of this.axes)for (let { label: i, options: s } of e.plotLinesAndBands)i && !s?.label?.allowOverlap && t.push(i);
                        return t;
                    });
                }), ox.compose(oP, e);
            }
            constructor(t, e){
                this.axis = t, this.options = e, this.id = e.id;
            }
            render() {
                oS(this, "render");
                let { axis: t, options: e } = this, { horiz: i, logarithmic: s } = t, { color: o, events: r, zIndex: a = 0 } = e, { renderer: n, time: h } = t.chart, l = {}, d = h.parse(e.to), c = h.parse(e.from), p = h.parse(e.value), u = e.borderWidth, g = e.label, { label: f, svgElem: m } = this, x = [], y, b = ok(c) && ok(d), v = ok(p), k = !m, M = {
                    class: "highcharts-plot-" + (b ? "band " : "line ") + (e.className || "")
                }, w = b ? "bands" : "lines";
                if (!t.chart.styledMode && (v ? (M.stroke = o || "#999999", M["stroke-width"] = oC(e.width, 1), e.dashStyle && (M.dashstyle = e.dashStyle)) : b && (M.fill = o || "#e6e9ff", u && (M.stroke = e.borderColor, M["stroke-width"] = u))), l.zIndex = a, w += "-" + a, (y = t.plotLinesAndBandsGroups[w]) || (t.plotLinesAndBandsGroups[w] = y = n.g("plot-" + w).attr(l).add()), m || (this.svgElem = m = n.path().attr(M).add(y)), ok(p)) x = t.getPlotLinePath({
                    value: s?.log2lin(p) ?? p,
                    lineWidth: m.strokeWidth(),
                    acrossPanes: e.acrossPanes
                });
                else {
                    if (!(ok(c) && ok(d))) return;
                    x = t.getPlotBandPath(s?.log2lin(c) ?? c, s?.log2lin(d) ?? d, e);
                }
                return !this.eventsAdded && r && (oT(r, (t, e)=>{
                    m?.on(e, (t)=>{
                        r[e].apply(this, [
                            t
                        ]);
                    });
                }), this.eventsAdded = !0), (k || !m.d) && x?.length ? m.attr({
                    d: x
                }) : m && (x ? (m.show(), m.animate({
                    d: x
                })) : m.d && (m.hide(), f && (this.label = f = f.destroy()))), g && (ok(g.text) || ok(g.formatter)) && x?.length && t.width > 0 && t.height > 0 && !x.isFlat ? (g = oA({
                    align: i && b ? "center" : void 0,
                    x: i ? !b && 4 : 10,
                    verticalAlign: !i && b ? "middle" : void 0,
                    y: i ? b ? 16 : 10 : b ? 6 : -4,
                    rotation: i && !b ? 90 : 0,
                    ...b ? {
                        inside: !0
                    } : {}
                }, g), this.renderLabel(g, x, b, a)) : f && f.hide(), this;
            }
            renderLabel(t, e, i, s) {
                let o = this.axis, r = o.chart.renderer, a = t.inside, n = this.label;
                n || (this.label = n = r.text(this.getLabelText(t), 0, 0, t.useHTML).attr({
                    align: t.textAlign || t.align,
                    rotation: t.rotation,
                    class: "highcharts-plot-" + (i ? "band" : "line") + "-label " + (t.className || ""),
                    zIndex: s
                }), o.chart.styledMode || n.css(oA({
                    color: o.chart.options.title?.style?.color,
                    fontSize: "0.8em",
                    textOverflow: i && !a ? "" : "ellipsis"
                }, t.style)), n.add());
                let h = e.xBounds || [
                    e[0][1],
                    e[1][1],
                    i ? e[2][1] : e[0][1]
                ], l = e.yBounds || [
                    e[0][2],
                    e[1][2],
                    i ? e[2][2] : e[0][2]
                ], d = ov(h), c = ov(l), p = ob(h) - d;
                n.align(t, !1, {
                    x: d,
                    y: c,
                    width: p,
                    height: ob(l) - c
                }), n.alignAttr.y -= r.fontMetrics(n).b, (!n.alignValue || "left" === n.alignValue || ok(a)) && n.css({
                    width: (t.style?.width || (i && a ? p : 90 === n.rotation ? o.height - (n.alignAttr.y - o.top) : (t.clip ? o.width : o.chart.chartWidth) - (n.alignAttr.x - o.left))) + "px"
                }), n.show(!0);
            }
            getLabelText(t) {
                return ok(t.formatter) ? t.formatter.call(this) : t.text;
            }
            destroy() {
                ow(this.axis.plotLinesAndBands, this), delete this.axis, oM(this);
            }
        }
        let { animObject: oO } = eo, { format: oE } = eI, { composed: oL, dateFormats: oB, doc: oD, isSafari: oI } = V, { distribute: oz } = eX, { addEvent: oR, clamp: oN, css: oW, clearTimeout: oG, discardElement: oX, extend: oH, fireEvent: oF, getAlignFactor: oY, isArray: oj, isNumber: oU, isObject: oV, isString: o$, merge: o_, pick: oZ, pushUnique: oq, splat: oK, syncTimeout: oJ } = tx;
        class oQ {
            constructor(t, e, i){
                this.allowShared = !0, this.crosshairs = [], this.distance = 0, this.isHidden = !0, this.isSticky = !1, this.options = {}, this.outside = !1, this.chart = t, this.init(t, e), this.pointer = i;
            }
            bodyFormatter(t) {
                return t.map((t)=>{
                    let e = t.series.tooltipOptions, i = t.formatPrefix || "point";
                    return (e[i + "Formatter"] || t.tooltipFormatter).call(t, e[i + "Format"] || "");
                });
            }
            cleanSplit(t) {
                this.chart.series.forEach(function(e) {
                    let i = e?.tt;
                    i && (!i.isActive || t ? e.tt = i.destroy() : i.isActive = !1);
                });
            }
            defaultFormatter(t) {
                let e, i = this.points || oK(this);
                return (e = (e = [
                    t.headerFooterFormatter(i[0])
                ]).concat(t.bodyFormatter(i))).push(t.headerFooterFormatter(i[0], !0)), e;
            }
            destroy() {
                this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), oX(this.container)), oG(this.hideTimer);
            }
            getAnchor(t, e) {
                let i, { chart: s, pointer: o } = this, r = s.inverted, a = s.plotTop, n = s.plotLeft;
                if (t = oK(t), t[0].series?.yAxis && !t[0].series.yAxis.options.reversedStacks && (t = t.slice().reverse()), this.followPointer && e) void 0 === e.chartX && (e = o.normalize(e)), i = [
                    e.chartX - n,
                    e.chartY - a
                ];
                else if (t[0].tooltipPos) i = t[0].tooltipPos;
                else {
                    let s = 0, o = 0;
                    t.forEach(function(t) {
                        let e = t.pos(!0);
                        e && (s += e[0], o += e[1]);
                    }), s /= t.length, o /= t.length, this.shared && t.length > 1 && e && (r ? s = e.chartX : o = e.chartY), i = [
                        s - n,
                        o - a
                    ];
                }
                let h = {
                    point: t[0],
                    ret: i
                };
                return oF(this, "getAnchor", h), h.ret.map(Math.round);
            }
            getClassName(t, e, i) {
                let s = this.options, o = t.series, r = o.options;
                return [
                    s.className,
                    "highcharts-label",
                    i && "highcharts-tooltip-header",
                    e ? "highcharts-tooltip-box" : "highcharts-tooltip",
                    !i && "highcharts-color-" + oZ(t.colorIndex, o.colorIndex),
                    r?.className
                ].filter(o$).join(" ");
            }
            getLabel({ anchorX: t, anchorY: e } = {
                anchorX: 0,
                anchorY: 0
            }) {
                let i = this, s = this.chart.styledMode, o = this.options, r = this.split && this.allowShared, a = this.container, n = this.chart.renderer;
                if (this.label) {
                    let t = !this.label.hasClass("highcharts-label");
                    (!r && t || r && !t) && this.destroy();
                }
                if (!this.label) {
                    if (this.outside) {
                        let t = this.chart, e = t.options.chart.style, i = ez.getRendererType();
                        this.container = a = V.doc.createElement("div"), a.className = "highcharts-tooltip-container " + (t.renderTo.className.match(/(highcharts[a-zA-Z0-9-]+)\s?/gm) || ""), oW(a, {
                            position: "absolute",
                            top: "1px",
                            pointerEvents: "none",
                            zIndex: Math.max(this.options.style.zIndex || 0, (e?.zIndex || 0) + 3)
                        }), this.renderer = n = new i(a, 0, 0, e, void 0, void 0, n.styledMode);
                    }
                    if (r ? this.label = n.g("tooltip") : (this.label = n.label("", t, e, o.shape || "callout", void 0, void 0, o.useHTML, void 0, "tooltip").attr({
                        padding: o.padding,
                        r: o.borderRadius
                    }), s || this.label.attr({
                        fill: o.backgroundColor,
                        "stroke-width": o.borderWidth || 0
                    }).css(o.style).css({
                        pointerEvents: o.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none")
                    })), i.outside) {
                        let t = this.label;
                        [
                            t.xSetter,
                            t.ySetter
                        ].forEach((e, s)=>{
                            t[s ? "ySetter" : "xSetter"] = (o)=>{
                                e.call(t, i.distance), t[s ? "y" : "x"] = o, a && (a.style[s ? "top" : "left"] = `${o}px`);
                            };
                        });
                    }
                    this.label.attr({
                        zIndex: 8
                    }).shadow(o.shadow ?? !o.fixed).add();
                }
                return a && !a.parentElement && V.doc.body.appendChild(a), this.label;
            }
            getPlayingField() {
                let { body: t, documentElement: e } = oD, { chart: i, distance: s, outside: o } = this;
                return {
                    width: o ? Math.max(t.scrollWidth, e.scrollWidth, t.offsetWidth, e.offsetWidth, e.clientWidth) - 2 * s - 2 : i.chartWidth,
                    height: o ? Math.max(t.scrollHeight, e.scrollHeight, t.offsetHeight, e.offsetHeight, e.clientHeight) : i.chartHeight
                };
            }
            getPosition(t, e, i) {
                let { distance: s, chart: o, outside: r, pointer: a } = this, { inverted: n, plotLeft: h, plotTop: l, polar: d } = o, { plotX: c = 0, plotY: p = 0 } = i, u = {}, g = n && i.h || 0, { height: f, width: m } = this.getPlayingField(), x = a.getChartPosition(), y = (i)=>{
                    let a = "x" === i;
                    return [
                        i,
                        a ? m : f,
                        a ? t : e
                    ].concat(r ? [
                        a ? t * x.scaleX : e * x.scaleY,
                        a ? x.left - s + (c + h) * x.scaleX : x.top - s + (p + l) * x.scaleY,
                        0,
                        a ? m : f
                    ] : [
                        a ? t : e,
                        a ? c + h : p + l,
                        a ? h : l,
                        a ? h + o.plotWidth : l + o.plotHeight
                    ]);
                }, b = y("y"), v = y("x"), k, M = !!i.negative;
                !d && o.hoverSeries?.yAxis?.reversed && (M = !M);
                let w = !this.followPointer && oZ(i.ttBelow, !d && !n === M), S = function(t, e, i, o, a, n, h) {
                    let l = r ? "y" === t ? s * x.scaleY : s * x.scaleX : s, d = (i - o) / 2, c = o < a - s, p = a + s + o < e, f = a - l - i + d, m = a + l - d;
                    if (w && p) u[t] = m;
                    else if (!w && c) u[t] = f;
                    else if (c) u[t] = Math.min(h - o, f - g < 0 ? f : f - g);
                    else {
                        if (!p) return u[t] = 0, !1;
                        u[t] = Math.max(n, m + g + i > e ? m : m + g);
                    }
                }, A = function(t, e, i, o, r) {
                    if (r < s || r > e - s) return !1;
                    r < i / 2 ? u[t] = 1 : r > e - o / 2 ? u[t] = e - o - 2 : u[t] = r - i / 2;
                }, T = function(t) {
                    [b, v] = [
                        v,
                        b
                    ], k = t;
                }, C = ()=>{
                    !1 !== S.apply(0, b) ? !1 !== A.apply(0, v) || k || (T(!0), C()) : k ? u.x = u.y = 0 : (T(!0), C());
                };
                return (n && !d || this.len > 1) && T(), C(), u;
            }
            getFixedPosition(t, e, i) {
                let s = i.series, { chart: o, options: r, split: a } = this, n = r.position, h = n.relativeTo, l = r.shared || s?.yAxis?.isRadial && ("pane" === h || !h) ? "plotBox" : h, d = "chart" === l ? o.renderer : o[l] || o.getClipBox(s, !0);
                return {
                    x: d.x + (d.width - t) * oY(n.align) + n.x,
                    y: d.y + (d.height - e) * oY(n.verticalAlign) + (!a && n.y || 0)
                };
            }
            hide(t) {
                let e = this;
                oG(this.hideTimer), t = oZ(t, this.options.hideDelay), this.isHidden || (this.hideTimer = oJ(function() {
                    let i = e.getLabel();
                    e.getLabel().animate({
                        opacity: 0
                    }, {
                        duration: t ? 150 : t,
                        complete: ()=>{
                            i.hide(), e.container && e.container.remove();
                        }
                    }), e.isHidden = !0;
                }, t));
            }
            init(t, e) {
                this.chart = t, this.options = e, this.crosshairs = [], this.isHidden = !0, this.split = e.split && !t.inverted && !t.polar, this.shared = e.shared || this.split, this.outside = oZ(e.outside, !!(t.scrollablePixelsX || t.scrollablePixelsY));
            }
            shouldStickOnContact(t) {
                return !!(!this.followPointer && this.options.stickOnContact && (!t || this.pointer.inClass(t.target, "highcharts-tooltip")));
            }
            move(t, e, i, s) {
                let { followPointer: o, options: r } = this, a = oO(!o && !this.isHidden && !r.fixed && r.animation), n = o || (this.len || 0) > 1, h = {
                    x: t,
                    y: e
                };
                n ? h.anchorX = h.anchorY = NaN : (h.anchorX = i, h.anchorY = s), a.step = ()=>this.drawTracker(), this.getLabel().animate(h, a);
            }
            refresh(t, e) {
                let { chart: i, options: s, pointer: o, shared: r } = this, a = oK(t), n = a[0], h = s.format, l = s.formatter || this.defaultFormatter, d = i.styledMode, c = this.allowShared;
                if (!s.enabled || !n.series) return;
                oG(this.hideTimer), this.allowShared = !(!oj(t) && t.series && t.series.noSharedTooltip), c = c && !this.allowShared, this.followPointer = !this.split && n.series.tooltipOptions.followPointer;
                let p = this.getAnchor(t, e), u = p[0], g = p[1];
                r && this.allowShared && (o.applyInactiveState(a), a.forEach((t)=>t.setState("hover")), n.points = a), this.len = a.length;
                let f = o$(h) ? oE(h, n, i) : l.call(n, this);
                n.points = void 0;
                let m = n.series;
                if (this.distance = oZ(m.tooltipOptions.distance, 16), !1 === f) this.hide();
                else {
                    if (this.split && this.allowShared) this.renderSplit(f, a);
                    else {
                        let t = u, r = g;
                        if (e && o.isDirectTouch && (t = e.chartX - i.plotLeft, r = e.chartY - i.plotTop), !(i.polar || !1 === m.options.clip || a.some((e)=>o.isDirectTouch || e.series.shouldShowTooltip(t, r)))) return void this.hide();
                        {
                            let t = this.getLabel(c && this.tt || {});
                            (!s.style.width || d) && t.css({
                                width: (this.outside ? this.getPlayingField() : i.spacingBox).width + "px"
                            }), t.attr({
                                class: this.getClassName(n),
                                text: f && f.join ? f.join("") : f
                            }), this.outside && t.attr({
                                x: oN(t.x || 0, 0, this.getPlayingField().width - (t.width || 0) - 1)
                            }), d || t.attr({
                                stroke: s.borderColor || n.color || m.color || "#666666"
                            }), this.updatePosition({
                                plotX: u,
                                plotY: g,
                                negative: n.negative,
                                ttBelow: n.ttBelow,
                                series: m,
                                h: p[2] || 0
                            });
                        }
                    }
                    this.isHidden && this.label && this.label.attr({
                        opacity: 1
                    }).show(), this.isHidden = !1;
                }
                oF(this, "refresh");
            }
            renderSplit(t, e) {
                let i = this, { chart: s, chart: { chartWidth: o, chartHeight: r, plotHeight: a, plotLeft: n, plotTop: h, scrollablePixelsY: l = 0, scrollablePixelsX: d, styledMode: c }, distance: p, options: u, options: { fixed: g, position: f, positioner: m }, pointer: x } = i, { scrollLeft: y = 0, scrollTop: b = 0 } = s.scrollablePlotArea?.scrollingContainer || {}, v = i.outside && "number" != typeof d ? oD.documentElement.getBoundingClientRect() : {
                    left: y,
                    right: y + o,
                    top: b,
                    bottom: b + r
                }, k = i.getLabel(), M = this.renderer || s.renderer, w = !!s.xAxis[0]?.opposite, { left: S, top: A } = x.getChartPosition(), T = m || g, C = h + b, P = 0, O = a - l, E = function(t, e, s, o = [
                    0,
                    0
                ], r = !0) {
                    let a, n;
                    if (s.isHeader) n = w ? 0 : O, a = oN(o[0] - t / 2, v.left, v.right - t - (i.outside ? S : 0));
                    else if (g && s) {
                        let o = i.getFixedPosition(t, e, s);
                        a = o.x, n = o.y - C;
                    } else n = o[1] - C, a = oN(a = r ? o[0] - t - p : o[0] + p, r ? a : v.left, v.right);
                    return {
                        x: a,
                        y: n
                    };
                };
                o$(t) && (t = [
                    !1,
                    t
                ]);
                let L = t.slice(0, e.length + 1).reduce(function(t, s, o) {
                    if (!1 !== s && "" !== s) {
                        let r = e[o - 1] || {
                            isHeader: !0,
                            plotX: e[0].plotX,
                            plotY: a,
                            series: {}
                        }, l = r.isHeader, d = l ? i : r.series, f = d.tt = function(t, e, s) {
                            let o = t, { isHeader: r, series: a } = e, n = a.tooltipOptions || u;
                            if (!o) {
                                let t = {
                                    padding: n.padding,
                                    r: n.borderRadius
                                };
                                c || (t.fill = n.backgroundColor, t["stroke-width"] = n.borderWidth ?? (g && !r ? 0 : 1)), o = M.label("", 0, 0, n[r ? "headerShape" : "shape"] || (g && !r ? "rect" : "callout"), void 0, void 0, n.useHTML).addClass(i.getClassName(e, !0, r)).attr(t).add(k);
                            }
                            return o.isActive = !0, o.attr({
                                text: s
                            }), c || o.css(n.style).attr({
                                stroke: n.borderColor || e.color || a.color || "#333333"
                            }), o;
                        }(d.tt, r, s.toString()), x = f.getBBox(), y = x.width + f.strokeWidth();
                        l && (P = x.height, O += P, w && (C -= P));
                        let { anchorX: b, anchorY: S } = function(t) {
                            let e, i, { isHeader: s, plotX: o = 0, plotY: r = 0, series: l } = t;
                            if (s) e = Math.max(n + o, n), i = h + a / 2;
                            else {
                                let { xAxis: t, yAxis: s } = l;
                                e = t.pos + oN(o, -p, t.len + p), l.shouldShowTooltip(0, s.pos - h + r, {
                                    ignoreX: !0
                                }) && (i = s.pos + r);
                            }
                            return {
                                anchorX: e = oN(e, v.left - p, v.right + p),
                                anchorY: i
                            };
                        }(r);
                        if ("number" == typeof S) {
                            let e = x.height + 1, s = (m || E).call(i, y, e, r, [
                                b,
                                S
                            ]);
                            t.push({
                                align: T ? 0 : void 0,
                                anchorX: b,
                                anchorY: S,
                                boxWidth: y,
                                point: r,
                                rank: oZ(s.rank, +!!l),
                                size: e,
                                target: s.y,
                                tt: f,
                                x: s.x
                            });
                        } else f.isActive = !1;
                    }
                    return t;
                }, []);
                !T && L.some((t)=>{
                    let { outside: e } = i, s = (e ? S : 0) + t.anchorX;
                    return s < v.left && s + t.boxWidth < v.right || s < S - v.left + t.boxWidth && v.right - s > s;
                }) && (L = L.map((t)=>{
                    let { x: e, y: i } = E.call(this, t.boxWidth, t.size, t.point, [
                        t.anchorX,
                        t.anchorY
                    ], !1);
                    return oH(t, {
                        target: i,
                        x: e
                    });
                })), i.cleanSplit(), oz(L, O);
                let B = {
                    left: S,
                    right: S
                };
                L.forEach(function(t) {
                    let { x: e, boxWidth: s, isHeader: o } = t;
                    !o && (i.outside && S + e < B.left && (B.left = S + e), !o && i.outside && B.left + s > B.right && (B.right = S + e));
                }), L.forEach(function(t) {
                    let { x: e, anchorX: s, anchorY: o, pos: r, point: { isHeader: a } } = t, n = {
                        visibility: void 0 === r ? "hidden" : "inherit",
                        x: e,
                        y: (r || 0) + C + (g && f.y || 0),
                        anchorX: s,
                        anchorY: o
                    };
                    if (i.outside && e < s) {
                        let t = S - B.left;
                        t > 0 && (a || (n.x = e + t, n.anchorX = s + t), a && (n.x = (B.right - B.left) / 2, n.anchorX = s + t));
                    }
                    t.tt.attr(n);
                });
                let { container: D, outside: I, renderer: z } = i;
                if (I && D && z) {
                    let { width: t, height: e, x: i, y: s } = k.getBBox();
                    z.setSize(t + i, e + s, !1), D.style.left = B.left + "px", D.style.top = A + "px";
                }
                oI && k.attr({
                    opacity: 1 === k.opacity ? .999 : 1
                });
            }
            drawTracker() {
                let t = this;
                if (!this.shouldStickOnContact()) {
                    t.tracker && (t.tracker = t.tracker.destroy());
                    return;
                }
                let e = t.chart, i = t.label, s = t.shared ? e.hoverPoints : e.hoverPoint;
                if (!i || !s) return;
                let o = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                }, r = this.getAnchor(s), a = i.getBBox();
                r[0] += e.plotLeft - (i.translateX || 0), r[1] += e.plotTop - (i.translateY || 0), o.x = Math.min(0, r[0]), o.y = Math.min(0, r[1]), o.width = r[0] < 0 ? Math.max(Math.abs(r[0]), a.width - r[0]) : Math.max(Math.abs(r[0]), a.width), o.height = r[1] < 0 ? Math.max(Math.abs(r[1]), a.height - Math.abs(r[1])) : Math.max(Math.abs(r[1]), a.height), t.tracker ? t.tracker.attr(o) : (t.tracker = i.renderer.rect(o).addClass("highcharts-tracker").add(i), oR(t.tracker.element, "mouseenter", ()=>{
                    oG(t.hideTimer);
                }), e.styledMode || t.tracker.attr({
                    fill: "rgba(0,0,0,0)"
                }));
            }
            styledModeFormat(t) {
                return t.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
            }
            headerFooterFormatter(t, e) {
                let i = t.series, s = i.tooltipOptions, o = i.xAxis, r = o?.dateTime, a = {
                    isFooter: e,
                    point: t
                }, n = s.xDateFormat || "", h = s[e ? "footerFormat" : "headerFormat"];
                return oF(this, "headerFormatter", a, function(e) {
                    if (r && !n && oU(t.key) && (n = r.getXDateFormat(t.key, s.dateTimeLabelFormats)), r && n) {
                        if (oV(n)) {
                            let t = n;
                            oB[0] = (e)=>i.chart.time.dateFormat(t, e), n = "%0";
                        }
                        (t.tooltipDateKeys || [
                            "key"
                        ]).forEach((t)=>{
                            h = h.replace(RegExp("point\\." + t + "([ \\)}])"), `(point.${t}:${n})$1`);
                        });
                    }
                    i.chart.styledMode && (h = this.styledModeFormat(h)), e.text = oE(h, t, this.chart);
                }), a.text || "";
            }
            update(t) {
                this.destroy(), this.init(this.chart, o_(!0, this.options, t));
            }
            updatePosition(t) {
                let { chart: e, container: i, distance: s, options: o, pointer: r, renderer: a } = this, { height: n = 0, width: h = 0 } = this.getLabel(), { fixed: l, positioner: d } = o, { left: c, top: p, scaleX: u, scaleY: g } = r.getChartPosition(), f = (d || l && this.getFixedPosition || this.getPosition).call(this, h, n, t), m = V.doc, x = (t.plotX || 0) + e.plotLeft, y = (t.plotY || 0) + e.plotTop, b;
                if (a && i) {
                    if (d || l) {
                        let { scrollLeft: t = 0, scrollTop: i = 0 } = e.scrollablePlotArea?.scrollingContainer || {};
                        f.x += t + c - s, f.y += i + p - s;
                    }
                    b = (o.borderWidth || 0) + 2 * s + 2, a.setSize(oN(h + b, 0, m.documentElement.clientWidth) - 1, n + b, !1), (1 !== u || 1 !== g) && (oW(i, {
                        transform: `scale(${u}, ${g})`
                    }), x *= u, y *= g), x += c - f.x, y += p - f.y;
                }
                this.move(Math.round(f.x), Math.round(f.y || 0), x, y);
            }
        }
        (u = oQ || (oQ = {})).compose = function(t) {
            oq(oL, "Core.Tooltip") && oR(t, "afterInit", function() {
                let t = this.chart;
                t.options.tooltip && (t.tooltip = new u(t, t.options.tooltip, this));
            });
        };
        let o0 = oQ, { animObject: o1 } = eo, { defaultOptions: o2 } = tY, { format: o3 } = eI, { addEvent: o5, crisp: o6, erase: o9, extend: o4, fireEvent: o8, getNestedProperty: o7, isArray: rt, isFunction: re, isNumber: ri, isObject: rs, merge: ro, pick: rr, syncTimeout: ra, removeEvent: rn, uniqueKey: rh } = tx;
        class rl {
            constructor(t, e, i){
                this.formatPrefix = "point", this.visible = !0, this.point = this, this.series = t, this.applyOptions(e, i), this.id ?? (this.id = rh()), this.resolveColor(), this.dataLabelOnNull ?? (this.dataLabelOnNull = t.options.nullInteraction), t.chart.pointCount++, this.category = t.xAxis?.categories?.[this.x] ?? this.x, this.key = this.name ?? this.category, o8(this, "afterInit");
            }
            animateBeforeDestroy() {
                let t = this, e = {
                    x: t.startXPos,
                    opacity: 0
                }, i = t.getGraphicalProps();
                i.singular.forEach(function(i) {
                    t[i] = t[i].animate("dataLabel" === i ? {
                        x: t[i].startXPos,
                        y: t[i].startYPos,
                        opacity: 0
                    } : e);
                }), i.plural.forEach(function(e) {
                    t[e].forEach(function(e) {
                        e.element && e.animate(o4({
                            x: t.startXPos
                        }, e.startYPos ? {
                            x: e.startXPos,
                            y: e.startYPos
                        } : {}));
                    });
                });
            }
            applyOptions(t, e) {
                let i = this.series, s = i.options.pointValKey || i.pointValKey;
                return o4(this, t = rl.prototype.optionsToObject.call(this, t)), this.options = this.options ? o4(this.options, t) : t, t.group && delete this.group, t.dataLabels && delete this.dataLabels, s && (this.y = rl.prototype.getNestedProperty.call(this, s)), this.selected && (this.state = "select"), "name" in this && void 0 === e && i.xAxis && i.xAxis.hasNames && (this.x = i.xAxis.nameToX(this)), void 0 === this.x && i ? this.x = e ?? i.autoIncrement() : ri(t.x) && i.options.relativeXValue ? this.x = i.autoIncrement(t.x) : "string" == typeof this.x && (e ?? (e = i.chart.time.parse(this.x)), ri(e) && (this.x = e)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? "null" : "point", this;
            }
            destroy() {
                if (!this.destroyed) {
                    let t = this, e = t.series, i = e.chart, s = e.options.dataSorting, o = i.hoverPoints, r = o1(t.series.chart.renderer.globalAnimation), a = ()=>{
                        for(let e in (t.graphic || t.graphics || t.dataLabel || t.dataLabels) && (rn(t), t.destroyElements()), t)delete t[e];
                    };
                    t.legendItem && i.legend.destroyItem(t), o && (t.setState(), o9(o, t), o.length || (i.hoverPoints = null)), t === i.hoverPoint && t.onMouseOut(), s?.enabled ? (this.animateBeforeDestroy(), ra(a, r.duration)) : a(), i.pointCount--;
                }
                this.destroyed = !0;
            }
            destroyElements(t) {
                let e = this, i = e.getGraphicalProps(t);
                i.singular.forEach(function(t) {
                    e[t] = e[t].destroy();
                }), i.plural.forEach(function(t) {
                    e[t].forEach(function(t) {
                        t?.element && t.destroy();
                    }), delete e[t];
                });
            }
            firePointEvent(t, e, i) {
                let s = this, o = this.series.options;
                s.manageEvent(t), "click" === t && o.allowPointSelect && (i = function(t) {
                    !s.destroyed && s.select && s.select(null, t.ctrlKey || t.metaKey || t.shiftKey);
                }), o8(s, t, e, i);
            }
            getClassName() {
                return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone?.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
            }
            getGraphicalProps(t) {
                let e, i, s = this, o = [], r = {
                    singular: [],
                    plural: []
                };
                for((t = t || {
                    graphic: 1,
                    dataLabel: 1
                }).graphic && o.push("graphic", "connector"), t.dataLabel && o.push("dataLabel", "dataLabelPath", "dataLabelUpper"), i = o.length; i--;)s[e = o[i]] && r.singular.push(e);
                return [
                    "graphic",
                    "dataLabel"
                ].forEach(function(e) {
                    let i = e + "s";
                    t[e] && s[i] && r.plural.push(i);
                }), r;
            }
            getNestedProperty(t) {
                if (t) return 0 === t.indexOf("custom.") ? o7(t, this.options) : this[t];
            }
            getZone() {
                let t = this.series, e = t.zones, i = t.zoneAxis || "y", s, o = 0;
                for(s = e[0]; this[i] >= s.value;)s = e[++o];
                return this.nonZonedColor || (this.nonZonedColor = this.color), s?.color && !this.options.color ? this.color = s.color : this.color = this.nonZonedColor, s;
            }
            hasNewShapeType() {
                return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
            }
            isValid() {
                return (ri(this.x) || this.x instanceof Date) && ri(this.y);
            }
            optionsToObject(t) {
                let e = this.series, i = e.options.keys, s = i || e.pointArrayMap || [
                    "y"
                ], o = s.length, r = {}, a, n = 0, h = 0;
                if (ri(t) || null === t) r[s[0]] = t;
                else if (rt(t)) for(!i && t.length > o && ("string" == (a = typeof t[0]) ? e.xAxis?.dateTime ? r.x = e.chart.time.parse(t[0]) : r.name = t[0] : "number" === a && (r.x = t[0]), n++); h < o;)i && void 0 === t[n] || (s[h].indexOf(".") > 0 ? rl.prototype.setNestedProperty(r, t[n], s[h]) : r[s[h]] = t[n]), n++, h++;
                else "object" == typeof t && (r = t, t.dataLabels && (e.hasDataLabels = ()=>!0), t.marker && (e._hasPointMarkers = !0));
                return r;
            }
            pos(t, e = this.plotY) {
                if (!this.destroyed) {
                    let { plotX: i, series: s } = this, { chart: o, xAxis: r, yAxis: a } = s, n = 0, h = 0;
                    if (ri(i) && ri(e)) return t && (n = r ? r.pos : o.plotLeft, h = a ? a.pos : o.plotTop), o.inverted && r && a ? [
                        a.len - e + h,
                        r.len - i + n
                    ] : [
                        i + n,
                        e + h
                    ];
                }
            }
            resolveColor() {
                let t = this.series, e = t.chart.options.chart, i = t.chart.styledMode, s, o, r = e.colorCount, a;
                delete this.nonZonedColor, t.options.colorByPoint ? (i || (s = (o = t.options.colors || t.chart.options.colors)[t.colorCounter], r = o.length), a = t.colorCounter, t.colorCounter++, t.colorCounter === r && (t.colorCounter = 0)) : (i || (s = t.color), a = t.colorIndex), this.colorIndex = rr(this.options.colorIndex, a), this.color = rr(this.options.color, s);
            }
            setNestedProperty(t, e, i) {
                return i.split(".").reduce(function(t, i, s, o) {
                    let r = o.length - 1 === s;
                    return t[i] = r ? e : rs(t[i], !0) ? t[i] : {}, t[i];
                }, t), t;
            }
            shouldDraw() {
                return !this.isNull;
            }
            tooltipFormatter(t) {
                let { chart: e, pointArrayMap: i = [
                    "y"
                ], tooltipOptions: s } = this.series, { valueDecimals: o = "", valuePrefix: r = "", valueSuffix: a = "" } = s;
                return e.styledMode && (t = e.tooltip?.styledModeFormat(t) || t), i.forEach((e)=>{
                    e = "{point." + e, (r || a) && (t = t.replace(RegExp(e + "}", "g"), r + e + "}" + a)), t = t.replace(RegExp(e + "}", "g"), e + ":,." + o + "f}");
                }), o3(t, this, e);
            }
            update(t, e, i, s) {
                let o, r = this, a = r.series, n = r.graphic, h = a.chart, l = a.options;
                function d() {
                    r.applyOptions(t);
                    let s = n && r.hasMockGraphic, d = null === r.y ? !s : s;
                    n && d && (r.graphic = n.destroy(), delete r.hasMockGraphic), rs(t, !0) && (n?.element && t && t.marker && void 0 !== t.marker.symbol && (r.graphic = n.destroy()), t?.dataLabels && r.dataLabel && (r.dataLabel = r.dataLabel.destroy())), o = r.index;
                    let c = {};
                    for (let t of a.dataColumnKeys())c[t] = r[t];
                    a.dataTable.setRow(c, o), l.data[o] = rs(l.data[o], !0) || rs(t, !0) ? r.options : rr(t, l.data[o]), a.isDirty = a.isDirtyData = !0, !a.fixedBox && a.hasCartesianSeries && (h.isDirtyBox = !0), "point" === l.legendType && (h.isDirtyLegend = !0), e && h.redraw(i);
                }
                e = rr(e, !0), !1 === s ? d() : r.firePointEvent("update", {
                    options: t
                }, d);
            }
            remove(t, e) {
                this.series.removePoint(this.series.data.indexOf(this), t, e);
            }
            select(t, e) {
                let i = this, s = i.series, o = s.chart;
                t = rr(t, !i.selected), this.selectedStaging = t, i.firePointEvent(t ? "select" : "unselect", {
                    accumulate: e
                }, function() {
                    i.selected = i.options.selected = t, s.options.data[s.data.indexOf(i)] = i.options, i.setState(t && "select"), e || o.getSelectedPoints().forEach(function(t) {
                        let e = t.series;
                        t.selected && t !== i && (t.selected = t.options.selected = !1, e.options.data[e.data.indexOf(t)] = t.options, t.setState(o.hoverPoints && e.options.inactiveOtherPoints ? "inactive" : ""), t.firePointEvent("unselect"));
                    });
                }), delete this.selectedStaging;
            }
            onMouseOver(t) {
                let { inverted: e, pointer: i } = this.series.chart;
                i && (t = t ? i.normalize(t) : i.getChartCoordinatesFromPoint(this, e), i.runPointActions(t, this));
            }
            onMouseOut() {
                let t = this.series.chart;
                this.firePointEvent("mouseOut"), this.series.options.inactiveOtherPoints || (t.hoverPoints || []).forEach(function(t) {
                    t.setState();
                }), t.hoverPoints = t.hoverPoint = null;
            }
            manageEvent(t) {
                let e = ro(this.series.options.point, this.options), i = e.events?.[t];
                re(i) && (!this.hcEvents?.[t] || this.hcEvents?.[t]?.map((t)=>t.fn).indexOf(i) === -1) ? (this.importedUserEvent?.(), this.importedUserEvent = o5(this, t, i), this.hcEvents && (this.hcEvents[t].userEvent = !0)) : this.importedUserEvent && !i && this.hcEvents?.[t] && this.hcEvents?.[t].userEvent && (rn(this, t), delete this.hcEvents[t], Object.keys(this.hcEvents) || delete this.importedUserEvent);
            }
            setState(t, e) {
                let i = this.series, s = this.state, o = i.options.states[t || "normal"] || {}, r = o2.plotOptions[i.type].marker && i.options.marker, a = r && !1 === r.enabled, n = r?.states?.[t || "normal"] || {}, h = !1 === n.enabled, l = this.marker || {}, d = i.chart, c = r && i.markerAttribs, p = i.halo, u, g, f, m = i.stateMarkerGraphic, x;
                if ((t = t || "") === this.state && !e || this.selected && "select" !== t || !1 === o.enabled || t && (h || a && !1 === n.enabled) || t && l.states && l.states[t] && !1 === l.states[t].enabled) return;
                if (this.state = t, c && (u = i.markerAttribs(this, t)), this.graphic && !this.hasMockGraphic) {
                    if (s && this.graphic.removeClass("highcharts-point-" + s), t && this.graphic.addClass("highcharts-point-" + t), !d.styledMode) {
                        g = i.pointAttribs(this, t), f = rr(d.options.chart.animation, o.animation);
                        let e = g.opacity;
                        i.options.inactiveOtherPoints && ri(e) && (this.dataLabels || []).forEach(function(t) {
                            t && !t.hasClass("highcharts-data-label-hidden") && (t.animate({
                                opacity: e
                            }, f), t.connector && t.connector.animate({
                                opacity: e
                            }, f));
                        }), this.graphic.animate(g, f);
                    }
                    u && this.graphic.animate(u, rr(d.options.chart.animation, n.animation, r.animation)), m && m.hide();
                } else t && n && (x = l.symbol || i.symbol, m && m.currentSymbol !== x && (m = m.destroy()), u && (m ? m[e ? "animate" : "attr"]({
                    x: u.x,
                    y: u.y
                }) : x && (i.stateMarkerGraphic = m = d.renderer.symbol(x, u.x, u.y, u.width, u.height, ro(r, n)).add(i.markerGroup), m.currentSymbol = x)), !d.styledMode && m && "inactive" !== this.state && m.attr(i.pointAttribs(this, t))), m && (m[t && this.isInside ? "show" : "hide"](), m.element.point = this, m.addClass(this.getClassName(), !0));
                let y = o.halo, b = this.graphic || m, v = b?.visibility || "inherit";
                y?.size && b && "hidden" !== v && !this.isCluster ? (p || (i.halo = p = d.renderer.path().add(b.parentGroup)), p.show()[e ? "animate" : "attr"]({
                    d: this.haloPath(y.size)
                }), p.attr({
                    class: "highcharts-halo highcharts-color-" + rr(this.colorIndex, i.colorIndex) + (this.className ? " " + this.className : ""),
                    visibility: v,
                    zIndex: -1
                }), p.point = this, d.styledMode || p.attr(o4({
                    fill: this.color || i.color,
                    "fill-opacity": y.opacity
                }, ey.filterUserAttributes(y.attributes || {})))) : p?.point?.haloPath && !p.point.destroyed && p.animate({
                    d: p.point.haloPath(0)
                }, null, p.hide), o8(this, "afterSetState", {
                    state: t
                });
            }
            haloPath(t) {
                let e = this.pos();
                return e ? this.series.chart.renderer.symbols.circle(o6(e[0], 1) - t, e[1] - t, 2 * t, 2 * t) : [];
            }
        }
        let rd = rl, { parse: rc } = tJ, { charts: rp, composed: ru, isTouchDevice: rg } = V, { addEvent: rf, attr: rm, css: rx, extend: ry, find: rb, fireEvent: rv, isNumber: rk, isObject: rM, objectEach: rw, offset: rS, pick: rA, pushUnique: rT, splat: rC } = tx;
        class rP {
            applyInactiveState(t = []) {
                let e = [];
                for (let i of (t.forEach((t)=>{
                    let i = t.series;
                    e.push(i), i.linkedParent && e.push(i.linkedParent), i.linkedSeries && e.push.apply(e, i.linkedSeries), i.navigatorSeries && e.push(i.navigatorSeries), i.boosted && i.markerGroup && e.push.apply(e, this.chart.series.filter((t)=>t.markerGroup === i.markerGroup));
                }), this.chart.series)){
                    let t = i.options;
                    t.states?.inactive?.enabled !== !1 && (-1 === e.indexOf(i) ? i.setState("inactive", !0) : t.inactiveOtherPoints && i.setAllPointsToState("inactive"));
                }
            }
            destroy() {
                let t = this;
                this.eventsToUnbind.forEach((t)=>t()), this.eventsToUnbind = [], !V.chartCount && (rP.unbindDocumentMouseUp.forEach((t)=>t.unbind()), rP.unbindDocumentMouseUp.length = 0, rP.unbindDocumentTouchEnd && (rP.unbindDocumentTouchEnd = rP.unbindDocumentTouchEnd())), rw(t, function(e, i) {
                    t[i] = void 0;
                });
            }
            getSelectionMarkerAttrs(t, e) {
                let i = {
                    args: {
                        chartX: t,
                        chartY: e
                    },
                    attrs: {},
                    shapeType: "rect"
                };
                return rv(this, "getSelectionMarkerAttrs", i, (i)=>{
                    let s, { chart: o, zoomHor: r, zoomVert: a } = this, { mouseDownX: n = 0, mouseDownY: h = 0 } = o, l = i.attrs;
                    l.x = o.plotLeft, l.y = o.plotTop, l.width = r ? 1 : o.plotWidth, l.height = a ? 1 : o.plotHeight, r && (l.width = Math.max(1, Math.abs(s = t - n)), l.x = (s > 0 ? 0 : s) + n), a && (l.height = Math.max(1, Math.abs(s = e - h)), l.y = (s > 0 ? 0 : s) + h);
                }), i;
            }
            drag(t) {
                let { chart: e } = this, { mouseDownX: i = 0, mouseDownY: s = 0 } = e, { panning: o, panKey: r, selectionMarkerFill: a } = e.options.chart, n = e.plotLeft, h = e.plotTop, l = e.plotWidth, d = e.plotHeight, c = rM(o) ? o.enabled : o, p = r && t[`${r}Key`], u = t.chartX, g = t.chartY, f, m = this.selectionMarker;
                if ((!m || !m.touch) && (u < n ? u = n : u > n + l && (u = n + l), g < h ? g = h : g > h + d && (g = h + d), this.hasDragged = Math.sqrt(Math.pow(i - u, 2) + Math.pow(s - g, 2)), this.hasDragged > 10)) {
                    f = e.isInsidePlot(i - n, s - h, {
                        visiblePlotOnly: !0
                    });
                    let { shapeType: r, attrs: l } = this.getSelectionMarkerAttrs(u, g);
                    this.hasZoom && f && !p && !m && (this.selectionMarker = m = e.renderer[r](), m.attr({
                        class: "highcharts-selection-marker",
                        zIndex: 7
                    }).add(), e.styledMode || m.attr({
                        fill: a || rc("#334eff").setOpacity(.25).get()
                    })), m && m.attr(l), f && !m && c && e.pan(t, o);
                }
            }
            dragStart(t) {
                let e = this.chart;
                e.mouseIsDown = t.type, e.cancelClick = !1, e.mouseDownX = t.chartX, e.mouseDownY = t.chartY;
            }
            getSelectionBox(t) {
                let e = {
                    args: {
                        marker: t
                    },
                    result: t.getBBox()
                };
                return rv(this, "getSelectionBox", e), e.result;
            }
            drop(t) {
                let e, { chart: i, selectionMarker: s } = this;
                for (let t of i.axes)t.isPanning && (t.isPanning = !1, (t.options.startOnTick || t.options.endOnTick || t.series.some((t)=>t.boosted)) && (t.forceRedraw = !0, t.setExtremes(t.userMin, t.userMax, !1), e = !0));
                if (e && i.redraw(), s && t) {
                    if (this.hasDragged) {
                        let e = this.getSelectionBox(s);
                        i.transform({
                            axes: i.axes.filter((t)=>t.zoomEnabled && ("xAxis" === t.coll && this.zoomX || "yAxis" === t.coll && this.zoomY)),
                            selection: {
                                originalEvent: t,
                                xAxis: [],
                                yAxis: [],
                                ...e
                            },
                            from: e
                        });
                    }
                    rk(i.index) && (this.selectionMarker = s.destroy());
                }
                i && rk(i.index) && (rx(i.container, {
                    cursor: i._cursor
                }), i.cancelClick = this.hasDragged > 10, i.mouseIsDown = !1, this.hasDragged = 0, this.pinchDown = [], this.hasPinchMoved = !1);
            }
            findNearestKDPoint(t, e, i) {
                let s;
                return t.forEach(function(t) {
                    var o;
                    let r, a, n, h = !(t.noSharedTooltip && e) && 0 > t.options.findNearestPointBy.indexOf("y"), l = t.searchPoint(i, h);
                    rM(l, !0) && l.series && (!rM(s, !0) || (r = (o = s).distX - l.distX, a = o.dist - l.dist, n = l.series.group?.zIndex - o.series.group?.zIndex, (0 !== r && e ? r : 0 !== a ? a : 0 !== n ? n : o.series.index > l.series.index ? -1 : 1) > 0)) && (s = l);
                }), s;
            }
            getChartCoordinatesFromPoint(t, e) {
                let { xAxis: i, yAxis: s } = t.series, o = t.shapeArgs;
                if (i && s) {
                    let r = t.clientX ?? t.plotX ?? 0, a = t.plotY || 0;
                    return t.isNode && o && rk(o.x) && rk(o.y) && (r = o.x, a = o.y), e ? {
                        chartX: s.len + s.pos - a,
                        chartY: i.len + i.pos - r
                    } : {
                        chartX: r + i.pos,
                        chartY: a + s.pos
                    };
                }
                if (o?.x && o.y) return {
                    chartX: o.x,
                    chartY: o.y
                };
            }
            getChartPosition() {
                if (this.chartPosition) return this.chartPosition;
                let { container: t } = this.chart, e = rS(t);
                this.chartPosition = {
                    left: e.left,
                    top: e.top,
                    scaleX: 1,
                    scaleY: 1
                };
                let { offsetHeight: i, offsetWidth: s } = t;
                return s > 2 && i > 2 && (this.chartPosition.scaleX = e.width / s, this.chartPosition.scaleY = e.height / i), this.chartPosition;
            }
            getCoordinates(t) {
                let e = {
                    xAxis: [],
                    yAxis: []
                };
                for (let i of this.chart.axes)e[i.isXAxis ? "xAxis" : "yAxis"].push({
                    axis: i,
                    value: i.toValue(t[i.horiz ? "chartX" : "chartY"])
                });
                return e;
            }
            getHoverData(t, e, i, s, o, r) {
                let a = [], n = function(t) {
                    return t.visible && !(!o && t.directTouch) && rA(t.options.enableMouseTracking, !0);
                }, h = e, l, d = {
                    chartX: r ? r.chartX : void 0,
                    chartY: r ? r.chartY : void 0,
                    shared: o
                };
                rv(this, "beforeGetHoverData", d), l = h && !h.stickyTracking ? [
                    h
                ] : i.filter((t)=>t.stickyTracking && (d.filter || n)(t));
                let c = s && t || !r ? t : this.findNearestKDPoint(l, o, r);
                return h = c?.series, c && (o && !h.noSharedTooltip ? (l = i.filter(function(t) {
                    return d.filter ? d.filter(t) : n(t) && !t.noSharedTooltip;
                })).forEach(function(t) {
                    let e = t.options?.nullInteraction, i = rb(t.points, function(t) {
                        return t.x === c.x && (!t.isNull || !!e);
                    });
                    rM(i) && (t.boosted && t.boost && (i = t.boost.getPoint(i)), a.push(i));
                }) : a.push(c)), rv(this, "afterGetHoverData", d = {
                    hoverPoint: c
                }), {
                    hoverPoint: d.hoverPoint,
                    hoverSeries: h,
                    hoverPoints: a
                };
            }
            getPointFromEvent(t) {
                let e = t.target, i;
                for(; e && !i;)i = e.point, e = e.parentNode;
                return i;
            }
            onTrackerMouseOut(t) {
                let e = this.chart, i = t.relatedTarget, s = e.hoverSeries;
                this.isDirectTouch = !1, !s || !i || s.stickyTracking || this.inClass(i, "highcharts-tooltip") || this.inClass(i, "highcharts-series-" + s.index) && this.inClass(i, "highcharts-tracker") || s.onMouseOut();
            }
            inClass(t, e) {
                let i = t, s;
                for(; i;){
                    if (s = rm(i, "class")) {
                        if (-1 !== s.indexOf(e)) return !0;
                        if (-1 !== s.indexOf("highcharts-container")) return !1;
                    }
                    i = i.parentElement;
                }
            }
            constructor(t, e){
                this.hasDragged = 0, this.pointerCaptureEventsToUnbind = [], this.eventsToUnbind = [], this.options = e, this.chart = t, this.runChartClick = !!e.chart.events?.click, this.pinchDown = [], this.setDOMEvents(), rv(this, "afterInit");
            }
            normalize(t, e) {
                let i = t.touches, s = i ? i.length ? i.item(0) : rA(i.changedTouches, t.changedTouches)[0] : t;
                e || (e = this.getChartPosition());
                let o = s.pageX - e.left, r = s.pageY - e.top;
                return ry(t, {
                    chartX: Math.round(o /= e.scaleX),
                    chartY: Math.round(r /= e.scaleY)
                });
            }
            onContainerClick(t) {
                let e = this.chart, i = e.hoverPoint, s = this.normalize(t), o = e.plotLeft, r = e.plotTop;
                !e.cancelClick && (i && this.inClass(s.target, "highcharts-tracker") ? (rv(i.series, "click", ry(s, {
                    point: i
                })), e.hoverPoint && i.firePointEvent("click", s)) : (ry(s, this.getCoordinates(s)), e.isInsidePlot(s.chartX - o, s.chartY - r, {
                    visiblePlotOnly: !0
                }) && rv(e, "click", s)));
            }
            onContainerMouseDown(t) {
                let e = (1 & (t.buttons || t.button)) == 1;
                t = this.normalize(t), V.isFirefox && 0 !== t.button && this.onContainerMouseMove(t), (void 0 === t.button || e) && (this.zoomOption(t), e && t.preventDefault?.(), this.dragStart(t));
            }
            onContainerMouseLeave(t) {
                let { pointer: e } = rp[rA(rP.hoverChartIndex, -1)] || {};
                t = this.normalize(t), this.onContainerMouseMove(t), e && !this.inClass(t.relatedTarget, "highcharts-tooltip") && (e.reset(), e.chartPosition = void 0);
            }
            onContainerMouseEnter() {
                delete this.chartPosition;
            }
            onContainerMouseMove(t) {
                let e = this.chart, i = e.tooltip, s = this.normalize(t);
                this.setHoverChartIndex(t), ("mousedown" === e.mouseIsDown || this.touchSelect(s)) && this.drag(s), !e.exporting?.openMenu && (this.inClass(s.target, "highcharts-tracker") || e.isInsidePlot(s.chartX - e.plotLeft, s.chartY - e.plotTop, {
                    visiblePlotOnly: !0
                })) && !i?.shouldStickOnContact(s) && (this.inClass(s.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(s));
            }
            onDocumentTouchEnd(t) {
                this.onDocumentMouseUp(t);
            }
            onContainerTouchMove(t) {
                this.touchSelect(t) ? this.onContainerMouseMove(t) : this.touch(t);
            }
            onContainerTouchStart(t) {
                this.touchSelect(t) ? this.onContainerMouseDown(t) : (this.zoomOption(t), this.touch(t, !0));
            }
            onDocumentMouseMove(t) {
                let e = this.chart, i = e.tooltip, s = this.chartPosition, o = this.normalize(t, s);
                !s || e.isInsidePlot(o.chartX - e.plotLeft, o.chartY - e.plotTop, {
                    visiblePlotOnly: !0
                }) || i?.shouldStickOnContact(o) || o.target !== e.container.ownerDocument && this.inClass(o.target, "highcharts-tracker") || this.reset();
            }
            onDocumentMouseUp(t) {
                t?.touches && this.hasPinchMoved && t?.preventDefault?.(), rp[rA(rP.hoverChartIndex, -1)]?.pointer?.drop(t);
            }
            pinch(t) {
                let e = this, { chart: i, hasZoom: s, lastTouches: o } = e, r = [].map.call(t.touches || [], (t)=>e.normalize(t)), a = r.length, n = 1 === a && (e.inClass(t.target, "highcharts-tracker") && i.runTrackerClick || e.runChartClick), h = i.tooltip, l = 1 === a && rA(h?.options.followTouchMove, !0);
                a > 1 ? e.initiated = !0 : l && (e.initiated = !1), s && e.initiated && !n && !1 !== t.cancelable && t.preventDefault(), "touchstart" === t.type ? (e.pinchDown = r, e.res = !0, i.mouseDownX = t.chartX) : l ? this.runPointActions(e.normalize(t)) : o && (rv(i, "touchpan", {
                    originalEvent: t,
                    touches: r
                }, ()=>{
                    let e = (t)=>{
                        let e = t[0], i = t[1] || e;
                        return {
                            x: e.chartX,
                            y: e.chartY,
                            width: i.chartX - e.chartX,
                            height: i.chartY - e.chartY
                        };
                    };
                    i.transform({
                        axes: i.axes.filter((t)=>t.zoomEnabled && (this.zoomHor && t.horiz || this.zoomVert && !t.horiz)),
                        to: e(r),
                        from: e(o),
                        trigger: t.type
                    });
                }), e.res && (e.res = !1, this.reset(!1, 0))), e.lastTouches = r;
            }
            reset(t, e) {
                let i = this.chart, s = i.hoverSeries, o = i.hoverPoint, r = i.hoverPoints, a = i.tooltip, n = a?.shared ? r : o;
                t && n && rC(n).forEach(function(e) {
                    e.series.isCartesian && void 0 === e.plotX && (t = !1);
                }), t ? a && n && rC(n).length && (a.refresh(n), a.shared && r ? r.forEach(function(t) {
                    t.setState(t.state, !0), t.series.isCartesian && (t.series.xAxis.crosshair && t.series.xAxis.drawCrosshair(null, t), t.series.yAxis.crosshair && t.series.yAxis.drawCrosshair(null, t));
                }) : o && (o.setState(o.state, !0), i.axes.forEach(function(t) {
                    t.crosshair && o.series[t.coll] === t && t.drawCrosshair(null, o);
                }))) : (o && o.onMouseOut(), r && r.forEach(function(t) {
                    t.setState();
                }), s && s.onMouseOut(), a && a.hide(e), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i.axes.forEach(function(t) {
                    t.hideCrosshair();
                }), i.hoverPoints = i.hoverPoint = void 0);
            }
            runPointActions(t, e, i) {
                let s = this.chart, o = s.series, r = s.tooltip?.options.enabled ? s.tooltip : void 0, a = !!r && r.shared, n = e || s.hoverPoint, h = n?.series || s.hoverSeries, l = (!t || "touchmove" !== t.type) && (!!e || h?.directTouch && this.isDirectTouch), d = this.getHoverData(n, h, o, l, a, t);
                n = d.hoverPoint, h = d.hoverSeries;
                let c = d.hoverPoints, p = h?.tooltipOptions.followPointer && !h.tooltipOptions.split, u = a && h && !h.noSharedTooltip;
                if (n && (i || n !== s.hoverPoint || r?.isHidden)) {
                    if ((s.hoverPoints || []).forEach(function(t) {
                        -1 === c.indexOf(t) && t.setState();
                    }), s.hoverSeries !== h && h.onMouseOver(), this.applyInactiveState(c), (c || []).forEach(function(t) {
                        t.setState("hover");
                    }), s.hoverPoint && s.hoverPoint.firePointEvent("mouseOut"), !n.series) return;
                    s.hoverPoints = c, s.hoverPoint = n, n.firePointEvent("mouseOver", void 0, ()=>{
                        r && n && r.refresh(u ? c : n, t);
                    });
                } else if (p && r && !r.isHidden) {
                    let e = r.getAnchor([
                        {}
                    ], t);
                    s.isInsidePlot(e[0], e[1], {
                        visiblePlotOnly: !0
                    }) && r.updatePosition({
                        plotX: e[0],
                        plotY: e[1]
                    });
                }
                this.unDocMouseMove || (this.unDocMouseMove = rf(s.container.ownerDocument, "mousemove", (t)=>rp[rP.hoverChartIndex ?? -1]?.pointer?.onDocumentMouseMove(t)), this.eventsToUnbind.push(this.unDocMouseMove)), s.axes.forEach(function(e) {
                    let i, o = e.crosshair?.snap ?? !0;
                    o && ((i = s.hoverPoint) && i.series[e.coll] === e || (i = rb(c, (t)=>t.series?.[e.coll] === e))), i || !o ? e.drawCrosshair(t, i) : e.hideCrosshair();
                });
            }
            setDOMEvents() {
                let t = this.chart.container, e = t.ownerDocument, i = (t)=>t.parentElement || t.getRootNode()?.host?.parentElement;
                t.onmousedown = this.onContainerMouseDown.bind(this), t.onmousemove = this.onContainerMouseMove.bind(this), t.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(rf(t, "mouseenter", this.onContainerMouseEnter.bind(this)), rf(t, "mouseleave", this.onContainerMouseLeave.bind(this))), rP.unbindDocumentMouseUp.some((t)=>t.doc === e) || rP.unbindDocumentMouseUp.push({
                    doc: e,
                    unbind: rf(e, "mouseup", this.onDocumentMouseUp.bind(this))
                });
                let s = i(this.chart.renderTo);
                for(; s && "BODY" !== s.tagName;)this.eventsToUnbind.push(rf(s, "scroll", ()=>{
                    delete this.chartPosition;
                })), s = i(s);
                this.eventsToUnbind.push(rf(t, "touchstart", this.onContainerTouchStart.bind(this), {
                    passive: !1
                }), rf(t, "touchmove", this.onContainerTouchMove.bind(this), {
                    passive: !1
                })), rP.unbindDocumentTouchEnd || (rP.unbindDocumentTouchEnd = rf(e, "touchend", this.onDocumentTouchEnd.bind(this), {
                    passive: !1
                })), this.setPointerCapture(), rf(this.chart, "redraw", this.setPointerCapture.bind(this));
            }
            setPointerCapture() {
                if (!rg) return;
                let t = this.pointerCaptureEventsToUnbind, e = this.chart, i = e.container, s = rA(e.options.tooltip?.followTouchMove, !0) && e.series.some((t)=>t.options.findNearestPointBy.indexOf("y") > -1);
                !this.hasPointerCapture && s ? (t.push(rf(i, "pointerdown", (t)=>{
                    t.target?.hasPointerCapture(t.pointerId) && t.target?.releasePointerCapture(t.pointerId);
                }), rf(i, "pointermove", (t)=>{
                    e.pointer?.getPointFromEvent(t)?.onMouseOver(t);
                })), e.styledMode || rx(i, {
                    "touch-action": "none"
                }), i.className += " highcharts-no-touch-action", this.hasPointerCapture = !0) : this.hasPointerCapture && !s && (t.forEach((t)=>t()), t.length = 0, e.styledMode || rx(i, {
                    "touch-action": rA(e.options.chart.style?.["touch-action"], "manipulation")
                }), i.className = i.className.replace(" highcharts-no-touch-action", ""), this.hasPointerCapture = !1);
            }
            setHoverChartIndex(t) {
                let e = this.chart, i = V.charts[rA(rP.hoverChartIndex, -1)];
                if (i && i !== e) {
                    let s = {
                        relatedTarget: e.container
                    };
                    t && !t?.relatedTarget && Object.assign({}, t, s), i.pointer?.onContainerMouseLeave(t || s);
                }
                i?.mouseIsDown || (rP.hoverChartIndex = e.index);
            }
            touch(t, e) {
                let i, { chart: s, pinchDown: o = [] } = this;
                this.setHoverChartIndex(), 1 === (t = this.normalize(t)).touches.length ? s.isInsidePlot(t.chartX - s.plotLeft, t.chartY - s.plotTop, {
                    visiblePlotOnly: !0
                }) && !s.exporting?.openMenu ? (e && this.runPointActions(t), "touchmove" === t.type && (this.hasPinchMoved = i = !!o[0] && Math.pow(o[0].chartX - t.chartX, 2) + Math.pow(o[0].chartY - t.chartY, 2) >= 16), rA(i, !0) && this.pinch(t)) : e && this.reset() : 2 === t.touches.length && this.pinch(t);
            }
            touchSelect(t) {
                return !!(this.chart.zooming.singleTouch && t.touches && 1 === t.touches.length);
            }
            zoomOption(t) {
                let e = this.chart, i = e.inverted, s = e.zooming.type || "", o, r;
                /touch/.test(t.type) && (s = rA(e.zooming.pinchType, s)), this.zoomX = o = /x/.test(s), this.zoomY = r = /y/.test(s), this.zoomHor = o && !i || r && i, this.zoomVert = r && !i || o && i, this.hasZoom = o || r;
            }
        }
        rP.unbindDocumentMouseUp = [], (g = rP || (rP = {})).compose = function(t) {
            rT(ru, "Core.Pointer") && rf(t, "beforeRender", function() {
                this.pointer = new g(this, this.options);
            });
        };
        let rO = rP;
        (f = P || (P = {})).setLength = function(t, e, i) {
            return Array.isArray(t) ? (t.length = e, t) : t[i ? "subarray" : "slice"](0, e);
        }, f.splice = function(t, e, i, s, o = []) {
            if (Array.isArray(t)) return Array.isArray(o) || (o = Array.from(o)), {
                removed: t.splice(e, i, ...o),
                array: t
            };
            let r = Object.getPrototypeOf(t).constructor, a = t[s ? "subarray" : "slice"](e, e + i), n = new r(t.length - i + o.length);
            return n.set(t.subarray(0, e), 0), n.set(o, e), n.set(t.subarray(e + i), e + o.length), {
                removed: a,
                array: n
            };
        }, f.convertToNumber = function(t, e) {
            switch(typeof t){
                case "boolean":
                    return +!!t;
                case "number":
                    return isNaN(t) && !e ? null : t;
                default:
                    return isNaN(t = parseFloat(`${t ?? ""}`)) && !e ? null : t;
            }
        };
        let { setLength: rE, splice: rL } = P, { fireEvent: rB, objectEach: rD, uniqueKey: rI } = tx, rz = class {
            constructor(t = {}){
                this.autoId = !t.id, this.columns = {}, this.id = t.id || rI(), this.rowCount = 0, this.versionTag = rI();
                let e = 0;
                rD(t.columns || {}, (t, i)=>{
                    this.columns[i] = t.slice(), e = Math.max(e, t.length);
                }), this.applyRowCount(e);
            }
            applyRowCount(t) {
                this.rowCount = t, rD(this.columns, (e, i)=>{
                    e.length !== t && (this.columns[i] = rE(e, t));
                });
            }
            deleteRows(t, e = 1) {
                if (e > 0 && t < this.rowCount) {
                    let i = 0;
                    rD(this.columns, (s, o)=>{
                        this.columns[o] = rL(s, t, e).array, i = s.length;
                    }), this.rowCount = i;
                }
                rB(this, "afterDeleteRows", {
                    rowIndex: t,
                    rowCount: e
                }), this.versionTag = rI();
            }
            getColumn(t, e) {
                return this.columns[t];
            }
            getColumns(t, e) {
                return (t || Object.keys(this.columns)).reduce((t, e)=>(t[e] = this.columns[e], t), {});
            }
            getRow(t, e) {
                return (e || Object.keys(this.columns)).map((e)=>this.columns[e]?.[t]);
            }
            setColumn(t, e = [], i = 0, s) {
                this.setColumns({
                    [t]: e
                }, i, s);
            }
            setColumns(t, e, i) {
                let s = this.rowCount;
                rD(t, (t, e)=>{
                    this.columns[e] = t.slice(), s = t.length;
                }), this.applyRowCount(s), i?.silent || (rB(this, "afterSetColumns"), this.versionTag = rI());
            }
            setRow(t, e = this.rowCount, i, s) {
                let { columns: o } = this, r = i ? this.rowCount + 1 : e + 1, a = Object.keys(t);
                if (s?.addColumns !== !1) for(let t = 0, e = a.length; t < e; t++){
                    let e = a[t];
                    o[e] || (o[e] = []);
                }
                rD(o, (a, n)=>{
                    a || s?.addColumns === !1 || (a = Array(r)), a && (i ? a = rL(a, e, 0, !0, [
                        t[n] ?? null
                    ]).array : a[e] = t[n] ?? null, o[n] = a);
                }), r > this.rowCount && this.applyRowCount(r), s?.silent || (rB(this, "afterSetRows"), this.versionTag = rI());
            }
            getModified() {
                return this.modified || this;
            }
        }, { extend: rR, merge: rN, pick: rW } = tx;
        var rG = O || (O = {});
        function rX(t, e, i) {
            let s = this.legendItem = this.legendItem || {}, { chart: o, options: r } = this, { baseline: a = 0, symbolWidth: n, symbolHeight: h } = t, l = this.symbol || "circle", d = h / 2, c = o.renderer, p = s.group, u = a - Math.round((t.fontMetrics?.b || h) * (i ? .4 : .3)), g = {}, f, m = r.marker, x = 0;
            if (o.styledMode || (g["stroke-width"] = Math.min(r.lineWidth || 0, 24), r.dashStyle ? g.dashstyle = r.dashStyle : "square" !== r.linecap && (g["stroke-linecap"] = "round")), s.line = c.path().addClass("highcharts-graph").attr(g).add(p), i && (s.area = c.path().addClass("highcharts-area").add(p)), g["stroke-linecap"] && (x = Math.min(s.line.strokeWidth(), n) / 2), n) {
                let t = [
                    [
                        "M",
                        x,
                        u
                    ],
                    [
                        "L",
                        n - x,
                        u
                    ]
                ];
                s.line.attr({
                    d: t
                }), s.area?.attr({
                    d: [
                        ...t,
                        [
                            "L",
                            n - x,
                            a
                        ],
                        [
                            "L",
                            x,
                            a
                        ]
                    ]
                });
            }
            if (m && !1 !== m.enabled && n) {
                let t = Math.min(rW(m.radius, d), d);
                0 === l.indexOf("url") && (m = rN(m, {
                    width: h,
                    height: h
                }), t = 0), s.symbol = f = c.symbol(l, n / 2 - t, u - t, 2 * t, 2 * t, rR({
                    context: "legend"
                }, m)).addClass("highcharts-point").add(p), f.isMarker = !0;
            }
        }
        rG.areaMarker = function(t, e) {
            rX.call(this, t, e, !0);
        }, rG.lineMarker = rX, rG.rectangle = function(t, e) {
            let i = e.legendItem || {}, s = t.options, o = t.symbolHeight, r = s.squareSymbol, a = r ? o : t.symbolWidth;
            i.symbol = this.chart.renderer.rect(r ? (t.symbolWidth - o) / 2 : 0, t.baseline - o + 1, a, o, rW(t.options.symbolRadius, o / 2)).addClass("highcharts-point").attr({
                zIndex: 3
            }).add(i.group);
        };
        let rH = O, { defaultOptions: rF } = tY, { extend: rY, extendClass: rj, merge: rU } = tx;
        var rV = E || (E = {});
        function r$(t, e) {
            let i = rF.plotOptions || {}, s = e.defaultOptions, o = e.prototype;
            return o.type = t, o.pointClass || (o.pointClass = rd), !rV.seriesTypes[t] && (s && (i[t] = s), rV.seriesTypes[t] = e, !0);
        }
        rV.seriesTypes = V.seriesTypes, rV.registerSeriesType = r$, rV.seriesType = function(t, e, i, s, o) {
            let r = rF.plotOptions || {};
            if (e = e || "", r[t] = rU(r[e], i), delete rV.seriesTypes[t], r$(t, rj(rV.seriesTypes[e] || V.Series, s)), rV.seriesTypes[t].prototype.type = t, o) {
                class e extends rd {
                }
                rY(e.prototype, o), rV.seriesTypes[t].prototype.pointClass = e;
            }
            return rV.seriesTypes[t];
        };
        let r_ = E, { animObject: rZ, setAnimation: rq } = eo, { defaultOptions: rK } = tY, { registerEventOptions: rJ } = sS, { svg: rQ, win: r0 } = V, { seriesTypes: r1 } = r_, { format: r2 } = eI, { arrayMax: r3, arrayMin: r5, clamp: r6, correctFloat: r9, crisp: r4, defined: r8, destroyObjectProperties: r7, diffObjects: at, erase: ae, error: ai, extend: as, find: ao, fireEvent: ar, getClosestDistance: aa, getNestedProperty: an, insertItem: ah, isArray: al, isNumber: ad, isString: ac, merge: ap, objectEach: au, pick: ag, removeEvent: af, syncTimeout: am } = tx;
        class ax {
            constructor(){
                this.zoneAxis = "y";
            }
            init(t, e) {
                let i;
                ar(this, "init", {
                    options: e
                }), this.dataTable ?? (this.dataTable = new rz);
                let s = t.series;
                this.eventsToUnbind = [], this.chart = t, this.options = this.setOptions(e);
                let o = this.options, r = !1 !== o.visible;
                this.linkedSeries = [], this.bindAxes(), as(this, {
                    name: o.name,
                    state: "",
                    visible: r,
                    selected: !0 === o.selected
                }), rJ(this, o);
                let a = o.events;
                (a?.click || o.point?.events?.click || o.allowPointSelect) && (t.runTrackerClick = !0), this.getColor(), this.getSymbol(), this.isCartesian && (t.hasCartesianSeries = !0), s.length && (i = s[s.length - 1]), this._i = ag(i?._i, -1) + 1, this.opacity = this.options.opacity, t.orderItems("series", ah(this, s)), o.dataSorting?.enabled ? this.setDataSortingOptions() : this.points || this.data || this.setData(o.data, !1), ar(this, "afterInit");
            }
            is(t) {
                return r1[t] && this instanceof r1[t];
            }
            bindAxes() {
                let t, e = this, i = e.options, s = e.chart;
                ar(this, "bindAxes", null, function() {
                    (e.axisTypes || []).forEach(function(o) {
                        (s[o] || []).forEach(function(s) {
                            t = s.options, (ag(i[o], 0) === s.index || void 0 !== i[o] && i[o] === t.id) && (ah(e, s.series), e[o] = s, s.isDirty = !0);
                        }), e[o] || e.optionalAxis === o || ai(18, !0, s);
                    });
                }), ar(this, "afterBindAxes");
            }
            hasData() {
                return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.dataTable.rowCount > 0;
            }
            hasMarkerChanged(t, e) {
                let i = t.marker, s = e.marker || {};
                return i && (s.enabled && !i.enabled || s.symbol !== i.symbol || s.height !== i.height || s.width !== i.width);
            }
            autoIncrement(t) {
                let e, i = this.options, { pointIntervalUnit: s, relativeXValue: o } = this.options, r = this.chart.time, a = this.xIncrement ?? r.parse(i.pointStart) ?? 0;
                if (this.pointInterval = e = ag(this.pointInterval, i.pointInterval, 1), o && ad(t) && (e *= t), s) {
                    let t = r.toParts(a);
                    "day" === s ? t[2] += e : "month" === s ? t[1] += e : "year" === s && (t[0] += e), e = r.makeTime.apply(r, t) - a;
                }
                return o && ad(t) ? a + e : (this.xIncrement = a + e, a);
            }
            setDataSortingOptions() {
                let t = this.options;
                as(this, {
                    requireSorting: !1,
                    sorted: !1,
                    enabledDataSorting: !0,
                    allowDG: !1
                }), r8(t.pointRange) || (t.pointRange = 1);
            }
            setOptions(t) {
                let e, i = this.chart, s = i.options.plotOptions, o = i.userOptions || {}, r = ap(t), a = i.styledMode, n = {
                    plotOptions: s,
                    userOptions: r
                };
                ar(this, "setOptions", n);
                let h = n.plotOptions[this.type], l = o.plotOptions || {}, d = l.series || {}, c = rK.plotOptions[this.type] || {}, p = l[this.type] || {};
                h.dataLabels = this.mergeArrays(c.dataLabels, h.dataLabels), this.userOptions = n.userOptions;
                let u = ap(h, s.series, p, r);
                this.tooltipOptions = ap(rK.tooltip, rK.plotOptions.series?.tooltip, c?.tooltip, i.userOptions.tooltip, l.series?.tooltip, p.tooltip, r.tooltip), this.stickyTracking = ag(r.stickyTracking, p.stickyTracking, d.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || u.stickyTracking), null === h.marker && delete u.marker, this.zoneAxis = u.zoneAxis || "y";
                let g = this.zones = (u.zones || []).map((t)=>({
                        ...t
                    }));
                return (u.negativeColor || u.negativeFillColor) && !u.zones && (e = {
                    value: u[this.zoneAxis + "Threshold"] || u.threshold || 0,
                    className: "highcharts-negative"
                }, a || (e.color = u.negativeColor, e.fillColor = u.negativeFillColor), g.push(e)), g.length && r8(g[g.length - 1].value) && g.push(a ? {} : {
                    color: this.color,
                    fillColor: this.fillColor
                }), ar(this, "afterSetOptions", {
                    options: u
                }), u;
            }
            getName() {
                return this.options.name ?? r2(this.chart.options.lang.seriesName, this, this.chart);
            }
            getCyclic(t, e, i) {
                let s, o, r = this.chart, a = `${t}Index`, n = `${t}Counter`, h = i?.length || r.options.chart.colorCount;
                !e && (r8(o = ag("color" === t ? this.options.colorIndex : void 0, this[a])) ? s = o : (r.series.length || (r[n] = 0), s = r[n] % h, r[n] += 1), i && (e = i[s])), void 0 !== s && (this[a] = s), this[t] = e;
            }
            getColor() {
                this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || rK.plotOptions[this.type].color, this.chart.options.colors);
            }
            getPointsCollection() {
                return (this.hasGroupedData ? this.points : this.data) || [];
            }
            getSymbol() {
                let t = this.options.marker;
                this.getCyclic("symbol", t.symbol, this.chart.options.symbols);
            }
            getColumn(t, e) {
                return (e ? this.dataTable.getModified() : this.dataTable).getColumn(t, !0) || [];
            }
            findPointIndex(t, e) {
                let i, s, o, { id: r, x: a } = t, n = this.points, h = this.options.dataSorting, l = this.cropStart || 0;
                if (r) {
                    let t = this.chart.get(r);
                    t instanceof rd && (i = t);
                } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
                    let e = (e)=>!e.touched && e.index === t.index;
                    if (h?.matchByName ? e = (e)=>!e.touched && e.name === t.name : this.options.relativeXValue && (e = (e)=>!e.touched && e.options.x === t.x), !(i = ao(n, e))) return;
                }
                return i && void 0 !== (o = i?.index) && (s = !0), void 0 === o && ad(a) && (o = this.getColumn("x").indexOf(a, e)), -1 !== o && void 0 !== o && this.cropped && (o = o >= l ? o - l : o), !s && ad(o) && n[o]?.touched && (o = void 0), o;
            }
            updateData(t, e) {
                let { options: i, requireSorting: s } = this, o = i.dataSorting, r = this.points, a = [], n = t.length === r.length, h = this.xIncrement, l, d, c, p, u = !0;
                if (this.xIncrement = null, t.forEach((t, e)=>{
                    let h, d = r8(t) && this.pointClass.prototype.optionsToObject.call({
                        series: this
                    }, t) || {}, { id: c, x: u } = d;
                    c || ad(u) ? (-1 === (h = this.findPointIndex(d, p)) || void 0 === h ? a.push(t) : r[h] && t !== i.data?.[h] ? (r[h].update(t, !1, void 0, !1), r[h].touched = !0, s && (p = h + 1)) : r[h] && (r[h].touched = !0), (!n || e !== h || o?.enabled || this.hasDerivedData) && (l = !0)) : a.push(t);
                }, this), l) for(d = r.length; d--;)(c = r[d]) && !c.touched && c.remove?.(!1, e);
                else n && !o?.enabled ? (t.forEach((t, e)=>{
                    t === r[e].y || r[e].destroyed || r[e].update(t, !1, void 0, !1);
                }), a.length = 0) : u = !1;
                if (r.forEach((t)=>{
                    t && (t.touched = !1);
                }), !u) return !1;
                a.forEach((t)=>{
                    this.addPoint(t, !1, void 0, void 0, !1);
                }, this);
                let g = this.getColumn("x");
                return null !== h && null === this.xIncrement && g.length && (this.xIncrement = r3(g), this.autoIncrement()), !0;
            }
            dataColumnKeys() {
                return [
                    "x",
                    ...this.pointArrayMap || [
                        "y"
                    ]
                ];
            }
            setData(t, e = !0, i, s) {
                let o = this.points, r = o?.length || 0, a = this.options, n = this.chart, h = a.dataSorting, l = this.xAxis, d = a.turboThreshold, c = this.dataTable, p = this.dataColumnKeys(), u = this.pointValKey || "y", g = (this.pointArrayMap || []).length, f = a.keys, m, x, y = 0, b = 1, v;
                n.options.chart.allowMutatingData || (a.data && delete this.options.data, this.userOptions.data && delete this.userOptions.data, v = ap(!0, t));
                let k = (t = v || t || []).length;
                if (h?.enabled && (t = this.sortData(t)), n.options.chart.allowMutatingData && !1 !== s && k && r && !this.cropped && !this.hasGroupedData && this.visible && !this.boosted && (x = this.updateData(t, i)), !x) {
                    this.xIncrement = null, this.colorCounter = 0;
                    let e = d && !a.relativeXValue && k > d;
                    if (e) {
                        let i = this.getFirstValidPoint(t), s = this.getFirstValidPoint(t, k - 1, -1), o = (t)=>!!(al(t) && (f || ad(t[0])));
                        if (ad(i) && ad(s)) {
                            let e = [], i = [];
                            for (let s of t)e.push(this.autoIncrement()), i.push(s);
                            c.setColumns({
                                x: e,
                                [u]: i
                            });
                        } else if (o(i) && o(s)) if (g) {
                            let e = +(i.length === g), s = Array(p.length).fill(0).map(()=>[]);
                            for (let i of t){
                                e && s[0].push(this.autoIncrement());
                                for(let t = e; t <= g; t++)s[t]?.push(i[t - e]);
                            }
                            c.setColumns(p.reduce((t, e, i)=>(t[e] = s[i], t), {}));
                        } else {
                            f && (y = f.indexOf("x"), b = f.indexOf("y"), y = y >= 0 ? y : 0, b = b >= 0 ? b : 1), 1 === i.length && (b = 0);
                            let e = [], s = [];
                            if (y === b) for (let i of t)e.push(this.autoIncrement()), s.push(i[b]);
                            else for (let i of t)e.push(i[y]), s.push(i[b]);
                            c.setColumns({
                                x: e,
                                [u]: s
                            });
                        }
                        else e = !1;
                    }
                    if (!e) {
                        let e = p.reduce((t, e)=>(t[e] = [], t), {});
                        for(m = 0; m < k; m++){
                            let i = this.pointClass.prototype.applyOptions.apply({
                                series: this
                            }, [
                                t[m]
                            ]);
                            for (let t of p)e[t][m] = i[t];
                        }
                        c.setColumns(e);
                    }
                    for(ac(this.getColumn("y")[0]) && ai(14, !0, n), this.data = [], this.options.data = this.userOptions.data = t, m = r; m--;)o[m]?.destroy();
                    l && (l.minRange = l.userMinRange), this.isDirty = n.isDirtyBox = !0, this.isDirtyData = !!o, i = !1;
                }
                "point" === a.legendType && (this.processData(), this.generatePoints()), e && n.redraw(i);
            }
            sortData(t) {
                let e = this, i = e.options.dataSorting.sortKey || "y", s = function(t, e) {
                    return r8(e) && t.pointClass.prototype.optionsToObject.call({
                        series: t
                    }, e) || {};
                };
                return t.forEach(function(i, o) {
                    t[o] = s(e, i), t[o].index = o;
                }, this), t.concat().sort((t, e)=>{
                    let s = an(i, t), o = an(i, e);
                    return o < s ? -1 : +(o > s);
                }).forEach(function(t, e) {
                    t.x = e;
                }, this), e.linkedSeries && e.linkedSeries.forEach(function(e) {
                    let i = e.options, o = i.data;
                    !i.dataSorting?.enabled && o && (o.forEach(function(i, r) {
                        o[r] = s(e, i), t[r] && (o[r].x = t[r].x, o[r].index = r);
                    }), e.setData(o, !1));
                }), t;
            }
            getProcessedData(t) {
                let e = this, { dataTable: i, isCartesian: s, options: o, xAxis: r } = e, a = o.cropThreshold, n = t || e.getExtremesFromAll, h = r?.logarithmic, l = i.rowCount, d, c, p = 0, u, g, f, m = e.getColumn("x"), x = i, y = !1;
                return r && (g = (u = r.getExtremes()).min, f = u.max, y = !!(r.categories && !r.names.length), s && e.sorted && !n && (!a || l > a || e.forceCrop) && (m[l - 1] < g || m[0] > f ? x = new rz : e.getColumn(e.pointValKey || "y").length && (m[0] < g || m[l - 1] > f) && (x = (d = this.cropData(i, g, f)).modified, p = d.start, c = !0))), m = x.getColumn("x") || [], {
                    modified: x,
                    cropped: c,
                    cropStart: p,
                    closestPointRange: aa([
                        h ? m.map(h.log2lin) : m
                    ], ()=>e.requireSorting && !y && ai(15, !1, e.chart))
                };
            }
            processData(t) {
                let e = this.xAxis, i = this.dataTable;
                if (this.isCartesian && !this.isDirty && !e.isDirty && !this.yAxis.isDirty && !t) return !1;
                let s = this.getProcessedData();
                i.modified = s.modified, this.cropped = s.cropped, this.cropStart = s.cropStart, this.closestPointRange = this.basePointRange = s.closestPointRange, ar(this, "afterProcessData");
            }
            cropData(t, e, i) {
                let s = t.getColumn("x", !0) || [], o = s.length, r = {}, a, n, h = 0, l = o;
                for(a = 0; a < o; a++)if (s[a] >= e) {
                    h = Math.max(0, a - 1);
                    break;
                }
                for(n = a; n < o; n++)if (s[n] > i) {
                    l = n + 1;
                    break;
                }
                for (let e of this.dataColumnKeys()){
                    let i = t.getColumn(e, !0);
                    i && (r[e] = i.slice(h, l));
                }
                return {
                    modified: new rz({
                        columns: r
                    }),
                    start: h,
                    end: l
                };
            }
            generatePoints() {
                let t = this.options, e = this.processedData || t.data, i = this.dataTable.getModified(), s = this.getColumn("x", !0), o = this.pointClass, r = i.rowCount, a = this.cropStart || 0, n = this.hasGroupedData, h = t.keys, l = [], d = t.dataGrouping?.groupAll ? a : 0, c = this.pointArrayMap || [
                    "y"
                ], p = this.dataColumnKeys(), u, g, f, m, x = this.data, y;
                if (!x && !n) {
                    let t = [];
                    t.length = e?.length || 0, x = this.data = t;
                }
                for(h && n && (this.options.keys = !1), m = 0; m < r; m++)g = a + m, n ? ((f = new o(this, i.getRow(m, p) || [])).dataGroup = this.groupMap?.[d + m], f.dataGroup?.options && (f.options = f.dataGroup.options, as(f, f.dataGroup.options), delete f.dataLabels, f.key = f.name ?? f.category)) : (f = x[g], y = e ? e[g] : i.getRow(m, c), f || void 0 === y ? f && (f.category = this.xAxis?.categories?.[f.x] ?? f.x, f.key = f.name ?? f.category) : x[g] = f = new o(this, y, s[m])), f && (f.index = n ? d + m : g, l[m] = f);
                if (this.options.keys = h, x && (r !== (u = x.length) || n)) for(m = 0; m < u; m++)m !== a || n || (m += r), x[m] && (x[m].destroyElements(), x[m].plotX = void 0);
                this.data = x, this.points = l, ar(this, "afterGeneratePoints");
            }
            getXExtremes(t) {
                return {
                    min: r5(t),
                    max: r3(t)
                };
            }
            getExtremes(t, e) {
                let { xAxis: i, yAxis: s } = this, o = e || this.getExtremesFromAll || this.options.getExtremesFromAll, r = o && this.cropped ? this.dataTable : this.dataTable.getModified(), a = r.rowCount, n = t || this.stackedYData, h = n ? [
                    n
                ] : (this.keysAffectYAxis || this.pointArrayMap || [
                    "y"
                ])?.map((t)=>r.getColumn(t, !0) || []) || [], l = this.getColumn("x", !0), d = [], c = this.requireSorting && !this.is("column") ? 1 : 0, p = !!s && s.positiveValuesOnly, u = o || this.cropped || !i, g, f, m, x = 0, y = 0;
                for(i && (x = (g = i.getExtremes()).min, y = g.max), m = 0; m < a; m++)if (f = l[m], u || (l[m + c] || f) >= x && (l[m - c] || f) <= y) for (let t of h){
                    let e = t[m];
                    ad(e) && (e > 0 || !p) && d.push(e);
                }
                let b = {
                    activeYData: d,
                    dataMin: r5(d),
                    dataMax: r3(d)
                };
                return ar(this, "afterGetExtremes", {
                    dataExtremes: b
                }), b;
            }
            applyExtremes() {
                let t = this.getExtremes();
                return this.dataMin = t.dataMin, this.dataMax = t.dataMax, t;
            }
            getFirstValidPoint(t, e = 0, i = 1) {
                let s = t.length, o = e;
                for(; o >= 0 && o < s;){
                    if (r8(t[o])) return t[o];
                    o += i;
                }
            }
            translate() {
                this.generatePoints();
                let t = this.options, e = t.stacking, i = this.xAxis, s = this.enabledDataSorting, o = this.yAxis, r = this.points, a = r.length, n = this.pointPlacementToXValue(), h = !!n, l = t.threshold, d = t.startFromThreshold ? l : 0, c = t?.nullInteraction && o.len, p, u, g, f, m = Number.MAX_VALUE;
                function x(t) {
                    return r6(t, -1e9, 1e9);
                }
                for(p = 0; p < a; p++){
                    let t, a = r[p], y = a.x, b, v, k = a.y, M = a.low, w = e && o.stacking?.stacks[(this.negStacks && k < (d ? 0 : l) ? "-" : "") + this.stackKey];
                    a.plotX = ad(u = i.translate(y, !1, !1, !1, !0, n)) ? r9(x(u)) : void 0, e && this.visible && w && w[y] && (f = this.getStackIndicator(f, y, this.index), !a.isNull && f.key && (v = (b = w[y]).points[f.key]), b && al(v) && (M = v[0], k = v[1], M === d && f.key === w[y].base && (M = ag(ad(l) ? l : o.min)), o.positiveValuesOnly && r8(M) && M <= 0 && (M = void 0), a.total = a.stackTotal = ag(b.total), a.percentage = r8(a.y) && b.total ? a.y / b.total * 100 : void 0, a.stackY = k, this.irregularWidths || b.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), a.yBottom = r8(M) ? x(o.translate(M, !1, !0, !1, !0)) : void 0, this.dataModify && (k = this.dataModify.modifyValue(k, p)), ad(k) && void 0 !== a.plotX ? t = ad(t = o.translate(k, !1, !0, !1, !0)) ? x(t) : void 0 : !ad(k) && c && (t = c), a.plotY = t, a.isInside = this.isPointInside(a), a.clientX = h ? r9(i.translate(y, !1, !1, !1, !0, n)) : u, a.negative = (a.y || 0) < (l || 0), a.isNull || !1 === a.visible || (void 0 !== g && (m = Math.min(m, Math.abs(u - g))), g = u), a.zone = this.zones.length ? a.getZone() : void 0, !a.graphic && this.group && s && (a.isNew = !0);
                }
                this.closestPointRangePx = m, ar(this, "afterTranslate");
            }
            getValidPoints(t, e, i) {
                let s = this.chart;
                return (t || this.points || []).filter(function(t) {
                    let { plotX: o, plotY: r } = t;
                    return (!!i || !t.isNull && !!ad(r)) && (!e || !!s.isInsidePlot(o, r, {
                        inverted: s.inverted
                    })) && !1 !== t.visible;
                });
            }
            getSharedClipKey() {
                return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0), this.sharedClipKey;
            }
            setClip() {
                let { chart: t, group: e, markerGroup: i } = this, s = t.sharedClips, o = t.renderer, r = t.getClipBox(this), a = this.getSharedClipKey(), n = s[a];
                ar(this, "setClip", {
                    clipBox: r
                }), n ? n.animate(r) : s[a] = n = o.clipRect(r), e && e.clip(!1 === this.options.clip ? void 0 : n), i && i.clip();
            }
            animate(t) {
                let { chart: e, group: i, markerGroup: s } = this, o = e.inverted, r = rZ(this.options.animation), a = [
                    this.getSharedClipKey(),
                    r.duration,
                    r.easing,
                    r.defer
                ].join(","), n = e.sharedClips[a], h = e.sharedClips[a + "m"];
                if (t && i) {
                    let t = e.getClipBox(this);
                    if (n) n.attr("height", t.height);
                    else {
                        t.width = 0, o && (t.x = e.plotHeight), n = e.renderer.clipRect(t), e.sharedClips[a] = n;
                        let i = {
                            x: -99,
                            y: -99,
                            width: o ? e.plotWidth + 199 : 99,
                            height: o ? 99 : e.plotHeight + 199
                        };
                        h = e.renderer.clipRect(i), e.sharedClips[a + "m"] = h;
                    }
                    i.clip(n), s?.clip(h);
                } else if (n && !n.hasClass("highcharts-animating")) {
                    let t = e.getClipBox(this), i = r.step;
                    (s?.element.childNodes.length || e.series.length > 1) && (r.step = function(t, e) {
                        i && i.apply(e, arguments), "width" === e.prop && h?.element && h.attr(o ? "height" : "width", t + 99);
                    }), n.addClass("highcharts-animating").animate(t, r);
                }
            }
            afterAnimate() {
                this.setClip(), au(this.chart.sharedClips, (t, e, i)=>{
                    t && !this.chart.container.querySelector(`[clip-path="url(#${t.id})"]`) && (t.destroy(), delete i[e]);
                }), this.finishedAnimating = !0, ar(this, "afterAnimate");
            }
            drawPoints(t = this.points) {
                let e, i, s, o, r, a, n, h = this.chart, l = h.styledMode, { colorAxis: d, options: c } = this, p = c.marker, u = c.nullInteraction, g = this[this.specialGroup || "markerGroup"], f = this.xAxis, m = ag(p.enabled, !f || !!f.isRadial || null, this.closestPointRangePx >= p.enabledThreshold * p.radius);
                if (!1 !== p.enabled || this._hasPointMarkers) for(e = 0; e < t.length; e++){
                    o = (s = (i = t[e]).graphic) ? "animate" : "attr", r = i.marker || {}, a = !!i.marker;
                    let c = i.isNull;
                    if ((m && !r8(r.enabled) || r.enabled) && (!c || u) && !1 !== i.visible) {
                        let t = ag(r.symbol, this.symbol, "rect");
                        n = this.markerAttribs(i, i.selected && "select"), this.enabledDataSorting && (i.startXPos = f.reversed ? -(n.width || 0) : f.width);
                        let e = !1 !== i.isInside;
                        if (!s && e && ((n.width || 0) > 0 || i.hasImage) && (i.graphic = s = h.renderer.symbol(t, n.x, n.y, n.width, n.height, a ? r : p).add(g), this.enabledDataSorting && h.hasRendered && (s.attr({
                            x: i.startXPos
                        }), o = "animate")), s && "animate" === o && s[e ? "show" : "hide"](e).animate(n), s) {
                            let t = this.pointAttribs(i, l || !i.selected ? void 0 : "select");
                            l ? d && s.css({
                                fill: t.fill
                            }) : s[o](t);
                        }
                        s && s.addClass(i.getClassName(), !0);
                    } else s && (i.graphic = s.destroy());
                }
            }
            markerAttribs(t, e) {
                let i = this.options, s = i.marker, o = t.marker || {}, r = o.symbol || s.symbol, a = {}, n, h, l = ag(o.radius, s?.radius);
                e && (n = s.states[e], h = o.states && o.states[e], l = ag(h?.radius, n?.radius, l && l + (n?.radiusPlus || 0))), t.hasImage = r && 0 === r.indexOf("url"), t.hasImage && (l = 0);
                let d = t.pos();
                return ad(l) && d && (i.crisp && (d[0] = r4(d[0], t.hasImage ? 0 : "rect" === r ? s?.lineWidth || 0 : 1)), a.x = d[0] - l, a.y = d[1] - l), l && (a.width = a.height = 2 * l), a;
            }
            pointAttribs(t, e) {
                let i = this.options, s = i.marker, o = t?.options, r = o?.marker || {}, a = o?.color, n = t?.color, h = t?.zone?.color, l, d, c = this.color, p, u, g = ag(r.lineWidth, s.lineWidth), f = t?.isNull && i.nullInteraction ? 0 : 1;
                return c = a || h || n || c, p = r.fillColor || s.fillColor || c, u = r.lineColor || s.lineColor || c, e = e || "normal", l = s.states[e] || {}, g = ag((d = r.states && r.states[e] || {}).lineWidth, l.lineWidth, g + ag(d.lineWidthPlus, l.lineWidthPlus, 0)), p = d.fillColor || l.fillColor || p, u = d.lineColor || l.lineColor || u, {
                    stroke: u,
                    "stroke-width": g,
                    fill: p,
                    opacity: f = ag(d.opacity, l.opacity, f)
                };
            }
            destroy(t) {
                let e, i, s = this, o = s.chart, r = /AppleWebKit\/533/.test(r0.navigator.userAgent), a = s.data || [];
                for(ar(s, "destroy", {
                    keepEventsForUpdate: t
                }), this.removeEvents(t), (s.axisTypes || []).forEach(function(t) {
                    i = s[t], i?.series && (ae(i.series, s), i.isDirty = i.forceRedraw = !0);
                }), s.legendItem && s.chart.legend.destroyItem(s), e = a.length; e--;)a[e]?.destroy?.();
                for (let t of s.zones)r7(t, void 0, !0);
                tx.clearTimeout(s.animationTimeout), au(s, function(t, e) {
                    t instanceof ic && !t.survive && t[r && "group" === e ? "hide" : "destroy"]();
                }), o.hoverSeries === s && (o.hoverSeries = void 0), ae(o.series, s), o.orderItems("series"), au(s, function(e, i) {
                    t && "hcEvents" === i || delete s[i];
                });
            }
            applyZones() {
                let { area: t, chart: e, graph: i, zones: s, points: o, xAxis: r, yAxis: a, zoneAxis: n } = this, { inverted: h, renderer: l } = e, d = this[`${n}Axis`], { isXAxis: c, len: p = 0, minPointOffset: u = 0 } = d || {}, g = (i?.strokeWidth() || 0) / 2 + 1, f = (t, e = 0, i = 0)=>{
                    h && (i = p - i);
                    let { translated: s = 0, lineClip: o } = t, r = i - s;
                    o?.push([
                        "L",
                        e,
                        Math.abs(r) < g ? i - g * (r <= 0 ? -1 : 1) : s
                    ]);
                };
                if (s.length && (i || t) && d && ad(d.min)) {
                    let e = d.getExtremes().max + u, g = (t)=>{
                        t.forEach((e, i)=>{
                            ("M" === e[0] || "L" === e[0]) && (t[i] = [
                                e[0],
                                c ? p - e[1] : e[1],
                                c ? e[2] : p - e[2]
                            ]);
                        });
                    };
                    if (s.forEach((t)=>{
                        t.lineClip = [], t.translated = r6(d.toPixels(ag(t.value, e), !0) || 0, 0, p);
                    }), i && !this.showLine && i.hide(), t && t.hide(), "y" === n && o.length < r.len) for (let t of o){
                        let { plotX: e, plotY: i, zone: o } = t, r = o && s[s.indexOf(o) - 1];
                        o && f(o, e, i), r && f(r, e, i);
                    }
                    let m = [], x = d.toPixels(d.getExtremes().min - u, !0);
                    s.forEach((e)=>{
                        let s = e.lineClip || [], o = Math.round(e.translated || 0);
                        r.reversed && s.reverse();
                        let { clip: n, simpleClip: d } = e, p = 0, u = 0, f = r.len, y = a.len;
                        c ? (p = o, f = x) : (u = o, y = x);
                        let b = [
                            [
                                "M",
                                p,
                                u
                            ],
                            [
                                "L",
                                f,
                                u
                            ],
                            [
                                "L",
                                f,
                                y
                            ],
                            [
                                "L",
                                p,
                                y
                            ],
                            [
                                "Z"
                            ]
                        ], v = [
                            b[0],
                            ...s,
                            b[1],
                            b[2],
                            ...m,
                            b[3],
                            b[4]
                        ];
                        m = s.reverse(), x = o, h && (g(v), t && g(b)), n ? (n.animate({
                            d: v
                        }), d?.animate({
                            d: b
                        })) : (n = e.clip = l.path(v), t && (d = e.simpleClip = l.path(b))), i && e.graph?.clip(n), t && e.area?.clip(d);
                    });
                } else this.visible && (i && i.show(), t && t.show());
            }
            plotGroup(t, e, i, s, o) {
                let r = this[t], a = !r, n = {
                    visibility: i,
                    zIndex: s || .1
                };
                return r8(this.opacity) && !this.chart.styledMode && "inactive" !== this.state && (n.opacity = this.opacity), r || (this[t] = r = this.chart.renderer.g().add(o)), r.addClass("highcharts-" + e + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (r8(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (r.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0), r.attr(n)[a ? "attr" : "animate"](this.getPlotBox(e)), r;
            }
            getPlotBox(t) {
                let e = this.xAxis, i = this.yAxis, s = this.chart, o = s.inverted && !s.polar && e && this.invertible && "series" === t;
                s.inverted && (e = i, i = this.xAxis);
                let r = {
                    scale: 1,
                    translateX: e ? e.left : s.plotLeft,
                    translateY: i ? i.top : s.plotTop,
                    name: t
                };
                ar(this, "getPlotBox", r);
                let { scale: a, translateX: n, translateY: h } = r;
                return {
                    translateX: n,
                    translateY: h,
                    rotation: 90 * !!o,
                    rotationOriginX: o ? a * (e.len - i.len) / 2 : 0,
                    rotationOriginY: o ? a * (e.len + i.len) / 2 : 0,
                    scaleX: o ? -a : a,
                    scaleY: a
                };
            }
            removeEvents(t) {
                let { eventsToUnbind: e } = this;
                t || af(this), e.length && (e.forEach((t)=>{
                    t();
                }), e.length = 0);
            }
            render() {
                let t = this, { chart: e, options: i, hasRendered: s } = t, o = rZ(i.animation), r = t.visible ? "inherit" : "hidden", a = i.zIndex, n = e.seriesGroup, h = t.finishedAnimating ? 0 : o.duration;
                ar(this, "render"), t.plotGroup("group", "series", r, a, n), t.markerGroup = t.plotGroup("markerGroup", "markers", r, a, n), !1 !== i.clip && t.setClip(), h && t.animate?.(!0), t.drawGraph && (t.drawGraph(), t.applyZones()), t.visible && t.drawPoints(), t.drawDataLabels?.(), t.redrawPoints?.(), i.enableMouseTracking && t.drawTracker?.(), h && t.animate?.(), s || (h && o.defer && (h += o.defer), t.animationTimeout = am(()=>{
                    t.afterAnimate();
                }, h || 0)), t.isDirty = !1, t.hasRendered = !0, ar(t, "afterRender");
            }
            redraw() {
                let t = this.isDirty || this.isDirtyData;
                this.translate(), this.render(), t && delete this.kdTree;
            }
            reserveSpace() {
                return this.visible || !this.chart.options.chart.ignoreHiddenSeries;
            }
            searchPoint(t, e) {
                let { xAxis: i, yAxis: s } = this, o = this.chart.inverted;
                return this.searchKDTree({
                    clientX: o ? i.len - t.chartY + i.pos : t.chartX - i.pos,
                    plotY: o ? s.len - t.chartX + s.pos : t.chartY - s.pos
                }, e, t);
            }
            buildKDTree(t) {
                this.buildingKdTree = !0;
                let e = this, i = e.options, s = i.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
                delete e.kdTree, am(function() {
                    e.kdTree = function t(i, s, o) {
                        let r, a, n = i?.length;
                        if (n) return r = e.kdAxisArray[s % o], i.sort((t, e)=>(t[r] || 0) - (e[r] || 0)), {
                            point: i[a = Math.floor(n / 2)],
                            left: t(i.slice(0, a), s + 1, o),
                            right: t(i.slice(a + 1), s + 1, o)
                        };
                    }(e.getValidPoints(void 0, !e.directTouch, i?.nullInteraction), s, s), e.buildingKdTree = !1;
                }, i.kdNow || t?.type === "touchstart" ? 0 : 1);
            }
            searchKDTree(t, e, i, s, o) {
                let r = this, [a, n] = this.kdAxisArray, h = e ? "distX" : "dist", l = (r.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1, d = !!r.isBubble, c = s || ((t, e, i)=>{
                    let s = t[i] || 0, o = e[i] || 0;
                    return [
                        s === o && t.index > e.index || s < o ? t : e,
                        !1
                    ];
                }), p = o || ((t, e)=>t < e);
                if (this.kdTree || this.buildingKdTree || this.buildKDTree(i), this.kdTree) return function t(e, i, s, o) {
                    let l, u, g, f, m, x, y, b = i.point, v = r.kdAxisArray[s % o], k = b, M = !1;
                    l = e[a], u = b[a], g = r8(l) && r8(u) ? l - u : null, f = e[n], m = b[n], x = r8(f) && r8(m) ? f - m : 0, y = d && b.marker?.radius || 0, b.dist = Math.sqrt((g && g * g || 0) + x * x) - y, b.distX = r8(g) ? Math.abs(g) - y : Number.MAX_VALUE;
                    let w = (e[v] || 0) - (b[v] || 0) + (d && b.marker?.radius || 0), S = w < 0 ? "left" : "right", A = w < 0 ? "right" : "left";
                    return i[S] && ([k, M] = c(b, t(e, i[S], s + 1, o), h)), i[A] && p(Math.sqrt(w * w), k[h], M) && (k = c(k, t(e, i[A], s + 1, o), h)[0]), k;
                }(t, this.kdTree, l, l);
            }
            pointPlacementToXValue() {
                let { options: t, xAxis: e } = this, i = t.pointPlacement;
                return "between" === i && (i = e.reversed ? -.5 : .5), ad(i) ? i * (t.pointRange || e.pointRange) : 0;
            }
            isPointInside(t) {
                let { chart: e, xAxis: i, yAxis: s } = this, { plotX: o = -1, plotY: r = -1 } = t;
                return r >= 0 && r <= (s ? s.len : e.plotHeight) && o >= 0 && o <= (i ? i.len : e.plotWidth);
            }
            drawTracker() {
                let t = this, e = t.options, i = e.trackByArea, s = [].concat((i ? t.areaPath : t.graphPath) || []), o = t.chart, r = o.pointer, a = o.renderer, n = o.options.tooltip?.snap || 0, h = ()=>{
                    e.enableMouseTracking && o.hoverSeries !== t && t.onMouseOver();
                }, l = "rgba(192,192,192," + (rQ ? 1e-4 : .002) + ")", d = t.tracker;
                d ? d.attr({
                    d: s
                }) : t.graph && (t.tracker = d = a.path(s).attr({
                    visibility: t.visible ? "inherit" : "hidden",
                    zIndex: 2
                }).addClass(i ? "highcharts-tracker-area" : "highcharts-tracker-line").add(t.group), o.styledMode || d.attr({
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    stroke: l,
                    fill: i ? l : "none",
                    "stroke-width": t.graph.strokeWidth() + (i ? 0 : 2 * n)
                }), [
                    t.tracker,
                    t.markerGroup,
                    ...t.dataLabelsGroups || []
                ].forEach((t)=>{
                    t && (t.addClass("highcharts-tracker").on("mouseover", h).on("mouseout", (t)=>{
                        r?.onTrackerMouseOut(t);
                    }), e.cursor && !o.styledMode && t.css({
                        cursor: e.cursor
                    }), t.on("touchstart", h));
                })), ar(this, "afterDrawTracker");
            }
            addPoint(t, e, i, s, o) {
                let r, a, n = this.options, { chart: h, data: l, dataTable: d, xAxis: c } = this, p = c?.hasNames && c.names, u = n.data, g = this.getColumn("x");
                e = ag(e, !0);
                let f = {
                    series: this
                };
                this.pointClass.prototype.applyOptions.apply(f, [
                    t
                ]);
                let m = f.x;
                if (a = g.length, this.requireSorting && m < g[a - 1]) for(r = !0; a && g[a - 1] > m;)a--;
                d.setRow(f, a, !0, {
                    addColumns: !1
                }), p && f.name && (p[m] = f.name), u?.splice(a, 0, t), (r || this.processedData) && (this.data.splice(a, 0, null), this.processData()), "point" === n.legendType && this.generatePoints(), i && (l[0] && l[0].remove ? l[0].remove(!1) : ([
                    l,
                    u
                ].filter(r8).forEach((t)=>{
                    t.shift();
                }), d.deleteRows(0))), !1 !== o && ar(this, "addPoint", {
                    point: f
                }), this.isDirty = !0, this.isDirtyData = !0, e && h.redraw(s);
            }
            removePoint(t, e, i) {
                let s = this, { chart: o, data: r, points: a, dataTable: n } = s, h = r[t], l = function() {
                    [
                        a?.length === r.length ? a : void 0,
                        r,
                        s.options.data
                    ].filter(r8).forEach((e)=>{
                        e.splice(t, 1);
                    }), n.deleteRows(t), h?.destroy(), s.isDirty = !0, s.isDirtyData = !0, e && o.redraw();
                };
                rq(i, o), e = ag(e, !0), h ? h.firePointEvent("remove", null, l) : l();
            }
            remove(t, e, i, s) {
                let o = this, r = o.chart;
                function a() {
                    o.destroy(s), r.isDirtyLegend = r.isDirtyBox = !0, r.linkSeries(s), ag(t, !0) && r.redraw(e);
                }
                !1 !== i ? ar(o, "remove", null, a) : a();
            }
            update(t, e) {
                ar(this, "update", {
                    options: t = at(t, this.userOptions)
                });
                let i = this, s = i.chart, o = i.userOptions, r = i.initialType || i.type, a = s.options.plotOptions, n = r1[r].prototype, h = i.finishedAnimating && {
                    animation: !1
                }, l = {}, d, c, p = ax.keepProps.slice(), u = t.type || o.type || s.options.chart.type, g = !(this.hasDerivedData || u && u !== this.type || void 0 !== t.keys || void 0 !== t.pointStart || void 0 !== t.pointInterval || void 0 !== t.relativeXValue || t.joinBy || t.mapData || [
                    "dataGrouping",
                    "pointStart",
                    "pointInterval",
                    "pointIntervalUnit",
                    "keys"
                ].some((t)=>i.hasOptionChanged(t)));
                u = u || r, g ? (p.push.apply(p, ax.keepPropsForPoints), !1 !== t.visible && p.push("area", "graph"), i.parallelArrays.forEach(function(t) {
                    p.push(t + "Data");
                }), t.data && (t.dataSorting && as(i.options.dataSorting, t.dataSorting), this.setData(t.data, !1))) : this.dataTable.modified = this.dataTable, t.dataLabels && o.dataLabels && (t.dataLabels = this.mergeArrays(o.dataLabels, t.dataLabels)), t = ap(o, {
                    index: void 0 === o.index ? i.index : o.index,
                    pointStart: a?.series?.pointStart ?? o.pointStart ?? i.getColumn("x")[0]
                }, !g && {
                    data: i.options.data
                }, t, h), g && t.data && (t.data = i.options.data), (p = [
                    "dataLabelsGroup",
                    "dataLabelsGroups",
                    "dataLabelsParentGroups",
                    "group",
                    "markerGroup",
                    "transformGroup"
                ].concat(p)).forEach(function(t) {
                    p[t] = i[t], delete i[t];
                });
                let f = !1;
                if (r1[u]) {
                    if (f = u !== i.type, i.remove(!1, !1, !1, !0), f) if (s.propFromSeries(), Object.setPrototypeOf) Object.setPrototypeOf(i, r1[u].prototype);
                    else {
                        let t = Object.hasOwnProperty.call(i, "hcEvents") && i.hcEvents;
                        for(c in n)i[c] = void 0;
                        as(i, r1[u].prototype), t ? i.hcEvents = t : delete i.hcEvents;
                    }
                } else ai(17, !0, s, {
                    missingModuleFor: u
                });
                if (p.forEach(function(t) {
                    i[t] = p[t];
                }), i.init(s, t), g && this.points) for (let t of (!1 === (d = i.options).visible ? (l.graphic = 1, l.dataLabel = 1) : (this.hasMarkerChanged(d, o) && (l.graphic = 1), i.hasDataLabels?.() || (l.dataLabel = 1)), this.points))t?.series && (t.resolveColor(), Object.keys(l).length && t.destroyElements(l), !1 === d.showInLegend && t.legendItem && s.legend.destroyItem(t));
                i.initialType = r, s.linkSeries(), s.setSortedData(), f && i.linkedSeries.length && (i.isDirtyData = !0), ar(this, "afterUpdate"), ag(e, !0) && s.redraw(!!g && void 0);
            }
            setName(t) {
                this.name = this.options.name = this.userOptions.name = t, this.chart.isDirtyLegend = !0;
            }
            hasOptionChanged(t) {
                let e = this.chart, i = this.options[t], s = e.options.plotOptions, o = this.userOptions[t], r = ag(s?.[this.type]?.[t], s?.series?.[t]);
                return o && !r8(r) ? i !== o : i !== ag(r, i);
            }
            onMouseOver() {
                let t = this.chart, e = t.hoverSeries, i = t.pointer;
                i?.setHoverChartIndex(), e && e !== this && e.onMouseOut(), this.options.events.mouseOver && ar(this, "mouseOver"), this.setState("hover"), t.hoverSeries = this;
            }
            onMouseOut() {
                let t = this.options, e = this.chart, i = e.tooltip, s = e.hoverPoint;
                e.hoverSeries = null, s && s.onMouseOut(), this && t.events.mouseOut && ar(this, "mouseOut"), i && !this.stickyTracking && (!i.shared || this.noSharedTooltip) && i.hide(), e.series.forEach(function(t) {
                    t.setState("", !0);
                });
            }
            setState(t, e) {
                let i = this, { graph: s, options: o } = i, { inactiveOtherPoints: r, states: a } = o, n = ag(a?.[t || "normal"]?.animation, i.chart.options.chart.animation), { lineWidth: h, opacity: l } = o;
                if (t = t || "", i.state !== t && ([
                    i.group,
                    i.markerGroup,
                    ...i.dataLabelsGroups || []
                ].forEach(function(e) {
                    e && (i.state && e.removeClass("highcharts-series-" + i.state), t && e.addClass("highcharts-series-" + t));
                }), i.state = t, !i.chart.styledMode)) {
                    if (a[t]?.enabled === !1) return;
                    if (t && (h = a[t].lineWidth || h + (a[t].lineWidthPlus || 0), l = ag(a[t].opacity, l)), s && !s.dashstyle && ad(h)) for (let t of [
                        s,
                        ...this.zones.map((t)=>t.graph)
                    ])t?.animate({
                        "stroke-width": h
                    }, n);
                    r || [
                        i.group,
                        i.markerGroup,
                        ...i.dataLabelsGroups || [],
                        i.labelBySeries
                    ].forEach(function(t) {
                        t?.animate({
                            opacity: l
                        }, n);
                    });
                }
                e && r && i.points && i.setAllPointsToState(t || void 0);
            }
            setAllPointsToState(t) {
                this.points.forEach(function(e) {
                    e.setState && e.setState(t);
                });
            }
            setVisible(t, e) {
                let i = this, s = i.chart, o = s.options.chart.ignoreHiddenSeries, r = i.visible;
                i.visible = t = i.options.visible = i.userOptions.visible = void 0 === t ? !r : t;
                let a = t ? "show" : "hide";
                [
                    "group",
                    "markerGroup",
                    "tracker",
                    "tt"
                ].forEach((t)=>{
                    i[t]?.[a]();
                }), i.dataLabelsGroups?.forEach((t)=>{
                    t?.[a]();
                }), (s.hoverSeries === i || s.hoverPoint?.series === i) && i.onMouseOut(), i.legendItem && s.legend.colorizeItem(i, t), i.isDirty = !0, i.options.stacking && s.series.forEach((t)=>{
                    t.options.stacking && t.visible && (t.isDirty = !0);
                }), i.linkedSeries.forEach((e)=>{
                    e.setVisible(t, !1);
                }), o && (s.isDirtyBox = !0), ar(i, a), !1 !== e && s.redraw();
            }
            show() {
                this.setVisible(!0);
            }
            hide() {
                this.setVisible(!1);
            }
            select(t) {
                this.selected = t = this.options.selected = void 0 === t ? !this.selected : t, this.checkbox && (this.checkbox.checked = t), ar(this, t ? "select" : "unselect");
            }
            shouldShowTooltip(t, e, i = {}) {
                return i.series = this, i.visiblePlotOnly = !0, this.chart.isInsidePlot(t, e, i);
            }
            drawLegendSymbol(t, e) {
                rH[this.options.legendSymbol || "rectangle"]?.call(this, t, e);
            }
        }
        ax.defaultOptions = {
            lineWidth: 2,
            allowPointSelect: !1,
            crisp: !0,
            showCheckbox: !1,
            animation: {
                duration: 1e3
            },
            enableMouseTracking: !0,
            events: {},
            marker: {
                enabledThreshold: 2,
                lineColor: "#ffffff",
                lineWidth: 0,
                radius: 4,
                states: {
                    normal: {
                        animation: !0
                    },
                    hover: {
                        animation: {
                            duration: 150
                        },
                        enabled: !0,
                        radiusPlus: 2,
                        lineWidthPlus: 1
                    },
                    select: {
                        fillColor: "#cccccc",
                        lineColor: "#000000",
                        lineWidth: 2
                    }
                }
            },
            point: {
                events: {}
            },
            dataLabels: {
                animation: {},
                align: "center",
                borderWidth: 0,
                defer: !0,
                formatter: function() {
                    let { numberFormatter: t } = this.series.chart;
                    return "number" != typeof this.y ? "" : t(this.y, -1);
                },
                padding: 5,
                style: {
                    fontSize: "0.7em",
                    fontWeight: "bold",
                    color: "contrast",
                    textOutline: "1px contrast"
                },
                verticalAlign: "bottom",
                x: 0,
                y: 0
            },
            cropThreshold: 300,
            opacity: 1,
            pointRange: 0,
            softThreshold: !0,
            states: {
                normal: {
                    animation: !0
                },
                hover: {
                    animation: {
                        duration: 150
                    },
                    lineWidthPlus: 1,
                    marker: {},
                    halo: {
                        size: 10,
                        opacity: .25
                    }
                },
                select: {
                    animation: {
                        duration: 0
                    }
                },
                inactive: {
                    animation: {
                        duration: 150
                    },
                    opacity: .2
                }
            },
            stickyTracking: !0,
            turboThreshold: 1e3,
            findNearestPointBy: "x"
        }, ax.types = r_.seriesTypes, ax.registerType = r_.registerSeriesType, ax.keepProps = [
            "colorIndex",
            "eventOptions",
            "navigatorSeries",
            "symbolIndex",
            "baseSeries"
        ], ax.keepPropsForPoints = [
            "data",
            "isDirtyData",
            "isDirtyCanvas",
            "points",
            "dataTable",
            "processedData",
            "xIncrement",
            "cropped",
            "_hasPointMarkers",
            "hasDataLabels",
            "nodes",
            "layout",
            "level",
            "mapMap",
            "mapData",
            "minY",
            "maxY",
            "minX",
            "maxX",
            "transformGroups"
        ], as(ax.prototype, {
            axisTypes: [
                "xAxis",
                "yAxis"
            ],
            coll: "series",
            colorCounter: 0,
            directTouch: !1,
            invertible: !0,
            isCartesian: !0,
            kdAxisArray: [
                "clientX",
                "plotY"
            ],
            parallelArrays: [
                "x",
                "y"
            ],
            pointClass: rd,
            requireSorting: !0,
            sorted: !0
        }), r_.series = ax;
        let ay = ax, { animObject: ab, setAnimation: av } = eo, { registerEventOptions: ak } = sS, { composed: aM, marginNames: aw } = V, { distribute: aS } = eX, { format: aA } = eI, { addEvent: aT, createElement: aC, css: aP, defined: aO, discardElement: aE, find: aL, fireEvent: aB, isNumber: aD, merge: aI, pick: az, pushUnique: aR, relativeLength: aN, stableSort: aW, syncTimeout: aG } = tx;
        class aX {
            constructor(t, e){
                this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t, this.setOptions(e), e.enabled && (this.render(), ak(this, e), aT(this.chart, "endResize", function() {
                    this.legend.positionCheckboxes();
                })), aT(this.chart, "render", ()=>{
                    this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems());
                });
            }
            setOptions(t) {
                let e = az(t.padding, 8);
                this.options = t, this.chart.styledMode || (this.itemStyle = t.itemStyle, this.itemHiddenStyle = aI(this.itemStyle, t.itemHiddenStyle)), this.itemMarginTop = t.itemMarginTop, this.itemMarginBottom = t.itemMarginBottom, this.padding = e, this.initialItemY = e - 5, this.symbolWidth = az(t.symbolWidth, 16), this.pages = [], this.proximate = "proximate" === t.layout && !this.chart.inverted, this.baseline = void 0;
            }
            update(t, e) {
                let i = this.chart;
                this.setOptions(aI(!0, this.options, t)), "events" in this.options && ak(this, this.options), this.destroy(), i.isDirtyLegend = i.isDirtyBox = !0, az(e, !0) && i.redraw(), aB(this, "afterUpdate", {
                    redraw: e
                });
            }
            colorizeItem(t, e) {
                let i = t.color, { area: s, group: o, label: r, line: a, symbol: n } = t.legendItem || {};
                if ((t instanceof ay || t instanceof rd) && (t.color = t.options?.legendSymbolColor || i), o?.[e ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"), !this.chart.styledMode) {
                    let { itemHiddenStyle: i = {} } = this, o = i.color, { fillColor: h, fillOpacity: l, lineColor: d, marker: c } = t.options, p = (t)=>(!e && (t.fill && (t.fill = o), t.stroke && (t.stroke = o)), t);
                    r?.css(aI(e ? this.itemStyle : i)), a?.attr(p({
                        stroke: d || t.color
                    })), n && n.attr(p(c && n.isMarker ? t.pointAttribs() : {
                        fill: t.color
                    })), s?.attr(p({
                        fill: h || t.color,
                        "fill-opacity": h ? 1 : l ?? .75
                    }));
                }
                t.color = i, aB(this, "afterColorizeItem", {
                    item: t,
                    visible: e
                });
            }
            positionItems() {
                this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();
            }
            positionItem(t) {
                let { group: e, x: i = 0, y: s = 0 } = t.legendItem || {}, o = this.options, r = o.symbolPadding, a = !o.rtl, n = t.checkbox;
                if (e?.element) {
                    let o = {
                        translateX: a ? i : this.legendWidth - i - 2 * r - 4,
                        translateY: s
                    }, n = ()=>{
                        aB(this, "afterPositionItem", {
                            item: t
                        });
                    };
                    e[aO(e.translateY) ? "animate" : "attr"](o, void 0, n);
                }
                n && (n.x = i, n.y = s);
            }
            destroyItem(t) {
                let e = t.legendItem || {};
                for (let t of [
                    "group",
                    "label",
                    "line",
                    "symbol"
                ])e[t] && (e[t] = e[t].destroy());
                t.checkbox = aE(t.checkbox), t.legendItem = void 0;
            }
            destroy() {
                for (let t of this.getAllItems())this.destroyItem(t);
                for (let t of [
                    "clipRect",
                    "up",
                    "down",
                    "pager",
                    "nav",
                    "box",
                    "title",
                    "group"
                ])this[t] && (this[t] = this[t].destroy());
                this.display = null;
            }
            positionCheckboxes() {
                let t, e = this.group?.alignAttr, i = this.clipHeight || this.legendHeight, s = this.titleHeight;
                e && (t = e.translateY, this.allItems.forEach(function(o) {
                    let r, a = o.checkbox;
                    a && (r = t + s + a.y + (this.scrollOffset || 0) + 3, aP(a, {
                        left: e.translateX + o.checkboxOffset + a.x - 20 + "px",
                        top: r + "px",
                        display: this.proximate || r > t - 6 && r < t + i - 6 ? "" : "none"
                    }));
                }, this));
            }
            renderTitle() {
                let t = this.options, e = this.padding, i = t.title, s, o = 0;
                i.text && (this.title || (this.title = this.chart.renderer.label(i.text, e - 3, e - 4, void 0, void 0, void 0, t.useHTML, void 0, "legend-title").attr({
                    zIndex: 1
                }), this.chart.styledMode || this.title.css(i.style), this.title.add(this.group)), i.width || this.title.css({
                    width: this.maxLegendWidth + "px"
                }), o = (s = this.title.getBBox()).height, this.offsetWidth = s.width, this.contentGroup.attr({
                    translateY: o
                })), this.titleHeight = o;
            }
            setText(t) {
                let e = this.options;
                t.legendItem.label.attr({
                    text: e.labelFormat ? aA(e.labelFormat, t, this.chart) : e.labelFormatter.call(t)
                });
            }
            renderItem(t) {
                let e = t.legendItem = t.legendItem || {}, i = this.chart, s = i.renderer, o = this.options, r = "horizontal" === o.layout, a = this.symbolWidth, n = o.symbolPadding || 0, h = this.itemStyle, l = this.itemHiddenStyle, d = r ? az(o.itemDistance, 20) : 0, c = !o.rtl, p = !t.series, u = !p && t.series.drawLegendSymbol ? t.series : t, g = u.options, f = !!this.createCheckboxForItem && g && g.showCheckbox, m = o.useHTML, x = t.options.className, y = e.label, b = a + n + d + 20 * !!f;
                !y && (e.group = s.g("legend-item").addClass("highcharts-" + u.type + "-series highcharts-color-" + t.colorIndex + (x ? " " + x : "") + (p ? " highcharts-series-" + t.index : "")).attr({
                    zIndex: 1
                }).add(this.scrollGroup), e.label = y = s.text("", c ? a + n : -n, this.baseline || 0, m), i.styledMode || y.css(aI(t.visible ? h : l)), y.attr({
                    align: c ? "left" : "right",
                    zIndex: 2
                }).add(e.group), !this.baseline && (this.fontMetrics = s.fontMetrics(y), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, y.attr("y", this.baseline), this.symbolHeight = az(o.symbolHeight, this.fontMetrics.f), o.squareSymbol && (this.symbolWidth = az(o.symbolWidth, Math.max(this.symbolHeight, 16)), b = this.symbolWidth + n + d + 20 * !!f, c && y.attr("x", this.symbolWidth + n))), u.drawLegendSymbol(this, t), this.setItemEvents && this.setItemEvents(t, y, m)), f && !t.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t), this.colorizeItem(t, t.visible), (i.styledMode || !h.width) && y.css({
                    width: Math.min(o.itemWidth || this.widthOption || i.spacingBox.width, o.maxWidth ? aN(o.maxWidth, i.chartWidth) : 1 / 0) - b + "px"
                }), this.setText(t);
                let v = y.getBBox(), k = this.fontMetrics?.h || 0;
                t.itemWidth = t.checkboxOffset = o.itemWidth || e.labelWidth || v.width + b, this.maxItemWidth = Math.max(this.maxItemWidth, t.itemWidth), this.totalItemWidth += t.itemWidth, this.itemHeight = t.itemHeight = Math.round(e.labelHeight || (v.height > 1.5 * k ? v.height : k));
            }
            layoutItem(t) {
                let e = this.options, i = this.padding, s = "horizontal" === e.layout, o = t.itemHeight, r = this.itemMarginBottom, a = this.itemMarginTop, n = s ? az(e.itemDistance, 20) : 0, h = this.maxLegendWidth, l = e.alignColumns && this.totalItemWidth > h ? this.maxItemWidth : t.itemWidth, d = t.legendItem || {};
                s && this.itemX - i + l > h && (this.itemX = i, this.lastLineHeight && (this.itemY += a + this.lastLineHeight + r), this.lastLineHeight = 0), this.lastItemY = a + this.itemY + r, this.lastLineHeight = Math.max(o, this.lastLineHeight), d.x = this.itemX, d.y = this.itemY, s ? this.itemX += l : (this.itemY += a + o + r, this.lastLineHeight = o), this.offsetWidth = this.widthOption || Math.max((s ? this.itemX - i - (t.checkbox ? 0 : n) : l) + i, this.offsetWidth);
            }
            getAllItems() {
                let t = [];
                return this.chart.series.forEach(function(e) {
                    let i = e?.options;
                    e && az(i.showInLegend, !aO(i.linkedTo) && void 0, !0) && (t = t.concat(e.legendItem?.labels || ("point" === i.legendType ? e.data : e)));
                }), aB(this, "afterGetAllItems", {
                    allItems: t
                }), t;
            }
            getAlignment() {
                let t = this.options;
                return this.proximate ? t.align.charAt(0) + "tv" : t.floating ? "" : t.align.charAt(0) + t.verticalAlign.charAt(0) + t.layout.charAt(0);
            }
            adjustMargins(t, e) {
                let i = this.chart, s = this.options, o = this.getAlignment();
                o && [
                    /(lth|ct|rth)/,
                    /(rtv|rm|rbv)/,
                    /(rbh|cb|lbh)/,
                    /(lbv|lm|ltv)/
                ].forEach((r, a)=>{
                    r.test(o) && !aO(t[a]) && (i[aw[a]] = Math.max(i[aw[a]], i.legend[(a + 1) % 2 ? "legendHeight" : "legendWidth"] + [
                        1,
                        -1,
                        -1,
                        1
                    ][a] * s[a % 2 ? "x" : "y"] + (s.margin ?? 12) + e[a] + (i.titleOffset[a] || 0)));
                });
            }
            proximatePositions() {
                let t, e = this.chart, i = [], s = "left" === this.options.align;
                for (let o of (this.allItems.forEach(function(t) {
                    let o, r, a = s, n, h;
                    t.yAxis && (t.xAxis.options.reversed && (a = !a), t.points && (o = aL(a ? t.points : t.points.slice(0).reverse(), function(t) {
                        return aD(t.plotY);
                    })), r = this.itemMarginTop + t.legendItem.label.getBBox().height + this.itemMarginBottom, h = t.yAxis.top - e.plotTop, n = t.visible ? (o ? o.plotY : t.yAxis.height) + (h - .3 * r) : h + t.yAxis.height, i.push({
                        target: n,
                        size: r,
                        item: t
                    }));
                }, this), aS(i, e.plotHeight)))t = o.item.legendItem || {}, aD(o.pos) && (t.y = e.plotTop - e.spacing[0] + o.pos);
            }
            render() {
                let t = this.chart, e = t.spacingBox.width, i = t.renderer, s = this.options, o = this.padding, r = this.getAllItems(), a, n, h, l = this.group, d, c = this.box;
                this.itemX = o, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = aN(s.width, e - o), d = e - 2 * o - s.x, [
                    "rm",
                    "lm"
                ].indexOf(this.getAlignment().substring(0, 2)) > -1 && (d /= 2), this.maxLegendWidth = this.widthOption || d, l || (this.group = l = i.g("legend").addClass(s.className || "").attr({
                    zIndex: 7
                }).add(), this.contentGroup = i.g().attr({
                    zIndex: 1
                }).add(l), this.scrollGroup = i.g().add(this.contentGroup)), this.renderTitle(), aW(r, (t, e)=>(t.options?.legendIndex || 0) - (e.options?.legendIndex || 0)), s.reversed && r.reverse(), this.allItems = r, this.display = a = !!r.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, r.forEach(this.renderItem, this), r.forEach(this.layoutItem, this), n = (s.maxWidth ? Math.min(this.widthOption || this.offsetWidth, d, aN(s.maxWidth, t.chartWidth) || 1 / 0) : this.widthOption || this.offsetWidth) + o, h = this.lastItemY + this.lastLineHeight + this.titleHeight, h = this.handleOverflow(h) + o, c || (this.box = c = i.rect().addClass("highcharts-legend-box").attr({
                    r: s.borderRadius
                }).add(l)), t.styledMode || c.attr({
                    stroke: s.borderColor,
                    "stroke-width": s.borderWidth || 0,
                    fill: s.backgroundColor || "none"
                }).shadow(s.shadow), n > 0 && h > 0 && c[c.placed ? "animate" : "attr"](c.crisp.call({}, {
                    x: 0,
                    y: 0,
                    width: n,
                    height: h
                }, c.strokeWidth())), l[a ? "show" : "hide"](), t.styledMode && "none" === l.getStyle("display") && (n = h = 0), this.legendWidth = n, this.legendHeight = h, a && this.align(), this.proximate || this.positionItems(), aB(this, "afterRender");
            }
            align(t = this.chart.spacingBox) {
                let e = this.chart, i = this.options, s = t.y;
                /(lth|ct|rth)/.test(this.getAlignment()) && e.titleOffset[0] > 0 ? s += e.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e.titleOffset[2] > 0 && (s -= e.titleOffset[2]), s !== t.y && (t = aI(t, {
                    y: s
                })), e.hasRendered || (this.group.placed = !1), this.group.align(aI(i, {
                    width: this.legendWidth,
                    height: this.legendHeight,
                    verticalAlign: this.proximate ? "top" : i.verticalAlign
                }), !0, t);
            }
            handleOverflow(t) {
                let e = this, i = this.chart, s = i.renderer, o = this.options, r = o.y, a = "top" === o.verticalAlign, n = this.padding, h = o.maxHeight, l = o.navigation, d = az(l.animation, !0), c = l.arrowSize || 12, p = this.pages, u = this.allItems, g = function(t) {
                    "number" == typeof t ? M.attr({
                        height: t
                    }) : M && (e.clipRect = M.destroy(), e.contentGroup.clip()), e.contentGroup.div && (e.contentGroup.div.style.clip = t ? "rect(" + n + "px,9999px," + (n + t) + "px,0)" : "auto");
                }, f = function(t) {
                    return e[t] = s.circle(0, 0, 1.3 * c).translate(c / 2, c / 2).add(k), i.styledMode || e[t].attr("fill", "rgba(0,0,0,0.0001)"), e[t];
                }, m, x, y, b, v = i.spacingBox.height + (a ? -r : r) - n, k = this.nav, M = this.clipRect;
                return "horizontal" !== o.layout || "middle" === o.verticalAlign || o.floating || (v /= 2), h && (v = Math.min(v, h)), p.length = 0, t && v > 0 && t > v && !1 !== l.enabled ? (this.clipHeight = m = Math.max(v - 20 - this.titleHeight - n, 0), this.currentPage = az(this.currentPage, 1), this.fullHeight = t, u.forEach((t, e)=>{
                    let i = (y = t.legendItem || {}).y || 0, s = Math.round(y.label.getBBox().height), o = p.length;
                    (!o || i - p[o - 1] > m && (x || i) !== p[o - 1]) && (p.push(x || i), o++), y.pageIx = o - 1, x && b && (b.pageIx = o - 1), e === u.length - 1 && i + s - p[o - 1] > m && i > p[o - 1] && (p.push(i), y.pageIx = o), i !== x && (x = i), b = y;
                }), M || (M = e.clipRect = s.clipRect(0, n - 2, 9999, 0), e.contentGroup.clip(M)), g(m), k || (this.nav = k = s.g().attr({
                    zIndex: 1
                }).add(this.group), this.up = s.symbol("triangle", 0, 0, c, c).add(k), f("upTracker").on("click", function() {
                    e.scroll(-1, d);
                }), this.pager = s.text("", 15, 10).addClass("highcharts-legend-navigation"), !i.styledMode && l.style && this.pager.css(l.style), this.pager.add(k), this.down = s.symbol("triangle-down", 0, 0, c, c).add(k), f("downTracker").on("click", function() {
                    e.scroll(1, d);
                })), e.scroll(0), t = v) : k && (g(), this.nav = k.destroy(), this.scrollGroup.attr({
                    translateY: 1
                }), this.clipHeight = 0), t;
            }
            scroll(t, e) {
                let i = this.chart, s = this.pages, o = s.length, r = this.clipHeight, a = this.options.navigation, n = this.pager, h = this.padding, l = this.currentPage + t;
                l > o && (l = o), l > 0 && (void 0 !== e && av(e, i), this.nav.attr({
                    translateX: h,
                    translateY: r + this.padding + 7 + this.titleHeight,
                    visibility: "inherit"
                }), [
                    this.up,
                    this.upTracker
                ].forEach(function(t) {
                    t.attr({
                        class: 1 === l ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                    });
                }), n.attr({
                    text: l + "/" + o
                }), [
                    this.down,
                    this.downTracker
                ].forEach(function(t) {
                    t.attr({
                        x: 18 + this.pager.getBBox().width,
                        class: l === o ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                    });
                }, this), i.styledMode || (this.up.attr({
                    fill: 1 === l ? a.inactiveColor : a.activeColor
                }), this.upTracker.css({
                    cursor: 1 === l ? "default" : "pointer"
                }), this.down.attr({
                    fill: l === o ? a.inactiveColor : a.activeColor
                }), this.downTracker.css({
                    cursor: l === o ? "default" : "pointer"
                })), this.scrollOffset = -s[l - 1] + this.initialItemY, this.scrollGroup.animate({
                    translateY: this.scrollOffset
                }), this.currentPage = l, this.positionCheckboxes(), aG(()=>{
                    aB(this, "afterScroll", {
                        currentPage: l
                    });
                }, ab(az(e, i.renderer.globalAnimation, !0)).duration));
            }
            setItemEvents(t, e, i) {
                let s = this, o = t.legendItem || {}, r = s.chart.renderer.boxWrapper, a = t instanceof rd, n = t instanceof ay, h = "highcharts-legend-" + (a ? "point" : "series") + "-active", l = s.chart.styledMode, d = i ? [
                    e,
                    o.symbol
                ] : [
                    o.group
                ], c = (e)=>{
                    s.allItems.forEach((i)=>{
                        t !== i && [
                            i
                        ].concat(i.linkedSeries || []).forEach((t)=>{
                            t.setState(e, !a);
                        });
                    });
                };
                for (let i of d)i && i.on("mouseover", function() {
                    t.visible && c("inactive"), t.setState("hover"), t.visible && r.addClass(h), l || e.css(s.options.itemHoverStyle);
                }).on("mouseout", function() {
                    s.chart.styledMode || e.css(aI(t.visible ? s.itemStyle : s.itemHiddenStyle)), c(""), r.removeClass(h), t.setState();
                }).on("click", function(e) {
                    let i = function() {
                        t.setVisible && t.setVisible(), c(t.visible ? "inactive" : "");
                    };
                    r.removeClass(h), aB(s, "itemClick", {
                        browserEvent: e,
                        legendItem: t
                    }, i), a ? t.firePointEvent("legendItemClick", {
                        browserEvent: e
                    }) : n && aB(t, "legendItemClick", {
                        browserEvent: e
                    });
                });
            }
            createCheckboxForItem(t) {
                t.checkbox = aC("input", {
                    type: "checkbox",
                    className: "highcharts-legend-checkbox",
                    checked: t.selected,
                    defaultChecked: t.selected
                }, this.options.itemCheckboxStyle, this.chart.container), aT(t.checkbox, "click", function(e) {
                    let i = e.target;
                    aB(t.series || t, "checkboxClick", {
                        checked: i.checked,
                        item: t
                    }, function() {
                        t.select();
                    });
                });
            }
        }
        (m = aX || (aX = {})).compose = function(t) {
            aR(aM, "Core.Legend") && aT(t, "beforeMargins", function() {
                this.legend = new m(this, this.options.legend);
            });
        };
        let aH = aX, { animate: aF, animObject: aY, setAnimation: aj } = eo, { defaultOptions: aU } = tY, { numberFormat: aV } = eI, { registerEventOptions: a$ } = sS, { charts: a_, doc: aZ, marginNames: aq, svg: aK, win: aJ } = V, { seriesTypes: aQ } = r_, { addEvent: a0, attr: a1, createElement: a2, css: a3, defined: a5, diffObjects: a6, discardElement: a9, erase: a4, error: a8, extend: a7, find: nt, fireEvent: ne, getAlignFactor: ni, getStyle: ns, isArray: no, isNumber: nr, isObject: na, isString: nn, merge: nh, objectEach: nl, pick: nd, pInt: nc, relativeLength: np, removeEvent: nu, splat: ng, syncTimeout: nf, uniqueKey: nm } = tx;
        class nx {
            static chart(t, e, i) {
                return new nx(t, e, i);
            }
            constructor(t, e, i){
                this.sharedClips = {};
                const s = [
                    ...arguments
                ];
                (nn(t) || t.nodeName) && (this.renderTo = s.shift()), this.init(s[0], s[1]);
            }
            setZoomOptions() {
                let t = this.options.chart, e = t.zooming;
                this.zooming = {
                    ...e,
                    type: nd(t.zoomType, e.type),
                    key: nd(t.zoomKey, e.key),
                    pinchType: nd(t.pinchType, e.pinchType),
                    singleTouch: nd(t.zoomBySingleTouch, e.singleTouch, !1),
                    resetButton: nh(e.resetButton, t.resetZoomButton)
                };
            }
            init(t, e) {
                ne(this, "init", {
                    args: arguments
                }, function() {
                    let i = nh(aU, t), s = i.chart, o = this.renderTo || s.renderTo;
                    this.userOptions = a7({}, t), (this.renderTo = nn(o) ? aZ.getElementById(o) : o) || a8(13, !0, this), this.margin = [], this.spacing = [], this.labelCollectors = [], this.callback = e, this.isResizing = 0, this.options = i, this.axes = [], this.series = [], this.locale = i.lang.locale ?? this.renderTo.closest("[lang]")?.lang, this.time = new tN(a7(i.time || {}, {
                        locale: this.locale
                    }), i.lang), i.time = this.time.options, this.numberFormatter = (s.numberFormatter || aV).bind(this), this.styledMode = s.styledMode, this.hasCartesianSeries = s.showAxes, this.index = a_.length, a_.push(this), V.chartCount++, a$(this, s), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), ne(this, "afterInit"), this.firstRender();
                });
            }
            initSeries(t) {
                let e = this.options.chart, i = t.type || e.type, s = aQ[i];
                s || a8(17, !0, this, {
                    missingModuleFor: i
                });
                let o = new s;
                return "function" == typeof o.init && o.init(this, t), o;
            }
            setSortedData() {
                this.getSeriesOrderByLinks().forEach(function(t) {
                    t.points || t.data || !t.enabledDataSorting || t.setData(t.options.data, !1);
                });
            }
            getSeriesOrderByLinks() {
                return this.series.concat().sort(function(t, e) {
                    return t.linkedSeries.length || e.linkedSeries.length ? e.linkedSeries.length - t.linkedSeries.length : 0;
                });
            }
            orderItems(t, e = 0) {
                let i = this[t], s = this.options[t] = ng(this.options[t]).slice(), o = this.userOptions[t] = this.userOptions[t] ? ng(this.userOptions[t]).slice() : [];
                if (this.hasRendered && (s.splice(e), o.splice(e)), i) for(let t = e, r = i.length; t < r; ++t){
                    let e = i[t];
                    e && (e.index = t, e instanceof ay && (e.name = e.getName()), e.options.isInternal || (s[t] = e.options, o[t] = e.userOptions));
                }
            }
            getClipBox(t, e) {
                let i = this.inverted, { xAxis: s, yAxis: o } = t || {}, { x: r, y: a, width: n, height: h } = nh(this.clipBox);
                return t && (s && s.len !== this.plotSizeX && (n = s.len), o && o.len !== this.plotSizeY && (h = o.len), i && !t.invertible && ([n, h] = [
                    h,
                    n
                ])), e && (r += (i ? o : s)?.pos ?? this.plotLeft, a += (i ? s : o)?.pos ?? this.plotTop), {
                    x: r,
                    y: a,
                    width: n,
                    height: h
                };
            }
            isInsidePlot(t, e, i = {}) {
                let { inverted: s, plotBox: o, plotLeft: r, plotTop: a, scrollablePlotBox: n } = this, { scrollLeft: h = 0, scrollTop: l = 0 } = i.visiblePlotOnly && this.scrollablePlotArea?.scrollingContainer || {}, d = i.series, c = i.visiblePlotOnly && n || o, p = i.inverted ? e : t, u = i.inverted ? t : e, g = {
                    x: p,
                    y: u,
                    isInsidePlot: !0,
                    options: i
                };
                if (!i.ignoreX) {
                    let t = d && (s && !this.polar ? d.yAxis : d.xAxis) || {
                        pos: r,
                        len: 1 / 0
                    }, e = i.paneCoordinates ? t.pos + p : r + p;
                    e >= Math.max(h + r, t.pos) && e <= Math.min(h + r + c.width, t.pos + t.len) || (g.isInsidePlot = !1);
                }
                if (!i.ignoreY && g.isInsidePlot) {
                    let t = !s && i.axis && !i.axis.isXAxis && i.axis || d && (s ? d.xAxis : d.yAxis) || {
                        pos: a,
                        len: 1 / 0
                    }, e = i.paneCoordinates ? t.pos + u : a + u;
                    e >= Math.max(l + a, t.pos) && e <= Math.min(l + a + c.height, t.pos + t.len) || (g.isInsidePlot = !1);
                }
                return ne(this, "afterIsInsidePlot", g), g.isInsidePlot;
            }
            redraw(t) {
                ne(this, "beforeRedraw");
                let e = this.hasCartesianSeries ? this.axes : this.colorAxis || [], i = this.series, s = this.pointer, o = this.legend, r = this.userOptions.legend, a = this.renderer, n = a.isHidden(), h = [], l, d, c, p = this.isDirtyBox, u = this.isDirtyLegend, g;
                for(a.rootFontSize = a.boxWrapper.getStyle("font-size"), this.setResponsive && this.setResponsive(!1), aj(!!this.hasRendered && t, this), n && this.temporaryDisplay(), this.layOutTitles(!1), c = i.length; c--;)if (((g = i[c]).options.stacking || g.options.centerInCategory) && (d = !0, g.isDirty)) {
                    l = !0;
                    break;
                }
                if (l) for(c = i.length; c--;)(g = i[c]).options.stacking && (g.isDirty = !0);
                i.forEach(function(t) {
                    t.isDirty && ("point" === t.options.legendType ? ("function" == typeof t.updateTotals && t.updateTotals(), u = !0) : r && (r.labelFormatter || r.labelFormat) && (u = !0)), t.isDirtyData && ne(t, "updatedData");
                }), u && o && o.options.enabled && (o.render(), this.isDirtyLegend = !1), d && this.getStacks(), e.forEach(function(t) {
                    t.updateNames(), t.setScale();
                }), this.getMargins(), e.forEach(function(t) {
                    t.isDirty && (p = !0);
                }), e.forEach(function(t) {
                    let e = t.min + "," + t.max;
                    t.extKey !== e && (t.extKey = e, h.push(function() {
                        ne(t, "afterSetExtremes", a7(t.eventArgs, t.getExtremes())), delete t.eventArgs;
                    })), (p || d) && t.redraw();
                }), p && this.drawChartBox(), ne(this, "predraw"), i.forEach(function(t) {
                    (p || t.isDirty) && t.visible && t.redraw(), t.isDirtyData = !1;
                }), s && s.reset(!0), a.draw(), ne(this, "redraw"), ne(this, "render"), n && this.temporaryDisplay(!0), h.forEach(function(t) {
                    t.call();
                });
            }
            get(t) {
                let e = this.series;
                function i(e) {
                    return e.id === t || e.options && e.options.id === t;
                }
                let s = nt(this.axes, i) || nt(this.series, i);
                for(let t = 0; !s && t < e.length; t++)s = nt(e[t].points || [], i);
                return s;
            }
            createAxes() {
                let t = this.userOptions;
                for (let e of (ne(this, "createAxes"), [
                    "xAxis",
                    "yAxis"
                ]))for (let i of t[e] = ng(t[e] || {}))new oo(this, i, e);
                ne(this, "afterCreateAxes");
            }
            getSelectedPoints() {
                return this.series.reduce((t, e)=>(e.getPointsCollection().forEach((e)=>{
                        nd(e.selectedStaging, e.selected) && t.push(e);
                    }), t), []);
            }
            getSelectedSeries() {
                return this.series.filter((t)=>t.selected);
            }
            setTitle(t, e, i) {
                this.applyDescription("title", t), this.applyDescription("subtitle", e), this.applyDescription("caption", void 0), this.layOutTitles(i);
            }
            applyDescription(t, e) {
                let i = this, s = this.options[t] = nh(this.options[t], e), o = this[t];
                o && e && (this[t] = o = o.destroy()), s && !o && ((o = this.renderer.text(s.text, 0, 0, s.useHTML).attr({
                    align: s.align,
                    class: "highcharts-" + t,
                    zIndex: s.zIndex || 4
                }).css({
                    textOverflow: "ellipsis",
                    whiteSpace: "nowrap"
                }).add()).update = function(e, s) {
                    i.applyDescription(t, e), i.layOutTitles(s);
                }, this.styledMode || o.css(a7("title" === t ? {
                    fontSize: this.options.isStock ? "1em" : "1.2em"
                } : {}, s.style)), o.textPxLength = o.getBBox().width, o.css({
                    whiteSpace: s.style?.whiteSpace
                }), this[t] = o);
            }
            layOutTitles(t = !0) {
                let e = [
                    0,
                    0,
                    0
                ], { options: i, renderer: s, spacingBox: o } = this;
                [
                    "title",
                    "subtitle",
                    "caption"
                ].forEach((t)=>{
                    let i = this[t], r = this.options[t], a = nh(o), n = i?.textPxLength || 0;
                    if (i && r) {
                        ne(this, "layOutTitle", {
                            alignTo: a,
                            key: t,
                            textPxLength: n
                        });
                        let o = s.fontMetrics(i), h = o.b, l = o.h, d = r.verticalAlign || "top", c = "top" === d, p = c && r.minScale || 1, u = "title" === t ? c ? -3 : 0 : c ? e[0] + 2 : 0, g = Math.min(a.width / n, 1), f = Math.max(p, g), m = nh({
                            y: "bottom" === d ? h : u + h
                        }, {
                            align: "title" === t ? g < p ? "left" : "center" : this.title?.alignValue
                        }, r), x = (r.width || (g > p ? this.chartWidth : a.width) / f) + "px";
                        i.alignValue !== m.align && (i.placed = !1);
                        let y = Math.round(i.css({
                            width: x
                        }).getBBox(r.useHTML).height);
                        if (m.height = y, i.align(m, !1, a).attr({
                            align: m.align,
                            scaleX: f,
                            scaleY: f,
                            "transform-origin": `${a.x + n * f * ni(m.align)} ${l}`
                        }), !r.floating) {
                            let t = y * (y < 1.2 * l ? 1 : f);
                            "top" === d ? e[0] = Math.ceil(e[0] + t) : "bottom" === d && (e[2] = Math.ceil(e[2] + t));
                        }
                    }
                }, this), e[0] && "top" === (i.title?.verticalAlign || "top") && (e[0] += i.title?.margin || 0), e[2] && i.caption?.verticalAlign === "bottom" && (e[2] += i.caption?.margin || 0);
                let r = !this.titleOffset || this.titleOffset.join(",") !== e.join(",");
                this.titleOffset = e, ne(this, "afterLayOutTitles"), !this.isDirtyBox && r && (this.isDirtyBox = this.isDirtyLegend = r, this.hasRendered && t && this.isDirtyBox && this.redraw());
            }
            getContainerBox() {
                let t = [].map.call(this.renderTo.children, (t)=>{
                    if (t !== this.container) {
                        let e = t.style.display;
                        return t.style.display = "none", [
                            t,
                            e
                        ];
                    }
                }), e = {
                    width: ns(this.renderTo, "width", !0) || 0,
                    height: ns(this.renderTo, "height", !0) || 0
                };
                return t.filter(Boolean).forEach(([t, e])=>{
                    t.style.display = e;
                }), e;
            }
            getChartSize() {
                let t = this.options.chart, e = t.width, i = t.height, s = this.getContainerBox(), o = s.height <= 1 || !this.renderTo.parentElement?.style.height && "100%" === this.renderTo.style.height;
                this.chartWidth = Math.max(0, e || s.width || 600), this.chartHeight = Math.max(0, np(i, this.chartWidth) || (o ? 400 : s.height)), this.containerBox = s;
            }
            temporaryDisplay(t) {
                let e = this.renderTo, i;
                if (t) for(; e?.style;)e.hcOrigStyle && (a3(e, e.hcOrigStyle), delete e.hcOrigStyle), e.hcOrigDetached && (aZ.body.removeChild(e), e.hcOrigDetached = !1), e = e.parentNode;
                else for(; e?.style && (aZ.body.contains(e) || e.parentNode || (e.hcOrigDetached = !0, aZ.body.appendChild(e)), ("none" === ns(e, "display", !1) || e.hcOricDetached) && (e.hcOrigStyle = {
                    display: e.style.display,
                    height: e.style.height,
                    overflow: e.style.overflow
                }, i = {
                    display: "block",
                    overflow: "hidden"
                }, e !== this.renderTo && (i.height = 0), a3(e, i), e.offsetWidth || e.style.setProperty("display", "block", "important")), (e = e.parentNode) !== aZ.body););
            }
            setClassName(t) {
                this.container.className = "highcharts-container " + (t || "");
            }
            getContainer() {
                let t, e = this.options, i = e.chart, s = "data-highcharts-chart", o = nm(), r = this.renderTo, a = nc(a1(r, s));
                nr(a) && a_[a] && a_[a].hasRendered && a_[a].destroy(), a1(r, s, this.index), r.innerHTML = ey.emptyHTML, i.skipClone || r.offsetWidth || this.temporaryDisplay(), this.getChartSize();
                let n = this.chartHeight, h = this.chartWidth;
                a3(r, {
                    overflow: "hidden"
                }), this.styledMode || (t = a7({
                    position: "relative",
                    overflow: "hidden",
                    width: h + "px",
                    height: n + "px",
                    textAlign: "left",
                    lineHeight: "normal",
                    zIndex: 0,
                    "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                    userSelect: "none",
                    "touch-action": "manipulation",
                    outline: "none",
                    padding: "0px"
                }, i.style || {}));
                let l = a2("div", {
                    id: o
                }, t, r);
                this.container = l, this.getChartSize(), h !== this.chartWidth && (h = this.chartWidth, this.styledMode || a3(l, {
                    width: nd(i.style?.width, h + "px")
                })), this.containerBox = this.getContainerBox(), this._cursor = l.style.cursor;
                let d = i.renderer || !aK ? ez.getRendererType(i.renderer) : ss;
                if (this.renderer = new d(l, h, n, void 0, i.forExport, e.exporting?.allowHTML, this.styledMode), aj(void 0, this), this.setClassName(i.className), this.styledMode) for(let t in e.defs)this.renderer.definition(e.defs[t]);
                else this.renderer.setStyle(i.style);
                this.renderer.chartIndex = this.index, ne(this, "afterGetContainer");
            }
            getMargins(t) {
                let { spacing: e, margin: i, titleOffset: s } = this;
                this.resetMargins(), s[0] && !a5(i[0]) && (this.plotTop = Math.max(this.plotTop, s[0] + e[0])), s[2] && !a5(i[2]) && (this.marginBottom = Math.max(this.marginBottom, s[2] + e[2])), this.legend?.display && this.legend.adjustMargins(i, e), ne(this, "getMargins"), t || this.getAxisMargins();
            }
            getAxisMargins() {
                let t = this, e = t.axisOffset = [
                    0,
                    0,
                    0,
                    0
                ], i = t.colorAxis, s = t.margin, o = (t)=>{
                    t.forEach((t)=>{
                        t.visible && t.getOffset();
                    });
                };
                t.hasCartesianSeries ? o(t.axes) : i?.length && o(i), aq.forEach((i, o)=>{
                    a5(s[o]) || (t[i] += e[o]);
                }), t.setChartSize();
            }
            getOptions() {
                return a6(this.userOptions, aU);
            }
            reflow(t) {
                let e = this, i = e.containerBox, s = e.getContainerBox();
                delete e.pointer?.chartPosition, !e.exporting?.isPrinting && !e.isResizing && i && s.width && ((s.width !== i.width || s.height !== i.height) && (tx.clearTimeout(e.reflowTimeout), e.reflowTimeout = nf(function() {
                    e.container && e.setSize(void 0, void 0, !1);
                }, 100 * !!t)), e.containerBox = s);
            }
            setReflow() {
                let t = this, e = (e)=>{
                    t.options?.chart.reflow && t.hasLoaded && t.reflow(e);
                };
                if ("function" == typeof ResizeObserver) new ResizeObserver(e).observe(t.renderTo);
                else {
                    let t = a0(aJ, "resize", e);
                    a0(this, "destroy", t);
                }
            }
            setSize(t, e, i) {
                let s = this, o = s.renderer;
                s.isResizing += 1, aj(i, s);
                let r = o.globalAnimation;
                s.oldChartHeight = s.chartHeight, s.oldChartWidth = s.chartWidth, void 0 !== t && (s.options.chart.width = t), void 0 !== e && (s.options.chart.height = e), s.getChartSize();
                let { chartWidth: a, chartHeight: n, scrollablePixelsX: h = 0, scrollablePixelsY: l = 0 } = s;
                (s.isDirtyBox || a !== s.oldChartWidth || n !== s.oldChartHeight) && (s.styledMode || (r ? aF : a3)(s.container, {
                    width: `${a + h}px`,
                    height: `${n + l}px`
                }, r), s.setChartSize(!0), o.setSize(a, n, r), s.axes.forEach(function(t) {
                    t.isDirty = !0, t.setScale();
                }), s.isDirtyLegend = !0, s.isDirtyBox = !0, s.layOutTitles(), s.getMargins(), s.redraw(r), s.oldChartHeight = void 0, ne(s, "resize"), setTimeout(()=>{
                    s && ne(s, "endResize");
                }, aY(r).duration)), s.isResizing -= 1;
            }
            setChartSize(t) {
                let e, i, s, o, { chartHeight: r, chartWidth: a, inverted: n, spacing: h, renderer: l } = this, d = this.clipOffset, c = Math[n ? "floor" : "round"];
                this.plotLeft = e = Math.round(this.plotLeft), this.plotTop = i = Math.round(this.plotTop), this.plotWidth = s = Math.max(0, Math.round(a - e - (this.marginRight ?? 0))), this.plotHeight = o = Math.max(0, Math.round(r - i - (this.marginBottom ?? 0))), this.plotSizeX = n ? o : s, this.plotSizeY = n ? s : o, this.spacingBox = l.spacingBox = {
                    x: h[3],
                    y: h[0],
                    width: a - h[3] - h[1],
                    height: r - h[0] - h[2]
                }, this.plotBox = l.plotBox = {
                    x: e,
                    y: i,
                    width: s,
                    height: o
                }, d && (this.clipBox = {
                    x: c(d[3]),
                    y: c(d[0]),
                    width: c(this.plotSizeX - d[1] - d[3]),
                    height: c(this.plotSizeY - d[0] - d[2])
                }), t || (this.axes.forEach(function(t) {
                    t.setAxisSize(), t.setAxisTranslation();
                }), l.alignElements()), ne(this, "afterSetChartSize", {
                    skipAxes: t
                });
            }
            resetMargins() {
                ne(this, "resetMargins");
                let t = this, e = t.options.chart, i = e.plotBorderWidth || 0, s = Math.round(i) / 2;
                [
                    "margin",
                    "spacing"
                ].forEach((i)=>{
                    let s = e[i], o = na(s) ? s : [
                        s,
                        s,
                        s,
                        s
                    ];
                    [
                        "Top",
                        "Right",
                        "Bottom",
                        "Left"
                    ].forEach((s, r)=>{
                        t[i][r] = e[`${i}${s}`] ?? o[r];
                    });
                }), aq.forEach((e, i)=>{
                    t[e] = t.margin[i] ?? t.spacing[i];
                }), t.axisOffset = [
                    0,
                    0,
                    0,
                    0
                ], t.clipOffset = [
                    s,
                    s,
                    s,
                    s
                ], t.plotBorderWidth = i;
            }
            drawChartBox() {
                let t = this.options.chart, e = this.renderer, i = this.chartWidth, s = this.chartHeight, o = this.styledMode, r = this.plotBGImage, a = t.backgroundColor, n = t.plotBackgroundColor, h = t.plotBackgroundImage, l = this.plotLeft, d = this.plotTop, c = this.plotWidth, p = this.plotHeight, u = this.plotBox, g = this.clipRect, f = this.clipBox, m = this.chartBackground, x = this.plotBackground, y = this.plotBorder, b, v, k, M = "animate";
                m || (this.chartBackground = m = e.rect().addClass("highcharts-background").add(), M = "attr"), o ? b = v = m.strokeWidth() : (v = (b = t.borderWidth || 0) + 8 * !!t.shadow, k = {
                    fill: a || "none"
                }, (b || m["stroke-width"]) && (k.stroke = t.borderColor, k["stroke-width"] = b), m.attr(k).shadow(t.shadow)), m[M]({
                    x: v / 2,
                    y: v / 2,
                    width: i - v - b % 2,
                    height: s - v - b % 2,
                    r: t.borderRadius
                }), M = "animate", x || (M = "attr", this.plotBackground = x = e.rect().addClass("highcharts-plot-background").add()), x[M](u), !o && (x.attr({
                    fill: n || "none"
                }).shadow(t.plotShadow), h && (r ? (h !== r.attr("href") && r.attr("href", h), r.animate(u)) : this.plotBGImage = e.image(h, l, d, c, p).add())), g ? g.animate({
                    width: f.width,
                    height: f.height
                }) : this.clipRect = e.clipRect(f), M = "animate", y || (M = "attr", this.plotBorder = y = e.rect().addClass("highcharts-plot-border").attr({
                    zIndex: 1
                }).add()), o || y.attr({
                    stroke: t.plotBorderColor,
                    "stroke-width": t.plotBorderWidth || 0,
                    fill: "none"
                }), y[M](y.crisp(u, -y.strokeWidth())), this.isDirtyBox = !1, ne(this, "afterDrawChartBox");
            }
            propFromSeries() {
                let t, e, i, s = this, o = s.options.chart, r = s.options.series;
                [
                    "inverted",
                    "angular",
                    "polar"
                ].forEach(function(a) {
                    for(e = aQ[o.type], i = o[a] || e && e.prototype[a], t = r?.length; !i && t--;)(e = aQ[r[t].type]) && e.prototype[a] && (i = !0);
                    s[a] = i;
                });
            }
            linkSeries(t) {
                let e = this, i = e.series;
                i.forEach(function(t) {
                    t.linkedSeries.length = 0;
                }), i.forEach(function(t) {
                    let { linkedTo: s } = t.options, o = nn(s) && (":previous" === s ? i[t.index - 1] : e.get(s));
                    o && o.linkedParent !== t && (o.linkedSeries.push(t), t.linkedParent = o, o.enabledDataSorting && t.setDataSortingOptions(), t.visible = t.options.visible ?? o.options.visible ?? t.visible);
                }), ne(this, "afterLinkSeries", {
                    isUpdating: t
                });
            }
            renderSeries() {
                this.series.forEach(function(t) {
                    t.translate(), t.render();
                });
            }
            render() {
                let t = this.axes, e = this.colorAxis, i = this.renderer, s = this.options.chart.axisLayoutRuns || 2, o = (t)=>{
                    t.forEach((t)=>{
                        t.visible && t.render();
                    });
                }, r = 0, a = !0, n, h = 0;
                for (let e of (this.setTitle(), ne(this, "beforeMargins"), this.getStacks?.(), this.getMargins(!0), this.setChartSize(), t)){
                    let { options: t } = e, { labels: i } = t;
                    if (this.hasCartesianSeries && e.horiz && e.visible && i.enabled && e.series.length && "colorAxis" !== e.coll && !this.polar) {
                        r = t.tickLength, e.createGroups();
                        let s = new sN(e, 0, "", !0), o = s.createLabel("x", i);
                        if (s.destroy(), o && nd(i.reserveSpace, !nr(t.crossing)) && (r = o.getBBox().height + i.distance + Math.max(t.offset || 0, 0)), r) {
                            o?.destroy();
                            break;
                        }
                    }
                }
                for(this.plotHeight = Math.max(this.plotHeight - r, 0); (a || n || s > 1) && h < s;){
                    let e = this.plotWidth, i = this.plotHeight;
                    for (let e of t)0 === h ? e.setScale() : (e.horiz && a || !e.horiz && n) && e.setTickInterval(!0);
                    0 === h ? this.getAxisMargins() : this.getMargins(), a = e / this.plotWidth > (h ? 1 : 1.1), n = i / this.plotHeight > (h ? 1 : 1.05), h++;
                }
                this.drawChartBox(), this.hasCartesianSeries ? o(t) : e?.length && o(e), this.seriesGroup || (this.seriesGroup = i.g("series-group").attr({
                    zIndex: 3
                }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = !0;
            }
            addCredits(t) {
                let e = this, i = nh(!0, this.options.credits, t);
                i.enabled && !this.credits && (this.credits = this.renderer.text(i.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
                    i.href && (aJ.location.href = i.href);
                }).attr({
                    align: i.position.align,
                    zIndex: 8
                }), e.styledMode || this.credits.css(i.style), this.credits.add().align(i.position), this.credits.update = function(t) {
                    e.credits = e.credits.destroy(), e.addCredits(t);
                });
            }
            destroy() {
                let t, e = this, i = e.axes, s = e.series, o = e.container, r = o?.parentNode;
                for(ne(e, "destroy"), e.renderer.forExport ? a4(a_, e) : a_[e.index] = void 0, V.chartCount--, e.renderTo.removeAttribute("data-highcharts-chart"), nu(e), t = i.length; t--;)i[t] = i[t].destroy();
                for(this.scroller?.destroy?.(), t = s.length; t--;)s[t] = s[t].destroy();
                [
                    "title",
                    "subtitle",
                    "chartBackground",
                    "plotBackground",
                    "plotBGImage",
                    "plotBorder",
                    "seriesGroup",
                    "clipRect",
                    "credits",
                    "pointer",
                    "rangeSelector",
                    "legend",
                    "resetZoomButton",
                    "tooltip",
                    "renderer"
                ].forEach((t)=>{
                    e[t] = e[t]?.destroy?.();
                }), o && (o.innerHTML = ey.emptyHTML, nu(o), r && a9(o)), nl(e, function(t, i) {
                    delete e[i];
                });
            }
            firstRender() {
                let t = this, e = t.options;
                t.getContainer(), t.resetMargins(), t.setChartSize(), t.propFromSeries(), t.createAxes();
                let i = no(e.series) ? e.series : [];
                e.series = [], i.forEach(function(e) {
                    t.initSeries(e);
                }), t.linkSeries(), t.setSortedData(), ne(t, "beforeRender"), t.render(), t.pointer?.getChartPosition(), t.renderer.imgCount || t.hasLoaded || t.onload(), t.temporaryDisplay(!0);
            }
            onload() {
                this.callbacks.concat([
                    this.callback
                ]).forEach(function(t) {
                    t && void 0 !== this.index && t.apply(this, [
                        this
                    ]);
                }, this), ne(this, "load"), ne(this, "render"), a5(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.warnIfCSSNotLoaded(), this.hasLoaded = !0;
            }
            warnIfA11yModuleNotLoaded() {
                let { options: t, title: e } = this;
                t && !this.accessibility && (this.renderer.boxWrapper.attr({
                    role: "img",
                    "aria-label": (e?.element.textContent || "").replace(/</g, "&lt;")
                }), t.accessibility && !1 === t.accessibility.enabled || a8('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));
            }
            warnIfCSSNotLoaded() {
                this.styledMode && "0" !== aJ.getComputedStyle(this.container).zIndex && a8(35, !1, this);
            }
            addSeries(t, e, i) {
                let s, o = this;
                return t && (e = nd(e, !0), ne(o, "addSeries", {
                    options: t
                }, function() {
                    s = o.initSeries(t), o.isDirtyLegend = !0, o.linkSeries(), s.enabledDataSorting && s.setData(t.data, !1), ne(o, "afterAddSeries", {
                        series: s
                    }), e && o.redraw(i);
                })), s;
            }
            addAxis(t, e, i, s) {
                return this.createAxis(e ? "xAxis" : "yAxis", {
                    axis: t,
                    redraw: i,
                    animation: s
                });
            }
            addColorAxis(t, e, i) {
                return this.createAxis("colorAxis", {
                    axis: t,
                    redraw: e,
                    animation: i
                });
            }
            createAxis(t, e) {
                let i = new oo(this, e.axis, t);
                return nd(e.redraw, !0) && this.redraw(e.animation), i;
            }
            showLoading(t) {
                let e = this, i = e.options, s = i.loading, o = function() {
                    r && a3(r, {
                        left: e.plotLeft + "px",
                        top: e.plotTop + "px",
                        width: e.plotWidth + "px",
                        height: e.plotHeight + "px"
                    });
                }, r = e.loadingDiv, a = e.loadingSpan;
                r || (e.loadingDiv = r = a2("div", {
                    className: "highcharts-loading highcharts-loading-hidden"
                }, null, e.container)), a || (e.loadingSpan = a = a2("span", {
                    className: "highcharts-loading-inner"
                }, null, r), a0(e, "redraw", o)), r.className = "highcharts-loading", ey.setElementHTML(a, nd(t, i.lang.loading, "")), !e.styledMode && (a3(r, a7(s.style, {
                    zIndex: 10
                })), a3(a, s.labelStyle), e.loadingShown || (a3(r, {
                    opacity: 0,
                    display: ""
                }), aF(r, {
                    opacity: s.style.opacity || .5
                }, {
                    duration: s.showDuration || 0
                }))), e.loadingShown = !0, o();
            }
            hideLoading() {
                let t = this.options, e = this.loadingDiv;
                e && (e.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || aF(e, {
                    opacity: 0
                }, {
                    duration: t.loading.hideDuration || 100,
                    complete: function() {
                        a3(e, {
                            display: "none"
                        });
                    }
                })), this.loadingShown = !1;
            }
            update(t, e, i, s) {
                let o, r, a, n = this, h = {
                    credits: "addCredits",
                    title: "setTitle",
                    subtitle: "setSubtitle",
                    caption: "setCaption"
                }, l = t.isResponsiveOptions, d = [];
                ne(n, "update", {
                    options: t
                }), l || n.setResponsive(!1, !0), t = a6(t, n.options), n.userOptions = nh(n.userOptions, t);
                let c = t.chart;
                c && (nh(!0, n.options.chart, c), this.setZoomOptions(), "className" in c && n.setClassName(c.className), ("inverted" in c || "polar" in c || "type" in c) && (n.propFromSeries(), o = !0), "alignTicks" in c && (o = !0), "events" in c && a$(this, c), nl(c, function(t, e) {
                    -1 !== n.propsRequireUpdateSeries.indexOf("chart." + e) && (r = !0), -1 !== n.propsRequireDirtyBox.indexOf(e) && (n.isDirtyBox = !0), -1 !== n.propsRequireReflow.indexOf(e) && (n.isDirtyBox = !0, l || (a = !0));
                }), !n.styledMode && c.style && n.renderer.setStyle(n.options.chart.style || {})), !n.styledMode && t.colors && (this.options.colors = t.colors), nl(t, function(e, i) {
                    n[i] && "function" == typeof n[i].update ? n[i].update(e, !1) : "function" == typeof n[h[i]] ? n[h[i]](e) : "colors" !== i && -1 === n.collectionsWithUpdate.indexOf(i) && nh(!0, n.options[i], t[i]), "chart" !== i && -1 !== n.propsRequireUpdateSeries.indexOf(i) && (r = !0);
                }), this.collectionsWithUpdate.forEach(function(e) {
                    t[e] && (ng(t[e]).forEach(function(t, s) {
                        let o, r = a5(t.id);
                        r && (o = n.get(t.id)), !o && n[e] && (o = n[e][nd(t.index, s)]) && (r && a5(o.options.id) || o.options.isInternal) && (o = void 0), o && o.coll === e && (o.update(t, !1), i && (o.touched = !0)), !o && i && n.collectionsWithInit[e] && (n.collectionsWithInit[e][0].apply(n, [
                            t
                        ].concat(n.collectionsWithInit[e][1] || []).concat([
                            !1
                        ])).touched = !0);
                    }), i && n[e].forEach(function(t) {
                        t.touched || t.options.isInternal ? delete t.touched : d.push(t);
                    }));
                }), d.forEach(function(t) {
                    t.chart && t.remove && t.remove(!1);
                }), o && n.axes.forEach(function(t) {
                    t.update({}, !1);
                }), r && n.getSeriesOrderByLinks().forEach(function(t) {
                    t.chart && t.update({}, !1);
                }, this);
                let p = c?.width, u = c && (nn(c.height) ? np(c.height, p || n.chartWidth) : c.height);
                a || nr(p) && p !== n.chartWidth || nr(u) && u !== n.chartHeight ? n.setSize(p, u, s) : nd(e, !0) && n.redraw(s), ne(n, "afterUpdate", {
                    options: t,
                    redraw: e,
                    animation: s
                });
            }
            setSubtitle(t, e) {
                this.applyDescription("subtitle", t), this.layOutTitles(e);
            }
            setCaption(t, e) {
                this.applyDescription("caption", t), this.layOutTitles(e);
            }
            showResetZoom() {
                let t = this, e = aU.lang, i = t.zooming.resetButton, s = i.theme, o = "chart" === i.relativeTo || "spacingBox" === i.relativeTo ? null : "plotBox";
                function r() {
                    t.zoomOut();
                }
                ne(this, "beforeShowResetZoom", null, function() {
                    t.resetZoomButton = t.renderer.button(e.resetZoom, null, null, r, s).attr({
                        align: i.position.align,
                        title: e.resetZoomTitle
                    }).addClass("highcharts-reset-zoom").add().align(i.position, !1, o);
                }), ne(this, "afterShowResetZoom");
            }
            zoomOut() {
                ne(this, "selection", {
                    resetSelection: !0
                }, ()=>this.transform({
                        reset: !0,
                        trigger: "zoom"
                    }));
            }
            pan(t, e) {
                let i = this, s = "object" == typeof e ? e : {
                    enabled: e,
                    type: "x"
                }, o = s.type, r = o && i[({
                    x: "xAxis",
                    xy: "axes",
                    y: "yAxis"
                })[o]].filter((t)=>t.options.panningEnabled && !t.options.isInternal), a = i.options.chart;
                a?.panning && (a.panning = s), ne(this, "pan", {
                    originalEvent: t
                }, ()=>{
                    i.transform({
                        axes: r,
                        event: t,
                        to: {
                            x: t.chartX - (i.mouseDownX || 0),
                            y: t.chartY - (i.mouseDownY || 0)
                        },
                        trigger: "pan"
                    }), a3(i.container, {
                        cursor: "move"
                    });
                });
            }
            transform(t) {
                let { axes: e = this.axes, event: i, from: s = {}, reset: o, selection: r, to: a = {}, trigger: n, allowResetButton: h = !0 } = t, { inverted: l, time: d } = this;
                this.hoverPoints?.forEach((t)=>t.setState()), ne(this, "transform", t);
                let c = t.hasZoomed || !1, p, u;
                for (let t of e){
                    let { horiz: e, len: g, minPointOffset: f = 0, options: m, reversed: x } = t, y = e ? "width" : "height", b = e ? "x" : "y", v = nd(a[y], t.len), k = nd(s[y], t.len), M = 10 > Math.abs(v) ? 1 : v / k, w = (s[b] || 0) + k / 2 - t.pos, S = w - ((a[b] ?? t.pos) + v / 2 - t.pos) / M, A = x && !l || !x && l ? -1 : 1;
                    if (!o && (w < 0 || w > t.len)) continue;
                    let T = t.chart.polar || t.isOrdinal ? 0 : f * A || 0, C = t.toValue(S, !0), P = t.toValue(S + g / M, !0), O = C + T, E = P - T, L = t.allExtremes;
                    if (r && r[t.coll].push({
                        axis: t,
                        min: Math.min(C, P),
                        max: Math.max(C, P)
                    }), O > E && ([O, E] = [
                        E,
                        O
                    ]), 1 === M && !o && "yAxis" === t.coll && !L) {
                        for (let e of t.series){
                            let t = e.getExtremes(e.getProcessedData(!0).modified.getColumn(e.pointValKey || "y") || [], !0);
                            L ?? (L = {
                                dataMin: Number.MAX_VALUE,
                                dataMax: -Number.MAX_VALUE
                            }), nr(t.dataMin) && nr(t.dataMax) && (L.dataMin = Math.min(t.dataMin, L.dataMin), L.dataMax = Math.max(t.dataMax, L.dataMax));
                        }
                        t.allExtremes = L;
                    }
                    let { dataMin: B, dataMax: D, min: I, max: z } = a7(t.getExtremes(), L || {}), R = d.parse(m.min), N = d.parse(m.max), W = B ?? R, G = D ?? N, X = E - O, H = t.categories ? 0 : Math.min(X, G - W), F = W - H * (a5(R) ? 0 : m.minPadding), Y = G + H * (a5(N) ? 0 : m.maxPadding), j = t.allowZoomOutside || 1 === M || "zoom" !== n && M > 1, U = Math.min(R ?? F, F, j ? I : F), V = Math.max(N ?? Y, Y, j ? z : Y);
                    (!t.isOrdinal || 1 !== M || o) && (O < U && (O = U, M >= 1 && (E = O + X)), E > V && (E = V, M >= 1 && (O = E - X)), (o || t.series.length && (O !== I || E !== z) && O >= U && E <= V) && (r ? r[t.coll].push({
                        axis: t,
                        min: O,
                        max: E
                    }) : (t.isPanning = "zoom" !== n, t.isPanning && "mousewheel" !== n && (u = !0), t.setExtremes(o ? void 0 : O, o ? void 0 : E, !1, !1, {
                        move: S,
                        trigger: n,
                        scale: M
                    }), !o && (O > U || E < V) && (p = h)), c = !0), this.hasCartesianSeries || o || (p = h), i && (this[e ? "mouseDownX" : "mouseDownY"] = i[e ? "chartX" : "chartY"]));
                }
                return c && (r ? ne(this, "selection", r, ()=>{
                    delete t.selection, t.trigger = "zoom", this.transform(t);
                }) : (!p || u || this.resetZoomButton ? !p && this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy()) : this.showResetZoom(), this.redraw("zoom" === n && (this.options.chart.animation ?? this.pointCount < 100)))), c;
            }
        }
        a7(nx.prototype, {
            callbacks: [],
            collectionsWithInit: {
                xAxis: [
                    nx.prototype.addAxis,
                    [
                        !0
                    ]
                ],
                yAxis: [
                    nx.prototype.addAxis,
                    [
                        !1
                    ]
                ],
                series: [
                    nx.prototype.addSeries
                ]
            },
            collectionsWithUpdate: [
                "xAxis",
                "yAxis",
                "series"
            ],
            propsRequireDirtyBox: [
                "backgroundColor",
                "borderColor",
                "borderWidth",
                "borderRadius",
                "plotBackgroundColor",
                "plotBackgroundImage",
                "plotBorderColor",
                "plotBorderWidth",
                "plotShadow",
                "shadow"
            ],
            propsRequireReflow: [
                "margin",
                "marginTop",
                "marginRight",
                "marginBottom",
                "marginLeft",
                "spacing",
                "spacingTop",
                "spacingRight",
                "spacingBottom",
                "spacingLeft"
            ],
            propsRequireUpdateSeries: [
                "chart.inverted",
                "chart.polar",
                "chart.ignoreHiddenSeries",
                "chart.type",
                "colors",
                "plotOptions",
                "time",
                "tooltip"
            ]
        });
        let ny = nx, { stop: nb } = eo, { composed: nv } = V, { addEvent: nk, createElement: nM, css: nw, defined: nS, erase: nA, merge: nT, pushUnique: nC } = tx;
        function nP() {
            let t = this.scrollablePlotArea;
            (this.scrollablePixelsX || this.scrollablePixelsY) && !t && (this.scrollablePlotArea = t = new nE(this)), t?.applyFixed();
        }
        function nO() {
            this.chart.scrollablePlotArea && (this.chart.scrollablePlotArea.isDirty = !0);
        }
        class nE {
            static compose(t, e, i) {
                nC(nv, this.compose) && (nk(t, "afterInit", nO), nk(e, "afterSetChartSize", (t)=>this.afterSetSize(t.target, t)), nk(e, "render", nP), nk(i, "show", nO));
            }
            static afterSetSize(t, e) {
                let i, s, o, { minWidth: r, minHeight: a } = t.options.chart.scrollablePlotArea || {}, { clipBox: n, plotBox: h, inverted: l, renderer: d } = t;
                if (!d.forExport) if (r ? (t.scrollablePixelsX = i = Math.max(0, r - t.chartWidth), i && (t.scrollablePlotBox = nT(t.plotBox), h.width = t.plotWidth += i, n[l ? "height" : "width"] += i, o = !0)) : a && (t.scrollablePixelsY = s = Math.max(0, a - t.chartHeight), nS(s) && (t.scrollablePlotBox = nT(t.plotBox), h.height = t.plotHeight += s, n[l ? "width" : "height"] += s, o = !1)), nS(o)) {
                    if (!e.skipAxes) for (let e of t.axes)(e.horiz === o || t.hasParallelCoordinates && "yAxis" === e.coll) && (e.setAxisSize(), e.setAxisTranslation());
                } else delete t.scrollablePlotBox;
            }
            constructor(t){
                let e;
                const i = t.options.chart, s = ez.getRendererType(), o = i.scrollablePlotArea || {}, r = this.moveFixedElements.bind(this), a = {
                    WebkitOverflowScrolling: "touch",
                    overflowX: "hidden",
                    overflowY: "hidden"
                };
                t.scrollablePixelsX && (a.overflowX = "auto"), t.scrollablePixelsY && (a.overflowY = "auto"), this.chart = t;
                const n = this.parentDiv = nM("div", {
                    className: "highcharts-scrolling-parent"
                }, {
                    position: "relative"
                }, t.renderTo), h = this.scrollingContainer = nM("div", {
                    className: "highcharts-scrolling"
                }, a, n), l = this.innerContainer = nM("div", {
                    className: "highcharts-inner-container"
                }, void 0, h), d = this.fixedDiv = nM("div", {
                    className: "highcharts-fixed"
                }, {
                    position: "absolute",
                    overflow: "hidden",
                    pointerEvents: "none",
                    zIndex: (i.style?.zIndex || 0) + 2,
                    top: 0
                }, void 0, !0), c = this.fixedRenderer = new s(d, t.chartWidth, t.chartHeight, i.style);
                this.mask = c.path().attr({
                    fill: i.backgroundColor || "#fff",
                    "fill-opacity": o.opacity ?? .85,
                    zIndex: -1
                }).addClass("highcharts-scrollable-mask").add(), h.parentNode.insertBefore(d, h), nw(t.renderTo, {
                    overflow: "visible"
                }), nk(t, "afterShowResetZoom", r), nk(t, "afterApplyDrilldown", r), nk(t, "afterLayOutTitles", r), nk(h, "scroll", ()=>{
                    let { pointer: i, hoverPoint: s } = t;
                    i && (delete i.chartPosition, s && (e = s), i.runPointActions(void 0, e, !0));
                }), l.appendChild(t.container);
            }
            applyFixed() {
                let { chart: t, fixedRenderer: e, isDirty: i, scrollingContainer: s } = this, { axisOffset: o, chartWidth: r, chartHeight: a, container: n, plotHeight: h, plotLeft: l, plotTop: d, plotWidth: c, scrollablePixelsX: p = 0, scrollablePixelsY: u = 0 } = t, { scrollPositionX: g = 0, scrollPositionY: f = 0 } = t.options.chart.scrollablePlotArea || {}, m = r + p, x = a + u;
                e.setSize(r, a), (i ?? !0) && (this.isDirty = !1, this.moveFixedElements()), nb(t.container), nw(n, {
                    width: `${m}px`,
                    height: `${x}px`
                }), t.renderer.boxWrapper.attr({
                    width: m,
                    height: x,
                    viewBox: [
                        "0 0",
                        m,
                        x
                    ].join(" ")
                }), t.chartBackground?.attr({
                    width: m,
                    height: x
                }), nw(s, {
                    width: `${r}px`,
                    height: `${a}px`
                }), nS(i) || (s.scrollLeft = p * g, s.scrollTop = u * f);
                let y = d - o[0] - 1, b = l - o[3] - 1, v = d + h + o[2] + 1, k = l + c + o[1] + 1, M = l + c - p, w = d + h - u, S = [
                    [
                        "M",
                        0,
                        0
                    ]
                ];
                p ? S = [
                    [
                        "M",
                        0,
                        y
                    ],
                    [
                        "L",
                        l - 1,
                        y
                    ],
                    [
                        "L",
                        l - 1,
                        v
                    ],
                    [
                        "L",
                        0,
                        v
                    ],
                    [
                        "Z"
                    ],
                    [
                        "M",
                        M,
                        y
                    ],
                    [
                        "L",
                        r,
                        y
                    ],
                    [
                        "L",
                        r,
                        v
                    ],
                    [
                        "L",
                        M,
                        v
                    ],
                    [
                        "Z"
                    ]
                ] : u && (S = [
                    [
                        "M",
                        b,
                        0
                    ],
                    [
                        "L",
                        b,
                        d - 1
                    ],
                    [
                        "L",
                        k,
                        d - 1
                    ],
                    [
                        "L",
                        k,
                        0
                    ],
                    [
                        "Z"
                    ],
                    [
                        "M",
                        b,
                        w
                    ],
                    [
                        "L",
                        b,
                        a
                    ],
                    [
                        "L",
                        k,
                        a
                    ],
                    [
                        "L",
                        k,
                        w
                    ],
                    [
                        "Z"
                    ]
                ]), "adjustHeight" !== t.redrawTrigger && this.mask.attr({
                    d: S
                });
            }
            moveFixedElements() {
                let t, { container: e, inverted: i, scrollablePixelsX: s, scrollablePixelsY: o } = this.chart, r = this.fixedRenderer, a = nE.fixedSelectors;
                if (s && !i ? t = ".highcharts-yaxis" : s && i || o && !i ? t = ".highcharts-xaxis" : o && i && (t = ".highcharts-yaxis"), t && !(this.chart.hasParallelCoordinates && ".highcharts-yaxis" === t)) for (let e of [
                    `${t}:not(.highcharts-radial-axis)`,
                    `${t}-labels:not(.highcharts-radial-axis-labels)`
                ])nC(a, e);
                else for (let t of [
                    ".highcharts-xaxis",
                    ".highcharts-yaxis"
                ])for (let e of [
                    `${t}:not(.highcharts-radial-axis)`,
                    `${t}-labels:not(.highcharts-radial-axis-labels)`
                ])nA(a, e);
                for (let t of a)[].forEach.call(e.querySelectorAll(t), (t)=>{
                    (t.namespaceURI === r.SVG_NS ? r.box : r.box.parentNode).appendChild(t), t.style.pointerEvents = "auto";
                });
            }
        }
        nE.fixedSelectors = [
            ".highcharts-breadcrumbs-group",
            ".highcharts-contextbutton",
            ".highcharts-caption",
            ".highcharts-credits",
            ".highcharts-drillup-button",
            ".highcharts-legend",
            ".highcharts-legend-checkbox",
            ".highcharts-navigator-series",
            ".highcharts-navigator-xaxis",
            ".highcharts-navigator-yaxis",
            ".highcharts-navigator",
            ".highcharts-range-selector-group",
            ".highcharts-reset-zoom",
            ".highcharts-scrollbar",
            ".highcharts-subtitle",
            ".highcharts-title"
        ];
        let { format: nL } = eI, { series: nB } = r_, { destroyObjectProperties: nD, fireEvent: nI, getAlignFactor: nz, isNumber: nR, pick: nN } = tx, nW = class {
            constructor(t, e, i, s, o){
                const r = t.chart.inverted, a = t.reversed;
                this.axis = t;
                const n = this.isNegative = !!i != !!a;
                this.options = e = e || {}, this.x = s, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = !1, this.stack = o, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = {
                    align: e.align || (r ? n ? "left" : "right" : "center"),
                    verticalAlign: e.verticalAlign || (r ? "middle" : n ? "bottom" : "top"),
                    y: e.y,
                    x: e.x
                }, this.textAlign = e.textAlign || (r ? n ? "right" : "left" : "center");
            }
            destroy() {
                nD(this, this.axis);
            }
            render(t) {
                let e = this.axis.chart, i = this.options, s = i.format, o = s ? nL(s, this, e) : i.formatter.call(this);
                if (this.label) this.label.attr({
                    text: o,
                    visibility: "hidden"
                });
                else {
                    this.label = e.renderer.label(o, null, void 0, i.shape, void 0, void 0, i.useHTML, !1, "stack-labels");
                    let s = {
                        r: i.borderRadius || 0,
                        text: o,
                        padding: nN(i.padding, 5),
                        visibility: "hidden"
                    };
                    e.styledMode || (s.fill = i.backgroundColor, s.stroke = i.borderColor, s["stroke-width"] = i.borderWidth, this.label.css(i.style || {})), this.label.attr(s), this.label.added || this.label.add(t);
                }
                this.label.labelrank = e.plotSizeY, nI(this, "afterRender");
            }
            setOffset(t, e, i, s, o, r) {
                let { alignOptions: a, axis: n, label: h, options: l, textAlign: d } = this, c = n.chart, p = this.getStackBox({
                    xOffset: t,
                    width: e,
                    boxBottom: i,
                    boxTop: s,
                    defaultX: o,
                    xAxis: r
                }), { verticalAlign: u } = a;
                if (h && p) {
                    let t = h.getBBox(void 0, 0), e = h.padding, i = "justify" === nN(l.overflow, "justify"), s;
                    a.x = l.x || 0, a.y = l.y || 0;
                    let { x: o, y: r } = this.adjustStackPosition({
                        labelBox: t,
                        verticalAlign: u,
                        textAlign: d
                    });
                    p.x -= o, p.y -= r, h.align(a, !1, p), (s = c.isInsidePlot(h.alignAttr.x + a.x + o, h.alignAttr.y + a.y + r)) || (i = !1), i && nB.prototype.justifyDataLabel.call(n, h, a, h.alignAttr, t, p), h.attr({
                        x: h.alignAttr.x,
                        y: h.alignAttr.y,
                        rotation: l.rotation,
                        rotationOriginX: t.width * nz(l.textAlign || "center"),
                        rotationOriginY: t.height / 2
                    }), nN(!i && l.crop, !0) && (s = nR(h.x) && nR(h.y) && c.isInsidePlot(h.x - e + (h.width || 0), h.y) && c.isInsidePlot(h.x + e, h.y)), h[s ? "show" : "hide"]();
                }
                nI(this, "afterSetOffset", {
                    xOffset: t,
                    width: e
                });
            }
            adjustStackPosition({ labelBox: t, verticalAlign: e, textAlign: i }) {
                return {
                    x: t.width / 2 + t.width / 2 * (2 * nz(i) - 1),
                    y: t.height / 2 * 2 * (1 - nz(e))
                };
            }
            getStackBox(t) {
                let e = this.axis, i = e.chart, { boxTop: s, defaultX: o, xOffset: r, width: a, boxBottom: n } = t, h = e.stacking.usePercentage ? 100 : nN(s, this.total, 0), l = e.toPixels(h), d = t.xAxis || i.xAxis[0], c = nN(o, d.translate(this.x)) + r, p = Math.abs(l - e.toPixels(n || nR(e.min) && e.logarithmic && e.logarithmic.lin2log(e.min) || 0)), u = i.inverted, g = this.isNegative;
                return u ? {
                    x: (g ? l : l - p) - i.plotLeft,
                    y: d.height - c - a + d.top - i.plotTop,
                    width: p,
                    height: a
                } : {
                    x: c + d.transB - i.plotLeft,
                    y: (g ? l - p : l) - i.plotTop,
                    width: a,
                    height: p
                };
            }
        }, { getDeferredAnimation: nG } = eo, { series: { prototype: nX } } = r_, { addEvent: nH, correctFloat: nF, defined: nY, destroyObjectProperties: nj, fireEvent: nU, isNumber: nV, objectEach: n$, pick: n_ } = tx;
        function nZ() {
            let t = this.inverted;
            this.axes.forEach((t)=>{
                t.stacking?.stacks && t.hasVisibleSeries && (t.stacking.oldStacks = t.stacking.stacks);
            }), this.series.forEach((e)=>{
                let i = e.xAxis?.options || {};
                e.options.stacking && e.reserveSpace() && (e.stackKey = [
                    e.type,
                    n_(e.options.stack, ""),
                    t ? i.top : i.left,
                    t ? i.height : i.width
                ].join(","));
            });
        }
        function nq() {
            let t = this.stacking;
            if (t) {
                let e = t.stacks;
                n$(e, (t, i)=>{
                    nj(t), delete e[i];
                }), t.stackTotalGroup?.destroy();
            }
        }
        function nK() {
            this.stacking || (this.stacking = new n3(this));
        }
        function nJ(t, e, i, s) {
            return !nY(t) || t.x !== e || s && t.stackKey !== s ? t = {
                x: e,
                index: 0,
                key: s,
                stackKey: s
            } : t.index++, t.key = [
                i,
                e,
                t.index
            ].join(","), t;
        }
        function nQ() {
            let t, e = this, i = e.yAxis, s = e.stackKey || "", o = i.stacking.stacks, r = e.getColumn("x", !0), a = e.options.stacking, n = e[a + "Stacker"];
            n && [
                s,
                "-" + s
            ].forEach((i)=>{
                let s = r.length, a, h, l;
                for(; s--;)a = r[s], t = e.getStackIndicator(t, a, e.index, i), h = o[i]?.[a], (l = h?.points[t.key || ""]) && n.call(e, l, h, s);
            });
        }
        function n0(t, e, i) {
            let s = e.total ? 100 / e.total : 0;
            t[0] = nF(t[0] * s), t[1] = nF(t[1] * s), this.stackedYData[i] = t[1];
        }
        function n1(t) {
            (this.is("column") || this.is("columnrange")) && (this.options.centerInCategory && this.chart.series.length > 1 ? nX.setStackedPoints.call(this, t, "group") : t.stacking.resetStacks());
        }
        function n2(t, e) {
            let i, s, o, r, a, n, h, l = e || this.options.stacking;
            if (!l || !this.reserveSpace() || (({
                group: "xAxis"
            })[l] || "yAxis") !== t.coll) return;
            let d = this.getColumn("x", !0), c = this.getColumn(this.pointValKey || "y", !0), p = [], u = c.length, g = this.options, f = g.threshold || 0, m = g.startFromThreshold ? f : 0, x = g.stack, y = e ? `${this.type},${l}` : this.stackKey || "", b = "-" + y, v = this.negStacks, k = t.stacking, M = k.stacks, w = k.oldStacks;
            for(k.stacksTouched += 1, h = 0; h < u; h++){
                let e = d[h] || 0, u = c[h], g = nV(u) && u || 0;
                n = (i = this.getStackIndicator(i, e, this.index)).key || "", M[a = (s = v && g < (m ? 0 : f)) ? b : y] || (M[a] = {}), M[a][e] || (w[a]?.[e] ? (M[a][e] = w[a][e], M[a][e].total = null) : M[a][e] = new nW(t, t.options.stackLabels, !!s, e, x)), o = M[a][e], null !== u ? (o.points[n] = o.points[this.index] = [
                    n_(o.cumulative, m)
                ], nY(o.cumulative) || (o.base = n), o.touched = k.stacksTouched, i.index > 0 && !1 === this.singleStacks && (o.points[n][0] = o.points[this.index + "," + e + ",0"][0])) : (delete o.points[n], delete o.points[this.index]);
                let S = o.total || 0;
                "percent" === l ? (r = s ? y : b, S = v && M[r]?.[e] ? (r = M[r][e]).total = Math.max(r.total || 0, S) + Math.abs(g) : nF(S + Math.abs(g))) : "group" === l ? nV(u) && S++ : S = nF(S + g), "group" === l ? o.cumulative = (S || 1) - 1 : o.cumulative = nF(n_(o.cumulative, m) + g), o.total = S, null !== u && (o.points[n].push(o.cumulative), p[h] = o.cumulative, o.hasValidPoints = !0);
            }
            "percent" === l && (k.usePercentage = !0), "group" !== l && (this.stackedYData = p), k.oldStacks = {};
        }
        class n3 {
            constructor(t){
                this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t;
            }
            buildStacks() {
                let t, e, i = this.axis, s = i.series, o = "xAxis" === i.coll, r = i.options.reversedStacks, a = s.length;
                for(this.resetStacks(), this.usePercentage = !1, e = a; e--;)t = s[r ? e : a - e - 1], o && t.setGroupedPoints(i), t.setStackedPoints(i);
                if (!o) for(e = 0; e < a; e++)s[e].modifyStacks();
                nU(i, "afterBuildStacks");
            }
            cleanStacks() {
                this.oldStacks && (this.stacks = this.oldStacks, n$(this.stacks, (t)=>{
                    n$(t, (t)=>{
                        t.cumulative = t.total;
                    });
                }));
            }
            resetStacks() {
                n$(this.stacks, (t)=>{
                    n$(t, (e, i)=>{
                        nV(e.touched) && e.touched < this.stacksTouched ? (e.destroy(), delete t[i]) : (e.total = null, e.cumulative = null);
                    });
                });
            }
            renderStackTotals() {
                let t = this.axis, e = t.chart, i = e.renderer, s = this.stacks, o = nG(e, t.options.stackLabels?.animation || !1), r = this.stackTotalGroup = this.stackTotalGroup || i.g("stack-labels").attr({
                    zIndex: 6,
                    opacity: 0
                }).add();
                r.translate(e.plotLeft, e.plotTop), n$(s, (t)=>{
                    n$(t, (t)=>{
                        t.render(r);
                    });
                }), r.animate({
                    opacity: 1
                }, o);
            }
        }
        (L || (L = {})).compose = function(t, e, i) {
            let s = e.prototype, o = i.prototype;
            s.getStacks || (nH(t, "init", nK), nH(t, "destroy", nq), s.getStacks = nZ, o.getStackIndicator = nJ, o.modifyStacks = nQ, o.percentStacker = n0, o.setGroupedPoints = n1, o.setStackedPoints = n2);
        };
        let n5 = L, { defined: n6, merge: n9, isObject: n4 } = tx;
        class n8 extends ay {
            drawGraph() {
                let t = this.options, e = (this.gappedPath || this.getGraphPath).call(this), i = this.chart.styledMode;
                [
                    this,
                    ...this.zones
                ].forEach((s, o)=>{
                    let r, a = s.graph, n = a ? "animate" : "attr", h = s.dashStyle || t.dashStyle;
                    a ? (a.endX = this.preventGraphAnimation ? null : e.xMap, a.animate({
                        d: e
                    })) : e.length && (s.graph = a = this.chart.renderer.path(e).addClass("highcharts-graph" + (o ? ` highcharts-zone-graph-${o - 1} ` : " ") + (o && s.className || "")).attr({
                        zIndex: 1
                    }).add(this.group)), a && !i && (r = {
                        stroke: !o && t.lineColor || s.color || this.color || "#cccccc",
                        "stroke-width": t.lineWidth || 0,
                        fill: this.fillGraph && this.color || "none"
                    }, h ? r.dashstyle = h : "square" !== t.linecap && (r["stroke-linecap"] = r["stroke-linejoin"] = "round"), a[n](r).shadow(t.shadow && n9({
                        filterUnits: "userSpaceOnUse"
                    }, n4(t.shadow) ? t.shadow : {}))), a && (a.startX = e.xMap, a.isArea = e.isArea);
                });
            }
            getGraphPath(t, e, i) {
                let s = this, o = s.options, r = [], a = [], n, h = o.step, l = (t = t || s.points).reversed;
                return l && t.reverse(), (h = ({
                    right: 1,
                    center: 2
                })[h] || h && 3) && l && (h = 4 - h), (t = this.getValidPoints(t, !1, o.nullInteraction || !(o.connectNulls && !e && !i))).forEach(function(l, d) {
                    let c, p = l.plotX, u = l.plotY, g = t[d - 1], f = l.isNull || "number" != typeof u;
                    (l.leftCliff || g?.rightCliff) && !i && (n = !0), f && !n6(e) && d > 0 ? n = !o.connectNulls : f && !e ? n = !0 : (0 === d || n ? c = [
                        [
                            "M",
                            l.plotX,
                            l.plotY
                        ]
                    ] : s.getPointSpline ? c = [
                        s.getPointSpline(t, l, d)
                    ] : h ? (c = 1 === h ? [
                        [
                            "L",
                            g.plotX,
                            u
                        ]
                    ] : 2 === h ? [
                        [
                            "L",
                            (g.plotX + p) / 2,
                            g.plotY
                        ],
                        [
                            "L",
                            (g.plotX + p) / 2,
                            u
                        ]
                    ] : [
                        [
                            "L",
                            p,
                            g.plotY
                        ]
                    ]).push([
                        "L",
                        p,
                        u
                    ]) : c = [
                        [
                            "L",
                            p,
                            u
                        ]
                    ], a.push(l.x), h && (a.push(l.x), 2 === h && a.push(l.x)), r.push.apply(r, c), n = !1);
                }), r.xMap = a, s.graphPath = r, r;
            }
        }
        n8.defaultOptions = n9(ay.defaultOptions, {
            legendSymbol: "lineMarker"
        }), r_.registerSeriesType("line", n8);
        let { seriesTypes: { line: n7 } } = r_, { extend: ht, merge: he, objectEach: hi, pick: hs } = tx;
        class ho extends n7 {
            drawGraph() {
                this.areaPath = [], super.drawGraph.apply(this);
                let { areaPath: t, options: e } = this;
                [
                    this,
                    ...this.zones
                ].forEach((i, s)=>{
                    let o = {}, r = i.fillColor || e.fillColor, a = i.area, n = a ? "animate" : "attr";
                    a ? (a.endX = this.preventGraphAnimation ? null : t.xMap, a.animate({
                        d: t
                    })) : (o.zIndex = 0, (a = i.area = this.chart.renderer.path(t).addClass("highcharts-area" + (s ? ` highcharts-zone-area-${s - 1} ` : " ") + (s && i.className || "")).add(this.group)).isArea = !0), this.chart.styledMode || (o.fill = r || i.color || this.color, o["fill-opacity"] = r ? 1 : e.fillOpacity ?? .75, a.css({
                        pointerEvents: this.stickyTracking ? "none" : "auto"
                    })), a[n](o), a.startX = t.xMap, a.shiftUnit = e.step ? 2 : 1;
                });
            }
            getGraphPath(t) {
                let e, i, s, o = n7.prototype.getGraphPath, r = this.options, a = r.stacking, n = this.yAxis, h = [], l = [], d = this.index, c = n.stacking.stacks[this.stackKey], p = r.threshold, u = Math.round(n.getThreshold(r.threshold)), g = hs(r.connectNulls, "percent" === a), f = function(i, s, o) {
                    let r = t[i], g = a && c[r.x].points[d], f = r[o + "Null"] || 0, m = r[o + "Cliff"] || 0, x, y, b = !0;
                    m || f ? (x = (f ? g[0] : g[1]) + m, y = g[0] + m, b = !!f) : !a && t[s] && t[s].isNull && (x = y = p), void 0 !== x && (l.push({
                        plotX: e,
                        plotY: null === x ? u : n.getThreshold(x),
                        isNull: b,
                        isCliff: !0
                    }), h.push({
                        plotX: e,
                        plotY: null === y ? u : n.getThreshold(y),
                        doCurve: !1
                    }));
                };
                t = t || this.points, a && (t = this.getStackPoints(t));
                for(let o = 0, r = t.length; o < r; ++o)a || (t[o].leftCliff = t[o].rightCliff = t[o].leftNull = t[o].rightNull = void 0), i = t[o].isNull, e = hs(t[o].rectPlotX, t[o].plotX), s = a ? hs(t[o].yBottom, u) : u, (!i || g) && (g || f(o, o - 1, "left"), i && !a && g || (l.push(t[o]), h.push({
                    x: o,
                    plotX: e,
                    plotY: s
                })), g || f(o, o + 1, "right"));
                let m = o.call(this, l, !0, !0);
                h.reversed = !0;
                let x = o.call(this, h, !0, !0), y = x[0];
                y && "M" === y[0] && (x[0] = [
                    "L",
                    y[1],
                    y[2]
                ]);
                let b = m.concat(x);
                b.length && b.push([
                    "Z"
                ]);
                let v = o.call(this, l, !1, g);
                return this.chart.series.length > 1 && a && l.some((t)=>t.isCliff) && (b.hasStackedCliffs = v.hasStackedCliffs = !0), b.xMap = m.xMap, this.areaPath = b, v;
            }
            getStackPoints(t) {
                let e = this, i = [], s = [], o = this.xAxis, r = this.yAxis, a = r.stacking.stacks[this.stackKey], n = {}, h = r.series, l = h.length, d = r.options.reversedStacks ? 1 : -1, c = h.indexOf(e);
                if (t = t || this.points, this.options.stacking) {
                    for(let e = 0; e < t.length; e++)t[e].leftNull = t[e].rightNull = void 0, n[t[e].x] = t[e];
                    hi(a, function(t, e) {
                        null !== t.total && s.push(e);
                    }), s.sort(function(t, e) {
                        return t - e;
                    });
                    let p = h.map((t)=>t.visible);
                    s.forEach(function(t, u) {
                        let g = 0, f, m;
                        if (n[t] && !n[t].isNull) i.push(n[t]), [
                            -1,
                            1
                        ].forEach(function(i) {
                            let o = 1 === i ? "rightNull" : "leftNull", r = a[s[u + i]], g = 0;
                            if (r) {
                                let i = c;
                                for(; i >= 0 && i < l;){
                                    let s = h[i].index;
                                    !(f = r.points[s]) && (s === e.index ? n[t][o] = !0 : p[i] && (m = a[t].points[s]) && (g -= m[1] - m[0])), i += d;
                                }
                            }
                            n[t][1 === i ? "rightCliff" : "leftCliff"] = g;
                        });
                        else {
                            let e = c;
                            for(; e >= 0 && e < l;){
                                let i = h[e].index;
                                if (f = a[t].points[i]) {
                                    g = f[1];
                                    break;
                                }
                                e += d;
                            }
                            g = hs(g, 0), g = r.translate(g, 0, 1, 0, 1), i.push({
                                isNull: !0,
                                plotX: o.translate(t, 0, 0, 0, 1),
                                x: t,
                                plotY: g,
                                yBottom: g
                            });
                        }
                    });
                }
                return i;
            }
        }
        ho.defaultOptions = he(n7.defaultOptions, {
            threshold: 0,
            legendSymbol: "areaMarker"
        }), ht(ho.prototype, {
            singleStacks: !1
        }), r_.registerSeriesType("area", ho);
        let { line: hr } = r_.seriesTypes, { merge: ha, pick: hn } = tx;
        class hh extends hr {
            getPointSpline(t, e, i) {
                let s, o, r, a, n = e.plotX || 0, h = e.plotY || 0, l = t[i - 1], d = t[i + 1];
                function c(t) {
                    return t && !t.isNull && !1 !== t.doCurve && !e.isCliff;
                }
                if (c(l) && c(d)) {
                    let t = l.plotX || 0, i = l.plotY || 0, c = d.plotX || 0, p = d.plotY || 0, u = 0;
                    s = (1.5 * n + t) / 2.5, o = (1.5 * h + i) / 2.5, r = (1.5 * n + c) / 2.5, a = (1.5 * h + p) / 2.5, r !== s && (u = (a - o) * (r - n) / (r - s) + h - a), o += u, a += u, o > i && o > h ? (o = Math.max(i, h), a = 2 * h - o) : o < i && o < h && (o = Math.min(i, h), a = 2 * h - o), a > p && a > h ? (a = Math.max(p, h), o = 2 * h - a) : a < p && a < h && (a = Math.min(p, h), o = 2 * h - a), e.rightContX = r, e.rightContY = a, e.controlPoints = {
                        low: [
                            s,
                            o
                        ],
                        high: [
                            r,
                            a
                        ]
                    };
                }
                let p = [
                    "C",
                    hn(l.rightContX, l.plotX, 0),
                    hn(l.rightContY, l.plotY, 0),
                    hn(s, n, 0),
                    hn(o, h, 0),
                    n,
                    h
                ];
                return l.rightContX = l.rightContY = void 0, p;
            }
        }
        hh.defaultOptions = ha(hr.defaultOptions), r_.registerSeriesType("spline", hh);
        let hl = hh, { area: hd, area: { prototype: hc } } = r_.seriesTypes, { extend: hp, merge: hu } = tx;
        class hg extends hl {
        }
        hg.defaultOptions = hu(hl.defaultOptions, hd.defaultOptions), hp(hg.prototype, {
            getGraphPath: hc.getGraphPath,
            getStackPoints: hc.getStackPoints,
            drawGraph: hc.drawGraph
        }), r_.registerSeriesType("areaspline", hg);
        let { animObject: hf } = eo, { parse: hm } = tJ, { noop: hx } = V, { clamp: hy, crisp: hb, defined: hv, extend: hk, fireEvent: hM, isArray: hw, isNumber: hS, merge: hA, pick: hT, objectEach: hC } = tx;
        class hP extends ay {
            animate(t) {
                let e, i, s = this, o = this.yAxis, r = o.pos, a = o.reversed, n = s.options, { clipOffset: h, inverted: l } = this.chart, d = {}, c = l ? "translateX" : "translateY";
                t && h ? (d.scaleY = .001, i = hy(o.toPixels(n.threshold || 0), r, r + o.len), l ? d.translateX = (i += a ? -Math.floor(h[0]) : Math.ceil(h[2])) - o.len : d.translateY = i += a ? Math.ceil(h[0]) : -Math.floor(h[2]), s.clipBox && s.setClip(), s.group.attr(d)) : (e = Number(s.group.attr(c)), s.group.animate({
                    scaleY: 1
                }, hk(hf(s.options.animation), {
                    step: function(t, i) {
                        s.group && (d[c] = e + i.pos * (r - e), s.group.attr(d));
                    }
                })));
            }
            init(t, e) {
                super.init.apply(this, arguments);
                let i = this;
                (t = i.chart).hasRendered && t.series.forEach(function(t) {
                    t.type === i.type && (t.isDirty = !0);
                });
            }
            getColumnMetrics() {
                let t = this, e = t.options, i = t.xAxis, s = t.yAxis, o = i.options.reversedStacks, r = i.reversed && !o || !i.reversed && o, a = {}, n, h = 0;
                !1 === e.grouping ? h = 1 : t.chart.series.forEach(function(e) {
                    let i, o = e.yAxis, r = e.options;
                    e.type === t.type && e.reserveSpace() && s.len === o.len && s.pos === o.pos && (r.stacking && "group" !== r.stacking ? (void 0 === a[n = e.stackKey] && (a[n] = h++), i = a[n]) : !1 !== r.grouping && (i = h++), e.columnIndex = i);
                });
                let l = Math.min(Math.abs(i.transA) * (!i.brokenAxis?.hasBreaks && i.ordinal?.slope || e.pointRange || i.closestPointRange || i.tickInterval || 1), i.len), d = l * e.groupPadding, c = (l - 2 * d) / (h || 1), p = Math.min(e.maxPointWidth || i.len, hT(e.pointWidth, c * (1 - 2 * e.pointPadding))), u = (t.columnIndex || 0) + +!!r;
                return t.columnMetrics = {
                    width: p,
                    offset: (c - p) / 2 + (d + u * c - l / 2) * (r ? -1 : 1),
                    paddedWidth: c,
                    columnCount: h
                }, t.columnMetrics;
            }
            crispCol(t, e, i, s) {
                let o = this.borderWidth, r = this.chart.inverted;
                return s = hb(e + s, o, r) - (e = hb(e, o, r)), this.options.crisp && (i = hb(t + i, o) - (t = hb(t, o))), {
                    x: t,
                    y: e,
                    width: i,
                    height: s
                };
            }
            adjustForMissingColumns(t, e, i, s) {
                if (!i.isNull && s.columnCount > 1) {
                    let o = this.xAxis.series.filter((t)=>t.visible).map((t)=>t.index), r = 0, a = 0;
                    hC(this.xAxis.stacking?.stacks, (t)=>{
                        let e = "number" == typeof i.x ? t[i.x.toString()]?.points : void 0, s = e?.[this.index], n = {};
                        if (e && hw(s)) {
                            let t = this.index, i = Object.keys(e).filter((t)=>!t.match(",") && e[t] && e[t].length > 1).map(parseFloat).filter((t)=>-1 !== o.indexOf(t)).filter((e)=>{
                                let i = this.chart.series[e].options, s = i.stacking && i.stack;
                                if (hv(s)) {
                                    if (hS(n[s])) return t === e && (t = n[s]), !1;
                                    n[s] = e;
                                }
                                return !0;
                            }).sort((t, e)=>e - t);
                            r = i.indexOf(t), a = i.length;
                        }
                    }), r = this.xAxis.reversed ? a - 1 - r : r;
                    let n = (a - 1) * s.paddedWidth + e;
                    t = (i.plotX || 0) + n / 2 - e - r * s.paddedWidth;
                }
                return t;
            }
            translate() {
                let t = this, e = t.chart, i = t.options, s = t.dense = t.closestPointRange * t.xAxis.transA < 2, o = t.borderWidth = hT(i.borderWidth, +!s), r = t.xAxis, a = t.yAxis, n = i.threshold, h = hT(i.minPointLength, 5), l = t.getColumnMetrics(), d = l.width, c = t.pointXOffset = l.offset, p = t.dataMin, u = t.dataMax, g = t.translatedThreshold = a.getThreshold(n), f = t.barW = Math.max(d, 1 + 2 * o);
                i.pointPadding && i.crisp && (f = Math.ceil(f)), ay.prototype.translate.apply(t), t.points.forEach(function(s) {
                    let o = hT(s.yBottom, g), m = 999 + Math.abs(o), x = s.plotX || 0, y = hy(s.plotY, -m, a.len + m), b, v = Math.min(y, o), k = Math.max(y, o) - v, M = d, w = x + c, S = f;
                    h && Math.abs(k) < h && (k = h, b = !a.reversed && !s.negative || a.reversed && s.negative, hS(n) && hS(u) && s.y === n && u <= n && (a.min || 0) < n && (p !== u || (a.max || 0) <= n) && (b = !b, s.negative = !s.negative), v = Math.abs(v - g) > h ? o - h : g - (b ? h : 0)), hv(s.options.pointWidth) && (w -= Math.round(((M = S = Math.ceil(s.options.pointWidth)) - d) / 2)), i.centerInCategory && (w = t.adjustForMissingColumns(w, M, s, l)), s.barX = w, s.pointWidth = M, s.tooltipPos = e.inverted ? [
                        hy(a.len + a.pos - e.plotLeft - y, a.pos - e.plotLeft, a.len + a.pos - e.plotLeft),
                        r.len + r.pos - e.plotTop - w - S / 2,
                        k
                    ] : [
                        r.left - e.plotLeft + w + S / 2,
                        hy(y + a.pos - e.plotTop, a.pos - e.plotTop, a.len + a.pos - e.plotTop),
                        k
                    ], s.shapeType = t.pointClass.prototype.shapeType || "roundedRect", s.shapeArgs = t.crispCol(w, v, S, s.isNull ? 0 : k);
                }), hM(this, "afterColumnTranslate");
            }
            drawGraph() {
                this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
            }
            pointAttribs(t, e) {
                let i = this.options, s = this.pointAttrToOptions || {}, o = s.stroke || "borderColor", r = s["stroke-width"] || "borderWidth", a, n, h, l = t && t.color || this.color, d = t && t[o] || i[o] || l, c = t && t.options.dashStyle || i.dashStyle, p = t && t[r] || i[r] || this[r] || 0, u = t?.isNull && i.nullInteraction ? 0 : t?.opacity ?? i.opacity ?? 1;
                t && this.zones.length && (n = t.getZone(), l = t.options.color || n && (n.color || t.nonZonedColor) || this.color, n && (d = n.borderColor || d, c = n.dashStyle || c, p = n.borderWidth || p)), e && t && (h = (a = hA(i.states[e], t.options.states?.[e] || {})).brightness, l = a.color || void 0 !== h && hm(l).brighten(a.brightness).get() || l, d = a[o] || d, p = a[r] || p, c = a.dashStyle || c, u = hT(a.opacity, u));
                let g = {
                    fill: l,
                    stroke: d,
                    "stroke-width": p,
                    opacity: u
                };
                return c && (g.dashstyle = c), g;
            }
            drawPoints(t = this.points) {
                let e, i = this, s = this.chart, o = i.options, r = o.nullInteraction, a = s.renderer, n = o.animationLimit || 250;
                t.forEach(function(t) {
                    let h = t.plotY, l = t.graphic, d = !!l, c = l && s.pointCount < n ? "animate" : "attr";
                    hS(h) && (null !== t.y || r) ? (e = t.shapeArgs, l && t.hasNewShapeType() && (l = l.destroy()), i.enabledDataSorting && (t.startXPos = i.xAxis.reversed ? -(e && e.width || 0) : i.xAxis.width), !l && (t.graphic = l = a[t.shapeType](e).add(t.group || i.group), l && i.enabledDataSorting && s.hasRendered && s.pointCount < n && (l.attr({
                        x: t.startXPos
                    }), d = !0, c = "animate")), l && d && l[c](hA(e)), s.styledMode || l[c](i.pointAttribs(t, t.selected && "select")).shadow(!1 !== t.allowShadow && o.shadow), l && (l.addClass(t.getClassName(), !0), l.attr({
                        visibility: t.visible ? "inherit" : "hidden"
                    }))) : l && (t.graphic = l.destroy());
                });
            }
            drawTracker(t = this.points) {
                let e, i = this, s = i.chart, o = s.pointer, r = function(t) {
                    o?.normalize(t);
                    let e = o?.getPointFromEvent(t);
                    o && e && i.options.enableMouseTracking && (s.isInsidePlot(t.chartX - s.plotLeft, t.chartY - s.plotTop, {
                        visiblePlotOnly: !0
                    }) || o?.inClass(t.target, "highcharts-data-label")) && (o.isDirectTouch = !0, e.onMouseOver(t));
                };
                t.forEach(function(t) {
                    e = hw(t.dataLabels) ? t.dataLabels : t.dataLabel ? [
                        t.dataLabel
                    ] : [], t.graphic && (t.graphic.element.point = t), e.forEach(function(e) {
                        (e.div || e.element).point = t;
                    });
                }), i._hasTracking || (i.trackerGroups?.reduce((t, e)=>("dataLabelsGroup" === e ? t.push(...i.dataLabelsGroups || []) : t.push(i[e]), t), []).forEach((t)=>{
                    t && (t.addClass("highcharts-tracker").on("mouseover", r).on("mouseout", function(t) {
                        o?.onTrackerMouseOut(t);
                    }).on("touchstart", r), !s.styledMode && i.options.cursor && t.css({
                        cursor: i.options.cursor
                    }));
                }), i._hasTracking = !0), hM(this, "afterDrawTracker");
            }
            remove() {
                let t = this, e = t.chart;
                e.hasRendered && e.series.forEach(function(e) {
                    e.type === t.type && (e.isDirty = !0);
                }), ay.prototype.remove.apply(t, arguments);
            }
        }
        hP.defaultOptions = hA(ay.defaultOptions, {
            borderRadius: 3,
            centerInCategory: !1,
            groupPadding: .2,
            marker: null,
            pointPadding: .1,
            minPointLength: 0,
            cropThreshold: 50,
            pointRange: null,
            states: {
                hover: {
                    halo: !1,
                    brightness: .1
                },
                select: {
                    color: "#cccccc",
                    borderColor: "#000000"
                }
            },
            dataLabels: {
                align: void 0,
                verticalAlign: void 0,
                y: void 0
            },
            startFromThreshold: !0,
            stickyTracking: !1,
            tooltip: {
                distance: 6
            },
            threshold: 0,
            borderColor: "#ffffff"
        }), hk(hP.prototype, {
            directTouch: !0,
            getSymbol: hx,
            negStacks: !0,
            trackerGroups: [
                "group",
                "dataLabelsGroup"
            ]
        }), r_.registerSeriesType("column", hP);
        let hO = hP, { getDeferredAnimation: hE } = eo, { format: hL } = eI, { defined: hB, extend: hD, fireEvent: hI, getAlignFactor: hz, isArray: hR, isString: hN, merge: hW, objectEach: hG, pick: hX, pInt: hH, splat: hF } = tx;
        !function(t) {
            function e() {
                return h(this).some((t)=>t?.enabled);
            }
            function i(t, e, i, s, o) {
                let { chart: r, enabledDataSorting: a } = this, n = this.isCartesian && r.inverted, h = t.plotX, l = t.plotY, d = i.rotation || 0, c = hB(h) && hB(l) && r.isInsidePlot(h, Math.round(l), {
                    inverted: n,
                    paneCoordinates: !0,
                    series: this
                }), p = 0 === d && "justify" === hX(i.overflow, a ? "none" : "justify"), u = this.visible && !1 !== t.visible && hB(h) && (t.series.forceDL || a && !p || c || hX(i.inside, !!this.options.stacking) && s && r.isInsidePlot(h, n ? s.x + 1 : s.y + s.height - 1, {
                    inverted: n,
                    paneCoordinates: !0,
                    series: this
                })), g = t.pos();
                if (u && g) {
                    var f;
                    let h = e.getBBox(), l = e.getBBox(void 0, 0);
                    if (s = hD({
                        x: g[0],
                        y: Math.round(g[1]),
                        width: 0,
                        height: 0
                    }, s || {}), "plotEdges" === i.alignTo && this.isCartesian && (s[n ? "x" : "y"] = 0, s[n ? "width" : "height"] = this.yAxis?.len || 0), hD(i, {
                        width: h.width,
                        height: h.height
                    }), f = s, a && this.xAxis && !p && this.setDataLabelStartPos(t, e, o, c, f), e.align(hW(i, {
                        width: l.width,
                        height: l.height
                    }), !1, s, !1), e.alignAttr.x += hz(i.align) * (l.width - h.width), e.alignAttr.y += hz(i.verticalAlign) * (l.height - h.height), e[e.placed ? "animate" : "attr"]({
                        "text-align": e.alignAttr["text-align"] || "center",
                        x: e.alignAttr.x + (h.width - l.width) / 2,
                        y: e.alignAttr.y + (h.height - l.height) / 2,
                        rotationOriginX: (e.width || 0) / 2,
                        rotationOriginY: (e.height || 0) / 2
                    }), p && s.height >= 0) this.justifyDataLabel(e, i, e.alignAttr, h, s, o);
                    else if (hX(i.crop, !0)) {
                        let { x: t, y: i } = e.alignAttr;
                        u = r.isInsidePlot(t, i, {
                            paneCoordinates: !0,
                            series: this
                        }) && r.isInsidePlot(t + h.width - 1, i + h.height - 1, {
                            paneCoordinates: !0,
                            series: this
                        });
                    }
                    i.shape && !d && e[o ? "attr" : "animate"]({
                        anchorX: g[0],
                        anchorY: g[1]
                    });
                }
                o && a && (e.placed = !1), u || a && !p ? (e.show(), e.placed = !0) : (e.hide(), e.placed = !1);
            }
            function s(t, e) {
                hI(this, "initDataLabelsGroup", {
                    index: t,
                    zIndex: e?.zIndex ?? 6
                }), this.dataLabelsGroup = this.dataLabelsGroups?.[t];
                let i = this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", e?.zIndex ?? 6, this.dataLabelsParentGroups?.[t]);
                return this.dataLabelsGroups || (this.dataLabelsGroups = []), this.dataLabelsGroups[t] = i, this.dataLabelsGroup = this.dataLabelsGroups[0], i;
            }
            function o(t, e, i) {
                let s = !!this.hasRendered, o = this.initDataLabelsGroup(t, i).attr({
                    opacity: +s
                });
                return !s && o && (this.visible && o.show(), this.options.animation ? o.animate({
                    opacity: 1
                }, e) : o.attr({
                    opacity: 1
                })), o;
            }
            function r(t) {
                let e;
                t = t || this.points;
                let i = this, s = i.chart, o = i.options, r = s.renderer, { backgroundColor: a, plotBackgroundColor: l } = s.options.chart, d = r.getContrast(hN(l) && l || hN(a) && a || "#000000"), c = h(i), { animation: p, defer: u } = c[0], g = u ? hE(s, p, i) : {
                    defer: 0,
                    duration: 0
                };
                hI(this, "drawDataLabels"), i.hasDataLabels?.() && t.forEach((t)=>{
                    let a = t.dataLabels || [], h = t.color || i.color;
                    hF(n(c, t.dlOptions || t.options?.dataLabels)).forEach((n, l)=>{
                        e = this.initDataLabels(l, g, n);
                        let c = n.enabled && (t.visible || t.dataLabelOnHidden) && (!t.isNull || t.dataLabelOnNull) && function(t, e) {
                            let i = e.filter;
                            if (i) {
                                let e = i.operator, s = t[i.property], o = i.value;
                                return ">" === e && s > o || "<" === e && s < o || ">=" === e && s >= o || "<=" === e && s <= o || "==" === e && s == o || "===" === e && s === o || "!=" === e && s != o || "!==" === e && s !== o || !1;
                            }
                            return !0;
                        }(t, n), { backgroundColor: p, borderColor: u, distance: f, style: m = {} } = n, x, y, b, v = {}, k = a[l], M = !k, w;
                        c && (y = hB(x = hX(n[t.formatPrefix + "Format"], n.format)) ? hL(x, t, s) : (n[t.formatPrefix + "Formatter"] || n.formatter).call(t, n), b = n.rotation, !s.styledMode && (m.color = hX(n.color, m.color, hN(i.color) ? i.color : void 0, "#000000"), "contrast" === m.color ? ("none" !== p && (w = p), t.contrastColor = r.getContrast("auto" !== w && hN(w) && w || (hN(h) ? h : "")), m.color = w || !hB(f) && n.inside || 0 > hH(f || 0) || o.stacking ? t.contrastColor : d) : delete t.contrastColor, o.cursor && (m.cursor = o.cursor)), v = {
                            r: n.borderRadius || 0,
                            rotation: b,
                            padding: n.padding,
                            zIndex: 1
                        }, s.styledMode || (v.fill = "auto" === p ? t.color : p, v.stroke = "auto" === u ? t.color : u, v["stroke-width"] = n.borderWidth), hG(v, (t, e)=>{
                            void 0 === t && delete v[e];
                        })), !k || c && hB(y) && !!(k.div || k.text?.foreignObject) == !!n.useHTML && (k.rotation && n.rotation || k.rotation === n.rotation) || (k = void 0, M = !0), c && hB(y) && "" !== y && (k ? v.text = y : (k = r.label(y, 0, 0, n.shape, void 0, void 0, n.useHTML, void 0, "data-label")).addClass(" highcharts-data-label-color-" + t.colorIndex + " " + (n.className || "") + (n.useHTML ? " highcharts-tracker" : "")), k && (k.options = n, k.attr(v), s.styledMode ? m.width && k.css({
                            width: m.width,
                            textOverflow: m.textOverflow,
                            whiteSpace: m.whiteSpace
                        }) : k.css(m).shadow(n.shadow), hI(k, "beforeAddingDataLabel", {
                            labelOptions: n,
                            point: t
                        }), k.added || k.add(e), i.alignDataLabel(t, k, n, void 0, M), k.isActive = !0, a[l] && a[l] !== k && a[l].destroy(), a[l] = k));
                    });
                    let l = a.length;
                    for(; l--;)a[l]?.isActive ? a[l].isActive = !1 : (a[l]?.destroy(), a.splice(l, 1));
                    t.dataLabel = a[0], t.dataLabels = a;
                }), hI(this, "afterDrawDataLabels");
            }
            function a(t, e, i, s, o, r) {
                let a = this.chart, n = e.align, h = e.verticalAlign, l = t.box ? 0 : t.padding || 0, d = a.inverted ? this.yAxis : this.xAxis, c = d ? d.left - a.plotLeft : 0, p = a.inverted ? this.xAxis : this.yAxis, u = p ? p.top - a.plotTop : 0, { x: g = 0, y: f = 0 } = e, m, x;
                return (m = (i.x || 0) + l + c) < 0 && ("right" === n && g >= 0 ? (e.align = "left", e.inside = !0) : g -= m, x = !0), (m = (i.x || 0) + s.width - l + c) > a.plotWidth && ("left" === n && g <= 0 ? (e.align = "right", e.inside = !0) : g += a.plotWidth - m, x = !0), (m = i.y + l + u) < 0 && ("bottom" === h && f >= 0 ? (e.verticalAlign = "top", e.inside = !0) : f -= m, x = !0), (m = (i.y || 0) + s.height - l + u) > a.plotHeight && ("top" === h && f <= 0 ? (e.verticalAlign = "bottom", e.inside = !0) : f += a.plotHeight - m, x = !0), x && (e.x = g, e.y = f, t.placed = !r, t.align(e, void 0, o)), x;
            }
            function n(t, e) {
                let i = [], s;
                if (hR(t) && !hR(e)) i = t.map(function(t) {
                    return hW(t, e);
                });
                else if (hR(e) && !hR(t)) i = e.map(function(e) {
                    return hW(t, e);
                });
                else if (hR(t) || hR(e)) {
                    if (hR(t) && hR(e)) for(s = Math.max(t.length, e.length); s--;)i[s] = hW(t[s], e[s]);
                } else i = hW(t, e);
                return i;
            }
            function h(t) {
                let e = t.chart.options.plotOptions;
                return hF(n(n(e?.series?.dataLabels, e?.[t.type]?.dataLabels), t.options.dataLabels));
            }
            function l(t, e, i, s, o) {
                let r = this.chart, a = r.inverted, n = this.xAxis, h = n.reversed, l = ((a ? e.height : e.width) || 0) / 2, d = t.pointWidth, c = d ? d / 2 : 0;
                e.startXPos = a ? o.x : h ? -l - c : n.width - l + c, e.startYPos = a ? h ? this.yAxis.height - l + c : -l - c : o.y, s ? "hidden" === e.visibility && (e.show(), e.attr({
                    opacity: 0
                }).animate({
                    opacity: 1
                })) : e.attr({
                    opacity: 1
                }).animate({
                    opacity: 0
                }, void 0, e.hide), r.hasRendered && (i && e.attr({
                    x: e.startXPos,
                    y: e.startYPos
                }), e.placed = !0);
            }
            t.compose = function(t) {
                let h = t.prototype;
                h.initDataLabels || (h.initDataLabels = o, h.initDataLabelsGroup = s, h.alignDataLabel = i, h.drawDataLabels = r, h.justifyDataLabel = a, h.mergeArrays = n, h.setDataLabelStartPos = l, h.hasDataLabels = e);
            };
        }(B || (B = {}));
        let hY = B, { composed: hj } = V, { series: hU } = r_, { merge: hV, pushUnique: h$ } = tx;
        function h_(t, e, i, s, o) {
            let { chart: r, options: a } = this, n = r.inverted, h = this.xAxis?.len || r.plotSizeX || 0, l = this.yAxis?.len || r.plotSizeY || 0, d = t.dlBox || t.shapeArgs, c = t.below ?? (t.plotY || 0) > (this.translatedThreshold ?? l), p = i.inside ?? !!a.stacking;
            if (d) {
                if (s = hV(d), "allow" !== i.overflow || !1 !== i.crop || !1 !== a.clip) {
                    s.y < 0 && (s.height += s.y, s.y = 0);
                    let t = s.y + s.height - l;
                    t > 0 && t < s.height - 1 && (s.height -= t);
                }
                n && (s = {
                    x: l - s.y - s.height,
                    y: h - s.x - s.width,
                    width: s.height,
                    height: s.width
                }), p || (n ? (s.x += c ? 0 : s.width, s.width = 0) : (s.y += c ? s.height : 0, s.height = 0));
            }
            i.align ?? (i.align = !n || p ? "center" : c ? "right" : "left"), i.verticalAlign ?? (i.verticalAlign = n || p ? "middle" : c ? "top" : "bottom"), hU.prototype.alignDataLabel.call(this, t, e, i, s, o), i.inside && t.contrastColor && e.css({
                color: t.contrastColor
            });
        }
        (D || (D = {})).compose = function(t) {
            hY.compose(hU), h$(hj, "ColumnDataLabel") && (t.prototype.alignDataLabel = h_);
        };
        let hZ = D, { extend: hq, merge: hK } = tx;
        class hJ extends hO {
        }
        hJ.defaultOptions = hK(hO.defaultOptions, {}), hq(hJ.prototype, {
            inverted: !0
        }), r_.registerSeriesType("bar", hJ);
        let { column: hQ, line: h0 } = r_.seriesTypes, { addEvent: h1, extend: h2, merge: h3 } = tx;
        class h5 extends h0 {
            applyJitter() {
                let t = this, e = this.options.jitter, i = this.points.length;
                e && this.points.forEach(function(s, o) {
                    [
                        "x",
                        "y"
                    ].forEach(function(r, a) {
                        if (e[r] && !s.isNull) {
                            let n = `plot${r.toUpperCase()}`, h = t[`${r}Axis`], l = e[r] * h.transA;
                            if (h && !h.logarithmic) {
                                let t, e = Math.max(0, (s[n] || 0) - l), d = Math.min(h.len, (s[n] || 0) + l);
                                s[n] = e + (d - e) * ((t = 1e4 * Math.sin(o + a * i)) - Math.floor(t)), "x" === r && (s.clientX = s.plotX);
                            }
                        }
                    });
                });
            }
            drawGraph() {
                this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());
            }
        }
        h5.defaultOptions = h3(h0.defaultOptions, {
            lineWidth: 0,
            findNearestPointBy: "xy",
            jitter: {
                x: 0,
                y: 0
            },
            marker: {
                enabled: !0
            },
            tooltip: {
                headerFormat: '<span style="color:{point.color}">‚óè</span> <span style="font-size: 0.8em"> {series.name}</span><br/>',
                pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
            }
        }), h2(h5.prototype, {
            drawTracker: hQ.prototype.drawTracker,
            sorted: !1,
            requireSorting: !1,
            noSharedTooltip: !0,
            trackerGroups: [
                "group",
                "markerGroup",
                "dataLabelsGroup"
            ]
        }), h1(h5, "afterTranslate", function() {
            this.applyJitter();
        }), r_.registerSeriesType("scatter", h5);
        let { deg2rad: h6 } = V, { fireEvent: h9, isNumber: h4, pick: h8, relativeLength: h7 } = tx;
        (x = I || (I = {})).getCenter = function() {
            let t = this.options, e = this.chart, i = 2 * (t.slicedOffset || 0), s = e.plotWidth - 2 * i, o = e.plotHeight - 2 * i, r = t.center, a = Math.min(s, o), n = t.thickness, h, l = t.size, d = t.innerSize || 0, c, p;
            "string" == typeof l && (l = parseFloat(l)), "string" == typeof d && (d = parseFloat(d));
            let u = [
                h8(r?.[0], "50%"),
                h8(r?.[1], "50%"),
                h8(l && l < 0 ? void 0 : t.size, "100%"),
                h8(d && d < 0 ? void 0 : t.innerSize || 0, "0%")
            ];
            for(!e.angular || this instanceof ay || (u[3] = 0), c = 0; c < 4; ++c)p = u[c], h = c < 2 || 2 === c && /%$/.test(p), u[c] = h7(p, [
                s,
                o,
                a,
                u[2]
            ][c]) + (h ? i : 0);
            return u[3] > u[2] && (u[3] = u[2]), h4(n) && 2 * n < u[2] && n > 0 && (u[3] = u[2] - 2 * n), h9(this, "afterGetCenter", {
                positions: u
            }), u;
        }, x.getStartAndEndRadians = function(t, e) {
            let i = h4(t) ? t : 0, s = h4(e) && e > i && e - i < 360 ? e : i + 360;
            return {
                start: h6 * (i + -90),
                end: h6 * (s + -90)
            };
        };
        let lt = I, { setAnimation: le } = eo, { addEvent: li, defined: ls, extend: lo, isNumber: lr, pick: la, relativeLength: ln } = tx;
        class lh extends rd {
            getConnectorPath(t) {
                let e = t.dataLabelPosition, i = t.options || {}, s = i.connectorShape, o = this.connectorShapes[s] || s;
                return e && o.call(this, {
                    ...e.computed,
                    alignment: e.alignment
                }, e.connectorPosition, i) || [];
            }
            getTranslate() {
                return this.sliced && this.slicedTranslation || {
                    translateX: 0,
                    translateY: 0
                };
            }
            haloPath(t) {
                let e = this.shapeArgs;
                return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + t, e.r + t, {
                    innerR: e.r - 1,
                    start: e.start,
                    end: e.end,
                    borderRadius: e.borderRadius
                });
            }
            constructor(t, e, i){
                super(t, e, i), this.half = 0, this.name ?? (this.name = t.chart.options.lang.pieSliceName);
                const s = (t)=>{
                    this.slice("select" === t.type);
                };
                li(this, "select", s), li(this, "unselect", s);
            }
            isValid() {
                return lr(this.y) && this.y >= 0;
            }
            setVisible(t, e = !0) {
                t !== this.visible && this.update({
                    visible: t ?? !this.visible
                }, e, void 0, !1);
            }
            slice(t, e, i) {
                let s = this.series;
                le(i, s.chart), e = la(e, !0), this.sliced = this.options.sliced = t = ls(t) ? t : !this.sliced, s.options.data[s.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());
            }
        }
        lo(lh.prototype, {
            connectorShapes: {
                fixedOffset: function(t, e, i) {
                    let s = e.breakAt, o = e.touchingSliceAt, r = i.softConnector ? [
                        "C",
                        t.x + ("left" === t.alignment ? -5 : 5),
                        t.y,
                        2 * s.x - o.x,
                        2 * s.y - o.y,
                        s.x,
                        s.y
                    ] : [
                        "L",
                        s.x,
                        s.y
                    ];
                    return [
                        [
                            "M",
                            t.x,
                            t.y
                        ],
                        r,
                        [
                            "L",
                            o.x,
                            o.y
                        ]
                    ];
                },
                straight: function(t, e) {
                    let i = e.touchingSliceAt;
                    return [
                        [
                            "M",
                            t.x,
                            t.y
                        ],
                        [
                            "L",
                            i.x,
                            i.y
                        ]
                    ];
                },
                crookedLine: function(t, e, i) {
                    let { angle: s = this.angle || 0, breakAt: o, touchingSliceAt: r } = e, { series: a } = this, [n, h, l] = a.center, d = l / 2, { plotLeft: c, plotWidth: p } = a.chart, u = "left" === t.alignment, { x: g, y: f } = t, m = o.x;
                    if (i.crookDistance) {
                        let t = ln(i.crookDistance, 1);
                        m = u ? n + d + (p + c - n - d) * (1 - t) : c + (n - d) * t;
                    } else m = n + (h - f) * Math.tan(s - Math.PI / 2);
                    let x = [
                        [
                            "M",
                            g,
                            f
                        ]
                    ];
                    return (u ? m <= g && m >= o.x : m >= g && m <= o.x) && x.push([
                        "L",
                        m,
                        f
                    ]), x.push([
                        "L",
                        o.x,
                        o.y
                    ], [
                        "L",
                        r.x,
                        r.y
                    ]), x;
                }
            }
        });
        let { getStartAndEndRadians: ll } = lt, { noop: ld } = V, { clamp: lc, extend: lp, fireEvent: lu, merge: lg, pick: lf } = tx;
        class lm extends ay {
            animate(t) {
                let e = this, i = e.points, s = e.startAngleRad;
                t || i.forEach(function(t) {
                    let i = t.graphic, o = t.shapeArgs;
                    i && o && (i.attr({
                        r: lf(t.startR, e.center && e.center[3] / 2),
                        start: s,
                        end: s
                    }), i.animate({
                        r: o.r,
                        start: o.start,
                        end: o.end
                    }, e.options.animation));
                });
            }
            drawEmpty() {
                let t, e, i = this.startAngleRad, s = this.endAngleRad, o = this.options;
                0 === this.total && this.center ? (t = this.center[0], e = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t, e, this.center[1] / 2, 0, i, s).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({
                    d: iC.arc(t, e, this.center[2] / 2, 0, {
                        start: i,
                        end: s,
                        innerR: this.center[3] / 2
                    })
                }), this.chart.styledMode || this.graph.attr({
                    "stroke-width": o.borderWidth,
                    fill: o.fillColor || "none",
                    stroke: o.color || "#cccccc"
                })) : this.graph && (this.graph = this.graph.destroy());
            }
            drawPoints() {
                let t = this.chart.renderer;
                this.points.forEach(function(e) {
                    e.graphic && e.hasNewShapeType() && (e.graphic = e.graphic.destroy()), e.graphic || (e.graphic = t[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0);
                });
            }
            generatePoints() {
                super.generatePoints(), this.updateTotals();
            }
            getX(t, e, i, s) {
                let o = this.center, r = this.radii ? this.radii[i.index] || 0 : o[2] / 2, a = s.dataLabelPosition, n = a?.distance || 0, h = Math.asin(lc((t - o[1]) / (r + n), -1, 1));
                return o[0] + Math.cos(h) * (r + n) * (e ? -1 : 1) + (n > 0 ? (e ? -1 : 1) * (s.padding || 0) : 0);
            }
            hasData() {
                return this.points.some((t)=>t.visible);
            }
            redrawPoints() {
                let t, e, i, s, o = this, r = o.chart;
                this.drawEmpty(), o.group && !r.styledMode && o.group.shadow(o.options.shadow), o.points.forEach(function(a) {
                    let n = {};
                    e = a.graphic, !a.isNull && e ? (s = a.shapeArgs, t = a.getTranslate(), r.styledMode || (i = o.pointAttribs(a, a.selected && "select")), a.delayedRendering ? (e.setRadialReference(o.center).attr(s).attr(t), r.styledMode || e.attr(i).attr({
                        "stroke-linejoin": "round"
                    }), a.delayedRendering = !1) : (e.setRadialReference(o.center), r.styledMode || lg(!0, n, i), lg(!0, n, s, t), e.animate(n)), e.attr({
                        visibility: a.visible ? "inherit" : "hidden"
                    }), e.addClass(a.getClassName(), !0)) : e && (a.graphic = e.destroy());
                });
            }
            sortByAngle(t, e) {
                t.sort(function(t, i) {
                    return void 0 !== t.angle && (i.angle - t.angle) * e;
                });
            }
            translate(t) {
                lu(this, "translate"), this.generatePoints();
                let e = this.options, i = e.slicedOffset, s = ll(e.startAngle, e.endAngle), o = this.startAngleRad = s.start, r = (this.endAngleRad = s.end) - o, a = this.points, n = e.ignoreHiddenPoint, h = a.length, l, d, c, p, u, g, f, m = 0;
                for(t || (this.center = t = this.getCenter()), g = 0; g < h; g++){
                    f = a[g], l = o + m * r, f.isValid() && (!n || f.visible) && (m += f.percentage / 100), d = o + m * r;
                    let e = {
                        x: t[0],
                        y: t[1],
                        r: t[2] / 2,
                        innerR: t[3] / 2,
                        start: Math.round(1e3 * l) / 1e3,
                        end: Math.round(1e3 * d) / 1e3
                    };
                    f.shapeType = "arc", f.shapeArgs = e, (c = (d + l) / 2) > 1.5 * Math.PI ? c -= 2 * Math.PI : c < -Math.PI / 2 && (c += 2 * Math.PI), f.slicedTranslation = {
                        translateX: Math.round(Math.cos(c) * i),
                        translateY: Math.round(Math.sin(c) * i)
                    }, p = Math.cos(c) * t[2] / 2, u = Math.sin(c) * t[2] / 2, f.tooltipPos = [
                        t[0] + .7 * p,
                        t[1] + .7 * u
                    ], f.half = +(c < -Math.PI / 2 || c > Math.PI / 2), f.angle = c;
                }
                lu(this, "afterTranslate");
            }
            updateTotals() {
                let t = this.points, e = t.length, i = this.options.ignoreHiddenPoint, s, o, r = 0;
                for(s = 0; s < e; s++)(o = t[s]).isValid() && (!i || o.visible) && (r += o.y);
                for(s = 0, this.total = r; s < e; s++)(o = t[s]).percentage = r > 0 && (o.visible || !i) ? o.y / r * 100 : 0, o.total = r;
            }
        }
        lm.defaultOptions = lg(ay.defaultOptions, {
            borderRadius: 3,
            center: [
                null,
                null
            ],
            clip: !1,
            colorByPoint: !0,
            dataLabels: {
                connectorPadding: 5,
                connectorShape: "crookedLine",
                crookDistance: void 0,
                distance: 30,
                enabled: !0,
                formatter: function() {
                    return this.isNull ? void 0 : this.name;
                },
                softConnector: !0,
                x: 0
            },
            fillColor: void 0,
            ignoreHiddenPoint: !0,
            inactiveOtherPoints: !0,
            legendType: "point",
            marker: null,
            size: null,
            showInLegend: !1,
            slicedOffset: 10,
            stickyTracking: !1,
            tooltip: {
                followPointer: !0
            },
            borderColor: "#ffffff",
            borderWidth: 1,
            lineWidth: void 0,
            states: {
                hover: {
                    brightness: .1
                }
            }
        }), lp(lm.prototype, {
            axisTypes: [],
            directTouch: !0,
            drawGraph: void 0,
            drawTracker: hO.prototype.drawTracker,
            getCenter: lt.getCenter,
            getSymbol: ld,
            invertible: !1,
            isCartesian: !1,
            noSharedTooltip: !0,
            pointAttribs: hO.prototype.pointAttribs,
            pointClass: lh,
            requireSorting: !1,
            searchPoint: ld,
            trackerGroups: [
                "group",
                "dataLabelsGroup"
            ]
        }), r_.registerSeriesType("pie", lm);
        let { composed: lx, noop: ly } = V, { distribute: lb } = eX, { series: lv } = r_, { arrayMax: lk, clamp: lM, defined: lw, isNumber: lS, pick: lA, pushUnique: lT, relativeLength: lC } = tx;
        !function(t) {
            let e = {
                radialDistributionY: function(t, e) {
                    return (e.dataLabelPosition?.top || 0) + t.distributeBox.pos;
                },
                radialDistributionX: function(t, e, i, s, o) {
                    let r = o.dataLabelPosition;
                    return t.getX(i < (r?.top || 0) + 2 || i > (r?.bottom || 0) - 2 ? s : i, e.half, e, o);
                },
                justify: function(t, e, i, s) {
                    return s[0] + (t.half ? -1 : 1) * (i + (e.dataLabelPosition?.distance || 0));
                },
                alignToPlotEdges: function(t, e, i, s) {
                    let o = t.getBBox().width;
                    return e ? o + s : i - o - s;
                },
                alignToConnectors: function(t, e, i, s) {
                    let o = 0, r;
                    return t.forEach(function(t) {
                        (r = t.dataLabel.getBBox().width) > o && (o = r);
                    }), e ? o + s : i - o - s;
                }
            };
            function i(t, e) {
                let i = Math.PI / 2, { start: s = 0, end: o = 0 } = t.shapeArgs || {}, r = t.angle || 0;
                e > 0 && s < i && o > i && r > i / 2 && r < 1.5 * i && (r = r <= i ? Math.max(i / 2, (s + i) / 2) : Math.min(1.5 * i, (i + o) / 2));
                let { center: a, options: n } = this, h = a[2] / 2, l = Math.cos(r), d = Math.sin(r), c = a[0] + l * h, p = a[1] + d * h, u = Math.min((n.slicedOffset || 0) + (n.borderWidth || 0), e / 5);
                return {
                    natural: {
                        x: c + l * e,
                        y: p + d * e
                    },
                    computed: {},
                    alignment: e < 0 ? "center" : t.half ? "right" : "left",
                    connectorPosition: {
                        angle: r,
                        breakAt: {
                            x: c + l * u,
                            y: p + d * u
                        },
                        touchingSliceAt: {
                            x: c,
                            y: p
                        }
                    },
                    distance: e
                };
            }
            function s() {
                let t = this, e = t.points, i = t.chart, s = i.plotWidth, o = i.plotHeight, r = i.plotLeft, a = Math.round(i.chartWidth / 3), n = t.center, h = n[2] / 2, l = n[1], d = [
                    [],
                    []
                ], c = [
                    0,
                    0,
                    0,
                    0
                ], p = t.dataLabelPositioners, u, g, f, m = 0;
                t.visible && t.hasDataLabels?.() && (e.forEach((t)=>{
                    (t.dataLabels || []).forEach((t)=>{
                        t.shortened && (t.attr({
                            width: "auto"
                        }).css({
                            width: "auto",
                            textOverflow: "clip"
                        }), t.shortened = !1);
                    });
                }), lv.prototype.drawDataLabels.apply(t), e.forEach((t)=>{
                    (t.dataLabels || []).forEach((e, i)=>{
                        let s = n[2] / 2, o = e.options, r = lC(o?.distance || 0, s);
                        0 === i && d[t.half].push(t), !lw(o?.style?.width) && e.getBBox().width > a && (e.css({
                            width: Math.round(.7 * a) + "px"
                        }), e.shortened = !0), e.dataLabelPosition = this.getDataLabelPosition(t, r), m = Math.max(m, r);
                    });
                }), d.forEach((e, a)=>{
                    let d = e.length, u = [], x, y, b = 0, v;
                    d && (t.sortByAngle(e, a - .5), m > 0 && (x = Math.max(0, l - h - m), y = Math.min(l + h + m, i.plotHeight), e.forEach((t)=>{
                        (t.dataLabels || []).forEach((e)=>{
                            let s = e.dataLabelPosition;
                            s && s.distance > 0 && (s.top = Math.max(0, l - h - s.distance), s.bottom = Math.min(l + h + s.distance, i.plotHeight), b = e.getBBox().height || 21, e.lineHeight = i.renderer.fontMetrics(e.text || e).h + 2 * e.padding, t.distributeBox = {
                                target: (e.dataLabelPosition?.natural.y || 0) - s.top + e.lineHeight / 2,
                                size: b,
                                rank: t.y
                            }, u.push(t.distributeBox));
                        });
                    }), lb(u, v = y + b - x, v / 5)), e.forEach((i)=>{
                        (i.dataLabels || []).forEach((l)=>{
                            let d = l.options || {}, m = i.distributeBox, x = l.dataLabelPosition, y = x?.natural.y || 0, b = d.connectorPadding || 0, v = l.lineHeight || 21, k = (v - l.getBBox().height) / 2, M = 0, w = y, S = "inherit";
                            if (x) {
                                if (u && lw(m) && x.distance > 0 && (void 0 === m.pos ? S = "hidden" : (f = m.size, w = p.radialDistributionY(i, l))), d.justify) M = p.justify(i, l, h, n);
                                else switch(d.alignTo){
                                    case "connectors":
                                        M = p.alignToConnectors(e, a, s, r);
                                        break;
                                    case "plotEdges":
                                        M = p.alignToPlotEdges(l, a, s, r);
                                        break;
                                    default:
                                        M = p.radialDistributionX(t, i, w - k, y, l);
                                }
                                if (x.attribs = {
                                    visibility: S,
                                    align: x.alignment
                                }, x.posAttribs = {
                                    x: M + (d.x || 0) + (({
                                        left: b,
                                        right: -b
                                    })[x.alignment] || 0),
                                    y: w + (d.y || 0) - v / 2
                                }, x.computed.x = M, x.computed.y = w - k, lA(d.crop, !0)) {
                                    let t;
                                    M - (g = l.getBBox().width) < b && 1 === a ? (t = Math.round(g - M + b), c[3] = Math.max(t, c[3])) : M + g > s - b && 0 === a && (t = Math.round(M + g - s + b), c[1] = Math.max(t, c[1])), w - f / 2 < 0 ? c[0] = Math.max(Math.round(-w + f / 2), c[0]) : w + f / 2 > o && (c[2] = Math.max(Math.round(w + f / 2 - o), c[2])), x.sideOverflow = t;
                                }
                            }
                        });
                    }));
                }), (0 === lk(c) || this.verifyDataLabelOverflow(c)) && (this.placeDataLabels(), this.points.forEach((e)=>{
                    e.dataLabels?.forEach((s, o)=>{
                        let { connectorColor: r, connectorWidth: a = 1 } = s.options || {}, n = s.dataLabelPosition;
                        if (lS(a)) {
                            let h;
                            u = s.connector, n && n.distance > 0 ? (h = !u, u || (s.connector = u = i.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + e.colorIndex + (e.className ? " " + e.className : "")).add(t.dataLabelsGroups?.[o])), i.styledMode || u.attr({
                                "stroke-width": a,
                                stroke: r || e.color || "#666666"
                            }), u[h ? "attr" : "animate"]({
                                d: e.getConnectorPath(s)
                            }), u.attr({
                                visibility: n.attribs?.visibility
                            })) : u && (s.connector = u.destroy());
                        }
                    });
                })));
            }
            function o() {
                this.points.forEach((t)=>{
                    (t.dataLabels || []).forEach((t)=>{
                        let e = t.dataLabelPosition;
                        e ? (e.sideOverflow && (t.css({
                            width: Math.max(t.getBBox().width - e.sideOverflow, 0) + "px",
                            textOverflow: t.options?.style?.textOverflow || "ellipsis"
                        }), t.shortened = !0), t.attr(e.attribs), t[t.moved ? "animate" : "attr"](e.posAttribs), t.moved = !0) : t && t.attr({
                            y: -9999
                        });
                    }), delete t.distributeBox;
                }, this);
            }
            function r(t) {
                let e = this.center, i = this.options, s = i.center, o = i.minSize || 80, r = o, a = null !== i.size;
                return !a && (null !== s[0] ? r = Math.max(e[2] - Math.max(t[1], t[3]), o) : (r = Math.max(e[2] - t[1] - t[3], o), e[0] += (t[3] - t[1]) / 2), null !== s[1] ? r = lM(r, o, e[2] - Math.max(t[0], t[2])) : (r = lM(r, o, e[2] - t[0] - t[2]), e[1] += (t[0] - t[2]) / 2), r < e[2] ? (e[2] = r, e[3] = Math.min(i.thickness ? Math.max(0, r - 2 * i.thickness) : Math.max(0, lC(i.innerSize || 0, r)), r), this.translate(e), this.drawDataLabels && this.drawDataLabels()) : a = !0), a;
            }
            t.compose = function(t) {
                if (hY.compose(lv), lT(lx, "PieDataLabel")) {
                    let a = t.prototype;
                    a.dataLabelPositioners = e, a.alignDataLabel = ly, a.drawDataLabels = s, a.getDataLabelPosition = i, a.placeDataLabels = o, a.verifyDataLabelOverflow = r;
                }
            };
        }(z || (z = {}));
        let lP = z;
        (y = R || (R = {})).getCenterOfPoints = function(t) {
            let e = t.reduce((t, e)=>(t.x += e.x, t.y += e.y, t), {
                x: 0,
                y: 0
            });
            return {
                x: e.x / t.length,
                y: e.y / t.length
            };
        }, y.getDistanceBetweenPoints = function(t, e) {
            return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
        }, y.getAngleBetweenPoints = function(t, e) {
            return Math.atan2(e.x - t.x, e.y - t.y);
        }, y.pointInPolygon = function({ x: t, y: e }, i) {
            let s = i.length, o, r, a = !1;
            for(o = 0, r = s - 1; o < s; r = o++){
                let [s, n] = i[o], [h, l] = i[r];
                n > e != l > e && t < (h - s) * (e - n) / (l - n) + s && (a = !a);
            }
            return a;
        };
        let { pointInPolygon: lO } = R, { addEvent: lE, getAlignFactor: lL, fireEvent: lB, objectEach: lD, pick: lI } = tx;
        function lz(t, e) {
            let i, s = !1;
            return t && (i = t.newOpacity, t.oldOpacity !== i && (t.hasClass("highcharts-data-label") ? (t[i ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), s = !0, t[t.isOld ? "animate" : "attr"]({
                opacity: i
            }, void 0, function() {
                e.styledMode || t.css({
                    pointerEvents: i ? "auto" : "none"
                });
            }), lB(e, "afterHideOverlappingLabel")) : t.attr({
                opacity: i
            })), t.isOld = !0), s;
        }
        let { defaultOptions: lR } = tY, { noop: lN } = V, { addEvent: lW, extend: lG, isObject: lX, merge: lH, relativeLength: lF } = tx, lY = {
            radius: 0,
            scope: "stack",
            where: void 0
        }, lj = lN, lU = lN;
        function lV(t, e, i, s, o = {}) {
            let r = lj(t, e, i, s, o), { brStart: a = !0, brEnd: n = !0, innerR: h = 0, r: l = i, start: d = 0, end: c = 0 } = o;
            if (o.open || !o.borderRadius) return r;
            let p = c - d, u = Math.sin(p / 2), g = Math.max(Math.min(lF(o.borderRadius || 0, l - h), (l - h) / 2, l * u / (1 + u)), 0), f = Math.min(g, p / Math.PI * 2 * h), m = r.length - 1;
            for(; m--;)(a || 0 !== m && 3 !== m) && (n || 1 !== m && 2 !== m) && !function(t, e, i) {
                let s, o, r, a = t[e], n = t[e + 1];
                if ("Z" === n[0] && (n = t[0]), ("M" === a[0] || "L" === a[0]) && "A" === n[0] ? (s = a, o = n, r = !0) : "A" === a[0] && ("M" === n[0] || "L" === n[0]) && (s = n, o = a), s && o && o.params) {
                    let a = o[1], n = o[5], h = o.params, { start: l, end: d, cx: c, cy: p } = h, u = n ? a - i : a + i, g = u ? Math.asin(i / u) : 0, f = n ? g : -g, m = Math.cos(g) * u;
                    r ? (h.start = l + f, s[1] = c + m * Math.cos(l), s[2] = p + m * Math.sin(l), t.splice(e + 1, 0, [
                        "A",
                        i,
                        i,
                        0,
                        0,
                        1,
                        c + a * Math.cos(h.start),
                        p + a * Math.sin(h.start)
                    ])) : (h.end = d - f, o[6] = c + a * Math.cos(h.end), o[7] = p + a * Math.sin(h.end), t.splice(e + 1, 0, [
                        "A",
                        i,
                        i,
                        0,
                        0,
                        1,
                        c + m * Math.cos(d),
                        p + m * Math.sin(d)
                    ])), o[4] = Math.abs(h.end - h.start) < Math.PI ? 0 : 1;
                }
            }(r, m, m > 1 ? f : g);
            return r;
        }
        function l$() {
            if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {
                let { options: t, yAxis: e } = this, i = "percent" === t.stacking, s = lR.plotOptions?.[this.type]?.borderRadius, o = l_(t.borderRadius, lX(s) ? s : {}), r = e.options.reversed;
                for (let s of this.points){
                    let { shapeArgs: a } = s;
                    if ("roundedRect" === s.shapeType && a) {
                        let { width: n = 0, height: h = 0, y: l = 0 } = a, d = l, c = h;
                        if ("stack" === o.scope && s.stackTotal) {
                            let o = e.translate(i ? 100 : s.stackTotal, !1, !0, !1, !0), r = e.translate(t.threshold || 0, !1, !0, !1, !0), a = this.crispCol(0, Math.min(o, r), 0, Math.abs(o - r));
                            d = a.y, c = a.height;
                        }
                        let p = (s.negative ? -1 : 1) * (r ? -1 : 1) == -1, u = o.where;
                        !u && this.is("waterfall") && Math.abs((s.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (u = "all"), u || (u = "end");
                        let g = Math.min(lF(o.radius, n), n / 2, "all" === u ? h / 2 : 1 / 0) || 0;
                        "end" === u && (p && (d -= g), c += g), lG(a, {
                            brBoxHeight: c,
                            brBoxY: d,
                            r: g
                        });
                    }
                }
            }
        }
        function l_(t, e) {
            return lX(t) || (t = {
                radius: t || 0
            }), lH(lY, e, t);
        }
        function lZ() {
            let t = l_(this.options.borderRadius);
            for (let e of this.points){
                let i = e.shapeArgs;
                i && (i.borderRadius = lF(t.radius, (i.r || 0) - (i.innerR || 0)));
            }
        }
        function lq(t, e, i, s, o = {}) {
            let r = lU(t, e, i, s, o), { r: a = 0, brBoxHeight: n = s, brBoxY: h = e } = o, l = e - h, d = h + n - (e + s), c = l - a > -.1 ? 0 : a, p = d - a > -.1 ? 0 : a, u = Math.max(c && l, 0), g = Math.max(p && d, 0), f = [
                t + c,
                e
            ], m = [
                t + i - c,
                e
            ], x = [
                t + i,
                e + c
            ], y = [
                t + i,
                e + s - p
            ], b = [
                t + i - p,
                e + s
            ], v = [
                t + p,
                e + s
            ], k = [
                t,
                e + s - p
            ], M = [
                t,
                e + c
            ], w = (t, e)=>Math.sqrt(Math.pow(t, 2) - Math.pow(e, 2));
            if (u) {
                let t = w(c, c - u);
                f[0] -= t, m[0] += t, x[1] = M[1] = e + c - u;
            }
            if (s < c - u) {
                let o = w(c, c - u - s);
                x[0] = y[0] = t + i - c + o, b[0] = Math.min(x[0], b[0]), v[0] = Math.max(y[0], v[0]), k[0] = M[0] = t + c - o, x[1] = M[1] = e + s;
            }
            if (g) {
                let t = w(p, p - g);
                b[0] += t, v[0] -= t, y[1] = k[1] = e + s - p + g;
            }
            if (s < p - g) {
                let o = w(p, p - g - s);
                x[0] = y[0] = t + i - p + o, m[0] = Math.min(x[0], m[0]), f[0] = Math.max(y[0], f[0]), k[0] = M[0] = t + p - o, y[1] = k[1] = e;
            }
            return r.length = 0, r.push([
                "M",
                ...f
            ], [
                "L",
                ...m
            ], [
                "A",
                c,
                c,
                0,
                0,
                1,
                ...x
            ], [
                "L",
                ...y
            ], [
                "A",
                p,
                p,
                0,
                0,
                1,
                ...b
            ], [
                "L",
                ...v
            ], [
                "A",
                p,
                p,
                0,
                0,
                1,
                ...k
            ], [
                "L",
                ...M
            ], [
                "A",
                c,
                c,
                0,
                0,
                1,
                ...f
            ], [
                "Z"
            ]), r;
        }
        let { diffObjects: lK, extend: lJ, find: lQ, merge: l0, pick: l1, uniqueKey: l2 } = tx;
        function l3(t, e) {
            let i = t.condition;
            (i.callback || function() {
                return this.chartWidth <= l1(i.maxWidth, Number.MAX_VALUE) && this.chartHeight <= l1(i.maxHeight, Number.MAX_VALUE) && this.chartWidth >= l1(i.minWidth, 0) && this.chartHeight >= l1(i.minHeight, 0);
            }).call(this) && e.push(t._id);
        }
        function l5(t, e) {
            let i = this.options.responsive, s = this.currentResponsive, o = [], r;
            !e && i && i.rules && i.rules.forEach((t)=>{
                void 0 === t._id && (t._id = l2()), this.matchResponsiveRule(t, o);
            }, this);
            let a = l0(...o.map((t)=>lQ(i?.rules || [], (e)=>e._id === t)).map((t)=>t?.chartOptions));
            a.isResponsiveOptions = !0, o = o.toString() || void 0;
            let n = s?.ruleIds;
            o !== n && (s && (this.currentResponsive = void 0, this.updatingResponsive = !0, this.update(s.undoOptions, t, !0), this.updatingResponsive = !1), o ? ((r = lK(a, this.options, !0, this.collectionsWithUpdate)).isResponsiveOptions = !0, this.currentResponsive = {
                ruleIds: o,
                mergedOptions: a,
                undoOptions: r
            }, this.updatingResponsive || this.update(a, t, !0)) : this.currentResponsive = void 0);
        }
        (N || (N = {})).compose = function(t) {
            let e = t.prototype;
            return e.matchResponsiveRule || lJ(e, {
                matchResponsiveRule: l3,
                setResponsive: l5
            }), t;
        };
        let l6 = N;
        V.AST = ey, V.Axis = oo, V.Chart = ny, V.Color = tJ, V.DataLabel = hY, V.DataTableCore = rz, V.Fx = t3, V.HTMLElement = sx, V.Legend = aH, V.LegendSymbol = rH, V.PlotLineOrBand = oP, V.Point = rd, V.Pointer = rO, V.RendererRegistry = ez, V.Series = ay, V.SeriesRegistry = r_, V.StackItem = nW, V.SVGElement = ic, V.SVGRenderer = ss, V.Templating = eI, V.Tick = sN, V.Time = tN, V.Tooltip = o0, V.animate = eo.animate, V.animObject = eo.animObject, V.chart = ny.chart, V.color = tJ.parse, V.dateFormat = eI.dateFormat, V.defaultOptions = tY.defaultOptions, V.distribute = eX.distribute, V.format = eI.format, V.getDeferredAnimation = eo.getDeferredAnimation, V.getOptions = tY.getOptions, V.numberFormat = eI.numberFormat, V.seriesType = r_.seriesType, V.setAnimation = eo.setAnimation, V.setOptions = tY.setOptions, V.stop = eo.stop, V.time = tY.defaultTime, V.timers = t3.timers, ({
            compose: function(t, e, i) {
                let s = t.types.pie;
                if (!e.symbolCustomAttribs.includes("borderRadius")) {
                    let o = i.prototype.symbols;
                    lW(t, "afterColumnTranslate", l$, {
                        order: 9
                    }), lW(s, "afterTranslate", lZ), e.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY", "brEnd", "brStart"), lj = o.arc, lU = o.roundedRect, o.arc = lV, o.roundedRect = lq;
                }
            },
            optionsToObject: l_
        }).compose(V.Series, V.SVGElement, V.SVGRenderer), hZ.compose(V.Series.types.column), hY.compose(V.Series), ol.compose(V.Axis), sx.compose(V.SVGRenderer), aH.compose(V.Chart), ou.compose(V.Axis), (l = (b = V.Chart).prototype).hideOverlappingLabels || (l.hideOverlappingLabels = function(t) {
            let e = t.length, i = (t, e)=>!(e.x >= t.x + t.width || e.x + e.width <= t.x || e.y >= t.y + t.height || e.y + e.height <= t.y), s = (t, e)=>{
                for (let i of t)if (lO({
                    x: i[0],
                    y: i[1]
                }, e)) return !0;
                return !1;
            }, o, r, a, n, h, l = !1;
            for(let i = 0; i < e; i++)(o = t[i]) && (o.oldOpacity = o.opacity, o.newOpacity = 1, o.absoluteBox = function(t) {
                if (t && (!t.alignAttr || t.placed)) {
                    let e = t.box ? 0 : t.padding || 0, i = t.alignAttr || {
                        x: t.attr("x"),
                        y: t.attr("y")
                    }, { height: s, polygon: o, width: r } = t.getBBox(), a = lL(t.alignValue) * r;
                    return t.width = r, t.height = s, {
                        x: i.x + (t.parentGroup?.translateX || 0) + e - a,
                        y: i.y + (t.parentGroup?.translateY || 0) + e,
                        width: r - 2 * e,
                        height: s - 2 * e,
                        polygon: o
                    };
                }
            }(o));
            t.sort((t, e)=>(e?.labelrank || 0) - (t?.labelrank || 0));
            for(let o = 0; o < e; ++o){
                n = (r = t[o]) && r.absoluteBox;
                let l = n?.polygon;
                for(let d = o + 1; d < e; ++d){
                    h = (a = t[d]) && a.absoluteBox;
                    let e = !1;
                    if (n && h && r !== a && r?.newOpacity !== 0 && a?.newOpacity !== 0 && r?.visibility !== "hidden" && a?.visibility !== "hidden") {
                        let t = h.polygon;
                        if (l && t && l !== t ? s(l, t) && (e = !0) : i(n, h) && (e = !0), e) {
                            let t = r?.labelrank < a?.labelrank ? r : a, e = t?.text;
                            t && (t.newOpacity = 0), e?.element.querySelector("textPath") && e.hide();
                        }
                    }
                }
            }
            for (let e of t)e && lz(e, this) && (l = !0);
            l && lB(this, "afterHideAllOverlappingLabels");
        }, lE(b, "render", function() {
            let t = this, e = [];
            for (let i of t.labelCollectors || [])e = e.concat(i());
            for (let i of t.yAxis || [])i.stacking && i.options.stackLabels && !i.options.stackLabels.allowOverlap && lD(i.stacking.stacks, (t)=>{
                lD(t, (t)=>{
                    t.label && e.push(t.label);
                });
            });
            for (let i of t.series || [])if (i.visible && i.hasDataLabels?.()) {
                let s = (i)=>{
                    for (let s of i)s.visible && (s.dataLabels || []).forEach((i)=>{
                        let o = i.options || {};
                        i.labelrank = lI(o.labelrank, s.labelrank, s.shapeArgs?.height), o.allowOverlap ?? Number(o.distance) > 0 ? (i.oldOpacity = i.opacity, i.newOpacity = 1, lz(i, t)) : e.push(i);
                    });
                };
                s(i.nodes || []), s(i.points);
            }
            this.hideOverlappingLabels(e);
        })), lP.compose(V.Series.types.pie), oP.compose(V.Chart, V.Axis), rO.compose(V.Chart), l6.compose(V.Chart), nE.compose(V.Axis, V.Chart, V.Series), n5.compose(V.Axis, V.Chart, V.Series), o0.compose(V.Pointer), tx.extend(V, tx);
        let { tooltipFormatter: l9 } = rd.prototype, { addEvent: l4, arrayMax: l8, arrayMin: l7, correctFloat: dt, defined: de, isArray: di, isNumber: ds, isString: dr, pick: da } = tx;
        !function(t) {
            function e(t, e, i) {
                !this.isXAxis && (this.series.forEach(function(i) {
                    "compare" === t && "boolean" != typeof e ? i.setCompare(e, !1) : "cumulative" !== t || dr(e) || i.setCumulative(e, !1);
                }), da(i, !0) && this.chart.redraw());
            }
            function i(t) {
                let e = this, { numberFormatter: i } = e.series.chart, s = function(s) {
                    t = t.replace("{point." + s + "}", (e[s] > 0 && "change" === s ? "+" : "") + i(e[s], da(e.series.tooltipOptions.changeDecimals, 2)));
                };
                return de(e.change) && s("change"), de(e.cumulativeSum) && s("cumulativeSum"), l9.apply(this, [
                    t
                ]);
            }
            function s() {
                let t, e = this.options.linkedTo, i = this.chart;
                if (e) {
                    let t = ":previous" === e ? i.series[this.index - 1] : i.get(e);
                    t instanceof ay && (this.options.compare = da(this.userOptions.compare, t.options.compare));
                }
                let s = this.options.compare;
                ("percent" === s || "value" === s || this.options.cumulative) && (t = new d(this), "percent" === s || "value" === s ? t.initCompare(s) : t.initCumulative()), this.dataModify = t;
            }
            function o(t) {
                let e = t.dataExtremes, i = e.activeYData;
                if (this.dataModify && e) {
                    let t;
                    this.options.compare ? t = [
                        this.dataModify.modifyValue(e.dataMin),
                        this.dataModify.modifyValue(e.dataMax)
                    ] : this.options.cumulative && di(i) && i.length >= 2 && (t = d.getCumulativeExtremes(i)), t && (e.dataMin = l7(t), e.dataMax = l8(t));
                }
            }
            function r(t, e) {
                this.options.compare = this.userOptions.compare = t, this.update({}, da(e, !0)), this.dataModify && ("value" === t || "percent" === t) ? this.dataModify.initCompare(t) : this.points.forEach((t)=>{
                    delete t.change;
                });
            }
            function a() {
                let t = this.getColumn(this.pointArrayMap && (this.options.pointValKey || this.pointValKey) || "y", !0);
                if (this.xAxis && t.length && this.dataModify) {
                    let e = this.getColumn("x", !0), i = this.dataTable.rowCount, s = +(!0 !== this.options.compareStart);
                    for(let o = 0; o < i - s; o++){
                        let i = t[o];
                        if (ds(i) && 0 !== i && e[o + s] >= (this.xAxis.min || 0)) {
                            this.dataModify.compareValue = i;
                            break;
                        }
                    }
                }
            }
            function n(t, e) {
                this.setModifier("compare", t, e);
            }
            function h(t, e) {
                t = da(t, !1), this.options.cumulative = this.userOptions.cumulative = t, this.update({}, da(e, !0)), this.dataModify ? this.dataModify.initCumulative() : this.points.forEach((t)=>{
                    delete t.cumulativeSum;
                });
            }
            function l(t, e) {
                this.setModifier("cumulative", t, e);
            }
            t.compose = function(t, d, c) {
                let p = d.prototype, u = c.prototype, g = t.prototype;
                return g.setCompare || (g.setCompare = r, g.setCumulative = h, l4(t, "afterInit", s), l4(t, "afterGetExtremes", o), l4(t, "afterProcessData", a)), p.setCompare || (p.setCompare = n, p.setModifier = e, p.setCumulative = l, u.tooltipFormatter = i), t;
            };
            class d {
                constructor(t){
                    this.series = t;
                }
                modifyValue() {
                    return 0;
                }
                static getCumulativeExtremes(t) {
                    let e = 1 / 0, i = -1 / 0;
                    return t.reduce((t, s)=>{
                        let o = t + s;
                        return e = Math.min(e, o, t), i = Math.max(i, o, t), o;
                    }), [
                        e,
                        i
                    ];
                }
                initCompare(t) {
                    this.modifyValue = function(e, i) {
                        null === e && (e = 0);
                        let s = this.compareValue;
                        if (void 0 !== e && void 0 !== s) {
                            if ("value" === t ? e -= s : e = e / s * 100 - 100 * (100 !== this.series.options.compareBase), void 0 !== i) {
                                let t = this.series.points[i];
                                t && (t.change = e);
                            }
                            return e;
                        }
                        return 0;
                    };
                }
                initCumulative() {
                    this.modifyValue = function(t, e) {
                        if (null === t && (t = 0), void 0 !== t && void 0 !== e) {
                            let i = e > 0 ? this.series.points[e - 1] : null;
                            i && i.cumulativeSum && (t = dt(i.cumulativeSum + t));
                            let s = this.series.points[e], o = s.series.options.cumulativeStart, r = s.x <= this.series.xAxis.max && s.x >= this.series.xAxis.min;
                            return s && (!o || r ? s.cumulativeSum = t : s.cumulativeSum = void 0), t;
                        }
                        return 0;
                    };
                }
            }
            t.Additions = d;
        }(W || (W = {}));
        let dn = W, { isTouchDevice: dh } = V, { addEvent: dl, merge: dd, pick: dc } = tx, dp = [];
        function du() {
            this.navigator && this.navigator.setBaseSeries(null, !1);
        }
        function dg() {
            let t, e, i, s = this.legend, o = this.navigator;
            if (o) {
                t = s && s.options, e = o.xAxis, i = o.yAxis;
                let { scrollbarHeight: r, scrollButtonSize: a } = o;
                this.inverted ? (o.left = o.opposite ? this.chartWidth - r - o.height : this.spacing[3] + r, o.top = this.plotTop + a) : (o.left = dc(e.left, this.plotLeft + a), o.top = o.navigatorOptions.top || this.chartHeight - o.height - r - (this.scrollbar?.options.margin || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (t && "bottom" === t.verticalAlign && "proximate" !== t.layout && t.enabled && !t.floating ? s.legendHeight + dc(t.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0)), e && i && (this.inverted ? e.options.left = i.options.left = o.left : e.options.top = i.options.top = o.top, e.setAxisSize(), i.setAxisSize());
            }
        }
        function df(t) {
            !this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled) && (this.scroller = this.navigator = new i(this), dc(t.redraw, !0) && this.redraw(t.animation));
        }
        function dm() {
            let t = this.options;
            (t.navigator.enabled || t.scrollbar.enabled) && (this.scroller = this.navigator = new i(this));
        }
        function dx() {
            let t = this.options, e = t.navigator, i = t.rangeSelector;
            if ((e && e.enabled || i && i.enabled) && (!dh && "x" === this.zooming.type || dh && "x" === this.zooming.pinchType)) return !1;
        }
        function dy(t) {
            let e = t.navigator;
            if (e && t.xAxis[0]) {
                let i = t.xAxis[0].getExtremes();
                e.render(i.min, i.max);
            }
        }
        function db(t) {
            let e = t.options.navigator || {}, i = t.options.scrollbar || {};
            !this.navigator && !this.scroller && (e.enabled || i.enabled) && (dd(!0, this.options.navigator, e), dd(!0, this.options.scrollbar, i), delete t.options.navigator, delete t.options.scrollbar);
        }
        let dv = function(t, e) {
            if (tx.pushUnique(dp, t)) {
                let s = t.prototype;
                i = e, s.callbacks.push(dy), dl(t, "afterAddSeries", du), dl(t, "afterSetChartSize", dg), dl(t, "afterUpdate", df), dl(t, "beforeRender", dm), dl(t, "beforeShowResetZoom", dx), dl(t, "update", db);
            }
        }, { isTouchDevice: dk } = V, { addEvent: dM, correctFloat: dw, defined: dS, isNumber: dA, pick: dT } = tx;
        function dC() {
            this.navigatorAxis || (this.navigatorAxis = new dO(this));
        }
        function dP(t) {
            let e, i = this.chart, s = i.options, o = s.navigator, r = this.navigatorAxis, a = i.zooming.pinchType, n = s.rangeSelector, h = i.zooming.type;
            if (this.isXAxis && (o?.enabled || n?.enabled)) {
                if ("y" === h && "zoom" === t.trigger) e = !1;
                else if (("zoom" === t.trigger && "xy" === h || dk && "xy" === a) && this.options.range) {
                    let e = r.previousZoom;
                    dS(t.min) ? r.previousZoom = [
                        this.min,
                        this.max
                    ] : e && (t.min = e[0], t.max = e[1], r.previousZoom = void 0);
                }
            }
            void 0 !== e && t.preventDefault();
        }
        class dO {
            static compose(t) {
                t.keepProps.includes("navigatorAxis") || (t.keepProps.push("navigatorAxis"), dM(t, "init", dC), dM(t, "setExtremes", dP));
            }
            constructor(t){
                this.axis = t;
            }
            destroy() {
                this.axis = void 0;
            }
            toFixedRange(t, e, i, s) {
                let o = this.axis, r = (o.pointRange || 0) / 2, a = dT(i, o.translate(t, !0, !o.horiz)), n = dT(s, o.translate(e, !0, !o.horiz));
                return dS(i) || (a = dw(a + r)), dS(s) || (n = dw(n - r)), dA(a) && dA(n) || (a = n = void 0), {
                    min: a,
                    max: n
                };
            }
        }
        let { parse: dE } = tJ, { seriesTypes: dL } = r_, dB = {
            height: 40,
            margin: 22,
            maskInside: !0,
            handles: {
                width: 7,
                borderRadius: 0,
                height: 15,
                symbols: [
                    "navigator-handle",
                    "navigator-handle"
                ],
                enabled: !0,
                lineWidth: 1,
                backgroundColor: "#f2f2f2",
                borderColor: "#999999"
            },
            maskFill: dE("#667aff").setOpacity(.3).get(),
            outlineColor: "#999999",
            outlineWidth: 1,
            series: {
                type: void 0 === dL.areaspline ? "line" : "areaspline",
                fillOpacity: .05,
                lineWidth: 1,
                compare: null,
                sonification: {
                    enabled: !1
                },
                dataGrouping: {
                    approximation: "average",
                    enabled: !0,
                    groupPixelWidth: 2,
                    firstAnchor: "firstPoint",
                    anchor: "middle",
                    lastAnchor: "lastPoint",
                    units: [
                        [
                            "millisecond",
                            [
                                1,
                                2,
                                5,
                                10,
                                20,
                                25,
                                50,
                                100,
                                200,
                                500
                            ]
                        ],
                        [
                            "second",
                            [
                                1,
                                2,
                                5,
                                10,
                                15,
                                30
                            ]
                        ],
                        [
                            "minute",
                            [
                                1,
                                2,
                                5,
                                10,
                                15,
                                30
                            ]
                        ],
                        [
                            "hour",
                            [
                                1,
                                2,
                                3,
                                4,
                                6,
                                8,
                                12
                            ]
                        ],
                        [
                            "day",
                            [
                                1,
                                2,
                                3,
                                4
                            ]
                        ],
                        [
                            "week",
                            [
                                1,
                                2,
                                3
                            ]
                        ],
                        [
                            "month",
                            [
                                1,
                                3,
                                6
                            ]
                        ],
                        [
                            "year",
                            null
                        ]
                    ]
                },
                dataLabels: {
                    enabled: !1,
                    zIndex: 2
                },
                id: "highcharts-navigator-series",
                className: "highcharts-navigator-series",
                lineColor: null,
                marker: {
                    enabled: !1
                },
                threshold: null
            },
            xAxis: {
                className: "highcharts-navigator-xaxis",
                tickLength: 0,
                lineWidth: 0,
                gridLineColor: "#e6e6e6",
                id: "navigator-x-axis",
                gridLineWidth: 1,
                tickPixelInterval: 200,
                labels: {
                    align: "left",
                    style: {
                        color: "#000000",
                        fontSize: "0.7em",
                        opacity: .6,
                        textOutline: "2px contrast"
                    },
                    x: 3,
                    y: -4
                },
                crosshair: !1
            },
            yAxis: {
                className: "highcharts-navigator-yaxis",
                gridLineWidth: 0,
                startOnTick: !1,
                endOnTick: !1,
                minPadding: .1,
                id: "navigator-y-axis",
                maxPadding: .1,
                labels: {
                    enabled: !1
                },
                crosshair: !1,
                title: {
                    text: void 0
                },
                tickLength: 0,
                tickWidth: 0
            }
        }, { relativeLength: dD } = tx, dI = {
            "navigator-handle": function(t, e, i, s, o = {}) {
                let r = o.width ? o.width / 2 : i, a = dD(o.borderRadius || 0, Math.min(2 * r, s));
                return [
                    [
                        "M",
                        -1.5,
                        (s = o.height || s) / 2 - 3.5
                    ],
                    [
                        "L",
                        -1.5,
                        s / 2 + 4.5
                    ],
                    [
                        "M",
                        .5,
                        s / 2 - 3.5
                    ],
                    [
                        "L",
                        .5,
                        s / 2 + 4.5
                    ],
                    ...iC.rect(-r - 1, .5, 2 * r + 1, s, {
                        r: a
                    })
                ];
            }
        }, { defined: dz } = tx, dR = {
            setFixedRange: function(t) {
                let e = this.xAxis[0];
                dz(e.dataMax) && dz(e.dataMin) && t ? this.fixedRange = Math.min(t, e.dataMax - e.dataMin) : this.fixedRange = t;
            }
        }, { defaultOptions: dN } = tY, { composed: dW } = V, { getRendererType: dG } = ez, { setFixedRange: dX } = dR, { addEvent: dH, extend: dF, pushUnique: dY } = tx;
        function dj() {
            this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);
        }
        let dU = function(t, e, i) {
            dO.compose(e), dY(dW, "Navigator") && (t.prototype.setFixedRange = dX, dF(dG().prototype.symbols, dI), dF(dN, {
                navigator: dB
            }), dH(i, "afterUpdate", dj));
        }, { composed: dV } = V, { addEvent: d$, correctFloat: d_, defined: dZ, pick: dq, pushUnique: dK } = tx;
        !function(t) {
            let e;
            function i(t) {
                let e = dq(t.options?.min, t.min), i = dq(t.options?.max, t.max);
                return {
                    axisMin: e,
                    axisMax: i,
                    scrollMin: dZ(t.dataMin) ? Math.min(e, t.min ?? 1 / 0, t.dataMin, t.threshold ?? 1 / 0) : e,
                    scrollMax: t.treeGrid?.adjustedMax ?? (dZ(t.dataMax) ? Math.max(i, t.max ?? -1 / 0, t.dataMax, t.threshold ?? -1 / 0) : i)
                };
            }
            function s() {
                let t = this.scrollbar, e = t && !t.options.opposite, i = this.horiz ? 2 : e ? 3 : 1;
                t && (this.chart.scrollbarsOffsets = [
                    0,
                    0
                ], this.chart.axisOffset[i] += t.size + (t.options.margin || 0));
            }
            function o() {
                let t = this;
                t.options?.scrollbar?.enabled && (t.options.scrollbar.vertical = !t.horiz, t.options.startOnTick = t.options.endOnTick = !1, t.scrollbar = new e(t.chart.renderer, t.options.scrollbar, t.chart), d$(t.scrollbar, "changed", function(e) {
                    let s, o, { axisMin: r, axisMax: a, scrollMin: n, scrollMax: h } = i(t), l = t.toPixels(n), d = t.toPixels(h) - l;
                    if (dZ(r) && dZ(a)) if (t.horiz && !t.reversed || !t.horiz && t.reversed ? (s = Math.min(h, t.toValue(l + d * this.to)), o = Math.max(n, t.toValue(l + d * this.from))) : (s = Math.min(h, t.toValue(l + d * (1 - this.from))), o = Math.max(n, t.toValue(l + d * (1 - this.to)))), this.shouldUpdateExtremes(e.DOMType)) {
                        let i = "mousemove" !== e.DOMType && "touchmove" !== e.DOMType && void 0;
                        t.setExtremes(d_(o), d_(s), !0, i, e);
                    } else this.setRange(this.from, this.to);
                }));
            }
            function r() {
                let t, e, s, { scrollMin: o, scrollMax: r } = i(this), a = this.scrollbar, n = (this.axisTitleMargin || 0) + (this.titleOffset || 0), h = this.chart.scrollbarsOffsets, l = this.options.margin || 0;
                if (a && h) {
                    if (this.horiz) this.opposite || (h[1] += n), a.position(this.left, this.top + this.height + 2 + h[1] - (this.opposite ? l : 0), this.width, this.height), this.opposite || (h[1] += l), t = 1;
                    else {
                        let e;
                        this.opposite && (h[0] += n), e = a.options.opposite ? this.left + this.width + 2 + h[0] - (this.opposite ? 0 : l) : this.opposite ? 0 : l, a.position(e, this.top, this.width, this.height), this.opposite && (h[0] += l), t = 0;
                    }
                    if (h[t] += a.size + (a.options.margin || 0), isNaN(o) || isNaN(r) || !dZ(this.min) || !dZ(this.max) || dZ(this.dataMin) && this.dataMin === this.dataMax) a.setRange(0, 1);
                    else if (this.min === this.max) {
                        let t = this.pointRange / (this.dataMax + 1);
                        e = t * this.min, s = t * (this.max + 1), a.setRange(e, s);
                    } else e = (this.toPixels(this.min) - this.toPixels(o)) / (this.toPixels(r) - this.toPixels(o)), s = (this.toPixels(this.max) - this.toPixels(o)) / (this.toPixels(r) - this.toPixels(o)), this.horiz && !this.reversed || !this.horiz && this.reversed ? a.setRange(e, s) : a.setRange(1 - s, 1 - e);
                }
            }
            t.compose = function(t, i) {
                dK(dV, "Axis.Scrollbar") && (e = i, d$(t, "afterGetOffset", s), d$(t, "afterInit", o), d$(t, "afterRender", r));
            };
        }(G || (G = {}));
        let dJ = G, dQ = {
            height: 10,
            barBorderRadius: 5,
            buttonBorderRadius: 0,
            buttonsEnabled: !1,
            liveRedraw: void 0,
            margin: void 0,
            minWidth: 6,
            opposite: !0,
            step: .2,
            zIndex: 3,
            barBackgroundColor: "#cccccc",
            barBorderWidth: 0,
            barBorderColor: "#cccccc",
            buttonArrowColor: "#333333",
            buttonBackgroundColor: "#e6e6e6",
            buttonBorderColor: "#cccccc",
            buttonBorderWidth: 1,
            rifleColor: "none",
            trackBackgroundColor: "rgba(255, 255, 255, 0.001)",
            trackBorderColor: "#cccccc",
            trackBorderRadius: 5,
            trackBorderWidth: 1
        }, { defaultOptions: d0 } = tY, { composed: d1 } = V, { addEvent: d2, correctFloat: d3, crisp: d5, defined: d6, destroyObjectProperties: d9, extend: d4, fireEvent: d8, merge: d7, pick: ct, pushUnique: ce, removeEvent: ci } = tx;
        class cs {
            static compose(t) {
                dJ.compose(t, cs), ce(d1, "Scrollbar") && d4(d0, {
                    scrollbar: dQ
                });
            }
            static swapXY(t, e) {
                return e && t.forEach((t)=>{
                    let e, i = t.length;
                    for(let s = 0; s < i; s += 2)"number" == typeof (e = t[s + 1]) && (t[s + 1] = t[s + 2], t[s + 2] = e);
                }), t;
            }
            constructor(t, e, i){
                this._events = [], this.chartX = 0, this.chartY = 0, this.from = 0, this.scrollbarButtons = [], this.scrollbarLeft = 0, this.scrollbarStrokeWidth = 1, this.scrollbarTop = 0, this.size = 0, this.to = 0, this.trackBorderWidth = 1, this.x = 0, this.y = 0, this.init(t, e, i);
            }
            addEvents() {
                let t = this.options.inverted ? [
                    1,
                    0
                ] : [
                    0,
                    1
                ], e = this.scrollbarButtons, i = this.scrollbarGroup.element, s = this.track.element, o = this.mouseDownHandler.bind(this), r = this.mouseMoveHandler.bind(this), a = this.mouseUpHandler.bind(this), n = [
                    [
                        e[t[0]].element,
                        "click",
                        this.buttonToMinClick.bind(this)
                    ],
                    [
                        e[t[1]].element,
                        "click",
                        this.buttonToMaxClick.bind(this)
                    ],
                    [
                        s,
                        "click",
                        this.trackClick.bind(this)
                    ],
                    [
                        i,
                        "mousedown",
                        o
                    ],
                    [
                        i.ownerDocument,
                        "mousemove",
                        r
                    ],
                    [
                        i.ownerDocument,
                        "mouseup",
                        a
                    ],
                    [
                        i,
                        "touchstart",
                        o
                    ],
                    [
                        i.ownerDocument,
                        "touchmove",
                        r
                    ],
                    [
                        i.ownerDocument,
                        "touchend",
                        a
                    ]
                ];
                n.forEach(function(t) {
                    d2.apply(null, t);
                }), this._events = n;
            }
            buttonToMaxClick(t) {
                let e = (this.to - this.from) * ct(this.options.step, .2);
                this.updatePosition(this.from + e, this.to + e), d8(this, "changed", {
                    from: this.from,
                    to: this.to,
                    trigger: "scrollbar",
                    DOMEvent: t
                });
            }
            buttonToMinClick(t) {
                let e = d3(this.to - this.from) * ct(this.options.step, .2);
                this.updatePosition(d3(this.from - e), d3(this.to - e)), d8(this, "changed", {
                    from: this.from,
                    to: this.to,
                    trigger: "scrollbar",
                    DOMEvent: t
                });
            }
            cursorToScrollbarPosition(t) {
                let e = this.options, i = e.minWidth > this.calculatedWidth ? e.minWidth : 0;
                return {
                    chartX: (t.chartX - this.x - this.xOffset) / (this.barWidth - i),
                    chartY: (t.chartY - this.y - this.yOffset) / (this.barWidth - i)
                };
            }
            destroy() {
                let t = this, e = t.chart.scroller;
                t.removeEvents(), [
                    "track",
                    "scrollbarRifles",
                    "scrollbar",
                    "scrollbarGroup",
                    "group"
                ].forEach(function(e) {
                    t[e] && t[e].destroy && (t[e] = t[e].destroy());
                }), e && t === e.scrollbar && (e.scrollbar = null, d9(e.scrollbarButtons));
            }
            drawScrollbarButton(t) {
                let e = this.renderer, i = this.scrollbarButtons, s = this.options, o = this.size, r = e.g().add(this.group);
                if (i.push(r), s.buttonsEnabled) {
                    let a = e.rect().addClass("highcharts-scrollbar-button").add(r);
                    this.chart.styledMode || a.attr({
                        stroke: s.buttonBorderColor,
                        "stroke-width": s.buttonBorderWidth,
                        fill: s.buttonBackgroundColor
                    }), a.attr(a.crisp({
                        x: -.5,
                        y: -.5,
                        width: o,
                        height: o,
                        r: s.buttonBorderRadius
                    }, a.strokeWidth()));
                    let n = e.path(cs.swapXY([
                        [
                            "M",
                            o / 2 + (t ? -1 : 1),
                            o / 2 - 3
                        ],
                        [
                            "L",
                            o / 2 + (t ? -1 : 1),
                            o / 2 + 3
                        ],
                        [
                            "L",
                            o / 2 + (t ? 2 : -2),
                            o / 2
                        ]
                    ], s.vertical)).addClass("highcharts-scrollbar-arrow").add(i[t]);
                    this.chart.styledMode || n.attr({
                        fill: s.buttonArrowColor
                    });
                }
            }
            init(t, e, i) {
                this.scrollbarButtons = [], this.renderer = t, this.userOptions = e, this.options = d7(dQ, d0.scrollbar, e), this.options.margin = ct(this.options.margin, 10), this.chart = i, this.size = ct(this.options.size, this.options.height), e.enabled && (this.render(), this.addEvents());
            }
            mouseDownHandler(t) {
                let e = this.chart.pointer?.normalize(t) || t, i = this.cursorToScrollbarPosition(e);
                this.chartX = i.chartX, this.chartY = i.chartY, this.initPositions = [
                    this.from,
                    this.to
                ], this.grabbedCenter = !0;
            }
            mouseMoveHandler(t) {
                let e, i = this.chart.pointer?.normalize(t) || t, s = this.options.vertical ? "chartY" : "chartX", o = this.initPositions || [];
                this.grabbedCenter && (!t.touches || 0 !== t.touches[0][s]) && (e = this.cursorToScrollbarPosition(i)[s] - this[s], this.hasDragged = !0, this.updatePosition(o[0] + e, o[1] + e), this.hasDragged && d8(this, "changed", {
                    from: this.from,
                    to: this.to,
                    trigger: "scrollbar",
                    DOMType: t.type,
                    DOMEvent: t
                }));
            }
            mouseUpHandler(t) {
                this.hasDragged && d8(this, "changed", {
                    from: this.from,
                    to: this.to,
                    trigger: "scrollbar",
                    DOMType: t.type,
                    DOMEvent: t
                }), this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;
            }
            position(t, e, i, s) {
                let { buttonsEnabled: o, margin: r = 0, vertical: a } = this.options, n = this.rendered ? "animate" : "attr", h = s, l = 0;
                this.group.show(), this.x = t, this.y = e + this.trackBorderWidth, this.width = i, this.height = s, this.xOffset = h, this.yOffset = l, a ? (this.width = this.yOffset = i = l = this.size, this.xOffset = h = 0, this.yOffset = l = o ? this.size : 0, this.barWidth = s - (o ? 2 * i : 0), this.x = t += r) : (this.height = s = this.size, this.xOffset = h = o ? this.size : 0, this.barWidth = i - (o ? 2 * s : 0), this.y = this.y + r), this.group[n]({
                    translateX: t,
                    translateY: this.y
                }), this.track[n]({
                    width: i,
                    height: s
                }), this.scrollbarButtons[1][n]({
                    translateX: a ? 0 : i - h,
                    translateY: a ? s - l : 0
                });
            }
            removeEvents() {
                this._events.forEach(function(t) {
                    ci.apply(null, t);
                }), this._events.length = 0;
            }
            render() {
                let t = this.renderer, e = this.options, i = this.size, s = this.chart.styledMode, o = t.g("scrollbar").attr({
                    zIndex: e.zIndex
                }).hide().add();
                this.group = o, this.track = t.rect().addClass("highcharts-scrollbar-track").attr({
                    r: e.trackBorderRadius || 0,
                    height: i,
                    width: i
                }).add(o), s || this.track.attr({
                    fill: e.trackBackgroundColor,
                    stroke: e.trackBorderColor,
                    "stroke-width": e.trackBorderWidth
                });
                let r = this.trackBorderWidth = this.track.strokeWidth();
                this.track.attr({
                    x: -d5(0, r),
                    y: -d5(0, r)
                }), this.scrollbarGroup = t.g().add(o), this.scrollbar = t.rect().addClass("highcharts-scrollbar-thumb").attr({
                    height: i - r,
                    width: i - r,
                    r: e.barBorderRadius || 0
                }).add(this.scrollbarGroup), this.scrollbarRifles = t.path(cs.swapXY([
                    [
                        "M",
                        -3,
                        i / 4
                    ],
                    [
                        "L",
                        -3,
                        2 * i / 3
                    ],
                    [
                        "M",
                        0,
                        i / 4
                    ],
                    [
                        "L",
                        0,
                        2 * i / 3
                    ],
                    [
                        "M",
                        3,
                        i / 4
                    ],
                    [
                        "L",
                        3,
                        2 * i / 3
                    ]
                ], e.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup), s || (this.scrollbar.attr({
                    fill: e.barBackgroundColor,
                    stroke: e.barBorderColor,
                    "stroke-width": e.barBorderWidth
                }), this.scrollbarRifles.attr({
                    stroke: e.rifleColor,
                    "stroke-width": 1
                })), this.scrollbarStrokeWidth = this.scrollbar.strokeWidth(), this.scrollbarGroup.translate(-d5(0, this.scrollbarStrokeWidth), -d5(0, this.scrollbarStrokeWidth)), this.drawScrollbarButton(0), this.drawScrollbarButton(1);
            }
            setRange(t, e) {
                let i, s, o = this.options, r = o.vertical, a = o.minWidth, n = this.barWidth, h = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? "attr" : "animate";
                if (!d6(n)) return;
                let l = n * Math.min(e, 1);
                i = Math.ceil(n * (t = Math.max(t, 0))), this.calculatedWidth = s = d3(l - i), s < a && (i = (n - a + s) * t, s = a);
                let d = Math.floor(i + this.xOffset + this.yOffset), c = s / 2 - .5;
                this.from = t, this.to = e, r ? (this.scrollbarGroup[h]({
                    translateY: d
                }), this.scrollbar[h]({
                    height: s
                }), this.scrollbarRifles[h]({
                    translateY: c
                }), this.scrollbarTop = d, this.scrollbarLeft = 0) : (this.scrollbarGroup[h]({
                    translateX: d
                }), this.scrollbar[h]({
                    width: s
                }), this.scrollbarRifles[h]({
                    translateX: c
                }), this.scrollbarLeft = d, this.scrollbarTop = 0), s <= 12 ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(), !1 === o.showFull && (t <= 0 && e >= 1 ? this.group.hide() : this.group.show()), this.rendered = !0;
            }
            shouldUpdateExtremes(t) {
                return ct(this.options.liveRedraw, V.svg && !V.isTouchDevice && !this.chart.boosted) || "mouseup" === t || "touchend" === t || !d6(t);
            }
            trackClick(t) {
                let e = this.chart.pointer?.normalize(t) || t, i = this.to - this.from, s = this.y + this.scrollbarTop, o = this.x + this.scrollbarLeft;
                this.options.vertical && e.chartY > s || !this.options.vertical && e.chartX > o ? this.updatePosition(this.from + i, this.to + i) : this.updatePosition(this.from - i, this.to - i), d8(this, "changed", {
                    from: this.from,
                    to: this.to,
                    trigger: "scrollbar",
                    DOMEvent: t
                });
            }
            update(t) {
                this.destroy(), this.init(this.chart.renderer, d7(!0, this.options, t), this.chart);
            }
            updatePosition(t, e) {
                e > 1 && (t = d3(1 - d3(e - t)), e = 1), t < 0 && (e = d3(e - t), t = 0), this.from = t, this.to = e;
            }
        }
        cs.defaultOptions = dQ;
        let { defaultOptions: co } = tY, { isTouchDevice: cr } = V, { prototype: { symbols: ca } } = ss, { addEvent: cn, clamp: ch, correctFloat: cl, defined: cd, destroyObjectProperties: cc, erase: cp, extend: cu, find: cg, fireEvent: cf, isArray: cm, isNumber: cx, merge: cy, pick: cb, removeEvent: cv, splat: ck } = tx;
        function cM(t, ...e) {
            let i = [].filter.call(e, cx);
            if (i.length) return Math[t].apply(0, i);
        }
        class cw {
            static compose(t, e, i) {
                dv(t, cw), dU(t, e, i);
            }
            constructor(t){
                this.isDirty = !1, this.scrollbarHeight = 0, this.init(t);
            }
            drawHandle(t, e, i, s) {
                let o = this.navigatorOptions.handles.height;
                this.handles[e][s](i ? {
                    translateX: Math.round(this.left + this.height / 2),
                    translateY: Math.round(this.top + parseInt(t, 10) + .5 - o)
                } : {
                    translateX: Math.round(this.left + parseInt(t, 10)),
                    translateY: Math.round(this.top + this.height / 2 - o / 2 - 1)
                });
            }
            drawOutline(t, e, i, s) {
                let o = this.navigatorOptions.maskInside, r = this.outline.strokeWidth(), a = r / 2, n = r % 2 / 2, h = this.scrollButtonSize, l = this.size, d = this.top, c = this.height, p = d - a, u = d + c, g = this.left, f, m;
                i ? (f = d + e + n, e = d + t + n, m = [
                    [
                        "M",
                        g + c,
                        d - h - n
                    ],
                    [
                        "L",
                        g + c,
                        f
                    ],
                    [
                        "L",
                        g,
                        f
                    ],
                    [
                        "M",
                        g,
                        e
                    ],
                    [
                        "L",
                        g + c,
                        e
                    ],
                    [
                        "L",
                        g + c,
                        d + l + h
                    ]
                ], o && m.push([
                    "M",
                    g + c,
                    f - a
                ], [
                    "L",
                    g + c,
                    e + a
                ])) : (g -= h, t += g + h - n, e += g + h - n, m = [
                    [
                        "M",
                        g,
                        p
                    ],
                    [
                        "L",
                        t,
                        p
                    ],
                    [
                        "L",
                        t,
                        u
                    ],
                    [
                        "M",
                        e,
                        u
                    ],
                    [
                        "L",
                        e,
                        p
                    ],
                    [
                        "L",
                        g + l + 2 * h,
                        p
                    ]
                ], o && m.push([
                    "M",
                    t - a,
                    p
                ], [
                    "L",
                    e + a,
                    p
                ])), this.outline[s]({
                    d: m
                });
            }
            drawMasks(t, e, i, s) {
                let o, r, a, n, h = this.left, l = this.top, d = this.height;
                i ? (a = [
                    h,
                    h,
                    h
                ], n = [
                    l,
                    l + t,
                    l + e
                ], r = [
                    d,
                    d,
                    d
                ], o = [
                    t,
                    e - t,
                    this.size - e
                ]) : (a = [
                    h,
                    h + t,
                    h + e
                ], n = [
                    l,
                    l,
                    l
                ], r = [
                    t,
                    e - t,
                    this.size - e
                ], o = [
                    d,
                    d,
                    d
                ]), this.shades.forEach((t, e)=>{
                    t[s]({
                        x: a[e],
                        y: n[e],
                        width: r[e],
                        height: o[e]
                    });
                });
            }
            renderElements() {
                let t = this, e = t.navigatorOptions, i = e.maskInside, s = t.chart, o = s.inverted, r = s.renderer, a = {
                    cursor: o ? "ns-resize" : "ew-resize"
                }, n = t.navigatorGroup ?? (t.navigatorGroup = r.g("navigator").attr({
                    zIndex: 8,
                    visibility: "hidden"
                }).add());
                if ([
                    !i,
                    i,
                    !i
                ].forEach((i, o)=>{
                    let h = t.shades[o] ?? (t.shades[o] = r.rect().addClass("highcharts-navigator-mask" + (1 === o ? "-inside" : "-outside")).add(n));
                    s.styledMode || (h.attr({
                        fill: i ? e.maskFill : "rgba(0,0,0,0)"
                    }), 1 === o && h.css(a));
                }), t.outline || (t.outline = r.path().addClass("highcharts-navigator-outline").add(n)), s.styledMode || t.outline.attr({
                    "stroke-width": e.outlineWidth,
                    stroke: e.outlineColor
                }), e.handles?.enabled) {
                    let i = e.handles, { height: o, width: h } = i;
                    [
                        0,
                        1
                    ].forEach((e)=>{
                        let l = i.symbols[e];
                        if (t.handles[e] && t.handles[e].symbolUrl === l) {
                            if (!t.handles[e].isImg && t.handles[e].symbolName !== l) {
                                let i = ca[l].call(ca, -h / 2 - 1, 0, h, o);
                                t.handles[e].attr({
                                    d: i
                                }), t.handles[e].symbolName = l;
                            }
                        } else t.handles[e]?.destroy(), t.handles[e] = r.symbol(l, -h / 2 - 1, 0, h, o, i), t.handles[e].attr({
                            zIndex: 7 - e
                        }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + [
                            "left",
                            "right"
                        ][e]).add(n), t.addMouseEvents();
                        s.inverted && t.handles[e].attr({
                            rotation: 90,
                            rotationOriginX: Math.floor(-h / 2),
                            rotationOriginY: (o + h) / 2
                        }), s.styledMode || t.handles[e].attr({
                            fill: i.backgroundColor,
                            stroke: i.borderColor,
                            "stroke-width": i.lineWidth,
                            width: i.width,
                            height: i.height,
                            x: -h / 2 - 1,
                            y: 0
                        }).css(a);
                    });
                }
            }
            update(t, e = !1) {
                let i = this.chart, s = i.options.chart.inverted !== i.scrollbar?.options.vertical;
                if (cy(!0, i.options.navigator, t), this.navigatorOptions = i.options.navigator || {}, this.setOpposite(), cd(t.enabled) || s) return this.destroy(), this.navigatorEnabled = t.enabled || this.navigatorEnabled, this.init(i);
                if (this.navigatorEnabled && (this.isDirty = !0, !1 === t.adaptToUpdatedData && this.baseSeries.forEach((t)=>{
                    cv(t, "updatedData", this.updatedDataHandler);
                }, this), t.adaptToUpdatedData && this.baseSeries.forEach((t)=>{
                    t.eventsToUnbind.push(cn(t, "updatedData", this.updatedDataHandler));
                }, this), (t.series || t.baseSeries) && this.setBaseSeries(void 0, !1), t.height || t.xAxis || t.yAxis)) {
                    this.height = t.height ?? this.height;
                    let e = this.getXAxisOffsets();
                    this.xAxis.update({
                        ...t.xAxis,
                        offsets: e,
                        [i.inverted ? "width" : "height"]: this.height,
                        [i.inverted ? "height" : "width"]: void 0
                    }, !1), this.yAxis.update({
                        ...t.yAxis,
                        [i.inverted ? "width" : "height"]: this.height
                    }, !1);
                }
                e && i.redraw();
            }
            render(t, e, i, s) {
                let o = this.chart, r = this.xAxis, a = r.pointRange || 0, n = r.navigatorAxis.fake ? o.xAxis[0] : r, h = this.navigatorEnabled, l = this.rendered, d = o.inverted, c = o.xAxis[0].minRange, p = o.xAxis[0].options.maxRange, u = this.scrollButtonSize, g, f, m, x = this.scrollbarHeight, y, b;
                if (this.hasDragged && !cd(i)) return;
                if (this.isDirty && this.renderElements(), t = cl(t - a / 2), e = cl(e + a / 2), !cx(t) || !cx(e)) if (!l) return;
                else i = 0, s = cb(r.width, n.width);
                this.left = cb(r.left, o.plotLeft + u + (d ? o.plotWidth : 0));
                let v = this.size = y = cb(r.len, (d ? o.plotHeight : o.plotWidth) - 2 * u);
                g = d ? x : y + 2 * u, i = cb(i, r.toPixels(t, !0)), s = cb(s, r.toPixels(e, !0)), cx(i) && Math.abs(i) !== 1 / 0 || (i = 0, s = g);
                let k = r.toValue(i, !0), M = r.toValue(s, !0), w = Math.abs(cl(M - k));
                w < c ? this.grabbedLeft ? i = r.toPixels(M - c - a, !0) : this.grabbedRight && (s = r.toPixels(k + c + a, !0)) : cd(p) && cl(w - a) > p && (this.grabbedLeft ? i = r.toPixels(M - p - a, !0) : this.grabbedRight && (s = r.toPixels(k + p + a, !0))), this.zoomedMax = ch(Math.max(i, s), 0, v), this.zoomedMin = ch(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(i, s), 0, v), this.range = this.zoomedMax - this.zoomedMin, v = Math.round(this.zoomedMax);
                let S = Math.round(this.zoomedMin);
                h && (this.navigatorGroup.attr({
                    visibility: "inherit"
                }), b = l && !this.hasDragged ? "animate" : "attr", this.drawMasks(S, v, d, b), this.drawOutline(S, v, d, b), this.navigatorOptions.handles.enabled && (this.drawHandle(S, 0, d, b), this.drawHandle(v, 1, d, b))), this.scrollbar && (d ? (m = this.top - u, f = this.left - x + (h || !n.opposite ? 0 : (n.titleOffset || 0) + n.axisTitleMargin), x = y + 2 * u) : (m = this.top + (h ? this.height : -x), f = this.left - u), this.scrollbar.position(f, m, g, x), this.scrollbar.setRange(this.zoomedMin / (y || 1), this.zoomedMax / (y || 1))), this.rendered = !0, this.isDirty = !1, cf(this, "afterRender");
            }
            addMouseEvents() {
                let t = this, e = t.chart, i = e.container, s = [], o, r;
                t.mouseMoveHandler = o = function(e) {
                    t.onMouseMove(e);
                }, t.mouseUpHandler = r = function(e) {
                    t.onMouseUp(e);
                }, (s = t.getPartsEvents("mousedown")).push(cn(e.renderTo, "mousemove", o), cn(i.ownerDocument, "mouseup", r), cn(e.renderTo, "touchmove", o), cn(i.ownerDocument, "touchend", r)), s.concat(t.getPartsEvents("touchstart")), t.eventsToUnbind = s, t.series && t.series[0] && s.push(cn(t.series[0].xAxis, "foundExtremes", function() {
                    e.navigator.modifyNavigatorAxisExtremes();
                }));
            }
            getPartsEvents(t) {
                let e = this, i = [];
                return [
                    "shades",
                    "handles"
                ].forEach(function(s) {
                    e[s].forEach(function(o, r) {
                        i.push(cn(o.element, t, function(t) {
                            e[s + "Mousedown"](t, r);
                        }));
                    });
                }), i;
            }
            shadesMousedown(t, e) {
                t = this.chart.pointer?.normalize(t) || t;
                let i = this.chart, s = this.xAxis, o = this.zoomedMin, r = this.size, a = this.range, n = this.left, h = t.chartX, l, d, c, p;
                i.inverted && (h = t.chartY, n = this.top), 1 === e ? (this.grabbedCenter = h, this.fixedWidth = a, this.dragOffset = h - o) : (p = h - n - a / 2, 0 === e ? p = Math.max(0, p) : 2 === e && p + a >= r && (p = r - a, this.reversedExtremes ? (p -= a, d = this.getUnionExtremes().dataMin) : l = this.getUnionExtremes().dataMax), p !== o && (this.fixedWidth = a, cd((c = s.navigatorAxis.toFixedRange(p, p + a, d, l)).min) && cf(this, "setRange", {
                    min: Math.min(c.min, c.max),
                    max: Math.max(c.min, c.max),
                    redraw: !0,
                    eventArguments: {
                        trigger: "navigator"
                    }
                })));
            }
            handlesMousedown(t, e) {
                t = this.chart.pointer?.normalize(t) || t;
                let i = this.chart, s = i.xAxis[0], o = this.reversedExtremes;
                0 === e ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = o ? s.min : s.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = o ? s.max : s.min), i.setFixedRange(void 0);
            }
            onMouseMove(t) {
                let e = this, i = e.chart, s = e.navigatorSize, o = e.range, r = e.dragOffset, a = i.inverted, n = e.left, h;
                (!t.touches || 0 !== t.touches[0].pageX) && (h = (t = i.pointer?.normalize(t) || t).chartX, a && (n = e.top, h = t.chartY), e.grabbedLeft ? (e.hasDragged = !0, e.render(0, 0, h - n, e.otherHandlePos)) : e.grabbedRight ? (e.hasDragged = !0, e.render(0, 0, e.otherHandlePos, h - n)) : e.grabbedCenter && (e.hasDragged = !0, h < r ? h = r : h > s + r - o && (h = s + r - o), e.render(0, 0, h - r, h - r + o)), e.hasDragged && e.scrollbar && cb(e.scrollbar.options.liveRedraw, !cr && !this.chart.boosted) && (t.DOMType = t.type, setTimeout(function() {
                    e.onMouseUp(t);
                }, 0)));
            }
            onMouseUp(t) {
                let e, i, s, o, r, a, n = this.chart, h = this.xAxis, l = this.scrollbar, d = t.DOMEvent || t, c = n.inverted, p = this.rendered && !this.hasDragged ? "animate" : "attr";
                (this.hasDragged && (!l || !l.hasDragged) || "scrollbar" === t.trigger) && (s = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? o = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (r = this.fixedExtreme), this.zoomedMax === this.size && (r = this.reversedExtremes ? s.dataMin : s.dataMax), 0 === this.zoomedMin && (o = this.reversedExtremes ? s.dataMax : s.dataMin), cd((a = h.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, o, r)).min) && cf(this, "setRange", {
                    min: Math.min(a.min, a.max),
                    max: Math.max(a.min, a.max),
                    redraw: !0,
                    animation: !this.hasDragged && null,
                    eventArguments: {
                        trigger: "navigator",
                        triggerOp: "navigator-drag",
                        DOMEvent: d
                    }
                })), "mousemove" !== t.DOMType && "touchmove" !== t.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null), this.navigatorEnabled && cx(this.zoomedMin) && cx(this.zoomedMax) && (i = Math.round(this.zoomedMin), e = Math.round(this.zoomedMax), this.shades && this.drawMasks(i, e, c, p), this.outline && this.drawOutline(i, e, c, p), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(i, 0, c, p), this.drawHandle(e, 1, c, p)));
            }
            removeEvents() {
                this.eventsToUnbind && (this.eventsToUnbind.forEach(function(t) {
                    t();
                }), this.eventsToUnbind = void 0), this.removeBaseSeriesEvents();
            }
            removeBaseSeriesEvents() {
                let t = this.baseSeries || [];
                this.navigatorEnabled && t[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && t.forEach(function(t) {
                    cv(t, "updatedData", this.updatedDataHandler);
                }, this), t[0].xAxis && cv(t[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
            }
            getXAxisOffsets() {
                return this.chart.inverted ? [
                    this.scrollButtonSize,
                    0,
                    -this.scrollButtonSize,
                    0
                ] : [
                    0,
                    -this.scrollButtonSize,
                    0,
                    this.scrollButtonSize
                ];
            }
            init(t) {
                let e = t.options, i = e.navigator || {}, s = i.enabled, o = e.scrollbar || {}, r = o.enabled, a = s && i.height || 0, n = r && o.height || 0, h = o.buttonsEnabled && n || 0;
                this.handles = [], this.shades = [], this.chart = t, this.setBaseSeries(), this.height = a, this.scrollbarHeight = n, this.scrollButtonSize = h, this.scrollbarEnabled = r, this.navigatorEnabled = s, this.navigatorOptions = i, this.scrollbarOptions = o, this.setOpposite();
                let l = this, d = l.baseSeries, c = t.xAxis.length, p = t.yAxis.length, u = d && d[0] && d[0].xAxis || t.xAxis[0] || {
                    options: {}
                };
                if (t.isDirtyBox = !0, l.navigatorEnabled) {
                    let e = this.getXAxisOffsets();
                    l.xAxis = new oo(t, cy({
                        breaks: u.options.breaks,
                        ordinal: u.options.ordinal,
                        overscroll: u.options.overscroll
                    }, i.xAxis, {
                        type: "datetime",
                        yAxis: i.yAxis?.id,
                        index: c,
                        isInternal: !0,
                        offset: 0,
                        keepOrdinalPadding: !0,
                        startOnTick: !1,
                        endOnTick: !1,
                        minPadding: u.options.ordinal ? 0 : u.options.minPadding,
                        maxPadding: u.options.ordinal ? 0 : u.options.maxPadding,
                        zoomEnabled: !1
                    }, t.inverted ? {
                        offsets: e,
                        width: a
                    } : {
                        offsets: e,
                        height: a
                    }), "xAxis"), l.yAxis = new oo(t, cy(i.yAxis, {
                        alignTicks: !1,
                        offset: 0,
                        index: p,
                        isInternal: !0,
                        reversed: cb(i.yAxis && i.yAxis.reversed, t.yAxis[0] && t.yAxis[0].reversed, !1),
                        zoomEnabled: !1
                    }, t.inverted ? {
                        width: a
                    } : {
                        height: a
                    }), "yAxis"), d || i.series.data ? l.updateNavigatorSeries(!1) : 0 === t.series.length && (l.unbindRedraw = cn(t, "beforeRedraw", function() {
                        t.series.length > 0 && !l.series && (l.setBaseSeries(), l.unbindRedraw());
                    })), l.reversedExtremes = t.inverted && !l.xAxis.reversed || !t.inverted && l.xAxis.reversed, l.renderElements(), l.addMouseEvents();
                } else l.xAxis = {
                    chart: t,
                    navigatorAxis: {
                        fake: !0
                    },
                    translate: function(e, i) {
                        let s = t.xAxis[0], o = s.getExtremes(), r = s.len - 2 * h, a = cM("min", s.options.min, o.dataMin), n = cM("max", s.options.max, o.dataMax) - a;
                        return i ? e * n / r + a : r * (e - a) / n;
                    },
                    toPixels: function(t) {
                        return this.translate(t);
                    },
                    toValue: function(t) {
                        return this.translate(t, !0);
                    }
                }, l.xAxis.navigatorAxis.axis = l.xAxis, l.xAxis.navigatorAxis.toFixedRange = dO.prototype.toFixedRange.bind(l.xAxis.navigatorAxis);
                if (t.options.scrollbar?.enabled) {
                    let e = cy(t.options.scrollbar, {
                        vertical: t.inverted
                    });
                    cx(e.margin) || (e.margin = t.inverted ? -3 : 3), t.scrollbar = l.scrollbar = new cs(t.renderer, e, t), cn(l.scrollbar, "changed", function(t) {
                        let e = l.size, i = e * this.to, s = e * this.from;
                        l.hasDragged = l.scrollbar.hasDragged, l.render(0, 0, s, i), this.shouldUpdateExtremes(t.DOMType) && setTimeout(function() {
                            l.onMouseUp(t);
                        });
                    });
                }
                l.addBaseSeriesEvents(), l.addChartEvents();
            }
            setOpposite() {
                let t = this.navigatorOptions, e = this.navigatorEnabled, i = this.chart;
                this.opposite = cb(t.opposite, !!(!e && i.inverted));
            }
            getUnionExtremes(t) {
                let e, i = this.chart.xAxis[0], s = this.chart.time, o = this.xAxis, r = o.options, a = i.options;
                return t && null === i.dataMin || (e = {
                    dataMin: cb(s.parse(r?.min), cM("min", s.parse(a.min), i.dataMin, o.dataMin, o.min)),
                    dataMax: cb(s.parse(r?.max), cM("max", s.parse(a.max), i.dataMax, o.dataMax, o.max))
                }), e;
            }
            setBaseSeries(t, e) {
                let i = this.chart, s = this.baseSeries = [];
                t = t || i.options && i.options.navigator.baseSeries || (i.series.length ? cg(i.series, (t)=>!t.options.isInternal).index : 0), (i.series || []).forEach((e, i)=>{
                    !e.options.isInternal && (e.options.showInNavigator || (i === t || e.options.id === t) && !1 !== e.options.showInNavigator) && s.push(e);
                }), this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, e);
            }
            updateNavigatorSeries(t, e) {
                let i = this, s = i.chart, o = i.baseSeries, r = {
                    enableMouseTracking: !1,
                    index: null,
                    linkedTo: null,
                    group: "nav",
                    padXAxis: !1,
                    xAxis: this.navigatorOptions.xAxis?.id,
                    yAxis: this.navigatorOptions.yAxis?.id,
                    showInLegend: !1,
                    stacking: void 0,
                    isInternal: !0,
                    states: {
                        inactive: {
                            opacity: 1
                        }
                    }
                }, a = i.series = (i.series || []).filter((t)=>{
                    let e = t.baseSeries;
                    return !(0 > o.indexOf(e)) || (e && (cv(e, "updatedData", i.updatedDataHandler), delete e.navigatorSeries), t.chart && t.destroy(), !1);
                }), n, h, l = i.navigatorOptions.series, d;
                o && o.length && o.forEach((t)=>{
                    let c = t.navigatorSeries, p = cu({
                        color: t.color,
                        visible: t.visible
                    }, cm(l) ? co.navigator.series : l);
                    if (c && !1 === i.navigatorOptions.adaptToUpdatedData) return;
                    r.name = "Navigator " + o.length, d = (n = t.options || {}).navigatorOptions || {}, p.dataLabels = ck(p.dataLabels), (h = cy(n, r, p, d)).pointRange = cb(p.pointRange, d.pointRange, co.plotOptions[h.type || "line"].pointRange);
                    let u = d.data || p.data;
                    i.hasNavigatorData = i.hasNavigatorData || !!u, h.data = u || n.data?.slice(0), c && c.options ? c.update(h, e) : (t.navigatorSeries = s.initSeries(h), s.setSortedData(), t.navigatorSeries.baseSeries = t, a.push(t.navigatorSeries));
                }), (l.data && !(o && o.length) || cm(l)) && (i.hasNavigatorData = !1, (l = ck(l)).forEach((t, e)=>{
                    r.name = "Navigator " + (a.length + 1), (h = cy(co.navigator.series, {
                        color: s.series[e] && !s.series[e].options.isInternal && s.series[e].color || s.options.colors[e] || s.options.colors[0]
                    }, r, t)).data = t.data, h.data && (i.hasNavigatorData = !0, a.push(s.initSeries(h)));
                })), t && this.addBaseSeriesEvents();
            }
            addBaseSeriesEvents() {
                let t = this, e = t.baseSeries || [];
                e[0] && e[0].xAxis && e[0].eventsToUnbind.push(cn(e[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes)), e.forEach((i)=>{
                    i.eventsToUnbind.push(cn(i, "show", function() {
                        this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);
                    })), i.eventsToUnbind.push(cn(i, "hide", function() {
                        this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);
                    })), !1 !== this.navigatorOptions.adaptToUpdatedData && i.xAxis && i.eventsToUnbind.push(cn(i, "updatedData", this.updatedDataHandler)), i.eventsToUnbind.push(cn(i, "remove", function() {
                        e && cp(e, i), this.navigatorSeries && t.series && (cp(t.series, this.navigatorSeries), cd(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);
                    }));
                });
            }
            getBaseSeriesMin(t) {
                return this.baseSeries.reduce(function(t, e) {
                    return Math.min(t, e.getColumn("x")[0] ?? t);
                }, t);
            }
            modifyNavigatorAxisExtremes() {
                let t = this.xAxis;
                if (void 0 !== t.getExtremes) {
                    let e = this.getUnionExtremes(!0);
                    e && (e.dataMin !== t.min || e.dataMax !== t.max) && (t.min = e.dataMin, t.max = e.dataMax);
                }
            }
            modifyBaseAxisExtremes() {
                let t, e, i = this.chart.navigator, s = this.getExtremes(), o = s.min, r = s.max, a = s.dataMin, n = s.dataMax, h = r - o, l = i.stickToMin, d = i.stickToMax, c = cb(this.ordinal?.convertOverscroll(this.options.overscroll), 0), p = i.series && i.series[0], u = !!this.setExtremes;
                !(this.eventArgs && "rangeSelectorButton" === this.eventArgs.trigger) && (l && (t = (e = a) + h), d && (t = n + c, l || (e = Math.max(a, t - h, i.getBaseSeriesMin(p && p.xData ? p.xData[0] : -Number.MAX_VALUE)))), u && (l || d) && cx(e) && (this.min = this.userMin = e, this.max = this.userMax = t)), i.stickToMin = i.stickToMax = null;
            }
            updatedDataHandler() {
                let t = this.chart.navigator, e = this.navigatorSeries, i = t.reversedExtremes ? 0 === Math.round(t.zoomedMin) : Math.round(t.zoomedMax) >= Math.round(t.size);
                t.stickToMax = cb(this.chart.options.navigator && this.chart.options.navigator.stickToMax, i), t.stickToMin = t.shouldStickToMin(this, t), e && !t.hasNavigatorData && (e.options.pointStart = this.getColumn("x")[0], e.setData(this.options.data, !1, null, !1));
            }
            shouldStickToMin(t, e) {
                let i = e.getBaseSeriesMin(t.getColumn("x")[0]), s = t.xAxis, o = s.max, r = s.min, a = s.options.range;
                return !!(cx(o) && cx(r)) && (a && o - i > 0 ? o - i < a : r <= i);
            }
            addChartEvents() {
                this.eventsToUnbind || (this.eventsToUnbind = []), this.eventsToUnbind.push(cn(this.chart, "redraw", function() {
                    let t = this.navigator, e = t && (t.baseSeries && t.baseSeries[0] && t.baseSeries[0].xAxis || this.xAxis[0]);
                    e && t.render(e.min, e.max);
                }), cn(this.chart, "getMargins", function() {
                    let t = this.navigator, e = t.opposite ? "plotTop" : "marginBottom";
                    this.inverted && (e = t.opposite ? "marginRight" : "plotLeft"), this[e] = (this[e] || 0) + (t.navigatorEnabled || !this.inverted ? t.height + (this.scrollbar?.options.margin || 0) + t.scrollbarHeight : 0) + (t.navigatorOptions.margin || 0);
                }), cn(cw, "setRange", function(t) {
                    this.chart.xAxis[0].setExtremes(t.min, t.max, t.redraw, t.animation, t.eventArguments);
                }));
            }
            destroy() {
                this.removeEvents(), this.xAxis && (cp(this.chart.xAxis, this.xAxis), cp(this.chart.axes, this.xAxis)), this.yAxis && (cp(this.chart.yAxis, this.yAxis), cp(this.chart.axes, this.yAxis)), (this.series || []).forEach((t)=>{
                    t.destroy && t.destroy();
                }), [
                    "series",
                    "xAxis",
                    "yAxis",
                    "shades",
                    "outline",
                    "scrollbarTrack",
                    "scrollbarRifles",
                    "scrollbarGroup",
                    "scrollbar",
                    "navigatorGroup",
                    "rendered"
                ].forEach((t)=>{
                    this[t] && this[t].destroy && this[t].destroy(), this[t] = null;
                }), [
                    this.handles
                ].forEach((t)=>{
                    cc(t);
                }), this.baseSeries.forEach((t)=>{
                    t.navigatorSeries = void 0;
                }), this.navigatorEnabled = !1;
            }
        }
        let { addEvent: cS, correctFloat: cA, css: cT, defined: cC, error: cP, isNumber: cO, pick: cE, timeUnits: cL, isString: cB } = tx;
        !function(t) {
            function e(t, i, s, o, r = [], a = 0, n) {
                let h = {}, l = this.options.tickPixelInterval, d = this.chart.time, c = [], p, u, g, f, m, x = 0, y = [], b = -Number.MAX_VALUE;
                if (!this.options.ordinal && !this.options.breaks || !r || r.length < 3 || void 0 === i) return d.getTimeTicks.apply(d, arguments);
                let v = r.length;
                for(p = 0; p < v; p++){
                    if (m = p && r[p - 1] > s, r[p] < i && (x = p), p === v - 1 || r[p + 1] - r[p] > 5 * a || m) {
                        if (r[p] > b) {
                            for(u = d.getTimeTicks(t, r[x], r[p], o); u.length && u[0] <= b;)u.shift();
                            u.length && (b = u[u.length - 1]), c.push(y.length), y = y.concat(u);
                        }
                        x = p + 1;
                    }
                    if (m) break;
                }
                if (u) {
                    if (f = u.info, n && f.unitRange <= cL.hour) {
                        for(x = 1, p = y.length - 1; x < p; x++)d.dateFormat("%d", y[x]) !== d.dateFormat("%d", y[x - 1]) && (h[y[x]] = "day", g = !0);
                        g && (h[y[0]] = "day"), f.higherRanks = h;
                    }
                    f.segmentStarts = c, y.info = f;
                } else cP(12, !1, this.chart);
                if (n && cC(l)) {
                    let t = y.length, e = [], i = [], o, r, a, n, d, c = t;
                    for(; c--;)r = this.translate(y[c]), a && (i[c] = a - r), e[c] = a = r;
                    for(i.sort((t, e)=>t - e), (n = i[Math.floor(i.length / 2)]) < .6 * l && (n = null), c = y[t - 1] > s ? t - 1 : t, a = void 0; c--;)d = Math.abs(a - (r = e[c])), a && d < .8 * l && (null === n || d < .8 * n) ? (h[y[c]] && !h[y[c + 1]] ? (o = c + 1, a = r) : o = c, y.splice(o, 1)) : a = r;
                }
                return y;
            }
            function i(t) {
                let e = this.ordinal.positions;
                if (!e) return t;
                let i = e.length - 1, s;
                return (t < 0 ? t = e[0] : t > i ? t = e[i] : (i = Math.floor(t), s = t - i), void 0 !== s && void 0 !== e[i]) ? e[i] + (s ? s * (e[i + 1] - e[i]) : 0) : t;
            }
            function s(t) {
                let e = this.ordinal, i = this.old ? this.old.min : this.min, s = this.old ? this.old.transA : this.transA, o = e.getExtendedPositions();
                if (o?.length) {
                    let r = cA((t - i) * s + this.minPixelPadding), a = cA(e.getIndexOfPoint(r, o)), n = cA(a % 1);
                    if (a >= 0 && a <= o.length - 1) {
                        let t = o[Math.floor(a)], e = o[Math.ceil(a)];
                        return o[Math.floor(a)] + n * (e - t);
                    }
                }
                return t;
            }
            function o(e, i) {
                let s = t.Additions.findIndexOf(e, i, !0);
                if (e[s] === i) return s;
                let o = (i - e[s]) / (e[s + 1] - e[s]);
                return s + o;
            }
            function r() {
                this.ordinal || (this.ordinal = new t.Additions(this));
            }
            function a() {
                let { eventArgs: t, options: e } = this;
                if (this.isXAxis && cC(e.overscroll) && 0 !== e.overscroll && cO(this.max) && cO(this.min) && (this.options.ordinal && !this.ordinal.originalOrdinalRange && this.ordinal.getExtendedPositions(!1), this.isFullRange = cC(this.dataMin) && cC(this.dataMax) && this.max - this.min == this.dataMax - this.dataMin, this.max === this.dataMax && (t?.trigger !== "pan" || this.isInternal) && t?.trigger !== "navigator")) {
                    let i = this.ordinal.convertOverscroll(e.overscroll);
                    this.max += i, !this.isInternal && cC(this.userMin) && t?.trigger !== "mousewheel" && (this.min += i);
                }
            }
            function n() {
                this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);
            }
            function h() {
                this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));
            }
            function l(t) {
                let e = this.xAxis[0], i = e.ordinal.convertOverscroll(e.options.overscroll), s = t.originalEvent.chartX, o = this.options.chart.panning, r = !1;
                if (o?.type !== "y" && e.options.ordinal && e.series.length && (!t.touches || t.touches.length <= 1)) {
                    let o, a, n = this.mouseDownX, h = e.getExtremes(), l = h.dataMin, d = h.dataMax, c = h.min, p = h.max, u = this.hoverPoints, g = e.closestPointRange || e.ordinal?.overscrollPointsRange, f = Math.round((n - s) / (e.translationSlope * (e.ordinal.slope || g))), m = e.ordinal.getExtendedPositions(), x = {
                        ordinal: {
                            positions: m,
                            extendedOrdinalPositions: m
                        }
                    }, y = e.index2val, b = e.val2lin;
                    if (c <= l && f <= 0 || p >= d + i && f >= 0) return void t.preventDefault();
                    x.ordinal.positions ? Math.abs(f) > 1 && (u && u.forEach(function(t) {
                        t.setState();
                    }), a = x.ordinal.positions, i && (a = x.ordinal.positions = a.concat(e.ordinal.getOverscrollPositions())), d > a[a.length - 1] && a.push(d), this.setFixedRange(p - c), (o = e.navigatorAxis.toFixedRange(void 0, void 0, y.apply(x, [
                        b.apply(x, [
                            c,
                            !0
                        ]) + f
                    ]), y.apply(x, [
                        b.apply(x, [
                            p,
                            !0
                        ]) + f
                    ]))).min >= Math.min(a[0], c) && o.max <= Math.max(a[a.length - 1], p) + i && e.setExtremes(o.min, o.max, !0, !1, {
                        trigger: "pan"
                    }), this.mouseDownX = s, cT(this.container, {
                        cursor: "move"
                    })) : r = !0;
                } else r = !0;
                r || o && /y/.test(o.type) ? i && cO(e.dataMax) && (e.max = e.dataMax + i) : t.preventDefault();
            }
            function d() {
                let t = this.xAxis;
                t?.options.ordinal && (delete t.ordinal.index, delete t.ordinal.originalOrdinalRange);
            }
            function c(t, e) {
                let i, s = this.ordinal, r = s.positions, a = s.slope, n;
                if (!r) return t;
                let h = r.length;
                if (r[0] <= t && r[h - 1] >= t) i = o(r, t);
                else {
                    if (n = s.getExtendedPositions?.(), !n?.length) return t;
                    let h = n.length;
                    a || (a = (n[h - 1] - n[0]) / h);
                    let l = o(n, r[0]);
                    if (t >= n[0] && t <= n[h - 1]) i = o(n, t) - l;
                    else {
                        if (!e) return t;
                        i = t < n[0] ? -l - (n[0] - t) / a : (t - n[h - 1]) / a + h - l;
                    }
                }
                return e ? i : a * (i || 0) + s.offset;
            }
            t.compose = function(t, o, p) {
                let u = t.prototype;
                return u.ordinal2lin || (u.getTimeTicks = e, u.index2val = i, u.lin2val = s, u.val2lin = c, u.ordinal2lin = u.val2lin, cS(t, "afterInit", r), cS(t, "foundExtremes", a), cS(t, "afterSetScale", n), cS(t, "initialAxisTranslation", h), cS(p, "pan", l), cS(p, "touchpan", l), cS(o, "updatedData", d)), t;
            }, t.Additions = class {
                constructor(t){
                    this.index = {}, this.axis = t;
                }
                beforeSetTickPositions() {
                    let t = this.axis, e = t.ordinal, i = t.getExtremes(), s = i.min, o = i.max, r = t.brokenAxis?.hasBreaks, a = t.options.ordinal, n = t.options.overscroll && t.ordinal.convertOverscroll(t.options.overscroll) || 0, h, l, d, c, p, u, g, f = [], m = Number.MAX_VALUE, x = !1, y = !1, b = !1;
                    if (a || r) {
                        let i = 0;
                        if (t.series.forEach(function(t, e) {
                            let s = t.getColumn("x", !0);
                            if (l = [], e > 0 && "highcharts-navigator-series" !== t.options.id && s.length > 1 && (y = i !== s[1] - s[0]), i = s[1] - s[0], t.boosted && (b = t.boosted), t.reserveSpace() && (!1 !== t.takeOrdinalPosition || r) && (h = (f = f.concat(s)).length, f.sort(function(t, e) {
                                return t - e;
                            }), m = Math.min(m, cE(t.closestPointRange, m)), h)) {
                                for(e = 0; e < h - 1;)f[e] !== f[e + 1] && l.push(f[e + 1]), e++;
                                l[0] !== f[0] && l.unshift(f[0]), f = l;
                            }
                        }), t.ordinal.originalOrdinalRange || (t.ordinal.originalOrdinalRange = (f.length - 1) * m), y && b && (f.pop(), f.shift()), (h = f.length) > 2) {
                            for(d = f[1] - f[0], g = h - 1; g-- && !x;)f[g + 1] - f[g] !== d && (x = !0);
                            !t.options.keepOrdinalPadding && (f[0] - s > d || o - n - f[h - 1] > d) && (x = !0);
                        } else t.options.overscroll && (2 === h ? m = f[1] - f[0] : 1 === h ? (m = n, f = [
                            f[0],
                            f[0] + m
                        ]) : m = e.overscrollPointsRange);
                        x || t.forceOrdinal ? (t.options.overscroll && (e.overscrollPointsRange = m, f = f.concat(e.getOverscrollPositions())), e.positions = f, c = t.ordinal2lin(Math.max(s, f[0]), !0), p = Math.max(t.ordinal2lin(Math.min(o, f[f.length - 1]), !0), 1), e.slope = u = (o - s) / (p - c), e.offset = s - c * u) : (e.overscrollPointsRange = cE(t.closestPointRange, e.overscrollPointsRange), e.positions = t.ordinal.slope = e.offset = void 0);
                    }
                    t.isOrdinal = a && x, e.groupIntervalFactor = null;
                }
                static findIndexOf(t, e, i) {
                    let s = 0, o = t.length - 1, r;
                    for(; s < o;)t[r = Math.ceil((s + o) / 2)] <= e ? s = r : o = r - 1;
                    return t[s] === e || i ? s : -1;
                }
                getExtendedPositions(t = !0) {
                    let e = this, i = e.axis, s = i.constructor.prototype, o = i.chart, r = i.series.reduce((t, e)=>{
                        let i = e.currentDataGrouping;
                        return t + (i ? i.count + i.unitName : "raw");
                    }, ""), a = t ? i.ordinal.convertOverscroll(i.options.overscroll) : 0, n = i.getExtremes(), h, l, d = e.index;
                    return d || (d = e.index = {}), !d[r] && ((h = {
                        series: [],
                        chart: o,
                        forceOrdinal: !1,
                        getExtremes: function() {
                            return {
                                min: n.dataMin,
                                max: n.dataMax + a
                            };
                        },
                        applyGrouping: s.applyGrouping,
                        getGroupPixelWidth: s.getGroupPixelWidth,
                        getTimeTicks: s.getTimeTicks,
                        options: {
                            ordinal: !0
                        },
                        ordinal: {
                            getGroupIntervalFactor: this.getGroupIntervalFactor
                        },
                        ordinal2lin: s.ordinal2lin,
                        getIndexOfPoint: s.getIndexOfPoint,
                        val2lin: s.val2lin
                    }).ordinal.axis = h, i.series.forEach((i)=>{
                        if (!1 === i.takeOrdinalPosition) return;
                        l = {
                            xAxis: h,
                            chart: o,
                            groupPixelWidth: i.groupPixelWidth,
                            destroyGroupedData: V.noop,
                            getColumn: i.getColumn,
                            applyGrouping: i.applyGrouping,
                            getProcessedData: i.getProcessedData,
                            reserveSpace: i.reserveSpace,
                            visible: i.visible
                        };
                        let s = i.getColumn("x").concat(t ? e.getOverscrollPositions() : []);
                        l.dataTable = new rz({
                            columns: {
                                x: s
                            }
                        }), l.options = {
                            ...i.options,
                            dataGrouping: i.currentDataGrouping ? {
                                firstAnchor: i.options.dataGrouping?.firstAnchor,
                                anchor: i.options.dataGrouping?.anchor,
                                lastAnchor: i.options.dataGrouping?.firstAnchor,
                                enabled: !0,
                                forced: !0,
                                approximation: "open",
                                units: [
                                    [
                                        i.currentDataGrouping.unitName,
                                        [
                                            i.currentDataGrouping.count
                                        ]
                                    ]
                                ]
                            } : {
                                enabled: !1
                            }
                        }, h.series.push(l), i.processData.apply(l);
                    }), h.applyGrouping({
                        hasExtremesChanged: !0
                    }), l?.closestPointRange !== l?.basePointRange && l.currentDataGrouping && (h.forceOrdinal = !0), i.ordinal.beforeSetTickPositions.apply({
                        axis: h
                    }), !i.ordinal.originalOrdinalRange && h.ordinal.originalOrdinalRange && (i.ordinal.originalOrdinalRange = h.ordinal.originalOrdinalRange), h.ordinal.positions && (d[r] = h.ordinal.positions)), d[r];
                }
                getGroupIntervalFactor(t, e, i) {
                    let s = i.getColumn("x", !0), o = s.length, r = [], a, n, h = this.groupIntervalFactor;
                    if (!h) {
                        for(n = 0; n < o - 1; n++)r[n] = s[n + 1] - s[n];
                        r.sort(function(t, e) {
                            return t - e;
                        }), a = r[Math.floor(o / 2)], t = Math.max(t, s[0]), e = Math.min(e, s[o - 1]), this.groupIntervalFactor = h = o * a / (e - t);
                    }
                    return h;
                }
                getIndexOfPoint(t, e) {
                    let i = this.axis, s = i.min, r = i.minPixelPadding;
                    return o(e, s) + cA((t - r) / (i.translationSlope * (this.slope || i.closestPointRange || this.overscrollPointsRange)));
                }
                getOverscrollPositions() {
                    let t = this.axis, e = this.convertOverscroll(t.options.overscroll), i = this.overscrollPointsRange, s = [], o = t.dataMax;
                    if (cC(i)) for(; o < t.dataMax + e;)s.push(o += i);
                    return s;
                }
                postProcessTickInterval(t) {
                    let e = this.axis, i = this.slope, s = e.closestPointRange;
                    return i && s ? e.options.breaks ? s || t : t / (i / s) : t;
                }
                convertOverscroll(t = 0) {
                    let e = this, i = e.axis, s = function(t) {
                        return cE(e.originalOrdinalRange, cC(i.dataMax) && cC(i.dataMin) ? i.dataMax - i.dataMin : 0) * t;
                    };
                    if (cB(t)) {
                        let e = parseInt(t, 10);
                        if (!1 === i.isFullRange && cO(i.min) && cO(i.max) && (this.originalOrdinalRange = i.max - i.min), /%$/.test(t)) return s(e / 100);
                        if (/px/.test(t)) {
                            let t = Math.min(e, .9 * i.len) / i.len;
                            return s(t / (i.isFullRange ? 1 - t : 1));
                        }
                        return 0;
                    }
                    return t;
                }
            };
        }(X || (X = {}));
        let cD = X, cI = {
            rangeSelectorZoom: "Zoom",
            rangeSelectorFrom: "",
            rangeSelectorTo: "‚Üí",
            rangeSelector: {
                allText: "All",
                allTitle: "View all",
                monthText: "{count}m",
                monthTitle: "View {count} {#eq count 1}month{else}months{/eq}",
                yearText: "{count}y",
                yearTitle: "View {count} {#eq count 1}year{else}years{/eq}",
                ytdText: "YTD",
                ytdTitle: "View year to date"
            }
        }, cz = {
            allButtonsEnabled: !1,
            buttons: [
                {
                    type: "month",
                    count: 1
                },
                {
                    type: "month",
                    count: 3
                },
                {
                    type: "month",
                    count: 6
                },
                {
                    type: "ytd"
                },
                {
                    type: "year",
                    count: 1
                },
                {
                    type: "all"
                }
            ],
            buttonSpacing: 5,
            dropdown: "responsive",
            enabled: void 0,
            verticalAlign: "top",
            buttonTheme: {
                width: 28,
                height: 18,
                padding: 2,
                zIndex: 7
            },
            floating: !1,
            x: 0,
            y: 0,
            height: void 0,
            inputBoxBorderColor: "none",
            inputBoxHeight: 17,
            inputBoxWidth: void 0,
            inputDateFormat: "%[ebY]",
            inputDateParser: void 0,
            inputEditDateFormat: "%Y-%m-%d",
            inputEnabled: !0,
            inputPosition: {
                align: "right",
                x: 0,
                y: 0
            },
            inputSpacing: 5,
            selected: void 0,
            buttonPosition: {
                align: "left",
                x: 0,
                y: 0
            },
            inputStyle: {
                color: "#334eff",
                cursor: "pointer",
                fontSize: "0.8em"
            },
            labelStyle: {
                color: "#666666",
                fontSize: "0.8em"
            }
        }, { defaultOptions: cR } = tY, { composed: cN } = V, { addEvent: cW, defined: cG, extend: cX, isNumber: cH, merge: cF, pick: cY, pushUnique: cj } = tx, cU = [];
        function cV() {
            let t, e, i = this.range, s = i.type, o = this.max, r = this.chart.time, a = function(t, e) {
                let i = r.toParts(t), o = i.slice();
                "year" === s ? o[0] += e : o[1] += e;
                let a = r.makeTime.apply(r, o), n = r.toParts(a);
                return "month" === s && i[1] === n[1] && 1 === Math.abs(e) && (o[0] = i[0], o[1] = i[1], o[2] = 0), (a = r.makeTime.apply(r, o)) - t;
            };
            cH(i) ? (t = o - i, e = i) : i && (t = o + a(o, -(i.count || 1)), this.chart && this.chart.setFixedRange(o - t));
            let n = cY(this.dataMin, 5e-324);
            return cH(t) || (t = n), t <= n && (t = n, void 0 === e && (e = a(t, i.count)), this.newMax = Math.min(t + e, cY(this.dataMax, Number.MAX_VALUE))), cH(o) ? !cH(i) && i && i._offsetMin && (t += i._offsetMin) : t = void 0, t;
        }
        function c$() {
            this.rangeSelector?.redrawElements();
        }
        function c_() {
            this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new s(this));
        }
        function cZ() {
            let t = this.rangeSelector;
            if (t) {
                cH(t.deferredYTDClick) && (t.clickButton(t.deferredYTDClick), delete t.deferredYTDClick);
                let e = t.options.verticalAlign;
                t.options.floating || ("bottom" === e ? this.extraBottomMargin = !0 : "top" === e && (this.extraTopMargin = !0));
            }
        }
        function cq() {
            let t, e = this.rangeSelector;
            if (!e) return;
            let i = this.xAxis[0].getExtremes(), s = this.legend, o = e && e.options.verticalAlign;
            cH(i.min) && e.render(i.min, i.max), s.display && "top" === o && o === s.options.verticalAlign && (t = cF(this.spacingBox), "vertical" === s.options.layout ? t.y = this.plotTop : t.y += e.getHeight(), s.group.placed = !1, s.align(t));
        }
        function cK() {
            for(let t = 0, e = cU.length; t < e; ++t){
                let e = cU[t];
                if (e[0] === this) {
                    e[1].forEach((t)=>t()), cU.splice(t, 1);
                    return;
                }
            }
        }
        function cJ() {
            let t = this.rangeSelector;
            if (t?.options?.enabled) {
                let { min: e, max: i } = this.xAxis[0].getExtremes();
                cH(e) && t.inputGroup && t.inputGroup.getBBox().width < 20 && t.render(e, i);
                let s = t.getHeight(), o = t.options.verticalAlign;
                t.options.floating || ("bottom" === o ? this.marginBottom += s : "middle" !== o && (this.plotTop += s));
            }
        }
        function cQ(t) {
            let e = t.options.rangeSelector, i = this.extraBottomMargin, o = this.extraTopMargin, r = this.rangeSelector;
            if (e && e.enabled && !cG(r) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = r = new s(this)), this.extraBottomMargin = !1, this.extraTopMargin = !1, r) {
                let t = e && e.verticalAlign || r.options && r.options.verticalAlign;
                r.options.floating || ("bottom" === t ? this.extraBottomMargin = !0 : "middle" !== t && (this.extraTopMargin = !0)), (this.extraBottomMargin !== i || this.extraTopMargin !== o) && (this.isDirtyBox = !0);
            }
        }
        let c0 = function(t, e, i) {
            if (s = i, cj(cN, "RangeSelector")) {
                let i = e.prototype;
                t.prototype.minFromRange = cV, cW(e, "afterGetContainer", c_), cW(e, "beforeRender", cZ), cW(e, "destroy", cK), cW(e, "getMargins", cJ), cW(e, "redraw", cq), cW(e, "update", cQ), cW(e, "beforeRedraw", c$), i.callbacks.push(cq), cX(cR, {
                    rangeSelector: cz
                }), cX(cR.lang, cI);
            }
        }, { defaultOptions: c1 } = tY, { format: c2 } = eI, { addEvent: c3, createElement: c5, css: c6, defined: c9, destroyObjectProperties: c4, discardElement: c8, extend: c7, fireEvent: pt, isNumber: pe, isString: pi, merge: ps, objectEach: po, pick: pr, splat: pa } = tx;
        function pn(t) {
            let e = (e)=>RegExp(`%[[a-zA-Z]*${e}`).test(t);
            if (pi(t) ? -1 !== t.indexOf("%L") : t.fractionalSecondDigits) return "text";
            let i = pi(t) ? [
                "a",
                "A",
                "d",
                "e",
                "w",
                "b",
                "B",
                "m",
                "o",
                "y",
                "Y"
            ].some(e) : t.dateStyle || t.day || t.month || t.year, s = pi(t) ? [
                "H",
                "k",
                "I",
                "l",
                "M",
                "S"
            ].some(e) : t.timeStyle || t.hour || t.minute || t.second;
            return i && s ? "datetime-local" : i ? "date" : s ? "time" : "text";
        }
        class ph {
            static compose(t, e) {
                c0(t, e, ph);
            }
            constructor(t){
                this.isDirty = !1, this.buttonOptions = [], this.initialButtonGroupWidth = 0, this.maxButtonWidth = ()=>{
                    let t = 0;
                    return this.buttons.forEach((e)=>{
                        let i = e.getBBox();
                        i.width > t && (t = i.width);
                    }), t;
                }, this.init(t);
            }
            clickButton(t, e) {
                let i = this.chart, s = this.buttonOptions[t], o = i.xAxis[0], r = i.scroller && i.scroller.getUnionExtremes() || o || {}, a = s.type, n = s.dataGrouping, h = r.dataMin, l = r.dataMax, d, c = pe(o?.max) ? Math.round(Math.min(o.max, l ?? o.max)) : void 0, p, u = s._range, g, f, m, x = !0;
                if (null !== h && null !== l) {
                    if (this.setSelected(t), n && (this.forcedDataGrouping = !0, oo.prototype.setDataGrouping.call(o || {
                        chart: this.chart
                    }, n, !1), this.frozenStates = s.preserveDataGrouping), "month" === a || "year" === a) o ? (f = {
                        range: s,
                        max: c,
                        chart: i,
                        dataMin: h,
                        dataMax: l
                    }, d = o.minFromRange.call(f), pe(f.newMax) && (c = f.newMax), x = !1) : u = s;
                    else if (u) pe(c) && (c = Math.min((d = Math.max(c - u, h)) + u, l), x = !1);
                    else if ("ytd" === a) if (o) !o.hasData() || pe(l) && pe(h) || (h = Number.MAX_VALUE, l = -Number.MAX_VALUE, i.series.forEach((t)=>{
                        let e = t.getColumn("x");
                        e.length && (h = Math.min(e[0], h), l = Math.max(e[e.length - 1], l));
                    }), e = !1), pe(l) && pe(h) && (d = g = (m = this.getYTDExtremes(l, h)).min, c = m.max);
                    else {
                        this.deferredYTDClick = t;
                        return;
                    }
                    else "all" === a && o && (i.navigator && i.navigator.baseSeries[0] && (i.navigator.baseSeries[0].xAxis.options.range = void 0), d = h, c = l);
                    if (x && s._offsetMin && c9(d) && (d += s._offsetMin), s._offsetMax && c9(c) && (c += s._offsetMax), this.dropdown && (this.dropdown.selectedIndex = t + 1), o) (pe(d) || pe(c)) && (o.setExtremes(d, c, pr(e, !0), void 0, {
                        trigger: "rangeSelectorButton",
                        rangeSelectorButton: s
                    }), i.setFixedRange(s._range));
                    else {
                        p = pa(i.options.xAxis || {})[0];
                        let t = c3(i, "afterCreateAxes", function() {
                            let t = i.xAxis[0];
                            t.range = t.options.range = u, t.min = t.options.min = g;
                        });
                        c3(i, "load", function() {
                            let e = i.xAxis[0];
                            i.setFixedRange(s._range), e.options.range = p.range, e.options.min = p.min, t();
                        });
                    }
                    pt(this, "afterBtnClick");
                }
            }
            setSelected(t) {
                this.selected = this.options.selected = t;
            }
            init(t) {
                let e = this, i = t.options.rangeSelector, s = t.options.lang, o = i.buttons, r = i.selected, a = function() {
                    let t = e.minInput, i = e.maxInput;
                    t && t.blur && pt(t, "blur"), i && i.blur && pt(i, "blur");
                };
                e.chart = t, e.options = i, e.buttons = [], e.buttonOptions = o.map((t)=>(t.type && s.rangeSelector && (t.text ?? (t.text = s.rangeSelector[`${t.type}Text`]), t.title ?? (t.title = s.rangeSelector[`${t.type}Title`])), t.text = c2(t.text, {
                        count: t.count || 1
                    }), t.title = c2(t.title, {
                        count: t.count || 1
                    }), t)), this.eventsToUnbind = [], this.eventsToUnbind.push(c3(t.container, "mousedown", a)), this.eventsToUnbind.push(c3(t, "resize", a)), o.forEach(e.computeButtonRange), void 0 !== r && o[r] && this.clickButton(r, !1), this.eventsToUnbind.push(c3(t, "load", function() {
                    t.xAxis && t.xAxis[0] && c3(t.xAxis[0], "setExtremes", function(i) {
                        pe(this.max) && pe(this.min) && this.max - this.min !== t.fixedRange && "rangeSelectorButton" !== i.trigger && "updatedData" !== i.trigger && e.forcedDataGrouping && !e.frozenStates && this.setDataGrouping(!1, !1);
                    });
                })), this.createElements();
            }
            updateButtonStates() {
                let t = this, e = this.chart, i = this.dropdown, s = this.dropdownLabel, o = e.xAxis[0], r = Math.round(o.max - o.min), a = !o.hasVisibleSeries, n = 24 * 36e5, h = e.scroller && e.scroller.getUnionExtremes() || o, l = h.dataMin, d = h.dataMax, c = t.getYTDExtremes(d, l), p = c.min, u = c.max, g = t.selected, f = t.options.allButtonsEnabled, m = Array(t.buttonOptions.length).fill(0), x = pe(g), y = t.buttons, b = !1, v = null;
                t.buttonOptions.forEach((e, i)=>{
                    let s = e._range, h = e.type, c = e.count || 1, y = e._offsetMax - e._offsetMin, k = i === g, M = s > d - l, w = s < o.minRange, S = !1, A = s === r;
                    if (k && M && (b = !0), o.isOrdinal && o.ordinal?.positions && s && r < s) {
                        let t = o.ordinal.positions;
                        t[t.length - 1] - t[0] > s && (A = !0);
                    } else ("month" === h || "year" === h) && r + 36e5 >= ({
                        month: 28,
                        year: 365
                    })[h] * n * c - y && r - 36e5 <= ({
                        month: 31,
                        year: 366
                    })[h] * n * c + y ? A = !0 : "ytd" === h ? (A = u - p + y === r, S = !k) : "all" === h && (A = o.max - o.min >= d - l);
                    let T = !f && !(b && "all" === h) && (M || w || a), C = b && "all" === h || !S && A || k && t.frozenStates;
                    T ? m[i] = 3 : C && (!x || i === g) && (v = i);
                }), null !== v ? (m[v] = 2, t.setSelected(v), this.dropdown && (this.dropdown.selectedIndex = v + 1)) : (t.setSelected(), this.dropdown && (this.dropdown.selectedIndex = -1), s && (s.setState(0), s.attr({
                    text: (c1.lang.rangeSelectorZoom || "") + " ‚ñæ"
                })));
                for(let e = 0; e < m.length; e++){
                    let o = m[e], r = y[e];
                    if (r.state !== o && (r.setState(o), i)) {
                        i.options[e + 1].disabled = 3 === o, 2 === o && (s && (s.setState(2), s.attr({
                            text: t.buttonOptions[e].text + " ‚ñæ"
                        })), i.selectedIndex = e + 1);
                        let r = s.getBBox();
                        c6(i, {
                            width: `${r.width}px`,
                            height: `${r.height}px`
                        });
                    }
                }
            }
            computeButtonRange(t) {
                let e = t.type, i = t.count || 1, s = {
                    millisecond: 1,
                    second: 1e3,
                    minute: 6e4,
                    hour: 36e5,
                    day: 864e5,
                    week: 6048e5
                };
                s[e] ? t._range = s[e] * i : ("month" === e || "year" === e) && (t._range = 24 * ({
                    month: 30,
                    year: 365
                })[e] * 36e5 * i), t._offsetMin = pr(t.offsetMin, 0), t._offsetMax = pr(t.offsetMax, 0), t._range += t._offsetMax - t._offsetMin;
            }
            getInputValue(t) {
                let e = "min" === t ? this.minInput : this.maxInput, i = this.chart.options.rangeSelector, s = this.chart.time;
                return e ? ("text" === e.type && i.inputDateParser || this.defaultInputDateParser)(e.value, "UTC" === s.timezone, s) : 0;
            }
            setInputValue(t, e) {
                let i = this.options, s = this.chart.time, o = "min" === t ? this.minInput : this.maxInput, r = "min" === t ? this.minDateBox : this.maxDateBox;
                if (o) {
                    o.setAttribute("type", pn(i.inputDateFormat || "%e %b %Y"));
                    let t = o.getAttribute("data-hc-time"), a = c9(t) ? Number(t) : void 0;
                    if (c9(e)) {
                        let t = a;
                        c9(t) && o.setAttribute("data-hc-time-previous", t), o.setAttribute("data-hc-time", e), a = e;
                    }
                    o.value = s.dateFormat(this.inputTypeFormats[o.type] || i.inputEditDateFormat, a), r && r.attr({
                        text: s.dateFormat(i.inputDateFormat, a)
                    });
                }
            }
            setInputExtremes(t, e, i) {
                let s = "min" === t ? this.minInput : this.maxInput;
                if (s) {
                    let t = this.inputTypeFormats[s.type], o = this.chart.time;
                    if (t) {
                        let r = o.dateFormat(t, e);
                        s.min !== r && (s.min = r);
                        let a = o.dateFormat(t, i);
                        s.max !== a && (s.max = a);
                    }
                }
            }
            showInput(t) {
                let e = "min" === t ? this.minDateBox : this.maxDateBox, i = "min" === t ? this.minInput : this.maxInput;
                if (i && e && this.inputGroup) {
                    let t = "text" === i.type, { translateX: s = 0, translateY: o = 0 } = this.inputGroup, { x: r = 0, width: a = 0, height: n = 0 } = e, { inputBoxWidth: h } = this.options;
                    c6(i, {
                        width: t ? a + (h ? -2 : 20) + "px" : "auto",
                        height: n - 2 + "px",
                        border: "2px solid silver"
                    }), t && h ? c6(i, {
                        left: s + r + "px",
                        top: o + "px"
                    }) : c6(i, {
                        left: Math.min(Math.round(r + s - (i.offsetWidth - a) / 2), this.chart.chartWidth - i.offsetWidth) + "px",
                        top: o - (i.offsetHeight - n) / 2 + "px"
                    });
                }
            }
            hideInput(t) {
                let e = "min" === t ? this.minInput : this.maxInput;
                e && c6(e, {
                    top: "-9999em",
                    border: 0,
                    width: "1px",
                    height: "1px"
                });
            }
            defaultInputDateParser(t, e, i) {
                return i?.parse(t) || 0;
            }
            drawInput(t) {
                let { chart: e, div: i, inputGroup: s } = this, o = this, r = e.renderer.style || {}, a = e.renderer, n = e.options.rangeSelector, h = c1.lang, l = "min" === t;
                function d(t) {
                    let { maxInput: i, minInput: s } = o, r = e.xAxis[0], a = e.scroller?.getUnionExtremes() || r, n = a.dataMin, h = a.dataMax, d = e.xAxis[0].getExtremes()[t], c = o.getInputValue(t);
                    pe(c) && c !== d && (l && i && pe(n) ? c > Number(i.getAttribute("data-hc-time")) ? c = void 0 : c < n && (c = n) : s && pe(h) && (c < Number(s.getAttribute("data-hc-time")) ? c = void 0 : c > h && (c = h)), void 0 !== c && r.setExtremes(l ? c : r.min, l ? r.max : c, void 0, void 0, {
                        trigger: "rangeSelectorInput"
                    }));
                }
                let c = h[l ? "rangeSelectorFrom" : "rangeSelectorTo"] || "", p = a.label(c, 0).addClass("highcharts-range-label").attr({
                    padding: 2 * !!c,
                    height: c ? n.inputBoxHeight : 0
                }).add(s), u = a.label("", 0).addClass("highcharts-range-input").attr({
                    padding: 2,
                    width: n.inputBoxWidth,
                    height: n.inputBoxHeight,
                    "text-align": "center"
                }).on("click", function() {
                    o.showInput(t), o[t + "Input"].focus();
                });
                e.styledMode || u.attr({
                    stroke: n.inputBoxBorderColor,
                    "stroke-width": 1
                }), u.add(s);
                let g = c5("input", {
                    name: t,
                    className: "highcharts-range-selector"
                }, void 0, i);
                g.setAttribute("type", pn(n.inputDateFormat || "%e %b %Y")), e.styledMode || (p.css(ps(r, n.labelStyle)), u.css(ps({
                    color: "#333333"
                }, r, n.inputStyle)), c6(g, c7({
                    position: "absolute",
                    border: 0,
                    boxShadow: "0 0 15px rgba(0,0,0,0.3)",
                    width: "1px",
                    height: "1px",
                    padding: 0,
                    textAlign: "center",
                    fontSize: r.fontSize,
                    fontFamily: r.fontFamily,
                    top: "-9999em"
                }, n.inputStyle))), g.onfocus = ()=>{
                    o.showInput(t);
                }, g.onblur = ()=>{
                    g === V.doc.activeElement && d(t), o.hideInput(t), o.setInputValue(t), g.blur();
                };
                let f = !1;
                return g.onchange = ()=>{
                    f || (d(t), o.hideInput(t), g.blur());
                }, g.onkeypress = (e)=>{
                    13 === e.keyCode && d(t);
                }, g.onkeydown = (e)=>{
                    f = !0, ("ArrowUp" === e.key || "ArrowDown" === e.key || "Tab" === e.key) && d(t);
                }, g.onkeyup = ()=>{
                    f = !1;
                }, {
                    dateBox: u,
                    input: g,
                    label: p
                };
            }
            getPosition() {
                let t = this.chart, e = t.options.rangeSelector, i = "top" === e.verticalAlign ? t.plotTop - t.axisOffset[0] : 0;
                return {
                    buttonTop: i + e.buttonPosition.y,
                    inputTop: i + e.inputPosition.y - 10
                };
            }
            getYTDExtremes(t, e) {
                let i = this.chart.time, s = i.toParts(t)[0];
                return {
                    max: t,
                    min: Math.max(e, i.makeTime(s, 0))
                };
            }
            createElements() {
                let t = this.chart, e = t.renderer, i = t.container, s = t.options, o = s.rangeSelector, r = o.inputEnabled, a = pr(s.chart.style?.zIndex, 0) + 1;
                !1 !== o.enabled && (this.group = e.g("range-selector-group").attr({
                    zIndex: 7
                }).add(), this.div = c5("div", void 0, {
                    position: "relative",
                    height: 0,
                    zIndex: a
                }), this.buttonOptions.length && this.renderButtons(), i.parentNode && i.parentNode.insertBefore(this.div, i), r && this.createInputs());
            }
            createInputs() {
                this.inputGroup = this.chart.renderer.g("input-group").add(this.group);
                let t = this.drawInput("min");
                this.minDateBox = t.dateBox, this.minLabel = t.label, this.minInput = t.input;
                let e = this.drawInput("max");
                this.maxDateBox = e.dateBox, this.maxLabel = e.label, this.maxInput = e.input;
            }
            render(t, e) {
                if (!1 === this.options.enabled) return;
                let i = this.chart, s = i.options.rangeSelector;
                if (s.inputEnabled) {
                    this.inputGroup || this.createInputs(), this.setInputValue("min", t), this.setInputValue("max", e), this.chart.styledMode || (this.maxLabel?.css(s.labelStyle), this.minLabel?.css(s.labelStyle));
                    let o = i.scroller && i.scroller.getUnionExtremes() || i.xAxis[0] || {};
                    if (c9(o.dataMin) && c9(o.dataMax)) {
                        let t = i.xAxis[0].minRange || 0;
                        this.setInputExtremes("min", o.dataMin, Math.min(o.dataMax, this.getInputValue("max")) - t), this.setInputExtremes("max", Math.max(o.dataMin, this.getInputValue("min")) + t, o.dataMax);
                    }
                    if (this.inputGroup) {
                        let t = 0;
                        [
                            this.minLabel,
                            this.minDateBox,
                            this.maxLabel,
                            this.maxDateBox
                        ].forEach((e)=>{
                            if (e) {
                                let { width: i } = e.getBBox();
                                i && (e.attr({
                                    x: t
                                }), t += i + s.inputSpacing);
                            }
                        });
                    }
                } else this.inputGroup && (this.inputGroup.destroy(), delete this.inputGroup);
                !this.chart.styledMode && this.zoomText && this.zoomText.css(s.labelStyle), this.alignElements(), this.updateButtonStates();
            }
            renderButtons() {
                var t;
                let { chart: e, options: i } = this, s = c1.lang, o = e.renderer, r = ps(i.buttonTheme), a = r && r.states;
                delete r.width, delete r.states, this.buttonGroup = o.g("range-selector-buttons").add(this.group);
                let n = this.dropdown = c5("select", void 0, {
                    position: "absolute",
                    padding: 0,
                    border: 0,
                    cursor: "pointer",
                    opacity: 1e-4
                }, this.div), h = e.userOptions.rangeSelector?.buttonTheme;
                this.dropdownLabel = o.button("", 0, 0, ()=>{}, ps(r, {
                    "stroke-width": pr(r["stroke-width"], 0),
                    width: "auto",
                    paddingLeft: pr(i.buttonTheme.paddingLeft, h?.padding, 8),
                    paddingRight: pr(i.buttonTheme.paddingRight, h?.padding, 8)
                }), a && a.hover, a && a.select, a && a.disabled).hide().add(this.group), c3(n, "touchstart", ()=>{
                    n.style.fontSize = "16px";
                });
                let l = V.isMS ? "mouseover" : "mouseenter", d = V.isMS ? "mouseout" : "mouseleave";
                c3(n, l, ()=>{
                    pt(this.dropdownLabel.element, l);
                }), c3(n, d, ()=>{
                    pt(this.dropdownLabel.element, d);
                }), c3(n, "change", ()=>{
                    pt(this.buttons[n.selectedIndex - 1].element, "click");
                }), this.zoomText = o.label(s.rangeSelectorZoom || "", 0).attr({
                    padding: i.buttonTheme.padding,
                    height: i.buttonTheme.height,
                    paddingLeft: 0,
                    paddingRight: 0
                }).add(this.buttonGroup), this.chart.styledMode || (this.zoomText.css(i.labelStyle), (t = i.buttonTheme)["stroke-width"] ?? (t["stroke-width"] = 0)), c5("option", {
                    textContent: this.zoomText.textStr,
                    disabled: !0
                }, void 0, n), this.createButtons();
            }
            createButtons() {
                let { options: t } = this, e = ps(t.buttonTheme), i = e && e.states, s = e.width || 28;
                delete e.width, delete e.states, this.buttonOptions.forEach((t, e)=>{
                    this.createButton(t, e, s, i);
                });
            }
            createButton(t, e, i, s) {
                let { dropdown: o, buttons: r, chart: a, options: n } = this, h = a.renderer, l = ps(n.buttonTheme);
                o?.add(c5("option", {
                    textContent: t.title || t.text
                }), e + 2), r[e] = h.button(t.text ?? "", 0, 0, (i)=>{
                    let s, o = t.events && t.events.click;
                    o && (s = o.call(t, i)), !1 !== s && this.clickButton(e), this.isActive = !0;
                }, l, s && s.hover, s && s.select, s && s.disabled).attr({
                    "text-align": "center",
                    width: i
                }).add(this.buttonGroup), t.title && r[e].attr("title", t.title);
            }
            alignElements() {
                let { buttonGroup: t, buttons: e, chart: i, group: s, inputGroup: o, options: r, zoomText: a } = this, n = i.options, h = n.exporting && !1 !== n.exporting.enabled && n.navigation && n.navigation.buttonOptions, { buttonPosition: l, inputPosition: d, verticalAlign: c } = r, p = (t, e, s)=>h && this.titleCollision(i) && "top" === c && s && e.y - t.getBBox().height - 12 < (h.y || 0) + (h.height || 0) + i.spacing[0] ? -40 : 0, u = i.plotLeft;
                if (s && l && d) {
                    let n = l.x - i.spacing[3];
                    if (t) {
                        if (this.positionButtons(), !this.initialButtonGroupWidth) {
                            let t = 0;
                            a && (t += a.getBBox().width + 5), e.forEach((i, s)=>{
                                t += i.width || 0, s !== e.length - 1 && (t += r.buttonSpacing);
                            }), this.initialButtonGroupWidth = t;
                        }
                        u -= i.spacing[3];
                        let o = p(t, l, "right" === l.align || "right" === d.align);
                        this.alignButtonGroup(o), this.buttonGroup?.translateY && this.dropdownLabel.attr({
                            y: this.buttonGroup.translateY
                        }), s.placed = t.placed = i.hasLoaded;
                    }
                    let h = 0;
                    r.inputEnabled && o && (h = p(o, d, "right" === l.align || "right" === d.align), "left" === d.align ? n = u : "right" === d.align && (n = -Math.max(i.axisOffset[1], -h)), o.align({
                        y: d.y,
                        width: o.getBBox().width,
                        align: d.align,
                        x: d.x + n - 2
                    }, !0, i.spacingBox), o.placed = i.hasLoaded), this.handleCollision(h), s.align({
                        verticalAlign: c
                    }, !0, i.spacingBox);
                    let g = s.alignAttr.translateY, f = s.getBBox().height + 20, m = 0;
                    if ("bottom" === c) {
                        let t = i.legend && i.legend.options;
                        m = g - (f = f + (t && "bottom" === t.verticalAlign && t.enabled && !t.floating ? i.legend.legendHeight + pr(t.margin, 10) : 0) - 20) - (r.floating ? 0 : r.y) - (i.titleOffset ? i.titleOffset[2] : 0) - 10;
                    }
                    "top" === c ? (r.floating && (m = 0), i.titleOffset && i.titleOffset[0] && (m = i.titleOffset[0]), m += i.margin[0] - i.spacing[0] || 0) : "middle" === c && (d.y === l.y ? m = g : (d.y || l.y) && (d.y < 0 || l.y < 0 ? m -= Math.min(d.y, l.y) : m = g - f)), s.translate(r.x, r.y + Math.floor(m));
                    let { minInput: x, maxInput: y, dropdown: b } = this;
                    r.inputEnabled && x && y && (x.style.marginTop = s.translateY + "px", y.style.marginTop = s.translateY + "px"), b && (b.style.marginTop = s.translateY + "px");
                }
            }
            redrawElements() {
                let t = this.chart, { inputBoxHeight: e, inputBoxBorderColor: i } = this.options;
                if (this.maxDateBox?.attr({
                    height: e
                }), this.minDateBox?.attr({
                    height: e
                }), t.styledMode || (this.maxDateBox?.attr({
                    stroke: i
                }), this.minDateBox?.attr({
                    stroke: i
                })), this.isDirty) {
                    this.isDirty = !1, this.isCollapsed = void 0;
                    let t = this.options.buttons ?? [], e = Math.min(t.length, this.buttonOptions.length), { dropdown: i, options: s } = this, o = ps(s.buttonTheme), r = o && o.states, a = o.width || 28;
                    if (t.length < this.buttonOptions.length) for(let e = this.buttonOptions.length - 1; e >= t.length; e--){
                        let t = this.buttons.pop();
                        t?.destroy(), this.dropdown?.options.remove(e + 1);
                    }
                    for(let s = e - 1; s >= 0; s--){
                        let e = t[s];
                        this.buttons[s].destroy(), i?.options.remove(s + 1), this.createButton(e, s, a, r), this.computeButtonRange(e);
                    }
                    if (t.length > this.buttonOptions.length) for(let e = this.buttonOptions.length; e < t.length; e++)this.createButton(t[e], e, a, r), this.computeButtonRange(t[e]);
                    this.buttonOptions = this.options.buttons ?? [], c9(this.options.selected) && this.buttons.length && this.clickButton(this.options.selected, !1);
                }
            }
            alignButtonGroup(t, e) {
                let { chart: i, options: s, buttonGroup: o, dropdown: r, dropdownLabel: a } = this, { buttonPosition: n } = s, h = i.plotLeft - i.spacing[3], l = n.x - i.spacing[3], d = i.plotLeft;
                "right" === n.align ? (l += t - h, this.hasVisibleDropdown && (d = i.chartWidth + t - this.maxButtonWidth() - 20)) : "center" === n.align && (l -= h / 2, this.hasVisibleDropdown && (d = i.chartWidth / 2 - this.maxButtonWidth())), r && c6(r, {
                    left: d + "px",
                    top: o?.translateY + "px"
                }), a?.attr({
                    x: d
                }), o && o.align({
                    y: n.y,
                    width: pr(e, this.initialButtonGroupWidth),
                    align: n.align,
                    x: l
                }, !0, i.spacingBox);
            }
            positionButtons() {
                let { buttons: t, chart: e, options: i, zoomText: s } = this, o = e.hasLoaded ? "animate" : "attr", { buttonPosition: r } = i, a = e.plotLeft, n = a;
                s && "hidden" !== s.visibility && (s[o]({
                    x: pr(a + r.x, a)
                }), n += r.x + s.getBBox().width + 5);
                for(let e = 0, s = this.buttonOptions.length; e < s; ++e)"hidden" !== t[e].visibility ? (t[e][o]({
                    x: n
                }), n += (t[e].width || 0) + i.buttonSpacing) : t[e][o]({
                    x: a
                });
            }
            handleCollision(t) {
                let { chart: e, buttonGroup: i, inputGroup: s, initialButtonGroupWidth: o } = this, { buttonPosition: r, dropdown: a, inputPosition: n } = this.options, h = ()=>{
                    s && i && s.attr({
                        translateX: s.alignAttr.translateX + (e.axisOffset[1] >= -t ? 0 : -t),
                        translateY: s.alignAttr.translateY + i.getBBox().height + 10
                    });
                };
                s && i ? n.align === r.align ? (h(), o > e.plotWidth + t - 20 ? this.collapseButtons() : this.expandButtons()) : o - t + s.getBBox().width > e.plotWidth ? "responsive" === a || "always" === a ? this.collapseButtons() : h() : this.expandButtons() : i && "responsive" === a && (o > e.plotWidth ? this.collapseButtons() : this.expandButtons()), i && ("always" === a && this.collapseButtons(), "never" === a && this.expandButtons()), this.alignButtonGroup(t);
            }
            collapseButtons() {
                let { buttons: t, zoomText: e } = this;
                !0 !== this.isCollapsed && (this.isCollapsed = !0, e.hide(), t.forEach((t)=>void t.hide()), this.showDropdown());
            }
            expandButtons() {
                let { buttons: t, zoomText: e } = this;
                !1 !== this.isCollapsed && (this.isCollapsed = !1, this.hideDropdown(), e.show(), t.forEach((t)=>void t.show()), this.positionButtons());
            }
            showDropdown() {
                let { buttonGroup: t, dropdownLabel: e, dropdown: i } = this;
                t && i && (e.show(), c6(i, {
                    visibility: "inherit"
                }), this.hasVisibleDropdown = !0);
            }
            hideDropdown() {
                let { dropdown: t } = this;
                t && (this.dropdownLabel.hide(), c6(t, {
                    visibility: "hidden"
                }), this.hasVisibleDropdown = !1);
            }
            getHeight() {
                let t = this.options, e = this.group, i = t.inputPosition, s = t.buttonPosition, o = t.y, r = s.y, a = i.y, n = 0;
                if (t.height) return t.height;
                this.alignElements(), n = e ? e.getBBox(!0).height + 13 + o : 0;
                let h = Math.min(a, r);
                return (a < 0 && r < 0 || a > 0 && r > 0) && (n += Math.abs(h)), n;
            }
            titleCollision(t) {
                return !(t.options.title.text || t.options.subtitle.text);
            }
            update(t, e = !0) {
                let i = this.chart;
                if (ps(!0, this.options, t), this.options.selected && this.options.selected >= this.options.buttons.length && (this.options.selected = void 0, i.options.rangeSelector.selected = void 0), c9(t.enabled)) return this.destroy(), this.init(i);
                this.isDirty = !!t.buttons || !!t.buttonTheme, e && this.render();
            }
            destroy() {
                let t = this, e = t.minInput, i = t.maxInput;
                t.eventsToUnbind && (t.eventsToUnbind.forEach((t)=>t()), t.eventsToUnbind = void 0), c4(t.buttons), e && (e.onfocus = e.onblur = e.onchange = null), i && (i.onfocus = i.onblur = i.onchange = null), po(t, function(e, i) {
                    e && "chart" !== i && (e instanceof ic ? e.destroy() : e instanceof window.HTMLElement && c8(e), delete t[i]), e !== ph.prototype[i] && (t[i] = null);
                }, this), this.buttons = [];
            }
        }
        c7(ph.prototype, {
            inputTypeFormats: {
                "datetime-local": "%Y-%m-%dT%H:%M:%S",
                date: "%Y-%m-%d",
                time: "%H:%M:%S"
            }
        });
        let { format: pl } = eI, { getOptions: pd } = tY, { setFixedRange: pc } = dR, { addEvent: pp, clamp: pu, crisp: pg, defined: pf, extend: pm, find: px, isNumber: py, isString: pb, merge: pv, pick: pk, splat: pM } = tx;
        function pw(t, e, i) {
            return "xAxis" === t ? {
                minPadding: 0,
                maxPadding: 0,
                overscroll: 0,
                ordinal: !0
            } : "yAxis" === t ? {
                labels: {
                    y: -2
                },
                opposite: i.opposite ?? e.opposite ?? !0,
                showLastLabel: !!(e.categories || "category" === e.type),
                title: {
                    text: void 0
                }
            } : {};
        }
        function pS(t, e) {
            if ("xAxis" === t) {
                let t = pk(e.navigator?.enabled, dB.enabled, !0), i = {
                    type: "datetime",
                    categories: void 0
                };
                return t && (i.startOnTick = !1, i.endOnTick = !1), i;
            }
            return {};
        }
        class pA extends ny {
            init(t, e) {
                let i = pd(), s = t.xAxis, o = t.yAxis, r = pk(t.navigator?.enabled, dB.enabled, !0);
                t.xAxis = t.yAxis = void 0;
                let a = pv({
                    chart: {
                        panning: {
                            enabled: !0,
                            type: "x"
                        },
                        zooming: {
                            pinchType: "x",
                            mouseWheel: {
                                type: "x"
                            }
                        }
                    },
                    navigator: {
                        enabled: r
                    },
                    scrollbar: {
                        enabled: pk(dQ.enabled, !0)
                    },
                    rangeSelector: {
                        enabled: pk(cz.enabled, !0)
                    },
                    title: {
                        text: null
                    },
                    tooltip: {
                        split: pk(i.tooltip?.split, !0),
                        crosshairs: !0
                    },
                    legend: {
                        enabled: !1
                    }
                }, t, {
                    isStock: !0
                });
                t.xAxis = s, t.yAxis = o, a.xAxis = pM(t.xAxis || {}).map((e)=>pv(pw("xAxis", e, i.xAxis), e, pS("xAxis", t))), a.yAxis = pM(t.yAxis || {}).map((t)=>pv(pw("yAxis", t, i.yAxis), t)), super.init(a, e);
            }
            createAxis(t, e) {
                return e.axis = pv(pw(t, e.axis, pd()[t]), e.axis, pS(t, this.userOptions)), super.createAxis(t, e);
            }
        }
        pp(ny, "update", function(t) {
            let e = t.options;
            "scrollbar" in e && this.navigator && (pv(!0, this.options.scrollbar, e.scrollbar), this.navigator.update({
                enabled: !!this.navigator.navigatorEnabled
            }), delete e.scrollbar);
        }), function(t) {
            function e(t) {
                if (!(this.crosshair?.label?.enabled && this.cross && py(this.min) && py(this.max))) return;
                let e = this.chart, i = this.logarithmic, s = this.crosshair.label, o = this.horiz, r = this.opposite, a = this.left, n = this.top, h = this.width, l = "inside" === this.options.tickPosition, d = !1 !== this.crosshair.snap, c = t.e || this.cross?.e, p = t.point, u = this.crossLabel, g, f, m = s.format, x = "", y, b = 0, v = this.min, k = this.max;
                i && (v = i.lin2log(this.min), k = i.lin2log(this.max));
                let M = o ? "center" : r ? "right" === this.labelAlign ? "right" : "left" : "left" === this.labelAlign ? "left" : "center";
                !u && (u = this.crossLabel = e.renderer.label("", 0, void 0, s.shape || "callout").addClass("highcharts-crosshair-label highcharts-color-" + (p?.series ? p.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({
                    align: s.align || M,
                    padding: pk(s.padding, 8),
                    r: pk(s.borderRadius, 3),
                    zIndex: 2
                }).add(this.labelGroup), e.styledMode || u.attr({
                    fill: s.backgroundColor || p?.series?.color || "#666666",
                    stroke: s.borderColor || "",
                    "stroke-width": s.borderWidth || 0
                }).css(pm({
                    color: "#ffffff",
                    fontWeight: "normal",
                    fontSize: "0.7em",
                    textAlign: "center"
                }, s.style || {}))), o ? (g = d ? (p.plotX || 0) + a : c.chartX, f = n + (r ? 0 : this.height)) : (g = a + this.offset + (r ? h : 0), f = d ? (p.plotY || 0) + n : c.chartY), m || s.formatter || (this.dateTime && (x = "%b %d, %Y"), m = "{value" + (x ? ":" + x : "") + "}");
                let w = d ? this.isXAxis ? p.x : p.y : this.toValue(o ? c.chartX : c.chartY), S = p?.series ? p.series.isPointInside(p) : py(w) && w > v && w < k, A = "";
                m ? A = pl(m, {
                    value: w
                }, e) : s.formatter && py(w) && (A = s.formatter.call(this, w)), u.attr({
                    text: A,
                    x: g,
                    y: f,
                    visibility: S ? "inherit" : "hidden"
                });
                let T = u.getBBox();
                !py(u.x) || o || r || (g = u.x - T.width / 2), py(u.y) && (o ? (l && !r || !l && r) && (f = u.y - T.height) : f = u.y - T.height / 2), y = o ? {
                    left: a,
                    right: a + this.width
                } : {
                    left: "left" === this.labelAlign ? a : 0,
                    right: "right" === this.labelAlign ? a + this.width : e.chartWidth
                };
                let C = u.translateX || 0;
                C < y.left && (b = y.left - C), C + T.width >= y.right && (b = -(C + T.width - y.right)), u.attr({
                    x: Math.max(0, g + b),
                    y: Math.max(0, f),
                    anchorX: o ? g : this.opposite ? 0 : e.chartWidth,
                    anchorY: o ? this.opposite ? e.chartHeight : 0 : f + T.height / 2
                });
            }
            function i() {
                this.crossLabel && (this.crossLabel = this.crossLabel.hide());
            }
            function s(t) {
                let e = this.chart, i = this.options, s = e._labelPanes = e._labelPanes || {}, o = i.labels;
                if (e.options.isStock && "yAxis" === this.coll) {
                    let e = i.top + "," + i.height;
                    !s[e] && o.enabled && (15 === o.distance && 1 === this.side && (o.distance = 0), void 0 === o.align && (o.align = "right"), s[e] = this, t.align = "right", t.preventDefault());
                }
            }
            function o() {
                let t = this.chart, e = this.options && this.options.top + "," + this.options.height;
                e && t._labelPanes && t._labelPanes[e] === this && delete t._labelPanes[e];
            }
            function r(t) {
                let e = this.isLinked && !this.series && this.linkedParent ? this.linkedParent.series : this.series, { chart: i, horiz: s } = this, o = i.renderer, r = [], { acrossPanes: a = !0, force: n, translatedValue: h, value: l } = t, d = (this.isXAxis ? i.yAxis : i.xAxis) || [];
                function c(t, e, i) {
                    r.push([
                        "M",
                        s ? t : e,
                        s ? e : t
                    ], [
                        "L",
                        s ? t : i,
                        s ? i : t
                    ]);
                }
                let p = [], u, g;
                if (i.options.isStock && ("xAxis" === this.coll || "yAxis" === this.coll)) {
                    let f, m;
                    for (let s of (t.preventDefault(), f = "xAxis" === this.coll ? "yAxis" : "xAxis", m = this.options[f], p = a && !this.options.isInternal ? d.filter((t)=>!t.options.isInternal) : py(m) ? [
                        i[f][m]
                    ] : pb(m) ? [
                        i.get(m)
                    ] : e.map((t)=>t[f]), d))if (!s.options.isInternal) {
                        let t = s.isXAxis ? "yAxis" : "xAxis";
                        this === (pf(s.options[t]) && i[t][s.options[t]]) && p.push(s);
                    }
                    for (let t of (u = p.length ? [] : [
                        this.isXAxis ? i.yAxis[0] : i.xAxis[0]
                    ], p))-1 !== u.indexOf(t) || px(u, (e)=>e.pos === t.pos && e.len === t.len) || u.push(t);
                    if (py(g = pk(h, this.translate(l || 0, void 0, void 0, t.old)))) {
                        let t, e = s ? g + this.pos : this.pos + this.len - g;
                        if ("pass" !== n && (e < this.pos || e > this.pos + this.len) && (n ? e = pu(e, this.pos, this.pos + this.len) : t = !0), !t) {
                            let t = s ? "top" : "left", i = s ? "height" : "width";
                            if (!a && (this.options[t] || this.options[i])) c(e, this[t], this[t] + this[i]);
                            else for (let t of u)c(e, t.pos, t.pos + t.len);
                        }
                    }
                    t.path = r.length > 0 ? o.crispPolyLine(r, t.lineWidth || 1) : void 0;
                }
            }
            function a(t) {
                if (this.chart.options.isStock) {
                    let e;
                    this.is("column") || this.is("columnrange") ? e = {
                        borderWidth: 0,
                        shadow: !1
                    } : this.is("scatter") || this.is("sma") || (e = {
                        marker: {
                            enabled: !1,
                            radius: 2
                        }
                    }), e && (t.plotOptions[this.type] = pv(t.plotOptions[this.type], e));
                }
            }
            function n() {
                let t = this.chart, e = this.options.dataGrouping;
                return !1 !== this.allowDG && e && pk(e.enabled, t.options.isStock);
            }
            function h(t, e) {
                for(let i = 0; i < t.length; i += 2){
                    let s = t[i], o = t[i + 1];
                    pf(s[1]) && s[1] === o[1] && (s[1] = o[1] = pg(s[1], e)), pf(s[2]) && s[2] === o[2] && (s[2] = o[2] = pg(s[2], e));
                }
                return t;
            }
            t.compose = function(t, l, d, c) {
                let p = d.prototype;
                p.forceCropping || (pp(l, "afterDrawCrosshair", e), pp(l, "afterHideCrosshair", i), pp(l, "autoLabelAlign", s), pp(l, "destroy", o), pp(l, "getPlotLinePath", r), t.prototype.setFixedRange = pc, p.forceCropping = n, pp(d, "setOptions", a), c.prototype.crispPolyLine = h);
            }, t.stockChart = function(e, i, s) {
                return new t(e, i, s);
            };
        }(pA || (pA = {}));
        let pT = pA, { column: { prototype: { pointClass: pC } } } = r_.seriesTypes, { column: pP } = r_.seriesTypes, { crisp: pO, extend: pE, merge: pL } = tx, { defaultOptions: pB } = tY;
        class pD extends pP {
            extendStem(t, e, i) {
                let s = t[0], o = t[1];
                "number" == typeof s[2] && (s[2] = Math.max(i + e, s[2])), "number" == typeof o[2] && (o[2] = Math.min(i - e, o[2]));
            }
            getPointPath(t, e) {
                let i = e.strokeWidth(), s = t.series, o = pO(t.plotX || 0, i), r = Math.round(t.shapeArgs.width / 2), a = [
                    [
                        "M",
                        o,
                        Math.round(t.yBottom)
                    ],
                    [
                        "L",
                        o,
                        Math.round(t.plotHigh)
                    ]
                ];
                if (null !== t.close) {
                    let e = pO(t.plotClose, i);
                    a.push([
                        "M",
                        o,
                        e
                    ], [
                        "L",
                        o + r,
                        e
                    ]), s.extendStem(a, i / 2, e);
                }
                return a;
            }
            drawSinglePoint(t) {
                let e = t.series, i = e.chart, s, o = t.graphic;
                void 0 !== t.plotY && (o || (t.graphic = o = i.renderer.path().add(e.group)), i.styledMode || o.attr(e.pointAttribs(t, t.selected && "select")), s = e.getPointPath(t, o), o[!o ? "attr" : "animate"]({
                    d: s
                }).addClass(t.getClassName(), !0));
            }
            drawPoints() {
                this.points.forEach(this.drawSinglePoint);
            }
            init() {
                super.init.apply(this, arguments), this.options.stacking = void 0;
            }
            pointAttribs(t, e) {
                let i = super.pointAttribs.call(this, t, e);
                return delete i.fill, i;
            }
            toYData(t) {
                return [
                    t.high,
                    t.low,
                    t.close
                ];
            }
            translate() {
                let t = this, e = t.yAxis, i = this.pointArrayMap && this.pointArrayMap.slice() || [], s = i.map((t)=>`plot${t.charAt(0).toUpperCase() + t.slice(1)}`);
                s.push("yBottom"), i.push("low"), super.translate.apply(t), t.points.forEach(function(o) {
                    i.forEach(function(i, r) {
                        let a = o[i];
                        null !== a && (t.dataModify && (a = t.dataModify.modifyValue(a)), o[s[r]] = e.toPixels(a, !0));
                    }), o.tooltipPos[1] = o.plotHigh + e.pos - t.chart.plotTop;
                });
            }
        }
        pD.defaultOptions = pL(pP.defaultOptions, {
            lineWidth: 1,
            tooltip: {
                pointFormat: '<span style="color:{point.color}">‚óè</span> <b> {series.name}</b><br/>{series.chart.options.lang.stockHigh}: {point.high}<br/>{series.chart.options.lang.stockLow}: {point.low}<br/>{series.chart.options.lang.stockClose}: {point.close}<br/>'
            },
            threshold: null,
            states: {
                hover: {
                    lineWidth: 3
                }
            },
            stickyTracking: !0
        }), pE(pD.prototype, {
            pointClass: class extends pC {
            },
            animate: null,
            directTouch: !1,
            keysAffectYAxis: [
                "low",
                "high"
            ],
            pointArrayMap: [
                "high",
                "low",
                "close"
            ],
            pointAttrToOptions: {
                stroke: "color",
                "stroke-width": "lineWidth"
            },
            pointValKey: "close"
        }), pE(pB.lang, {
            stockOpen: "Open",
            stockHigh: "High",
            stockLow: "Low",
            stockClose: "Close"
        }), r_.registerSeriesType("hlc", pD);
        let { seriesTypes: { hlc: pI } } = r_;
        class pz extends pI.prototype.pointClass {
            getClassName() {
                return super.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down");
            }
            resolveUpColor() {
                this.open < this.close && !this.options.color && this.series.options.upColor && (this.color = this.series.options.upColor);
            }
            resolveColor() {
                super.resolveColor(), this.series.is("heikinashi") || this.resolveUpColor();
            }
            getZone() {
                let t = super.getZone();
                return this.resolveUpColor(), t;
            }
            applyOptions() {
                return super.applyOptions.apply(this, arguments), this.resolveColor && this.resolveColor(), this;
            }
        }
        let { composed: pR } = V, { hlc: pN } = r_.seriesTypes, { addEvent: pW, crisp: pG, extend: pX, merge: pH, pushUnique: pF } = tx;
        function pY(t) {
            let e = t.options, i = e.dataGrouping;
            i && e.useOhlcData && "highcharts-navigator-series" !== e.id && (i.approximation = "ohlc");
        }
        function pj(t) {
            let e = t.options;
            e.useOhlcData && "highcharts-navigator-series" !== e.id && pX(this, {
                pointValKey: pU.prototype.pointValKey,
                pointArrayMap: pU.prototype.pointArrayMap,
                toYData: pU.prototype.toYData
            });
        }
        class pU extends pN {
            static compose(t) {
                pF(pR, "OHLCSeries") && (pW(t, "afterSetOptions", pY), pW(t, "init", pj));
            }
            getPointPath(t, e) {
                let i = super.getPointPath(t, e), s = e.strokeWidth(), o = pG(t.plotX || 0, s), r = Math.round(t.shapeArgs.width / 2);
                if (null !== t.open) {
                    let e = pG(t.plotOpen, s);
                    i.push([
                        "M",
                        o,
                        e
                    ], [
                        "L",
                        o - r,
                        e
                    ]), super.extendStem(i, s / 2, e);
                }
                return i;
            }
            pointAttribs(t, e) {
                let i = super.pointAttribs.call(this, t, e), s = this.options;
                return delete i.fill, !t.options.color && s.upColor && t.open < t.close && (i.stroke = s.upColor), i;
            }
            toYData(t) {
                return [
                    t.open,
                    t.high,
                    t.low,
                    t.close
                ];
            }
        }
        pU.defaultOptions = pH(pN.defaultOptions, {
            tooltip: {
                pointFormat: '<span style="color:{point.color}">‚óè</span> <b> {series.name}</b><br/>{series.chart.options.lang.stockOpen}: {point.open}<br/>{series.chart.options.lang.stockHigh}: {point.high}<br/>{series.chart.options.lang.stockLow}: {point.low}<br/>{series.chart.options.lang.stockClose}: {point.close}<br/>'
            }
        }), pX(pU.prototype, {
            pointClass: pz,
            pointArrayMap: [
                "open",
                "high",
                "low",
                "close"
            ]
        }), r_.registerSeriesType("ohlc", pU);
        let { column: pV, ohlc: p$ } = r_.seriesTypes, { crisp: p_, merge: pZ } = tx;
        class pq extends p$ {
            pointAttribs(t, e) {
                let i = pV.prototype.pointAttribs.call(this, t, e), s = this.options, o = t.open < t.close, r = s.lineColor || this.color, a = t.color || this.color;
                if (i["stroke-width"] = s.lineWidth, i.fill = t.options.color || o && s.upColor || a, i.stroke = t.options.lineColor || o && s.upLineColor || r, e) {
                    let t = s.states[e];
                    i.fill = t.color || i.fill, i.stroke = t.lineColor || i.stroke, i["stroke-width"] = t.lineWidth || i["stroke-width"];
                }
                return i;
            }
            drawPoints() {
                let t = this.points, e = this.chart, i = this.yAxis.reversed;
                for (let s of t){
                    let t = s.graphic, o, r, a, n, h, l, d, c, p, u = !t;
                    if (void 0 !== s.plotY) {
                        t || (s.graphic = t = e.renderer.path().add(this.group)), this.chart.styledMode || t.attr(this.pointAttribs(s, s.selected && "select")).shadow(this.options.shadow);
                        let g = t.strokeWidth();
                        d = p_(s.plotX || 0, g), a = Math.min(o = s.plotOpen, r = s.plotClose), n = Math.max(o, r), p = Math.round(s.shapeArgs.width / 2), h = i ? n !== s.yBottom : Math.round(a) !== Math.round(s.plotHigh || 0), l = i ? Math.round(a) !== Math.round(s.plotHigh || 0) : n !== s.yBottom, a = p_(a, g), n = p_(n, g), (c = []).push([
                            "M",
                            d - p,
                            n
                        ], [
                            "L",
                            d - p,
                            a
                        ], [
                            "L",
                            d + p,
                            a
                        ], [
                            "L",
                            d + p,
                            n
                        ], [
                            "Z"
                        ], [
                            "M",
                            d,
                            a
                        ], [
                            "L",
                            d,
                            h ? Math.round(i ? s.yBottom : s.plotHigh) : a
                        ], [
                            "M",
                            d,
                            n
                        ], [
                            "L",
                            d,
                            l ? Math.round(i ? s.plotHigh : s.yBottom) : n
                        ]), t[u ? "attr" : "animate"]({
                            d: c
                        }).addClass(s.getClassName(), !0);
                    }
                }
            }
        }
        pq.defaultOptions = pZ(p$.defaultOptions, {
            tooltip: p$.defaultOptions.tooltip
        }, {
            states: {
                hover: {
                    lineWidth: 2
                }
            },
            threshold: null,
            lineColor: "#000000",
            lineWidth: 1,
            upColor: "#ffffff",
            stickyTracking: !0
        }), r_.registerSeriesType("candlestick", pq);
        let { column: { prototype: { pointClass: pK } } } = r_.seriesTypes, { isNumber: pJ } = tx, pQ = class extends pK {
            constructor(){
                super(...arguments), this.ttBelow = !1;
            }
            isValid() {
                return pJ(this.y) || void 0 === this.y;
            }
            hasNewShapeType() {
                let t = this.options.shape || this.series.options.shape;
                return this.graphic && t && t !== this.graphic.symbolKey;
            }
        };
        !function(t) {
            let e = [];
            function i(t, e, i, s, o) {
                let r = o && o.anchorX || t, a = o && o.anchorY || e, n = this.circle(r - 1, a - 1, 2, 2);
                return n.push([
                    "M",
                    r,
                    a
                ], [
                    "L",
                    t,
                    e + s
                ], [
                    "L",
                    t,
                    e
                ], [
                    "L",
                    t + i,
                    e
                ], [
                    "L",
                    t + i,
                    e + s
                ], [
                    "L",
                    t,
                    e + s
                ], [
                    "Z"
                ]), n;
            }
            function s(t, e) {
                t[e + "pin"] = function(i, s, o, r, a) {
                    let n, h = a && a.anchorX, l = a && a.anchorY;
                    if ("circle" === e && r > o && (i -= Math.round((r - o) / 2), o = r), n = t[e](i, s, o, r, a), h && l) {
                        let a = h;
                        if ("circle" === e) a = i + o / 2;
                        else {
                            let t = n[0], e = n[1];
                            "M" === t[0] && "L" === e[0] && (a = (t[1] + e[1]) / 2);
                        }
                        let d = s > l ? s : s + r;
                        n.push([
                            "M",
                            a,
                            d
                        ], [
                            "L",
                            h,
                            l
                        ]), n = n.concat(t.circle(h - 1, l - 1, 2, 2));
                    }
                    return n;
                };
            }
            t.compose = function(t) {
                if (-1 === e.indexOf(t)) {
                    e.push(t);
                    let o = t.prototype.symbols;
                    o.flag = i, s(o, "circle"), s(o, "square");
                }
                let o = ez.getRendererType();
                e.indexOf(o) && e.push(o);
            };
        }(H || (H = {}));
        let p0 = H, { composed: p1 } = V, { prototype: p2 } = hO, { prototype: p3 } = ay, { defined: p5, pushUnique: p6, stableSort: p9 } = tx;
        var p4 = F || (F = {});
        function p8(t) {
            return p3.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this, t);
        }
        function p7() {
            p2.translate.apply(this);
            let t = this, e = t.options, i = t.chart, s = t.points, o = e.onSeries, r = o && i.get(o), a = r && r.options.step, n = r && r.points, h = i.inverted, l = t.xAxis, d = t.yAxis, c = s.length - 1, p, u, g = e.onKey || "y", f = n && n.length, m = 0, x, y, b, v, k;
            if (r && r.visible && f) {
                for(m = (r.pointXOffset || 0) + (r.barW || 0) / 2, v = r.currentDataGrouping, y = n[f - 1].x + (v ? v.totalRange : 0), p9(s, (t, e)=>t.x - e.x), g = "plot" + g[0].toUpperCase() + g.substr(1); f-- && s[c];)if (x = n[f], (p = s[c]).y = x.y, x.x <= p.x && void 0 !== x[g]) {
                    if (p.x <= y && (p.plotY = x[g], x.x < p.x && !a && (b = n[f + 1])) && void 0 !== b[g]) if (p5(p.plotX) && r.is("spline")) {
                        let t = [
                            x.plotX || 0,
                            x.plotY || 0
                        ], e = [
                            b.plotX || 0,
                            b.plotY || 0
                        ], i = x.controlPoints?.high || t, s = b.controlPoints?.low || e, o = (o, r)=>Math.pow(1 - o, 3) * t[r] + 3 * (1 - o) * (1 - o) * o * i[r] + 3 * (1 - o) * o * o * s[r] + o * o * o * e[r], r = 0, a = 1, n;
                        for(let t = 0; t < 100; t++){
                            let t = (r + a) / 2, e = o(t, 0);
                            if (null === e) break;
                            if (.25 > Math.abs(e - p.plotX)) {
                                n = t;
                                break;
                            }
                            e < p.plotX ? r = t : a = t;
                        }
                        p5(n) && (p.plotY = o(n, 1), p.y = d.toValue(p.plotY, !0));
                    } else k = (p.x - x.x) / (b.x - x.x), p.plotY += k * (b[g] - x[g]), p.y += k * (b.y - x.y);
                    if (c--, f++, c < 0) break;
                }
            }
            s.forEach((e, i)=>{
                let o;
                e.plotX += m, (void 0 === e.plotY || h) && (e.plotX >= 0 && e.plotX <= l.len ? h ? (e.plotY = l.translate(e.x, 0, 1, 0, 1), e.plotX = p5(e.y) ? d.translate(e.y, 0, 0, 0, 1) : 0) : e.plotY = (l.opposite ? 0 : t.yAxis.len) + l.offset : e.shapeArgs = {}), (u = s[i - 1]) && u.plotX === e.plotX && (void 0 === u.stackIndex && (u.stackIndex = 0), o = u.stackIndex + 1), e.stackIndex = o;
            }), this.onSeries = r;
        }
        p4.compose = function(t) {
            if (p6(p1, "OnSeries")) {
                let e = t.prototype;
                e.getPlotBox = p8, e.translate = p7;
            }
            return t;
        }, p4.getPlotBox = p8, p4.translate = p7;
        let ut = F, { noop: ue } = V, { distribute: ui } = eX, { series: us, seriesTypes: { column: uo } } = r_, { addEvent: ur, defined: ua, extend: un, isNumber: uh, merge: ul, objectEach: ud, wrap: uc } = tx;
        class up extends uo {
            animate(t) {
                t && this.setClip();
            }
            drawPoints() {
                let t, e, i, s, o, r, a, n, h, l, d, c = this.points, p = this.chart, u = p.renderer, g = p.inverted, f = this.options, m = f.y, x = this.yAxis, y = {}, b = [], v = uh(f.borderRadius) ? f.borderRadius : 0;
                for(s = c.length; s--;)o = c[s], l = (g ? o.plotY : o.plotX) > this.xAxis.len, t = o.plotX, a = o.stackIndex, i = o.options.shape || f.shape, void 0 !== (e = o.plotY) && (e = o.plotY + m - (void 0 !== a && a * f.stackDistance)), o.anchorX = a ? void 0 : o.plotX, n = a ? void 0 : o.plotY, d = "flag" !== i, r = o.graphic, void 0 !== e && t >= 0 && !l ? (r && o.hasNewShapeType() && (r = r.destroy()), r || (r = o.graphic = u.label("", 0, void 0, i, void 0, void 0, f.useHTML).addClass(o.getClassName()).add(this.markerGroup), o.graphic.div && (o.graphic.div.point = o), r.isNew = !0), r.attr({
                    align: d ? "center" : "left",
                    width: f.width,
                    height: f.height,
                    "text-align": f.textAlign,
                    r: v
                }), p.styledMode || r.attr(this.pointAttribs(o)).css(ul(f.style, o.style)).shadow(f.shadow), t > 0 && (t -= r.strokeWidth() % 2), h = {
                    y: e,
                    anchorY: n
                }, f.allowOverlapX && (h.x = t, h.anchorX = o.anchorX), r.attr({
                    text: o.options.title ?? f.title ?? "A"
                })[r.isNew ? "attr" : "animate"](h), f.allowOverlapX || (y[o.plotX] ? y[o.plotX].size = Math.max(y[o.plotX].size, r.width || 0) : y[o.plotX] = {
                    align: .5 * !!d,
                    size: r.width || 0,
                    target: t,
                    anchorX: t
                }), o.tooltipPos = [
                    t,
                    e + x.pos - p.plotTop
                ]) : r && (o.graphic = r.destroy());
                if (!f.allowOverlapX) {
                    let t = 100;
                    for (let e of (ud(y, function(e) {
                        e.plotX = e.anchorX, b.push(e), t = Math.max(e.size, t);
                    }), ui(b, g ? x.len : this.xAxis.len, t), c)){
                        let t = e.plotX, i = e.graphic, s = i && y[t];
                        s && i && (ua(s.pos) ? i[i.isNew ? "attr" : "animate"]({
                            x: s.pos + (s.align || 0) * s.size,
                            anchorX: e.anchorX
                        }).show().isNew = !1 : i.hide().isNew = !0);
                    }
                }
                f.useHTML && this.markerGroup && uc(this.markerGroup, "on", function(t) {
                    return ic.prototype.on.apply(t.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));
                });
            }
            drawTracker() {
                let t = this.points;
                for (let e of (super.drawTracker(), t)){
                    let i = e.graphic;
                    i && (e.unbindMouseOver && e.unbindMouseOver(), e.unbindMouseOver = ur(i.element, "mouseover", function() {
                        for (let s of (e.stackIndex > 0 && !e.raised && (e._y = i.y, i.attr({
                            y: e._y - 8
                        }), e.raised = !0), t))s !== e && s.raised && s.graphic && (s.graphic.attr({
                            y: s._y
                        }), s.raised = !1);
                    }));
                }
            }
            pointAttribs(t, e) {
                let i = this.options, s = t && t.color || this.color, o = i.lineColor, r = t && t.lineWidth, a = t && t.fillColor || i.fillColor;
                return e && (a = i.states[e].fillColor, o = i.states[e].lineColor, r = i.states[e].lineWidth), {
                    fill: a || s,
                    stroke: o || s,
                    "stroke-width": r || i.lineWidth || 0
                };
            }
            setClip() {
                us.prototype.setClip.apply(this, arguments), !1 !== this.options.clip && this.sharedClipKey && this.markerGroup && this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);
            }
        }
        up.compose = p0.compose, up.defaultOptions = ul(uo.defaultOptions, {
            borderRadius: 0,
            pointRange: 0,
            allowOverlapX: !1,
            shape: "flag",
            stackDistance: 12,
            textAlign: "center",
            tooltip: {
                pointFormat: "{point.text}"
            },
            threshold: null,
            y: -30,
            fillColor: "#ffffff",
            lineWidth: 1,
            states: {
                hover: {
                    lineColor: "#000000",
                    fillColor: "#ccd3ff"
                }
            },
            style: {
                color: "#000000",
                fontSize: "0.7em",
                fontWeight: "bold"
            }
        }), ut.compose(up), un(up.prototype, {
            allowDG: !1,
            forceCrop: !0,
            invertible: !1,
            noSharedTooltip: !0,
            pointClass: pQ,
            sorted: !1,
            takeOrdinalPosition: !1,
            trackerGroups: [
                "markerGroup"
            ],
            buildKDTree: ue,
            init: us.prototype.init
        }), r_.registerSeriesType("flags", up);
        let { addEvent: uu, find: ug, fireEvent: uf, isArray: um, isNumber: ux, pick: uy } = tx;
        !function(t) {
            function e() {
                void 0 !== this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);
            }
            function i() {
                Object.keys(this.options.breaks?.[0] || {}).length && (this.options.ordinal = !1);
            }
            function s() {
                let t = this.brokenAxis;
                if (t?.hasBreaks) {
                    let e = this.tickPositions, i = this.tickPositions.info, s = [];
                    for(let i = 0; i < e.length; i++)t.isInAnyBreak(e[i]) || s.push(e[i]);
                    this.tickPositions = s, this.tickPositions.info = i;
                }
            }
            function o() {
                this.brokenAxis || (this.brokenAxis = new l(this));
            }
            function r() {
                let { isDirty: t, options: { connectNulls: e }, points: i, xAxis: s, yAxis: o } = this;
                if (t) {
                    let t = i.length;
                    for(; t--;){
                        let r = i[t], a = (null !== r.y || !1 !== e) && (s?.brokenAxis?.isInAnyBreak(r.x, !0) || o?.brokenAxis?.isInAnyBreak(r.y, !0));
                        r.visible = !a && !1 !== r.options.visible;
                    }
                }
            }
            function a() {
                this.drawBreaks(this.xAxis, [
                    "x"
                ]), this.drawBreaks(this.yAxis, uy(this.pointArrayMap, [
                    "y"
                ]));
            }
            function n(t, e) {
                let i, s, o, r = this, a = r.points;
                if (t?.brokenAxis?.hasBreaks) {
                    let n = t.brokenAxis;
                    e.forEach(function(e) {
                        i = n?.breakArray || [], s = t.isXAxis ? t.min : uy(r.options.threshold, t.min), a.forEach(function(r) {
                            o = r["stack" + e.toUpperCase()] ?? r[e], i.forEach(function(e) {
                                if (ux(s) && ux(o)) {
                                    let i = "";
                                    s < e.from && o > e.to || s > e.from && o < e.from ? i = "pointBreak" : (s < e.from && o > e.from && o < e.to || s > e.from && o > e.to && o < e.from) && (i = "pointInBreak"), i && uf(t, i, {
                                        point: r,
                                        brk: e
                                    });
                                }
                            });
                        });
                    });
                }
            }
            function h() {
                let t = this.currentDataGrouping, e = t?.gapSize, i = this.points.slice(), s = this.yAxis, o = this.options.gapSize, r = i.length - 1;
                if (o && r > 0) {
                    let t, a;
                    for("value" !== this.options.gapUnit && (o *= this.basePointRange), e && e > o && e >= this.basePointRange && (o = e); r--;)if (a && !1 !== a.visible || (a = i[r + 1]), t = i[r], !1 !== a.visible && !1 !== t.visible) {
                        if (a.x - t.x > o) {
                            let e = (t.x + a.x) / 2;
                            i.splice(r + 1, 0, {
                                isNull: !0,
                                x: e
                            }), s.stacking && this.options.stacking && ((s.stacking.stacks[this.stackKey][e] = new nW(s, s.options.stackLabels, !1, e, this.stack ?? "")).total = 0);
                        }
                        a = t;
                    }
                }
                return this.getGraphPath(i);
            }
            t.compose = function(t, l) {
                if (!t.keepProps.includes("brokenAxis")) {
                    t.keepProps.push("brokenAxis"), uu(t, "init", o), uu(t, "afterInit", e), uu(t, "afterSetTickPositions", s), uu(t, "afterSetOptions", i);
                    let d = l.prototype;
                    d.drawBreaks = n, d.gappedPath = h, uu(l, "afterGeneratePoints", r), uu(l, "afterRender", a);
                }
                return t;
            };
            class l {
                static isInBreak(t, e) {
                    let i = t.repeat || 1 / 0, s = t.from, o = t.to - t.from, r = e >= s ? (e - s) % i : i - (s - e) % i;
                    return t.inclusive ? r <= o : r < o && 0 !== r;
                }
                static lin2Val(t) {
                    let e = this.min || 0, i = this.brokenAxis, s = i?.breakArray;
                    if (!s?.length || !ux(t)) return t;
                    let o = t;
                    if (t > e) for (let t of s)if (t.from > o) break;
                    else t.to <= o && t.to > e ? o += t.len : l.isInBreak(t, o) && (o += t.len);
                    else if (t < e) for (let t of s)if (t.from > e) break;
                    else t.from >= o && t.from < e ? o -= t.len : l.isInBreak(t, o) && (o -= t.len);
                    return o;
                }
                static val2Lin(t) {
                    let e = this.min || 0, i = this.brokenAxis, s = i?.breakArray;
                    if (!s?.length || !ux(t)) return t;
                    let o = t;
                    if (t > e) {
                        for (let i of s)if (i.to <= t && i.to > e) o -= i.len;
                        else if (i.from > t) break;
                        else if (l.isInBreak(i, t)) {
                            o -= t - i.from;
                            break;
                        }
                    } else if (t < e) {
                        for (let i of s)if (i.from >= t && i.from < e) o += i.len;
                        else if (i.from > e) break;
                        else if (l.isInBreak(i, t)) {
                            o += i.to - t;
                            break;
                        }
                    }
                    return o;
                }
                constructor(t){
                    this.axis = t;
                }
                findBreakAt(t, e) {
                    return ug(e, function(e) {
                        return e.from < t && t < e.to;
                    });
                }
                isInAnyBreak(t, e) {
                    let i = this.axis, s = i.options.breaks || [], o = s.length, r, a, n;
                    if (o && ux(t)) {
                        for(; o--;)l.isInBreak(s[o], t) && (r = !0, a || (a = uy(s[o].showPoints, !i.isXAxis)));
                        n = r && e ? r && !a : r;
                    }
                    return n;
                }
                setBreaks(t, e) {
                    let i = this, s = i.axis, o = s.chart.time, r = um(t) && !!Object.keys(t?.[0] || {}).length;
                    s.isDirty = (i.hasBreaks ?? !1) !== r, i.hasBreaks = r, t?.forEach((t)=>{
                        t.from = o.parse(t.from) || 0, t.to = o.parse(t.to) || 0;
                    }), t !== s.options.breaks && (s.options.breaks = s.userOptions.breaks = t), s.forceRedraw = !0, s.series.forEach(function(t) {
                        t.isDirty = !0;
                    }), r || s.val2lin !== l.val2Lin || (delete s.val2lin, delete s.lin2val), r && (s.userOptions.ordinal = !1, s.lin2val = l.lin2Val, s.val2lin = l.val2Lin, s.setExtremes = function(t, e, o, r, a) {
                        if (i.hasBreaks && !s.treeGrid?.tree) {
                            let s, o = this.brokenAxis.breakArray || [];
                            for(; s = i.findBreakAt(t, o);)t = s.to;
                            for(; s = i.findBreakAt(e, o);)e = s.from;
                            e < t && (e = t);
                        }
                        s.constructor.prototype.setExtremes.call(this, t, e, o, r, a);
                    }, s.setAxisTranslation = function() {
                        if (s.constructor.prototype.setAxisTranslation.call(this), i.unitLength = void 0, i.hasBreaks) {
                            let t = s.options.breaks || [], e = [], o = [], r = s.pointRangePadding ?? 0, a = 0, n, h, d = s.userMin ?? s.min, c = s.userMax ?? s.max, p = s.dataMin ?? d, u = s.dataMax ?? c, g, f;
                            ux(s.threshold) && (p = Math.min(p ?? s.threshold, s.threshold), u = Math.max(u ?? s.threshold, s.threshold)), s.treeGrid?.tree || t.forEach(function(t) {
                                h = t.repeat || 1 / 0, ux(d) && ux(c) && (l.isInBreak(t, d) && (d += t.to % h - d % h), l.isInBreak(t, c) && (c -= c % h - t.from % h));
                            }), ux(p) && ux(u) && t.forEach(function(t) {
                                for(g = t.from, h = t.repeat || 1 / 0; g - h > p;)g -= h;
                                for(; g < p;)g += h;
                                for(f = g; f < u; f += h)e.push({
                                    value: f,
                                    move: "in"
                                }), e.push({
                                    value: f + t.to - t.from,
                                    move: "out",
                                    size: t.breakSize
                                });
                            }), e.sort(function(t, e) {
                                return t.value === e.value ? ("in" !== t.move) - ("in" !== e.move) : t.value - e.value;
                            }), n = 0, g = p, e.forEach((t)=>{
                                1 === (n += "in" === t.move ? 1 : -1) && "in" === t.move && (g = t.value), 0 === n && ux(g) && (o.push({
                                    from: g,
                                    to: t.value,
                                    len: t.value - g - (t.size || 0)
                                }), ux(d) && ux(c) && g < c && t.value > d && (a += t.value - g - (t.size || 0)));
                            }), i.breakArray = o, ux(d) && ux(c) && ux(s.min) && (i.unitLength = c - d - a + r, uf(s, "afterBreaks"), s.staticScale ? s.transA = s.staticScale : i.unitLength && (s.transA *= (c - s.min + r) / i.unitLength), r && (s.minPixelPadding = s.transA * (s.minPointOffset || 0)), s.min = d, s.max = c);
                        }
                    }), uy(e, !0) && s.chart.redraw();
                }
            }
            t.Additions = l;
        }(Y || (Y = {}));
        let ub = Y;
        V.BrokenAxis = V.BrokenAxis || ub, V.BrokenAxis.compose(V.Axis, V.Series);
        let uv = {}, { arrayMax: uk, arrayMin: uM, correctFloat: uw, extend: uS, isNumber: uA } = tx;
        function uT(t) {
            let e = t.length, i = uC(t);
            return uA(i) && e && (i = uw(i / e)), i;
        }
        function uC(t) {
            let e = t.length, i;
            if (!e && t.hasNulls) i = null;
            else if (e) for(i = 0; e--;)i += t[e];
            return i;
        }
        let uP = {
            average: uT,
            averages: function() {
                let t = [];
                return [].forEach.call(arguments, function(e) {
                    t.push(uT(e));
                }), void 0 === t[0] ? void 0 : t;
            },
            close: function(t) {
                return t.length ? t[t.length - 1] : t.hasNulls ? null : void 0;
            },
            high: function(t) {
                return t.length ? uk(t) : t.hasNulls ? null : void 0;
            },
            hlc: function(t, e, i) {
                if (t = uv.high(t), e = uv.low(e), i = uv.close(i), uA(t) || uA(e) || uA(i)) return [
                    t,
                    e,
                    i
                ];
            },
            low: function(t) {
                return t.length ? uM(t) : t.hasNulls ? null : void 0;
            },
            ohlc: function(t, e, i, s) {
                if (t = uv.open(t), e = uv.high(e), i = uv.low(i), s = uv.close(s), uA(t) || uA(e) || uA(i) || uA(s)) return [
                    t,
                    e,
                    i,
                    s
                ];
            },
            open: function(t) {
                return t.length ? t[0] : t.hasNulls ? null : void 0;
            },
            range: function(t, e) {
                return (t = uv.low(t), e = uv.high(e), uA(t) || uA(e)) ? [
                    t,
                    e
                ] : null === t && null === e ? null : void 0;
            },
            sum: uC
        };
        uS(uv, uP);
        let uO = {
            groupPixelWidth: 2,
            dateTimeLabelFormats: {
                millisecond: [
                    "%[AebHMSL]",
                    "%[AebHMSL]",
                    "-%[HMSL]"
                ],
                second: [
                    "%[AebHMS]",
                    "%[AebHMS]",
                    "-%[HMS]"
                ],
                minute: [
                    "%[AebHM]",
                    "%[AebHM]",
                    "-%[HM]"
                ],
                hour: [
                    "%[AebHM]",
                    "%[AebHM]",
                    "-%[HM]"
                ],
                day: [
                    "%[AebY]",
                    "%[Aeb]",
                    "-%[AebY]"
                ],
                week: [
                    "%v %[AebY]",
                    "%[Aeb]",
                    "-%[AebY]"
                ],
                month: [
                    "%[BY]",
                    "%[B]",
                    "-%[BY]"
                ],
                year: [
                    "%Y",
                    "%Y",
                    "-%Y"
                ]
            }
        }, uE = {
            line: {},
            spline: {},
            area: {},
            areaspline: {},
            arearange: {},
            column: {
                groupPixelWidth: 10
            },
            columnrange: {
                groupPixelWidth: 10
            },
            candlestick: {
                groupPixelWidth: 10
            },
            ohlc: {
                groupPixelWidth: 5
            },
            hlc: {
                groupPixelWidth: 5
            },
            heikinashi: {
                groupPixelWidth: 10
            }
        }, uL = [
            [
                "millisecond",
                [
                    1,
                    2,
                    5,
                    10,
                    20,
                    25,
                    50,
                    100,
                    200,
                    500
                ]
            ],
            [
                "second",
                [
                    1,
                    2,
                    5,
                    10,
                    15,
                    30
                ]
            ],
            [
                "minute",
                [
                    1,
                    2,
                    5,
                    10,
                    15,
                    30
                ]
            ],
            [
                "hour",
                [
                    1,
                    2,
                    3,
                    4,
                    6,
                    8,
                    12
                ]
            ],
            [
                "day",
                [
                    1
                ]
            ],
            [
                "week",
                [
                    1
                ]
            ],
            [
                "month",
                [
                    1,
                    3,
                    6
                ]
            ],
            [
                "year",
                null
            ]
        ], { addEvent: uB, extend: uD, merge: uI, pick: uz } = tx;
        function uR(t) {
            let e = this, i = e.series;
            i.forEach(function(t) {
                t.groupPixelWidth = void 0;
            }), i.forEach(function(i) {
                i.groupPixelWidth = e.getGroupPixelWidth && e.getGroupPixelWidth(), i.groupPixelWidth && (i.hasProcessed = !0), i.applyGrouping(!!t.hasExtremesChanged);
            });
        }
        function uN() {
            let t = this.series, e = t.length, i = 0, s = !1, o, r;
            for(; e--;)(r = t[e].options.dataGrouping) && (i = Math.max(i, uz(r.groupPixelWidth, uO.groupPixelWidth)), o = (t[e].dataTable.getModified() || t[e].dataTable).rowCount, (t[e].groupPixelWidth || o > this.chart.plotSizeX / i || o && r.forced) && (s = !0));
            return s ? i : 0;
        }
        function uW() {
            this.series.forEach(function(t) {
                t.hasProcessed = !1;
            });
        }
        function uG(t, e) {
            let i;
            if (e = uz(e, !0), t || (t = {
                forced: !1,
                units: null
            }), this instanceof o) for(i = this.series.length; i--;)this.series[i].update({
                dataGrouping: t
            }, !1);
            else this.chart.options.series.forEach(function(e) {
                e.dataGrouping = "boolean" == typeof t ? t : uI(t, e.dataGrouping);
            });
            this.ordinal && (this.ordinal.slope = void 0), e && this.chart.redraw();
        }
        let uX = function(t) {
            o = t;
            let e = t.prototype;
            e.applyGrouping || (uB(t, "afterSetScale", uW), uB(t, "postProcessData", uR), uD(e, {
                applyGrouping: uR,
                getGroupPixelWidth: uN,
                setDataGrouping: uG
            }));
        }, { series: { prototype: uH } } = r_, { addEvent: uF, defined: uY, error: uj, extend: uU, isNumber: uV, merge: u$, pick: u_, splat: uZ } = tx, uq = uH.generatePoints;
        function uK(t) {
            var e, i, s;
            let o, r, a = this.chart, n = this.options.dataGrouping, h = !1 !== this.allowDG && n && u_(n.enabled, a.options.isStock), l = this.reserveSpace(), d = this.currentDataGrouping, c, p, u = !1;
            h && !this.requireSorting && (this.requireSorting = u = !0);
            let g = !1 == (e = this, i = t, !(e.isCartesian && !e.isDirty && !e.xAxis.isDirty && !e.yAxis.isDirty && !i)) || !h;
            if (u && (this.requireSorting = !1), g) return;
            this.destroyGroupedData();
            let f = n.groupAll ? this.dataTable : this.dataTable.getModified() || this.dataTable, m = this.getColumn("x", !n.groupAll), x = a.plotSizeX, y = this.xAxis, b = y.getExtremes(), v = y.options.ordinal, k = this.groupPixelWidth;
            if (k && m && f.rowCount && x && uV(b.min)) {
                r = !0, this.isDirty = !0, this.points = null;
                let t = b.min, e = b.max, i = v && y.ordinal && y.ordinal.getGroupIntervalFactor(t, e, this) || 1, h = k * (e - t) / x * i, d = y.getTimeTicks(ol.Additions.prototype.normalizeTimeTickInterval(h, n.units || uL), Math.min(t, m[0]), Math.max(e, m[m.length - 1]), y.options.startOfWeek, m, this.closestPointRange), u = uH.groupData.apply(this, [
                    f,
                    d,
                    n.approximation
                ]), g = u.modified, M = g.getColumn("x", !0), w = 0;
                for(n?.smoothed && g.rowCount && (n.firstAnchor = "firstPoint", n.anchor = "middle", n.lastAnchor = "lastPoint", uj(32, !1, a, {
                    "dataGrouping.smoothed": "use dataGrouping.anchor"
                })), o = 1; o < d.length; o++)d.info.segmentStarts && -1 !== d.info.segmentStarts.indexOf(o) || (w = Math.max(d[o] - d[o - 1], w));
                (c = d.info).gapSize = w, this.closestPointRange = d.info.totalRange, this.groupMap = u.groupMap, this.currentDataGrouping = c, function(t, e, i) {
                    let s = t.options.dataGrouping, o = t.currentDataGrouping && t.currentDataGrouping.gapSize, r = t.getColumn("x");
                    if (!(s && r.length && o && t.groupMap)) return;
                    let a = e.length - 1, n = s.anchor, h = s.firstAnchor, l = s.lastAnchor, d = e.length - 1, c = 0;
                    if (h && r[0] >= e[0]) {
                        let i;
                        c++;
                        let s = t.groupMap[0].start, a = t.groupMap[0].length;
                        uV(s) && uV(a) && (i = s + (a - 1)), e[0] = ({
                            start: e[0],
                            middle: e[0] + .5 * o,
                            end: e[0] + o,
                            firstPoint: r[0],
                            lastPoint: i && r[i]
                        })[h];
                    }
                    if (a > 0 && l && o && e[a] >= i - o) {
                        d--;
                        let i = t.groupMap[t.groupMap.length - 1].start;
                        e[a] = ({
                            start: e[a],
                            middle: e[a] + .5 * o,
                            end: e[a] + o,
                            firstPoint: i && r[i],
                            lastPoint: r[r.length - 1]
                        })[l];
                    }
                    if (n && "start" !== n) {
                        let t = o * ({
                            middle: .5,
                            end: 1
                        })[n];
                        for(; d >= c;)e[d] += t, d--;
                    }
                }(this, M || [], e), l && M && (uY((s = M)[0]) && uV(y.min) && uV(y.dataMin) && s[0] < y.min && ((!uY(y.options.min) && y.min <= y.dataMin || y.min === y.dataMin) && (y.min = Math.min(s[0], y.min)), y.dataMin = Math.min(s[0], y.dataMin)), uY(s[s.length - 1]) && uV(y.max) && uV(y.dataMax) && s[s.length - 1] > y.max && ((!uY(y.options.max) && uV(y.dataMax) && y.max >= y.dataMax || y.max === y.dataMax) && (y.max = Math.max(s[s.length - 1], y.max)), y.dataMax = Math.max(s[s.length - 1], y.dataMax))), n.groupAll && (this.allGroupedTable = g, M = (g = (p = this.cropData(g, y.min || 0, y.max || 0)).modified).getColumn("x"), this.cropStart = p.start), this.dataTable.modified = g;
            } else this.groupMap = void 0, this.currentDataGrouping = void 0;
            this.hasGroupedData = r, this.preventGraphAnimation = (d && d.totalRange) !== (c && c.totalRange);
        }
        function uJ() {
            this.groupedData && (this.groupedData.forEach(function(t, e) {
                t && (this.groupedData[e] = t.destroy ? t.destroy() : null);
            }, this), this.groupedData.length = 0, delete this.allGroupedTable);
        }
        function uQ() {
            uq.apply(this), this.destroyGroupedData(), this.groupedData = this.hasGroupedData ? this.points : null;
        }
        function u0() {
            return this.is("arearange") ? "range" : this.is("ohlc") ? "ohlc" : this.is("hlc") ? "hlc" : this.is("column") || this.options.cumulative ? "sum" : "average";
        }
        function u1(t, e, i) {
            let s = t.getColumn("x", !0) || [], o = t.getColumn("y", !0), r = this, a = r.data, n = r.options && r.options.data, h = [], l = new rz, d = [], c = t.rowCount, p = !!o, u = [], g = r.pointArrayMap, f = g && g.length, m = [
                "x"
            ].concat(g || [
                "y"
            ]), x = (g || [
                "y"
            ]).map(()=>[]), y = this.options.dataGrouping && this.options.dataGrouping.groupAll, b, v, k, M = 0, w = 0, S = "function" == typeof i ? i : i && uv[i] ? uv[i] : uv[r.getDGApproximation && r.getDGApproximation() || "average"];
            if (f) {
                let t = g.length;
                for(; t--;)u.push([]);
            } else u.push([]);
            let A = f || 1;
            for(let t = 0; t <= c; t++)if (!(s[t] < e[0])) {
                for(; void 0 !== e[M + 1] && s[t] >= e[M + 1] || t === c;){
                    if (b = e[M], r.dataGroupInfo = {
                        start: y ? w : r.cropStart + w,
                        length: u[0].length,
                        groupStart: b
                    }, k = S.apply(r, u), r.pointClass && !uY(r.dataGroupInfo.options) && (r.dataGroupInfo.options = u$(r.pointClass.prototype.optionsToObject.call({
                        series: r
                    }, r.options.data[r.cropStart + w])), m.forEach(function(t) {
                        delete r.dataGroupInfo.options[t];
                    })), void 0 !== k) {
                        h.push(b);
                        let t = uZ(k);
                        for(let e = 0; e < t.length; e++)x[e].push(t[e]);
                        d.push(r.dataGroupInfo);
                    }
                    w = t;
                    for(let t = 0; t < A; t++)u[t].length = 0, u[t].hasNulls = !1;
                    if (M += 1, t === c) break;
                }
                if (t === c) break;
                if (g) {
                    let e, i = y ? t : r.cropStart + t, s = a && a[i] || r.pointClass.prototype.applyOptions.apply({
                        series: r
                    }, [
                        n[i]
                    ]);
                    for(let t = 0; t < f; t++)uV(e = s[g[t]]) ? u[t].push(e) : null === e && (u[t].hasNulls = !0);
                } else uV(v = p ? o[t] : null) ? u[0].push(v) : null === v && (u[0].hasNulls = !0);
            }
            let T = {
                x: h
            };
            return (g || [
                "y"
            ]).forEach((t, e)=>{
                T[t] = x[e];
            }), l.setColumns(T), {
                groupMap: d,
                modified: l
            };
        }
        function u2(t) {
            let e = t.options, i = this.type, s = this.chart.options.plotOptions, o = this.useCommonDataGrouping && uO, r = tY.defaultOptions.plotOptions[i].dataGrouping;
            if (s && (uE[i] || o)) {
                let t = this.chart.rangeSelector;
                r || (r = u$(uO, uE[i])), e.dataGrouping = u$(o, r, s.series && s.series.dataGrouping, s[i].dataGrouping, this.userOptions.dataGrouping, !e.isInternal && t && uV(t.selected) && t.buttonOptions[t.selected].dataGrouping);
            }
        }
        let u3 = function(t) {
            let e = t.prototype;
            e.applyGrouping || (uF(t.prototype.pointClass, "update", function() {
                if (this.dataGroup) return uj(24, !1, this.series.chart), !1;
            }), uF(t, "afterSetOptions", u2), uF(t, "destroy", uJ), uU(e, {
                applyGrouping: uK,
                destroyGroupedData: uJ,
                generatePoints: uQ,
                getDGApproximation: u0,
                groupData: u1
            }));
        }, { format: u5 } = eI, { composed: u6 } = V, { addEvent: u9, extend: u4, isNumber: u8, pick: u7, pushUnique: gt } = tx;
        function ge(t) {
            let e = this.chart, i = e.time, s = t.point, o = s.series, r = o.options, a = o.tooltipOptions, n = r.dataGrouping, h = o.xAxis, l = a.xDateFormat || "", d, c, p, u, g, f = a[t.isFooter ? "footerFormat" : "headerFormat"];
            if (h && "datetime" === h.options.type && n && u8(s.key)) {
                c = o.currentDataGrouping, p = n.dateTimeLabelFormats || uO.dateTimeLabelFormats, c ? (u = p[c.unitName], 1 === c.count ? l = u[0] : (l = u[1], d = u[2])) : !l && p && h.dateTime && (l = h.dateTime.getXDateFormat(s.x, a.dateTimeLabelFormats));
                let r = u7(o.groupMap?.[s.index].groupStart, s.key), m = r + (c?.totalRange || 0) - 1;
                g = i.dateFormat(l, r), d && (g += i.dateFormat(d, m)), o.chart.styledMode && (f = this.styledModeFormat(f)), t.text = u5(f, {
                    point: u4(s, {
                        key: g
                    }),
                    series: o
                }, e), t.preventDefault();
            }
        }
        V.dataGrouping = V.dataGrouping || {}, V.dataGrouping.approximationDefaults = V.dataGrouping.approximationDefaults || uP, V.dataGrouping.approximations = V.dataGrouping.approximations || uv, ({
            compose: function(t, e, i) {
                uX(t), u3(e), i && gt(u6, "DataGrouping") && u9(i, "headerFormatter", ge);
            },
            groupData: u1
        }).compose(V.Axis, V.Series, V.Tooltip);
        let { defined: gi, isNumber: gs, pick: go } = tx, gr = {
            backgroundColor: "string",
            borderColor: "string",
            borderRadius: "string",
            color: "string",
            fill: "string",
            fontSize: "string",
            labels: "string",
            name: "string",
            stroke: "string",
            title: "string"
        }, { addEvent: ga, isObject: gn, pick: gh, defined: gl, merge: gd } = tx, { getAssignedAxis: gc } = {
            annotationsFieldsTypes: gr,
            getAssignedAxis: function(t) {
                return t.filter((t)=>{
                    let e = t.axis.getExtremes(), i = e.min, s = e.max, o = go(t.axis.minPointOffset, 0);
                    return gs(i) && gs(s) && t.value >= i - o && t.value <= s + o && !t.axis.options.isInternal;
                })[0];
            },
            getFieldType: function(t, e) {
                let i = gr[t], s = typeof e;
                return gi(i) && (s = i), ({
                    string: "text",
                    number: "number",
                    boolean: "checkbox"
                })[s];
            }
        }, gp = [], gu = {
            enabled: !0,
            sensitivity: 1.1,
            showResetButton: !1
        }, gg = function(t, e, i, s, o, a, n) {
            let h = gh(n.type, t.zooming.type, ""), l = [];
            "x" === h ? l = i : "y" === h ? l = s : "xy" === h && (l = t.axes);
            let d = t.transform({
                axes: l,
                to: {
                    x: o - 5,
                    y: a - 5,
                    width: 10,
                    height: 10
                },
                from: {
                    x: o - 5 * e,
                    y: a - 5 * e,
                    width: 10 * e,
                    height: 10 * e
                },
                trigger: "mousewheel",
                allowResetButton: n.showResetButton
            });
            return d && (gl(r) && clearTimeout(r), r = setTimeout(()=>{
                t.pointer?.drop();
            }, 400)), d;
        };
        function gf() {
            var t;
            let e = (gn(t = this.zooming.mouseWheel) || (t = {
                enabled: t ?? !0
            }), gd(gu, t));
            e.enabled && ga(this.container, "wheel", (t)=>{
                t = this.pointer?.normalize(t) || t;
                let { pointer: i } = this, s = i && !i.inClass(t.target, "highcharts-no-mousewheel");
                if (this.isInsidePlot(t.chartX - this.plotLeft, t.chartY - this.plotTop) && s) {
                    let s = e.sensitivity || 1.1, o = t.detail || (t.deltaY || 0) / 120, r = gc(i.getCoordinates(t).xAxis), a = gc(i.getCoordinates(t).yAxis);
                    gg(this, Math.pow(s, o), r ? [
                        r.axis
                    ] : this.xAxis, a ? [
                        a.axis
                    ] : this.yAxis, t.chartX, t.chartY, e) && t.preventDefault?.();
                }
            });
        }
        V.MouseWheelZoom = V.MouseWheelZoom || {
            compose: function(t) {
                -1 === gp.indexOf(t) && (gp.push(t), ga(t, "afterGetContainer", gf));
            }
        }, V.MouseWheelZoom.compose(V.Chart), V.Navigator = V.Navigator || cw, V.OrdinalAxis = V.OrdinalAxis || cD, V.RangeSelector = V.RangeSelector || ph, V.Scrollbar = V.Scrollbar || cs, V.stockChart = V.stockChart || pT.stockChart, V.StockChart = V.StockChart || V.stockChart, V.extend(V.StockChart, pT), dn.compose(V.Series, V.Axis, V.Point), up.compose(V.Renderer), pU.compose(V.Series), V.Navigator.compose(V.Chart, V.Axis, V.Series), V.OrdinalAxis.compose(V.Axis, V.Series, V.Chart), V.RangeSelector.compose(V.Axis, V.Chart), V.Scrollbar.compose(V.Axis), V.StockChart.compose(V.Chart, V.Axis, V.Series, V.SVGRenderer), V.product = "Highstock";
        let gm = V;
        return U.default;
    })());
}),
"[project]/node_modules/highcharts/es-modules/Core/Globals.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
/* *
 *
 *  Namespace
 *
 * */ /**
 * Shared Highcharts properties.
 * @internal
 */ var Globals;
(function(Globals) {
    /* *
     *
     *  Constants
     *
     * */ Globals.SVG_NS = 'http://www.w3.org/2000/svg', Globals.product = 'Highcharts', Globals.version = '12.5.0', Globals.win = typeof window !== 'undefined' ? window : {}, Globals.doc = Globals.win.document, Globals.svg = !!Globals.doc?.createElementNS?.(Globals.SVG_NS, 'svg')?.createSVGRect, Globals.pageLang = Globals.doc?.documentElement?.closest('[lang]')?.lang, Globals.userAgent = Globals.win.navigator?.userAgent || '', Globals.isChrome = Globals.win.chrome, Globals.isFirefox = Globals.userAgent.indexOf('Firefox') !== -1, Globals.isMS = /(edge|msie|trident)/i.test(Globals.userAgent) && !Globals.win.opera, Globals.isSafari = !Globals.isChrome && Globals.userAgent.indexOf('Safari') !== -1, Globals.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(Globals.userAgent), Globals.isWebKit = Globals.userAgent.indexOf('AppleWebKit') !== -1, Globals.deg2rad = Math.PI * 2 / 360, Globals.marginNames = [
        'plotTop',
        'marginRight',
        'marginBottom',
        'plotLeft'
    ], Globals.noop = function() {}, Globals.supportsPassiveEvents = function() {
        // Checks whether the browser supports passive events, (#11353).
        let supportsPassive = false;
        // Object.defineProperty doesn't work on IE as well as passive
        // events - instead of using polyfill, we can exclude IE totally.
        if (!Globals.isMS) {
            const opts = Object.defineProperty({}, 'passive', {
                get: function() {
                    supportsPassive = true;
                }
            });
            if (Globals.win.addEventListener && Globals.win.removeEventListener) {
                Globals.win.addEventListener('testPassive', Globals.noop, opts);
                Globals.win.removeEventListener('testPassive', Globals.noop, opts);
            }
        }
        return supportsPassive;
    }();
    /**
     * An array containing the current chart objects in the page. A chart's
     * position in the array is preserved throughout the page's lifetime. When
     * a chart is destroyed, the array item becomes `undefined`.
     *
     * @name Highcharts.charts
     * @type {Array<Highcharts.Chart|undefined>}
     */ Globals.charts = [];
    /**
     * A shared registry between all bundles to keep track of applied
     * compositions.
     * @internal
     */ Globals.composed = [];
    /**
     * A hook for defining additional date format specifiers. New
     * specifiers are defined as key-value pairs by using the
     * specifier as key, and a function which takes the timestamp as
     * value. This function returns the formatted portion of the
     * date.
     *
     * Using `dateFormats` is also a convenient way to define new keys for
     * complex locale-aware date formats compatible with the
     * [Intl.DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat)
     * browser API, whenever the built-in formats are not sufficient.
     *
     * @sample highcharts/global/dateformats/
     *         Adding support for week number
     * @sample highcharts/global/dateformats-object/
     *         A locale-aware date format using `Intl.DateTimeFormat`
     *
     * @name Highcharts.dateFormats
     * @type {Record<string, Highcharts.TimeFormatCallbackFunction>}
     */ Globals.dateFormats = {};
    /**
     * @internal
     * @deprecated
     * @todo Use only `Core/Series/SeriesRegistry.seriesTypes`
     */ Globals.seriesTypes = {};
    /** @internal */ Globals.symbolSizes = {};
    /* *
     *
     *  Properties
     *
     * */ // eslint-disable-next-line prefer-const
    Globals.chartCount = 0;
})(Globals || (Globals = {}));
const __TURBOPACK__default__export__ = Globals;
/* *
 *
 *  API Declarations
 *
 * */ /**
 * Theme options that should get applied to the chart. In module mode it
 * might not be possible to change this property because of read-only
 * restrictions, instead use {@link Highcharts.setOptions}.
 *
 * @deprecated
 * @name Highcharts.theme
 * @type {Highcharts.Options}
 */ ''; // Keeps doclets above in JS file
}),
"[project]/node_modules/highcharts/es-modules/Core/Chart/ChartDefaults.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
/* *
 *
 *  API Options
 *
 * */ /**
 * General options for the chart.
 *
 * @optionparent chart
 */ const ChartDefaults = {
    /**
     * Default `mapData` for all series, in terms of a GeoJSON or TopoJSON
     * object. If set to a string, it functions as an index into the
     * `Highcharts.maps` array.
     *
     * For picking out individual shapes and geometries to use for each series
     * of the map, see [series.mapData](#series.map.mapData).
     *
     * @sample    maps/demo/geojson
     *            Loading GeoJSON data
     * @sample    maps/chart/topojson
     *            Loading TopoJSON data
     *
     * @type      {string|Array<*>|Highcharts.GeoJSON|Highcharts.TopoJSON}
     * @since     5.0.0
     * @product   highmaps
     * @apioption chart.map
     */ /**
     * Set lat/lon transformation definitions for the chart. If not defined,
     * these are extracted from the map data.
     *
     * @type      {*}
     * @since     5.0.0
     * @product   highmaps
     * @apioption chart.mapTransforms
     */ /**
     * When using multiple axes, the ticks of two or more opposite axes
     * will automatically be aligned by adding ticks to the axis or axes
     * with the least ticks, as if `tickAmount` were specified.
     *
     * This can be prevented by setting `alignTicks` to false. If the grid
     * lines look messy, it's a good idea to hide them for the secondary
     * axis by setting `gridLineWidth` to 0.
     *
     * If `startOnTick` or `endOnTick` in the axis options are set to false,
     * then the `alignTicks ` will be disabled for the axis.
     *
     * Disabled for logarithmic axes.
     *
     * @sample {highcharts} highcharts/chart/alignticks-true/
     *         True by default
     * @sample {highcharts} highcharts/chart/alignticks-false/
     *         False
     * @sample {highstock} stock/chart/alignticks-true/
     *         True by default
     * @sample {highstock} stock/chart/alignticks-false/
     *         False
     *
     * @type      {boolean}
     * @default   true
     * @product   highcharts highstock gantt
     * @apioption chart.alignTicks
     */ /**
     * When using multiple axes, align the thresholds. When this is true, other
     * ticks will also be aligned.
     *
     * Note that for line series and some other series types, the `threshold`
     * option is set to `null` by default. This will in turn cause their y-axis
     * to not have a threshold. In order to avoid that, set the series
     * `threshold` to 0 or another number.
     *
     * If `startOnTick` or `endOnTick` in the axis options are set to false, or
     * if the axis is logarithmic, the threshold will not be aligned.
     *
     * @sample {highcharts} highcharts/chart/alignthresholds/ Set to true
     *
     * @since 10.0.0
     * @product   highcharts highstock gantt
     * @apioption chart.alignThresholds
     */ alignThresholds: false,
    /**
     * Set the overall animation for all chart updating. Animation can be
     * disabled throughout the chart by setting it to false here. It can
     * be overridden for each individual API method as a function parameter.
     * The only animation not affected by this option is the initial series
     * animation, see [plotOptions.series.animation](
     * #plotOptions.series.animation).
     *
     * The animation can either be set as a boolean or a configuration
     * object. If `true`, it will use the 'swing' jQuery easing and a
     * duration of 500 ms. If used as a configuration object, the following
     * properties are supported:
     *
     * - `defer`: The animation delay time in milliseconds.
     *
     * - `duration`: The duration of the animation in milliseconds.
     *
     * - `easing`: A string reference to an easing function set on the
     *   `Math` object. See
     *   [the easing demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-animation-easing/).
     *
     * When zooming on a series with less than 100 points, the chart redraw
     * will be done with animation, but in case of more data points, it is
     * necessary to set this option to ensure animation on zoom.
     *
     * @sample {highcharts} highcharts/chart/animation-none/
     *         Updating with no animation
     * @sample {highcharts} highcharts/chart/animation-duration/
     *         With a longer duration
     * @sample {highcharts} highcharts/chart/animation-easing/
     *         With a jQuery UI easing
     * @sample {highmaps} maps/chart/animation-none/
     *         Updating with no animation
     * @sample {highmaps} maps/chart/animation-duration/
     *         With a longer duration
     *
     * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
     * @default   true
     * @apioption chart.animation
     */ /**
     * A CSS class name to apply to the charts container `div`, allowing
     * unique CSS styling for each chart.
     *
     * @type      {string}
     * @apioption chart.className
     */ /**
     * Event listeners for the chart.
     *
     * @apioption chart.events
     */ /**
     * Fires when a series is added to the chart after load time, using the
     * `addSeries` method. One parameter, `event`, is passed to the
     * function, containing common event information. Through
     * `event.options` you can access the series options that were passed to
     * the `addSeries` method. Returning false prevents the series from
     * being added.
     *
     * @sample {highcharts} highcharts/chart/events-addseries/
     *         Alert on add series
     * @sample {highstock} stock/chart/events-addseries/
     *         Alert on add series
     *
     * @type      {Highcharts.ChartAddSeriesCallbackFunction}
     * @since     1.2.0
     * @context   Highcharts.Chart
     * @apioption chart.events.addSeries
     */ /**
     * Fires when clicking on the plot background. One parameter, `event`,
     * is passed to the function, containing common event information.
     *
     * Information on the clicked spot can be found through `event.xAxis`
     * and `event.yAxis`, which are arrays containing the axes of each
     * dimension and each axis' value at the clicked spot. The primary axes
     * are `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
     * datetime axis is milliseconds since 1970-01-01 00:00:00.
     *
     * ```js
     * click: function(e) {
     *     console.log(
     *         Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', e.xAxis[0].value),
     *         e.yAxis[0].value
     *     )
     * }
     * ```
     *
     * @sample {highcharts} highcharts/chart/events-click/
     *         Alert coordinates on click
     * @sample {highcharts} highcharts/chart/events-container/
     *         Alternatively, attach event to container
     * @sample {highstock} stock/chart/events-click/
     *         Alert coordinates on click
     * @sample {highstock} highcharts/chart/events-container/
     *         Alternatively, attach event to container
     * @sample {highmaps} maps/chart/events-click/
     *         Record coordinates on click
     * @sample {highmaps} highcharts/chart/events-container/
     *         Alternatively, attach event to container
     *
     * @type      {Highcharts.ChartClickCallbackFunction}
     * @since     1.2.0
     * @context   Highcharts.Chart
     * @apioption chart.events.click
     */ /**
     * Fires when the chart is finished loading. Since v4.2.2, it also waits
     * for images to be loaded, for example from point markers. One
     * parameter, `event`, is passed to the function, containing common
     * event information.
     *
     * There is also a second parameter to the chart constructor where a
     * callback function can be passed to be executed on chart.load.
     *
     * @sample {highcharts} highcharts/chart/events-load/
     *         Alert on chart load
     * @sample {highcharts} highcharts/chart/events-render/
     *         Load vs Redraw vs Render
     * @sample {highstock} stock/chart/events-load/
     *         Alert on chart load
     * @sample {highmaps} maps/chart/events-load/
     *         Add series on chart load
     *
     * @type      {Highcharts.ChartLoadCallbackFunction}
     * @context   Highcharts.Chart
     * @apioption chart.events.load
     */ /**
     * Fires when the chart is redrawn, either after a call to
     * `chart.redraw()` or after an axis, series or point is modified with
     * the `redraw` option set to `true`. One parameter, `event`, is passed
     * to the function, containing common event information.
     *
     * @sample {highcharts} highcharts/chart/events-redraw/
     *         Alert on chart redraw
     * @sample {highcharts} highcharts/chart/events-render/
     *         Load vs Redraw vs Render
     * @sample {highstock} stock/chart/events-redraw/
     *         Alert on chart redraw when adding a series or moving the
     *         zoomed range
     * @sample {highmaps} maps/chart/events-redraw/
     *         Set subtitle on chart redraw
     *
     * @type      {Highcharts.ChartRedrawCallbackFunction}
     * @since     1.2.0
     * @context   Highcharts.Chart
     * @apioption chart.events.redraw
     */ /**
     * Fires after initial load of the chart (directly after the `load`
     * event), and after each redraw (directly after the `redraw` event).
     *
     * @sample {highcharts} highcharts/chart/events-render/
     *         Load vs Redraw vs Render
     *
     * @type      {Highcharts.ChartRenderCallbackFunction}
     * @since     5.0.7
     * @context   Highcharts.Chart
     * @apioption chart.events.render
     */ /**
     * Fires when an area of the chart has been selected. Selection is
     * enabled by setting the chart's zoomType. One parameter, `event`, is
     * passed to the function, containing common event information. The
     * default action for the selection event is to zoom the chart to the
     * selected area. It can be prevented by calling
     * `event.preventDefault()` or return false.
     *
     * Information on the selected area can be found through `event.xAxis`
     * and `event.yAxis`, which are arrays containing the axes of each
     * dimension and each axis' min and max values. The primary axes are
     * `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
     * datetime axis is milliseconds since 1970-01-01 00:00:00.
     *
     * ```js
     * selection: function(event) {
     *     // log the min and max of the primary, datetime x-axis
     *     console.log(
     *         Highcharts.dateFormat(
     *             '%Y-%m-%d %H:%M:%S',
     *             event.xAxis[0].min
     *         ),
     *         Highcharts.dateFormat(
     *             '%Y-%m-%d %H:%M:%S',
     *             event.xAxis[0].max
     *         )
     *     );
     *     // log the min and max of the y axis
     *     console.log(event.yAxis[0].min, event.yAxis[0].max);
     * }
     * ```
     *
     * @sample {highcharts} highcharts/chart/events-selection/
     *         Report on selection and reset
     * @sample {highcharts} highcharts/chart/events-selection-points/
     *         Select a range of points through a drag selection
     * @sample {highstock} stock/chart/events-selection/
     *         Report on selection and reset
     * @sample {highstock} highcharts/chart/events-selection-points/
     *         Select a range of points through a drag selection
     *         (Highcharts)
     *
     * @type      {Highcharts.ChartSelectionCallbackFunction}
     * @apioption chart.events.selection
     */ /**
     * The margin between the outer edge of the chart and the plot area.
     * The numbers in the array designate top, right, bottom and left
     * respectively. Use the options `marginTop`, `marginRight`,
     * `marginBottom` and `marginLeft` for shorthand setting of one option.
     *
     * By default there is no margin. The actual space is dynamically
     * calculated from the offset of axis labels, axis title, title,
     * subtitle and legend in addition to the `spacingTop`, `spacingRight`,
     * `spacingBottom` and `spacingLeft` options.
     *
     * @sample {highcharts} highcharts/chart/margins-zero/
     *         Zero margins
     * @sample {highstock} stock/chart/margin-zero/
     *         Zero margins
     *
     * @type      {number|Array<number>}
     * @apioption chart.margin
     */ /**
     * The margin between the bottom outer edge of the chart and the plot
     * area. Use this to set a fixed pixel value for the margin as opposed
     * to the default dynamic margin. See also `spacingBottom`.
     *
     * @sample {highcharts} highcharts/chart/marginbottom/
     *         100px bottom margin
     * @sample {highstock} stock/chart/marginbottom/
     *         100px bottom margin
     * @sample {highmaps} maps/chart/margin/
     *         100px margins
     *
     * @type      {number}
     * @since     2.0
     * @apioption chart.marginBottom
     */ /**
     * The margin between the left outer edge of the chart and the plot
     * area. Use this to set a fixed pixel value for the margin as opposed
     * to the default dynamic margin. See also `spacingLeft`.
     *
     * @sample {highcharts} highcharts/chart/marginleft/
     *         150px left margin
     * @sample {highstock} stock/chart/marginleft/
     *         150px left margin
     * @sample {highmaps} maps/chart/margin/
     *         100px margins
     *
     * @type      {number}
     * @since     2.0
     * @apioption chart.marginLeft
     */ /**
     * The margin between the right outer edge of the chart and the plot
     * area. Use this to set a fixed pixel value for the margin as opposed
     * to the default dynamic margin. See also `spacingRight`.
     *
     * @sample {highcharts} highcharts/chart/marginright/
     *         100px right margin
     * @sample {highstock} stock/chart/marginright/
     *         100px right margin
     * @sample {highmaps} maps/chart/margin/
     *         100px margins
     *
     * @type      {number}
     * @since     2.0
     * @apioption chart.marginRight
     */ /**
     * The margin between the top outer edge of the chart and the plot area.
     * Use this to set a fixed pixel value for the margin as opposed to
     * the default dynamic margin. See also `spacingTop`.
     *
     * @sample {highcharts} highcharts/chart/margintop/ 100px top margin
     * @sample {highstock} stock/chart/margintop/
     *         100px top margin
     * @sample {highmaps} maps/chart/margin/
     *         100px margins
     *
     * @type      {number}
     * @since     2.0
     * @apioption chart.marginTop
     */ /**
     * Callback function to override the default function that formats all
     * the numbers in the chart. Returns a string with the formatted number.
     *
     * @sample highcharts/members/highcharts-numberformat
     *      Arabic digits in Highcharts
     * @type {Highcharts.NumberFormatterCallbackFunction}
     * @since 8.0.0
     * @apioption chart.numberFormatter
     */ /**
     * When a chart with an x and a y-axis is rendered, we first pre-render the
     * labels of both in order to measure them. Then, if either of the axis
     * labels take up so much space that it significantly affects the length of
     * the other axis, we repeat the process.
     *
     * By default we stop at two axis layout runs, but it may be that the second
     * run also alter the space required by either axis, for example if it
     * causes the labels to rotate. In this situation, a subsequent redraw of
     * the chart may cause the tick and label placement to change for apparently
     * no reason.
     *
     * Use the `axisLayoutRuns` option to set the maximum allowed number of
     * repetitions. But keep in mind that the default value of 2 is set because
     * every run costs performance time.
     *
     * **Note:** Changing that option to higher than the default might decrease
     * performance significantly, especially with bigger sets of data.
     *
     * @type      {number}
     * @default   2
     * @since     11.3.0
     * @apioption chart.axisLayoutRuns
     */ /**
     * Allows setting a key to switch between zooming and panning. Can be
     * one of `alt`, `ctrl`, `meta` (the command key on Mac and Windows
     * key on Windows) or `shift`. The keys are mapped directly to the key
     * properties of the click event argument (`event.altKey`,
     * `event.ctrlKey`, `event.metaKey` and `event.shiftKey`).
     *
     * @type       {string}
     * @since      4.0.3
     * @product    highcharts gantt
     * @validvalue ["alt", "ctrl", "meta", "shift"]
     * @apioption  chart.panKey
     */ /**
     * Allow panning in a chart. Best used with [panKey](#chart.panKey)
     * to combine zooming and panning.
     *
     * On touch devices, when the [tooltip.followTouchMove](
     * #tooltip.followTouchMove) option is `true` (default), panning
     * requires two fingers. To allow panning with one finger, set
     * `followTouchMove` to `false`.
     *
     * @sample  {highcharts} highcharts/chart/pankey/ Zooming and panning
     * @sample  {highstock} stock/chart/panning/ Zooming and xy panning
     */ panning: {
        /**
         * Enable or disable chart panning.
         *
         * @type      {boolean}
         * @default   {highcharts} false
         * @default   {highstock|highmaps} true
         */ enabled: false,
        /**
         * Decides in what dimensions the user can pan the chart. Can be
         * one of `x`, `y`, or `xy`.
         *
         * During panning, all axes will behave as if
         * [`startOnTick`](#yAxis.startOnTick) and
         * [`endOnTick`](#yAxis.endOnTick) were set to `false`. After the
         * panning action is finished, the axes will adjust to their actual
         * settings.
         *
         * **Note:** For non-cartesian series, the only supported panning type
         * is `xy`, as zooming in a single direction is not applicable due to
         * the radial nature of the coordinate system.
         *
         * @sample {highcharts} highcharts/chart/panning-type
         *         Zooming and xy panning
         *
         * @declare    Highcharts.OptionsChartPanningTypeValue
         * @type       {string}
         * @validvalue ["x", "y", "xy"]
         * @product    highcharts highstock gantt
         */ type: 'x'
    },
    /**
     * Equivalent to [zoomType](#chart.zoomType), but for multitouch
     * gestures only. By default, the `pinchType` is the same as the
     * `zoomType` setting. However, pinching can be enabled separately in
     * some cases, for example in stock charts where a mouse drag pans the
     * chart, while pinching is enabled. When [tooltip.followTouchMove](
     * #tooltip.followTouchMove) is true, pinchType only applies to
     * two-finger touches.
     *
     * @type       {string}
     * @default    {highcharts} undefined
     * @default    {highstock} undefined
     * @since      3.0
     * @product    highcharts highstock gantt
     * @deprecated
     * @validvalue ["x", "y", "xy"]
     * @apioption  chart.pinchType
     */ /**
     * Whether to apply styled mode. When in styled mode, no presentational
     * attributes or CSS are applied to the chart SVG. Instead, CSS rules
     * are required to style the chart. The default style sheet is
     * available from `https://code.highcharts.com/css/highcharts.css`.
     *
     * [Read more in the docs](https://www.highcharts.com/docs/chart-design-and-style/style-by-css)
     * on what classes and variables are available.
     *
     * @sample highcharts/css/colors
     *         Color theming with CSS
     * @sample highcharts/css/prefers-color-scheme
     *         Dynamic theme based on system settings
     * @type       {boolean}
     * @default    false
     * @since      7.0
     * @apioption  chart.styledMode
     */ styledMode: false,
    /**
     * The corner radius of the outer chart border.
     *
     * @sample {highcharts} highcharts/chart/borderradius/
     *         20px radius
     * @sample {highstock} stock/chart/border/
     *         10px radius
     * @sample {highmaps} maps/chart/border/
     *         Border options
     *
     */ borderRadius: 0,
    /**
     * In styled mode, this sets how many colors the class names
     * should rotate between. With ten colors, series (or points) are
     * given class names like `highcharts-color-0`, `highcharts-color-1`
     * [...] `highcharts-color-9`. The equivalent in non-styled mode
     * is to set colors using the [colors](#colors) setting.
     *
     * @since      5.0.0
     */ colorCount: 10,
    /**
     * By default, (because of memory and performance reasons) the chart does
     * not copy the data but keeps it as a reference. In some cases, this might
     * result in mutating the original data source. In order to prevent that,
     * set that property to false. Please note that changing that might decrease
     * performance, especially with bigger sets of data.
     *
     * @type       {boolean}
     * @since 10.1.0
     */ allowMutatingData: true,
    /**
     * If true, the axes will scale to the remaining visible series once
     * one series is hidden. If false, hiding and showing a series will
     * not affect the axes or the other series. For stacks, once one series
     * within the stack is hidden, the rest of the stack will close in
     * around it even if the axis is not affected.
     *
     * @sample {highcharts} highcharts/chart/ignorehiddenseries-true/
     *         True by default
     * @sample {highcharts} highcharts/chart/ignorehiddenseries-false/
     *         False
     * @sample {highcharts} highcharts/chart/ignorehiddenseries-true-stacked/
     *         True with stack
     * @sample {highstock} stock/chart/ignorehiddenseries-true/
     *         True by default
     * @sample {highstock} stock/chart/ignorehiddenseries-false/
     *         False
     *
     * @since   1.2.0
     * @product highcharts highstock gantt
     */ ignoreHiddenSeries: true,
    /**
     * Whether to invert the axes so that the x axis is vertical and y axis
     * is horizontal. When `true`, the x axis is [reversed](#xAxis.reversed)
     * by default.
     *
     * @productdesc {highcharts}
     * If a bar series is present in the chart, it will be inverted
     * automatically. Inverting the chart doesn't have an effect if there
     * are no cartesian series in the chart.
     *
     * @sample {highcharts} highcharts/chart/inverted/
     *         Inverted line
     * @sample {highstock} stock/navigator/inverted/
     *         Inverted stock chart
     *
     * @type      {boolean}
     * @default   false
     * @product   highcharts highstock gantt
     * @apioption chart.inverted
     */ /**
     * The distance between the outer edge of the chart and the content,
     * like title or legend, or axis title and labels if present. The
     * numbers in the array designate top, right, bottom and left
     * respectively. Use the options spacingTop, spacingRight, spacingBottom
     * and spacingLeft options for shorthand setting of one option.
     *
     * @type    {Array<number>}
     * @see     [chart.margin](#chart.margin)
     * @default [10, 10, 15, 10]
     * @since   3.0.6
     */ spacing: [
        10,
        10,
        15,
        10
    ],
    /**
     * The button that appears after a selection zoom, allowing the user
     * to reset zoom. This option is deprecated in favor of
     * [zooming](#chart.zooming).
     *
     * @since      2.2
     * @deprecated 10.2.1
     */ resetZoomButton: {
        /**
         * What frame the button placement should be related to. Can be
         * either `plotBox` or `spacingBox`.
         *
         * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
         *         Relative to the chart
         * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
         *         Relative to the chart
         *
         * @type      {Highcharts.ButtonRelativeToValue}
         * @apioption chart.resetZoomButton.relativeTo
         */ /**
         * A collection of attributes for the button. The object takes SVG
         * attributes like `fill`, `stroke`, `stroke-width` or `r`, the
         * border radius. The theme also supports `style`, a collection of
         * CSS properties for the text. Equivalent attributes for the hover
         * state are given in `theme.states.hover`.
         *
         * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
         *         Theming the button
         * @sample {highstock} highcharts/chart/resetzoombutton-theme/
         *         Theming the button
         *
         * @type {Highcharts.SVGAttributes}
         */ theme: {
        },
        /**
         * The position of the button.
         *
         * @sample {highcharts} highcharts/chart/resetzoombutton-position/
         *         Above the plot area
         * @sample {highstock} highcharts/chart/resetzoombutton-position/
         *         Above the plot area
         * @sample {highmaps} highcharts/chart/resetzoombutton-position/
         *         Above the plot area
         *
         * @type {Highcharts.AlignObject}
         */ position: {
        }
    },
    /**
     * The pixel width of the plot area border.
     *
     * @sample {highcharts} highcharts/chart/plotborderwidth/
     *         1px border
     * @sample {highstock} stock/chart/plotborder/
     *         2px border
     * @sample {highmaps} maps/chart/plotborder/
     *         Plot border options
     *
     * @type      {number}
     * @default   0
     * @apioption chart.plotBorderWidth
     */ /**
     * Whether to apply a drop shadow to the plot area. Requires that
     * plotBackgroundColor be set. The shadow can be an object configuration
     * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
     *
     * @sample {highcharts} highcharts/chart/plotshadow/
     *         Plot shadow
     * @sample {highstock} stock/chart/plotshadow/
     *         Plot shadow
     * @sample {highmaps} maps/chart/plotborder/
     *         Plot border options
     *
     * @type      {boolean|Highcharts.ShadowOptionsObject}
     * @default   false
     * @apioption chart.plotShadow
     */ /**
     * When true, cartesian charts like line, spline, area and column are
     * transformed into the polar coordinate system. This produces _polar
     * charts_, also known as _radar charts_.
     *
     * @sample {highcharts} highcharts/demo/polar/
     *         Polar chart
     * @sample {highcharts} highcharts/demo/polar-wind-rose/
     *         Wind rose, stacked polar column chart
     * @sample {highcharts} highcharts/demo/polar-spider/
     *         Spider web chart
     * @sample {highcharts} highcharts/parallel-coordinates/polar/
     *         Star plot, multivariate data in a polar chart
     *
     * @type      {boolean}
     * @default   false
     * @since     2.3.0
     * @product   highcharts
     * @requires  highcharts-more
     * @apioption chart.polar
     */ /**
     * Whether to reflow the chart to fit the width of the container div
     * on resizing the window.
     *
     * @sample {highcharts} highcharts/chart/reflow-true/
     *         True by default
     * @sample {highcharts} highcharts/chart/reflow-false/
     *         False
     * @sample {highstock} stock/chart/reflow-true/
     *         True by default
     * @sample {highstock} stock/chart/reflow-false/
     *         False
     * @sample {highmaps} maps/chart/reflow-true/
     *         True by default
     * @sample {highmaps} maps/chart/reflow-false/
     *         False
     *
     * @since     2.1
     */ reflow: true,
    /**
     * The HTML element where the chart will be rendered. If it is a string,
     * the element by that id is used. The HTML element can also be passed
     * by direct reference, or as the first argument of the chart
     * constructor, in which case the option is not needed.
     *
     * @sample {highcharts} highcharts/chart/reflow-true/
     *         String
     * @sample {highcharts} highcharts/chart/renderto-object/
     *         Object reference
     * @sample {highstock} stock/chart/renderto-string/
     *         String
     * @sample {highstock} stock/chart/renderto-object/
     *         Object reference
     *
     * @type      {string|Highcharts.HTMLDOMElement}
     * @apioption chart.renderTo
     */ /**
     * The background color of the marker square when selecting (zooming
     * in on) an area of the chart.
     *
     * @see In styled mode, the selection marker fill is set with the
     *      `.highcharts-selection-marker` class.
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @default   rgba(51,92,173,0.25)
     * @since     2.1.7
     * @apioption chart.selectionMarkerFill
     */ /**
     * Whether to apply a drop shadow to the global series group. This causes
     * all the series to have the same shadow. Contrary to the `series.shadow`
     * option, this prevents items from casting shadows on each other, like for
     * others series in a stack. The shadow can be an object configuration
     * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
     *
     * @sample highcharts/chart/seriesgroupshadow/
     *         Shadow
     *
     * @type      {boolean|Highcharts.ShadowOptionsObject}
     * @default   false
     * @apioption chart.seriesGroupShadow
     */ /**
     * Whether to apply a drop shadow to the outer chart area. Requires
     * that backgroundColor be set. The shadow can be an object
     * configuration containing `color`, `offsetX`, `offsetY`, `opacity` and
     * `width`.
     *
     * @sample {highcharts} highcharts/chart/shadow/
     *         Shadow
     * @sample {highstock} stock/chart/shadow/
     *         Shadow
     * @sample {highmaps} maps/chart/border/
     *         Chart border and shadow
     *
     * @type      {boolean|Highcharts.ShadowOptionsObject}
     * @default   false
     * @apioption chart.shadow
     */ /**
     * Whether to show the axes initially. This only applies to empty charts
     * where series are added dynamically, as axes are automatically added
     * to cartesian series.
     *
     * @sample {highcharts} highcharts/chart/showaxes-false/
     *         False by default
     * @sample {highcharts} highcharts/chart/showaxes-true/
     *         True
     *
     * @type      {boolean}
     * @since     1.2.5
     * @product   highcharts gantt
     * @apioption chart.showAxes
     */ /**
     * The space between the bottom edge of the chart and the content (plot
     * area, axis title and labels, title, subtitle or legend in top
     * position).
     *
     * @sample {highcharts} highcharts/chart/spacingbottom/
     *         Spacing bottom set to 100
     * @sample {highstock} stock/chart/spacingbottom/
     *         Spacing bottom set to 100
     * @sample {highmaps} maps/chart/spacing/
     *         Spacing 100 all around
     *
     * @type      {number}
     * @default   15
     * @since     2.1
     * @apioption chart.spacingBottom
     */ /**
     * The space between the left edge of the chart and the content (plot
     * area, axis title and labels, title, subtitle or legend in top
     * position).
     *
     * @sample {highcharts} highcharts/chart/spacingleft/
     *         Spacing left set to 100
     * @sample {highstock} stock/chart/spacingleft/
     *         Spacing left set to 100
     * @sample {highmaps} maps/chart/spacing/
     *         Spacing 100 all around
     *
     * @type      {number}
     * @default   10
     * @since     2.1
     * @apioption chart.spacingLeft
     */ /**
     * The space between the right edge of the chart and the content (plot
     * area, axis title and labels, title, subtitle or legend in top
     * position).
     *
     * @sample {highcharts} highcharts/chart/spacingright-100/
     *         Spacing set to 100
     * @sample {highcharts} highcharts/chart/spacingright-legend/
     *         Legend in right position with default spacing
     * @sample {highstock} stock/chart/spacingright/
     *         Spacing set to 100
     * @sample {highmaps} maps/chart/spacing/
     *         Spacing 100 all around
     *
     * @type      {number}
     * @default   10
     * @since     2.1
     * @apioption chart.spacingRight
     */ /**
     * The space between the top edge of the chart and the content (plot
     * area, axis title and labels, title, subtitle or legend in top
     * position).
     *
     * @sample {highcharts} highcharts/chart/spacingtop-100/
     *         A top spacing of 100
     * @sample {highcharts} highcharts/chart/spacingtop-10/
     *         Floating chart title makes the plot area align to the default
     *         spacingTop of 10.
     * @sample {highstock} stock/chart/spacingtop/
     *         A top spacing of 100
     * @sample {highmaps} maps/chart/spacing/
     *         Spacing 100 all around
     *
     * @type      {number}
     * @default   10
     * @since     2.1
     * @apioption chart.spacingTop
     */ /**
     * Additional CSS styles to apply inline to the container `div` and the root
     * SVG.
     *
     * According to the CSS syntax documentation, it is recommended to quote
     * font family names that contain white space, digits, or punctuation
     * characters other than hyphens. In such cases, wrap the fontFamily
     * name as follows: `fontFamily: '"Font name"'`.
     *
     * Since v11, the root font size is 1rem by default, and all child element
     * are given a relative `em` font size by default. This allows implementers
     * to control all the chart's font sizes by only setting the root level.
     *
     * @see    In styled mode, general chart styles can be set with the
     *         `.highcharts-root` class.
     * @sample {highcharts} highcharts/chart/style-serif-font/
     *         Using a serif type font
     * @sample {highcharts} highcharts/chart/style-special-font/
     *         Using a font with special character in name
     * @sample {highcharts} highcharts/members/relative-font-size/
     *         Relative font sizes
     * @sample {highcharts} highcharts/css/em/
     *         Styled mode with relative font sizes
     * @sample {highstock} stock/chart/style/
     *         Using a serif type font
     * @sample {highmaps} maps/chart/style-serif-font/
     *         Using a serif type font
     *
     * @type      {Highcharts.CSSObject}
     * @default   {"fontFamily": "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', sans-serif", "fontSize":"1rem"}
     * @apioption chart.style
     */ /**
     * The default series type for the chart. Can be any of the chart types
     * listed under [plotOptions](#plotOptions) and [series](#series) or can
     * be a series provided by an additional module.
     *
     * In TypeScript this option has no effect in sense of typing and
     * instead the `type` option must always be set in the series.
     *
     * @sample {highcharts} highcharts/chart/type-bar/
     *         Bar
     * @sample {highstock} stock/chart/type/
     *         Areaspline
     * @sample {highmaps} maps/chart/type-mapline/
     *         Mapline
     *
     * @type       {string}
     * @default    {highcharts} line
     * @default    {highstock} line
     * @default    {highmaps} map
     * @since      2.1.0
     * @apioption  chart.type
     */ type: 'line',
    /**
     * Decides in what dimensions the user can zoom by dragging the mouse.
     * Can be one of `x`, `y` or `xy`.
     *
     * @see [panKey](#chart.panKey)
     *
     * @sample {highcharts} highcharts/chart/zoomtype-none/
     *         None by default
     * @sample {highcharts} highcharts/chart/zoomtype-x/
     *         X
     * @sample {highcharts} highcharts/chart/zoomtype-y/
     *         Y
     * @sample {highcharts} highcharts/chart/zoomtype-xy/
     *         Xy
     * @sample {highcharts} highcharts/chart/zoomtype-polar/
     *         Zoom on polar chart
     * @sample {highstock} stock/demo/basic-line/
     *         None by default
     * @sample {highstock} stock/chart/zoomtype-x/
     *         X
     * @sample {highstock} stock/chart/zoomtype-y/
     *         Y
     * @sample {highstock} stock/chart/zoomtype-xy/
     *         Xy
     * @sample {highmaps} maps/chart/zoomtype-xy/
     *         Map with selection zoom
     *
     * @type       {string}
     * @validvalue ["x", "y", "xy"]
     * @deprecated
     * @apioption  chart.zoomType
     */ /**
     * Enables zooming by a single touch, in combination with
     * [chart.zoomType](#chart.zoomType). When enabled, two-finger pinch
     * will still work as set up by [chart.pinchType](#chart.pinchType).
     * However, `zoomBySingleTouch` will interfere with touch-dragging the
     * chart to read the tooltip. And especially when vertical zooming is
     * enabled, it will make it hard to scroll vertically on the page.
     * @since      9.0.0
     * @sample     highcharts/chart/zoombysingletouch
     *             Zoom by single touch enabled, with buttons to toggle
     * @product    highcharts highstock gantt
     * @deprecated
     */ /**
     * Chart zooming options.
     * @since 10.2.1
     *
     * @sample     highcharts/plotoptions/sankey-node-color
     *             Zooming in sankey series
     * @sample     highcharts/series-treegraph/link-types
     *             Zooming in treegraph series
     */ zooming: {
        /**
         * Equivalent to [type](#chart.zooming.type), but for multitouch
         * gestures only. By default, the `pinchType` is the same as the
         * `type` setting. However, pinching can be enabled separately in
         * some cases, for example in stock charts where a mouse drag pans the
         * chart, while pinching is enabled. When [tooltip.followTouchMove](
         * #tooltip.followTouchMove) is true, pinchType only applies to
         * two-finger touches.
         *
         * @type       {string}
         * @default    {highcharts} undefined
         * @default    {highstock} x
         * @product    highcharts highstock gantt
         * @validvalue ["x", "y", "xy"]
         * @apioption  chart.zooming.pinchType
         */ /**
         * Decides in what dimensions the user can zoom by dragging the mouse.
         * Can be one of `x`, `y` or `xy`.
         *
         * **Note:** For non-cartesian series, the only supported zooming type
         * is `xy`, as zooming in a single direction is not applicable due to
         * the radial nature of the coordinate system.
         *
         * @declare    Highcharts.OptionsChartZoomingTypeValue
         * @type       {string}
         * @default    {highcharts} undefined
         * @product    highcharts highstock gantt
         * @validvalue ["x", "y", "xy"]
         * @apioption  chart.zooming.type
         */ /**
         * Set a key to hold when dragging to zoom the chart. This is useful to
         * avoid zooming while moving points. Should be set different than
         * [chart.panKey](#chart.panKey).
         *
         * @type       {string}
         * @default    {highcharts} undefined
         * @validvalue ["alt", "ctrl", "meta", "shift"]
         * @requires   modules/draggable-points
         * @apioption  chart.zooming.key
         */ /**
         * Enables zooming by a single touch, in combination with
         * [chart.zooming.type](#chart.zooming.type). When enabled, two-finger
         * pinch will still work as set up by [chart.zooming.pinchType]
         * (#chart.zooming.pinchType). However, `singleTouch` will interfere
         * with touch-dragging the chart to read the tooltip. And especially
         * when vertical zooming is enabled, it will make it hard to scroll
         * vertically on the page.
         *
         * @sample  highcharts/chart/zoombysingletouch
         *          Zoom by single touch enabled, with buttons to toggle
         *
         * @product highcharts highstock gantt
         */ singleTouch: false,
        /**
         * The button that appears after a selection zoom, allowing the user
         * to reset zoom.
         */ resetButton: {
            /**
             * What frame the button placement should be related to. Can be
             * either `plotBox` or `spacingBox`.
             *
             * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
             *         Relative to the chart
             * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
             *         Relative to the chart
             *
             * @type      {Highcharts.ButtonRelativeToValue}
             * @default   plot
             * @apioption chart.zooming.resetButton.relativeTo
             */ /**
             * A collection of attributes for the button. The object takes SVG
             * attributes like `fill`, `stroke`, `stroke-width` or `r`, the
             * border radius. The theme also supports `style`, a collection of
             * CSS properties for the text. Equivalent attributes for the hover
             * state are given in `theme.states.hover`.
             *
             * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
             *         Theming the button
             * @sample {highstock} highcharts/chart/resetzoombutton-theme/
             *         Theming the button
             *
             * @type  {Highcharts.SVGAttributes}
             * @since 10.2.1
             */ theme: {
                /** @internal */ zIndex: 6
            },
            /**
             * The position of the button.
             *
             * Note: Adjusting position values might cause overlap with chart
             * elements. Ensure coordinates do not obstruct other components or
             * data visibility.
             *
             * @sample {highcharts} highcharts/chart/resetzoombutton-position/
             *         Above the plot area
             * @sample {highstock} highcharts/chart/resetzoombutton-position/
             *         Above the plot area
             * @sample {highmaps} highcharts/chart/resetzoombutton-position/
             *         Above the plot area
             *
             * @type  {Highcharts.AlignObject}
             * @since 10.2.1
             */ position: {
                /** @internal */ align: 'right',
                /** @internal */ x: -10,
                /**
                 * The vertical alignment of the button.
                 *
                 * @type       {Highcharts.VerticalAlignValue}
                 * @default    top
                 * @apioption  chart.zooming.resetButton.position.verticalAlign
                 */ /** @internal */ y: 10
            }
        }
    },
    /**
     * An explicit width for the chart. By default (when `null`) the width
     * is calculated from the offset width of the containing element.
     *
     * @sample {highcharts} highcharts/chart/width/
     *         800px wide
     * @sample {highstock} stock/chart/width/
     *         800px wide
     * @sample {highmaps} maps/chart/size/
     *         Chart with explicit size
     *
     * @type {null|number|string}
     */ width: null,
    /**
     * An explicit height for the chart. If a _number_, the height is
     * given in pixels. If given a _percentage string_ (for example
     * `'56%'`), the height is given as the percentage of the actual chart
     * width. This allows for preserving the aspect ratio across responsive
     * sizes.
     *
     * By default (when `null`) the height is calculated from the offset
     * height of the containing element, or 400 pixels if the containing
     * element's height is 0.
     *
     * @sample {highcharts} highcharts/chart/height/
     *         Forced 200px height
     * @sample {highstock} stock/chart/height/
     *         300px height
     * @sample {highmaps} maps/chart/size/
     *         Chart with explicit size
     * @sample highcharts/chart/height-percent/
     *         Highcharts with percentage height
     * @sample highcharts/chart/height-inherited/
     *         Chart with inherited height
     *
     * @type {null|number|string}
     */ height: null,
    /**
     * The color of the outer chart border.
     *
     * @see In styled mode, the stroke is set with the
     *      `.highcharts-background` class.
     *
     * @sample {highcharts} highcharts/chart/bordercolor/
     *         Brown border
     * @sample {highstock} stock/chart/border/
     *         Brown border
     * @sample {highmaps} maps/chart/border/
     *         Border options
     *
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */ borderColor: "#334eff" /* Palette.highlightColor80 */ ,
    /**
     * The pixel width of the outer chart border.
     *
     * @see In styled mode, the stroke is set with the
     *      `.highcharts-background` class.
     *
     * @sample {highcharts} highcharts/chart/borderwidth/
     *         5px border
     * @sample {highstock} stock/chart/border/
     *         2px border
     * @sample {highmaps} maps/chart/border/
     *         Border options
     *
     * @type      {number}
     * @default   0
     * @apioption chart.borderWidth
     */ /**
     * The background color or gradient for the outer chart area.
     *
     * @see In styled mode, the background is set with the
     *      `.highcharts-background` class.
     *
     * @sample {highcharts} highcharts/chart/backgroundcolor-color/
     *         Color
     * @sample {highcharts} highcharts/chart/backgroundcolor-gradient/
     *         Gradient
     * @sample {highstock} stock/chart/backgroundcolor-color/
     *         Color
     * @sample {highstock} stock/chart/backgroundcolor-gradient/
     *         Gradient
     * @sample {highmaps} maps/chart/backgroundcolor-color/
     *         Color
     * @sample {highmaps} maps/chart/backgroundcolor-gradient/
     *         Gradient
     *
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */ backgroundColor: "#ffffff" /* Palette.backgroundColor */ ,
    /**
     * The background color or gradient for the plot area.
     *
     * @see In styled mode, the plot background is set with the
     *      `.highcharts-plot-background` class.
     *
     * @sample {highcharts} highcharts/chart/plotbackgroundcolor-color/
     *         Color
     * @sample {highcharts} highcharts/chart/plotbackgroundcolor-gradient/
     *         Gradient
     * @sample {highstock} stock/chart/plotbackgroundcolor-color/
     *         Color
     * @sample {highstock} stock/chart/plotbackgroundcolor-gradient/
     *         Gradient
     * @sample {highmaps} maps/chart/plotbackgroundcolor-color/
     *         Color
     * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
     *         Gradient
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @apioption chart.plotBackgroundColor
     */ /**
     * The URL for an image to use as the plot background. To set an image
     * as the background for the entire chart, set a CSS background image
     * to the container element. Note that for the image to be applied to
     * exported charts, its URL needs to be accessible by the export server.
     *
     * @see In styled mode, a plot background image can be set with the
     *      `.highcharts-plot-background` class and a [custom pattern](
     *      https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns).
     *
     * @sample {highcharts} highcharts/chart/plotbackgroundimage/
     *         Skies
     * @sample {highstock} stock/chart/plotbackgroundimage/
     *         Skies
     *
     * @type      {string}
     * @apioption chart.plotBackgroundImage
     */ /**
     * The color of the inner chart or plot area border.
     *
     * @see In styled mode, a plot border stroke can be set with the
     *      `.highcharts-plot-border` class.
     *
     * @sample {highcharts} highcharts/chart/plotbordercolor/
     *         Blue border
     * @sample {highstock} stock/chart/plotborder/
     *         Blue border
     * @sample {highmaps} maps/chart/plotborder/
     *         Plot border options
     *
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */ plotBorderColor: "#cccccc" /* Palette.neutralColor20 */ 
};
const __TURBOPACK__default__export__ = ChartDefaults;
}),
"[project]/node_modules/highcharts/es-modules/Core/Color/Palettes.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
/**
 * Series palettes for Highcharts. Series colors are defined in highcharts.css.
 * **Do not edit this file!** This file is generated using the 'gulp palette' task.
 * @internal
 */ const SeriesPalettes = {
    /**
     * Colors for data series and points
     */ colors: [
        '#2caffe',
        '#544fc5',
        '#00e272',
        '#fe6a35',
        '#6b8abc',
        '#d568fb',
        '#2ee0ca',
        '#fa4b42',
        '#feb56a',
        '#91e8e1'
    ]
};
const __TURBOPACK__default__export__ = SeriesPalettes;
}),
"[project]/node_modules/highcharts/es-modules/Core/Utilities.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Globals.js [app-client] (ecmascript)");
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
;
const { charts, doc, win } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
/* *
 *
 *  Functions
 *
 * */ /**
 * Provide error messages for debugging, with links to online explanation. This
 * function can be overridden to provide custom error handling.
 *
 * @sample highcharts/chart/highcharts-error/
 *         Custom error handler
 *
 * @function Highcharts.error
 *
 * @param {number|string} code
 *        The error code. See
 *        [errors.xml](https://github.com/highcharts/highcharts/blob/master/errors/errors.xml)
 *        for available codes. If it is a string, the error message is printed
 *        directly in the console.
 *
 * @param {boolean} [stop=false]
 *        Whether to throw an error or just log a warning in the console.
 *
 * @param {Highcharts.Chart} [chart]
 *        Reference to the chart that causes the error. Used in 'debugger'
 *        module to display errors directly on the chart.
 *        Important note: This argument is undefined for errors that lack
 *        access to the Chart instance. In such case, the error will be
 *        displayed on the last created chart.
 *
 * @param {Highcharts.Dictionary<string>} [params]
 *        Additional parameters for the generated message.
 *
 * @return {void}
 */ function error(code, stop, chart, params) {
    const severity = stop ? 'Highcharts error' : 'Highcharts warning';
    if (code === 32) {
        code = `${severity}: Deprecated member`;
    }
    const isCode = isNumber(code);
    let message = isCode ? `${severity} #${code}: www.highcharts.com/errors/${code}/` : code.toString();
    const defaultHandler = function() {
        if (stop) {
            throw new Error(message);
        }
        // Else ...
        if (win.console && error.messages.indexOf(message) === -1 // Prevent console flooting
        ) {
            console.warn(message); // eslint-disable-line no-console
        }
    };
    if (typeof params !== 'undefined') {
        let additionalMessages = '';
        if (isCode) {
            message += '?';
        }
        objectEach(params, function(value, key) {
            additionalMessages += `\n - ${key}: ${value}`;
            if (isCode) {
                message += encodeURI(key) + '=' + encodeURI(value);
            }
        });
        message += additionalMessages;
    }
    fireEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], 'displayError', {
        chart,
        code,
        message,
        params
    }, defaultHandler);
    error.messages.push(message);
}
(function(error) {
    error.messages = [];
})(error || (error = {}));
/**
 * Utility function to deep merge two or more objects and return a third object.
 * If the first argument is true, the contents of the second object is copied
 * into the first object. The merge function can also be used with a single
 * object argument to create a deep copy of an object.
 *
 * @function Highcharts.merge<T>
 *
 * @param {true | T} extendOrSource
 *        Whether to extend the left-side object,
 *        or the first object to merge as a deep copy.
 *
 * @param {...Array<object|undefined>} [sources]
 *        Object(s) to merge into the previous one.
 *
 * @return {T}
 *         The merged object. If the first argument is true, the return is the
 *         same as the second argument.
 */ function merge(extendOrSource, ...sources) {
    let i, args = [
        extendOrSource,
        ...sources
    ], ret = {};
    const doCopy = function(copy, original) {
        // An object is replacing a primitive
        if (typeof copy !== 'object') {
            copy = {};
        }
        objectEach(original, function(value, key) {
            // Prototype pollution (#14883)
            if (key === '__proto__' || key === 'constructor') {
                return;
            }
            // Copy the contents of objects, but not arrays or DOM nodes
            if (isObject(value, true) && !isClass(value) && !isDOMElement(value)) {
                copy[key] = doCopy(copy[key] || {}, value);
            // Primitives and arrays are copied over directly
            } else {
                copy[key] = original[key];
            }
        });
        return copy;
    };
    // If first argument is true, copy into the existing object. Used in
    // setOptions.
    if (extendOrSource === true) {
        ret = args[1];
        args = Array.prototype.slice.call(args, 2);
    }
    // For each argument, extend the return
    const len = args.length;
    for(i = 0; i < len; i++){
        ret = doCopy(ret, args[i]);
    }
    return ret;
}
/**
 * Constrain a value to within a lower and upper threshold.
 *
 * @internal
 * @param {number} value The initial value
 * @param {number} min The lower threshold
 * @param {number} max The upper threshold
 * @return {number} Returns a number value within min and max.
 */ function clamp(value, min, max) {
    return value > min ? value < max ? value : max : min;
}
/**
 * Utility for crisping a line position to the nearest full pixel depening on
 * the line width
 * @param {number} value       The raw pixel position
 * @param {number} lineWidth   The line width
 * @param {boolean} [inverted] Whether the containing group is inverted.
 *                             Crisping round numbers on the y-scale need to go
 *                             to the other side because the coordinate system
 *                             is flipped (scaleY is -1)
 * @return {number}            The pixel position to use for a crisp display
 */ function crisp(value, lineWidth = 0, inverted) {
    const mod = lineWidth % 2 / 2, inverter = inverted ? -1 : 1;
    return (Math.round(value * inverter - mod) + mod) * inverter;
}
// eslint-disable-next-line valid-jsdoc
/**
 * Return the deep difference between two objects. It can either return the new
 * properties, or optionally return the old values of new properties.
 * @internal
 */ function diffObjects(newer, older, keepOlder, collectionsWithUpdate) {
    const ret = {};
    /**
     * Recurse over a set of options and its current values, and store the
     * current values in the ret object.
     */ function diff(newer, older, ret, depth) {
        const keeper = keepOlder ? older : newer;
        objectEach(newer, function(newerVal, key) {
            if (!depth && collectionsWithUpdate && collectionsWithUpdate.indexOf(key) > -1 && older[key]) {
                newerVal = splat(newerVal);
                ret[key] = [];
                // Iterate over collections like series, xAxis or yAxis and map
                // the items by index.
                for(let i = 0; i < Math.max(newerVal.length, older[key].length); i++){
                    // Item exists in current data (#6347)
                    if (older[key][i]) {
                        // If the item is missing from the new data, we need to
                        // save the whole config structure. Like when
                        // responsively updating from a dual axis layout to a
                        // single axis and back (#13544).
                        if (newerVal[i] === void 0) {
                            ret[key][i] = older[key][i];
                        // Otherwise, proceed
                        } else {
                            ret[key][i] = {};
                            diff(newerVal[i], older[key][i], ret[key][i], depth + 1);
                        }
                    }
                }
            } else if (isObject(newerVal, true) && !newerVal.nodeType // #10044
            ) {
                ret[key] = isArray(newerVal) ? [] : {};
                diff(newerVal, older[key] || {}, ret[key], depth + 1);
                // Delete empty nested objects
                if (Object.keys(ret[key]).length === 0 && // Except colorAxis which is a special case where the empty
                // object means it is enabled. Which is unfortunate and we
                // should try to find a better way.
                !(key === 'colorAxis' && depth === 0)) {
                    delete ret[key];
                }
            } else if (newer[key] !== older[key] || key in newer && !(key in older)) {
                if (key !== '__proto__' && key !== 'constructor') {
                    ret[key] = keeper[key];
                }
            }
        });
    }
    diff(newer, older, ret, 0);
    return ret;
}
/**
 * Shortcut for parseInt
 *
 * @internal
 * @function Highcharts.pInt
 *
 * @param {*} s
 *        any
 *
 * @param {number} [mag]
 *        Magnitude
 *
 * @return {number}
 *         number
 */ function pInt(s, mag) {
    return parseInt(s, mag || 10);
}
/**
 * Utility function to check for string type.
 *
 * @function Highcharts.isString
 *
 * @param {*} s
 *        The item to check.
 *
 * @return {boolean}
 *         True if the argument is a string.
 */ function isString(s) {
    return typeof s === 'string';
}
/**
 * Utility function to check if an item is an array.
 *
 * @function Highcharts.isArray
 *
 * @param {*} obj
 *        The item to check.
 *
 * @return {boolean}
 *         True if the argument is an array.
 */ function isArray(obj) {
    const str = Object.prototype.toString.call(obj);
    return str === '[object Array]' || str === '[object Array Iterator]';
}
/**
 * Utility function to check if an item is of type object.
 *
 * @function Highcharts.isObject
 *
 * @param {*} obj
 *        The item to check.
 *
 * @param {boolean} [strict=false]
 *        Also checks that the object is not an array.
 *
 * @return {boolean}
 *         True if the argument is an object.
 */ function isObject(obj, strict) {
    return !!obj && typeof obj === 'object' && (!strict || !isArray(obj)); // eslint-disable-line @typescript-eslint/no-explicit-any
}
/**
 * Utility function to check if an Object is a HTML Element.
 *
 * @function Highcharts.isDOMElement
 *
 * @param {*} obj
 *        The item to check.
 *
 * @return {boolean}
 *         True if the argument is a HTML Element.
 */ function isDOMElement(obj) {
    return isObject(obj) && typeof obj.nodeType === 'number';
}
/**
 * Utility function to check if an Object is a class.
 *
 * @function Highcharts.isClass
 *
 * @param {object|undefined} obj
 *        The item to check.
 *
 * @return {boolean}
 *         True if the argument is a class.
 */ function isClass(obj) {
    const c = obj?.constructor;
    return !!(isObject(obj, true) && !isDOMElement(obj) && c?.name && c.name !== 'Object');
}
/**
 * Utility function to check if an item is a number and it is finite (not NaN,
 * Infinity or -Infinity).
 *
 * @function Highcharts.isNumber
 *
 * @param {*} n
 *        The item to check.
 *
 * @return {boolean}
 *         True if the item is a finite number
 */ function isNumber(n) {
    return typeof n === 'number' && !isNaN(n) && n < Infinity && n > -Infinity;
}
/**
 * Remove the last occurence of an item from an array.
 *
 * @function Highcharts.erase
 *
 * @param {Array<*>} arr
 *        The array.
 *
 * @param {*} item
 *        The item to remove.
 *
 * @return {void}
 */ function erase(arr, item) {
    let i = arr.length;
    while(i--){
        if (arr[i] === item) {
            arr.splice(i, 1);
            break;
        }
    }
}
/**
 * Insert a series or an axis in a collection with other items, either the
 * chart series or yAxis series or axis collections, in the correct order
 * according to the index option and whether it is internal. Used internally
 * when adding series and axes.
 *
 * @internal
 * @function Highcharts.Chart#insertItem
 * @param  {Highcharts.Series|Highcharts.Axis} item
 *         The item to insert
 * @param  {Array<Highcharts.Series>|Array<Highcharts.Axis>} collection
 *         A collection of items, like `chart.series` or `xAxis.series`.
 * @return {number} The index of the series in the collection.
 */ function insertItem(item, collection) {
    const indexOption = item.options.index, length = collection.length;
    let i;
    for(// Internal item (navigator) should always be pushed to the end
    i = item.options.isInternal ? length : 0; i < length + 1; i++){
        if (// No index option, reached the end of the collection,
        // equivalent to pushing
        !collection[i] || isNumber(indexOption) && indexOption < pick(collection[i].options.index, collection[i]._i) || // Insert the new item before other internal items
        // (navigator)
        collection[i].options.isInternal) {
            collection.splice(i, 0, item);
            break;
        }
    }
    return i;
}
/**
 * Adds an item to an array, if it is not present in the array.
 *
 * @function Highcharts.pushUnique
 *
 * @param {Array<unknown>} array
 * The array to add the item to.
 *
 * @param {unknown} item
 * The item to add.
 *
 * @return {boolean}
 * Returns true, if the item was not present and has been added.
 */ function pushUnique(array, item) {
    return array.indexOf(item) < 0 && !!array.push(item);
}
/**
 * Check if an object is null or undefined.
 *
 * @function Highcharts.defined
 *
 * @param {*} obj
 *        The object to check.
 *
 * @return {boolean}
 *         False if the object is null or undefined, otherwise true.
 */ function defined(obj) {
    return typeof obj !== 'undefined' && obj !== null;
}
/**
 * Set or get an attribute or an object of attributes.
 *
 * To use as a setter, pass a key and a value, or let the second argument be a
 * collection of keys and values. When using a collection, passing a value of
 * `null` or `undefined` will remove the attribute.
 *
 * To use as a getter, pass only a string as the second argument.
 *
 * @function Highcharts.attr
 *
 * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} elem
 *        The DOM element to receive the attribute(s).
 *
 * @param {string|Highcharts.HTMLAttributes|Highcharts.SVGAttributes} [keyOrAttribs]
 *        The property or an object of key-value pairs.
 *
 * @param {number|string} [value]
 *        The value if a single property is set.
 *
 * @return {string|null|undefined}
 *         When used as a getter, return the value.
 */ function attr(elem, keyOrAttribs, value) {
    const isGetter = isString(keyOrAttribs) && !defined(value);
    let ret;
    const attrSingle = (value, key)=>{
        // Set the value
        if (defined(value)) {
            elem.setAttribute(key, value);
        // Get the value
        } else if (isGetter) {
            ret = elem.getAttribute(key);
            // IE7 and below cannot get class through getAttribute (#7850)
            if (!ret && key === 'class') {
                ret = elem.getAttribute(key + 'Name');
            }
        // Remove the value
        } else {
            elem.removeAttribute(key);
        }
    };
    // If keyOrAttribs is a string
    if (isString(keyOrAttribs)) {
        attrSingle(value, keyOrAttribs);
    // Else if keyOrAttribs is defined, it is a hash of key/value pairs
    } else {
        objectEach(keyOrAttribs, attrSingle);
    }
    return ret;
}
/**
 * Check if an element is an array, and if not, make it into an array.
 *
 * @function Highcharts.splat
 *
 * @param {*} obj
 *        The object to splat.
 *
 * @return {Array}
 *         The produced or original array.
 */ function splat(obj) {
    return isArray(obj) ? obj : [
        obj
    ];
}
/**
 * Set a timeout if the delay is given, otherwise perform the function
 * synchronously.
 *
 * @function Highcharts.syncTimeout
 *
 * @param {Function} fn
 *        The function callback.
 *
 * @param {number} delay
 *        Delay in milliseconds.
 *
 * @param {*} [context]
 *        An optional context to send to the function callback.
 *
 * @return {number}
 *         An identifier for the timeout that can later be cleared with
 *         Highcharts.clearTimeout. Returns -1 if there is no timeout.
 */ function syncTimeout(fn, delay, context) {
    if (delay > 0) {
        return setTimeout(fn, delay, context);
    }
    fn.call(0, context);
    return -1;
}
/**
 * Internal clear timeout. The function checks that the `id` was not removed
 * (e.g. by `chart.destroy()`). For the details see
 * [issue #7901](https://github.com/highcharts/highcharts/issues/7901).
 *
 * @function Highcharts.clearTimeout
 *
 * @param {number|undefined} id
 * Id of a timeout.
 */ function internalClearTimeout(id) {
    if (defined(id)) {
        clearTimeout(id);
    }
}
/* eslint-disable valid-jsdoc */ /**
 * Utility function to extend an object with the members of another.
 *
 * @function Highcharts.extend<T>
 *
 * @param {T|undefined} a
 *        The object to be extended.
 *
 * @param {Partial<T>} b
 *        The object to add to the first one.
 *
 * @return {T}
 *         Object a, the original object.
 */ function extend(a, b) {
    /* eslint-enable valid-jsdoc */ let n;
    if (!a) {
        a = {};
    }
    for(n in b){
        a[n] = b[n];
    }
    return a;
}
/* eslint-disable valid-jsdoc */ /**
 * Return the first value that is not null or undefined.
 *
 * @function Highcharts.pick<T>
 *
 * @param {...Array<T|null|undefined>} items
 *        Variable number of arguments to inspect.
 *
 * @return {T}
 *         The value of the first argument that is not null or undefined.
 */ function pick() {
    const args = arguments;
    const length = args.length;
    for(let i = 0; i < length; i++){
        const arg = args[i];
        if (typeof arg !== 'undefined' && arg !== null) {
            return arg;
        }
    }
}
/**
 * Set CSS on a given element.
 *
 * @function Highcharts.css
 *
 * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} el
 *        An HTML DOM element.
 *
 * @param {Highcharts.CSSObject} styles
 *        Style object with camel case property names.
 *
 * @return {void}
 */ function css(el, styles) {
    extend(el.style, styles);
}
/**
 * Utility function to create an HTML element with attributes and styles.
 *
 * @function Highcharts.createElement
 *
 * @param {string} tag
 *        The HTML tag.
 *
 * @param {Highcharts.HTMLAttributes} [attribs]
 *        Attributes as an object of key-value pairs.
 *
 * @param {Highcharts.CSSObject} [styles]
 *        Styles as an object of key-value pairs.
 *
 * @param {Highcharts.HTMLDOMElement} [parent]
 *        The parent HTML object.
 *
 * @param {boolean} [nopad=false]
 *        If true, remove all padding, border and margin.
 *
 * @return {Highcharts.HTMLDOMElement}
 *         The created DOM element.
 */ function createElement(tag, attribs, styles, parent, nopad) {
    const el = doc.createElement(tag);
    if (attribs) {
        extend(el, attribs);
    }
    if (nopad) {
        css(el, {
            padding: '0',
            border: 'none',
            margin: '0'
        });
    }
    if (styles) {
        css(el, styles);
    }
    if (parent) {
        parent.appendChild(el);
    }
    return el;
}
// eslint-disable-next-line valid-jsdoc
/**
 * Extend a prototyped class by new members.
 *
 * @deprecated
 * @function Highcharts.extendClass<T>
 *
 * @param {Highcharts.Class<T>} parent
 *        The parent prototype to inherit.
 *
 * @param {Highcharts.Dictionary<*>} members
 *        A collection of prototype members to add or override compared to the
 *        parent prototype.
 *
 * @return {Highcharts.Class<T>}
 *         A new prototype.
 */ function extendClass(parent, members) {
    const obj = function() {};
    obj.prototype = new parent(); // eslint-disable-line new-cap
    extend(obj.prototype, members);
    return obj;
}
/**
 * Left-pad a string to a given length by adding a character repetitively.
 *
 * @function Highcharts.pad
 *
 * @param {number} number
 *        The input string or number.
 *
 * @param {number} [length]
 *        The desired string length.
 *
 * @param {string} [padder=0]
 *        The character to pad with.
 *
 * @return {string}
 *         The padded string.
 */ function pad(number, length, padder) {
    return new Array((length || 2) + 1 - String(number).replace('-', '').length).join(padder || '0') + number;
}
/**
 * Return a length based on either the integer value, or a percentage of a base.
 *
 * @function Highcharts.relativeLength
 *
 * @param {Highcharts.RelativeSize} value
 *        A percentage string or a number.
 *
 * @param {number} base
 *        The full length that represents 100%.
 *
 * @param {number} [offset=0]
 *        A pixel offset to apply for percentage values. Used internally in
 *        axis positioning.
 *
 * @return {number}
 *         The computed length.
 */ function relativeLength(value, base, offset) {
    return /%$/.test(value) ? base * parseFloat(value) / 100 + (offset || 0) : parseFloat(value);
}
/**
 * Replaces text in a string with a given replacement in a loop to catch nested
 * matches after previous replacements.
 *
 * @function Highcharts.replaceNested
 *
 * @param {string} text
 * Text to search and modify.
 *
 * @param {...Array<(RegExp|string)>} replacements
 * One or multiple tuples with search pattern (`[0]: (string|RegExp)`) and
 * replacement (`[1]: string`) for matching text.
 *
 * @return {string}
 * Text with replacements.
 */ function replaceNested(text, ...replacements) {
    let previous, replacement;
    do {
        previous = text;
        for (replacement of replacements){
            text = text.replace(replacement[0], replacement[1]);
        }
    }while (text !== previous)
    return text;
}
/**
 * Wrap a method with extended functionality, preserving the original function.
 *
 * @function Highcharts.wrap
 *
 * @param {*} obj
 *        The context object that the method belongs to. In real cases, this is
 *        often a prototype.
 *
 * @param {string} method
 *        The name of the method to extend.
 *
 * @param {Highcharts.WrapProceedFunction} func
 *        A wrapper function callback. This function is called with the same
 *        arguments as the original function, except that the original function
 *        is unshifted and passed as the first argument.
 */ function wrap(obj, method, func) {
    const proceed = obj[method];
    obj[method] = function() {
        const outerArgs = arguments, scope = this;
        return func.apply(this, [
            function() {
                return proceed.apply(scope, arguments.length ? arguments : outerArgs);
            }
        ].concat([].slice.call(arguments)));
    };
}
/**
 * Get the magnitude of a number.
 *
 * @function Highcharts.getMagnitude
 *
 * @param {number} num
 *        The number.
 *
 * @return {number}
 *         The magnitude, where 1-9 are magnitude 1, 10-99 magnitude 2 etc.
 */ function getMagnitude(num) {
    return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
}
/**
 * Take an interval and normalize it to multiples of round numbers.
 *
 * @deprecated
 * @function Highcharts.normalizeTickInterval
 *
 * @param {number} interval
 *        The raw, un-rounded interval.
 *
 * @param {Array<*>} [multiples]
 *        Allowed multiples.
 *
 * @param {number} [magnitude]
 *        The magnitude of the number.
 *
 * @param {boolean} [allowDecimals]
 *        Whether to allow decimals.
 *
 * @param {boolean} [hasTickAmount]
 *        If it has tickAmount, avoid landing on tick intervals lower than
 *        original.
 *
 * @return {number}
 *         The normalized interval.
 *
 * @todo
 * Move this function to the Axis prototype. It is here only for historical
 * reasons.
 */ function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, hasTickAmount) {
    let i, retInterval = interval;
    // Round to a tenfold of 1, 2, 2.5 or 5
    magnitude = pick(magnitude, getMagnitude(interval));
    const normalized = interval / magnitude;
    // Multiples for a linear scale
    if (!multiples) {
        multiples = hasTickAmount ? // Finer grained ticks when the tick amount is hard set, including
        // when alignTicks is true on multiple axes (#4580).
        [
            1,
            1.2,
            1.5,
            2,
            2.5,
            3,
            4,
            5,
            6,
            8,
            10
        ] : // Else, let ticks fall on rounder numbers
        [
            1,
            2,
            2.5,
            5,
            10
        ];
        // The allowDecimals option
        if (allowDecimals === false) {
            if (magnitude === 1) {
                multiples = multiples.filter(function(num) {
                    return num % 1 === 0;
                });
            } else if (magnitude <= 0.1) {
                multiples = [
                    1 / magnitude
                ];
            }
        }
    }
    // Normalize the interval to the nearest multiple
    for(i = 0; i < multiples.length; i++){
        retInterval = multiples[i];
        // Only allow tick amounts smaller than natural
        if (hasTickAmount && retInterval * magnitude >= interval || !hasTickAmount && normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {
            break;
        }
    }
    // Multiply back to the correct magnitude. Correct floats to appropriate
    // precision (#6085).
    retInterval = correctFloat(retInterval * magnitude, -Math.round(Math.log(0.001) / Math.LN10));
    return retInterval;
}
/**
 * Sort an object array and keep the order of equal items. The ECMAScript
 * standard does not specify the behaviour when items are equal.
 *
 * @function Highcharts.stableSort
 *
 * @param {Array<*>} arr
 *        The array to sort.
 *
 * @param {Function} sortFunction
 *        The function to sort it with, like with regular Array.prototype.sort.
 */ function stableSort(arr, sortFunction) {
    // @todo It seems like Chrome since v70 sorts in a stable way internally,
    // plus all other browsers do it, so over time we may be able to remove this
    // function
    const length = arr.length;
    let sortValue, i;
    // Add index to each item
    for(i = 0; i < length; i++){
        arr[i].safeI = i; // Stable sort index
    }
    arr.sort(function(a, b) {
        sortValue = sortFunction(a, b);
        return sortValue === 0 ? a.safeI - b.safeI : sortValue;
    });
    // Remove index from items
    for(i = 0; i < length; i++){
        delete arr[i].safeI; // Stable sort index
    }
}
/**
 * Non-recursive method to find the lowest member of an array. `Math.min` raises
 * a maximum call stack size exceeded error in Chrome when trying to apply more
 * than 150.000 points. This method is slightly slower, but safe.
 *
 * @function Highcharts.arrayMin
 *
 * @param {Array<*>} data
 *        An array of numbers.
 *
 * @return {number}
 *         The lowest number.
 */ function arrayMin(data) {
    let i = data.length, min = data[0];
    while(i--){
        if (data[i] < min) {
            min = data[i];
        }
    }
    return min;
}
/**
 * Non-recursive method to find the lowest member of an array. `Math.max` raises
 * a maximum call stack size exceeded error in Chrome when trying to apply more
 * than 150.000 points. This method is slightly slower, but safe.
 *
 * @function Highcharts.arrayMax
 *
 * @param {Array<*>} data
 *        An array of numbers.
 *
 * @return {number}
 *         The highest number.
 */ function arrayMax(data) {
    let i = data.length, max = data[0];
    while(i--){
        if (data[i] > max) {
            max = data[i];
        }
    }
    return max;
}
/**
 * Utility method that destroys any SVGElement instances that are properties on
 * the given object. It loops all properties and invokes destroy if there is a
 * destroy method. The property is then delete.
 *
 * @function Highcharts.destroyObjectProperties
 *
 * @param {*} obj
 *        The object to destroy properties on.
 *
 * @param {*} [except]
 *        Exception, do not destroy this property, only delete it.
 */ function destroyObjectProperties(obj, except, destructablesOnly) {
    objectEach(obj, function(val, n) {
        // If the object is non-null and destroy is defined
        if (val !== except && val?.destroy) {
            // Invoke the destroy
            val.destroy();
        }
        // Delete the property from the object
        if (val?.destroy || !destructablesOnly) {
            delete obj[n];
        }
    });
}
/**
 * Discard a HTML element
 *
 * @function Highcharts.discardElement
 *
 * @param {Highcharts.HTMLDOMElement} element
 *        The HTML node to discard.
 */ function discardElement(element) {
    element?.parentElement?.removeChild(element);
}
/**
 * Fix JS round off float errors.
 *
 * @function Highcharts.correctFloat
 *
 * @param {number} num
 *        A float number to fix.
 *
 * @param {number} [prec=14]
 *        The precision.
 *
 * @return {number}
 *         The corrected float number.
 */ function correctFloat(num, prec) {
    // When the number is higher than 1e14 use the number (#16275)
    return num > 1e14 ? num : parseFloat(num.toPrecision(prec || 14));
}
/**
 * The time unit lookup
 *
 * @ignore
 */ const timeUnits = {
    millisecond: 1,
    second: 1000,
    minute: 60000,
    hour: 3600000,
    day: 24 * 3600000,
    week: 7 * 24 * 3600000,
    month: 28 * 24 * 3600000,
    year: 364 * 24 * 3600000
};
/**
 * Easing definition
 *
 * @internal
 * @function Math.easeInOutSine
 *
 * @param {number} pos
 * Current position, ranging from 0 to 1.
 *
 * @return {number}
 * Ease result
 */ Math.easeInOutSine = function(pos) {
    return -0.5 * (Math.cos(Math.PI * pos) - 1);
};
/**
 * Convenience function to get the align factor, used several places for
 * computing positions
 * @internal
 */ const getAlignFactor = (align = '')=>({
        center: 0.5,
        right: 1,
        middle: 0.5,
        bottom: 1
    })[align] || 0;
/**
 * Find the closest distance between two values of a two-dimensional array
 * @internal
 * @function Highcharts.getClosestDistance
 *
 * @param {Array<Array<number>>} arrays
 *          An array of arrays of numbers
 *
 * @return {number | undefined}
 *          The closest distance between values
 */ function getClosestDistance(arrays, onError) {
    const allowNegative = !onError;
    let closest, loopLength, distance, i;
    arrays.forEach((xData)=>{
        if (xData.length > 1) {
            loopLength = xData.length - 1;
            for(i = loopLength; i > 0; i--){
                distance = xData[i] - xData[i - 1];
                if (distance < 0 && !allowNegative) {
                    onError?.();
                    // Only one call
                    onError = void 0;
                } else if (distance && (typeof closest === 'undefined' || distance < closest)) {
                    closest = distance;
                }
            }
        }
    });
    return closest;
}
/**
 * Returns the value of a property path on a given object.
 *
 * @internal
 * @function getNestedProperty
 *
 * @param {string} path
 * Path to the property, for example `custom.myValue`.
 *
 * @param {unknown} obj
 * Instance containing the property on the specific path.
 *
 * @return {unknown}
 * The unknown property value.
 */ function getNestedProperty(path, parent) {
    const pathElements = path.split('.');
    while(pathElements.length && defined(parent)){
        const pathElement = pathElements.shift();
        // Filter on the key
        if (typeof pathElement === 'undefined' || pathElement === '__proto__') {
            return; // Undefined
        }
        if (pathElement === 'this') {
            let thisProp;
            if (isObject(parent)) {
                thisProp = parent['@this'];
            }
            return thisProp ?? parent;
        }
        const child = parent[pathElement.replace(/[\\'"]/g, '')];
        // Filter on the child
        if (!defined(child) || typeof child === 'function' || typeof child.nodeType === 'number' || child === win) {
            return; // Undefined
        }
        // Else, proceed
        parent = child;
    }
    return parent;
}
/**
 * Get the computed CSS value for given element and property, only for numerical
 * properties. For width and height, the dimension of the inner box (excluding
 * padding) is returned. Used for fitting the chart within the container.
 *
 * @function Highcharts.getStyle
 *
 * @param {Highcharts.HTMLDOMElement} el
 * An HTML element.
 *
 * @param {string} prop
 * The property name.
 *
 * @param {boolean} [toInt=true]
 * Parse to integer.
 *
 * @return {number|string|undefined}
 * The style value.
 */ function getStyle(el, prop, toInt) {
    let style;
    // For width and height, return the actual inner pixel size (#4913)
    if (prop === 'width') {
        let offsetWidth = Math.min(el.offsetWidth, el.scrollWidth);
        // In flex boxes, we need to use getBoundingClientRect and floor it,
        // because scrollWidth doesn't support subpixel precision (#6427) ...
        const boundingClientRectWidth = el.getBoundingClientRect?.().width;
        // ...unless if the containing div or its parents are transform-scaled
        // down, in which case the boundingClientRect can't be used as it is
        // also scaled down (#9871, #10498).
        if (boundingClientRectWidth < offsetWidth && boundingClientRectWidth >= offsetWidth - 1) {
            offsetWidth = Math.floor(boundingClientRectWidth);
        }
        return Math.max(0, offsetWidth - (getStyle(el, 'padding-left', true) || 0) - (getStyle(el, 'padding-right', true) || 0));
    }
    if (prop === 'height') {
        return Math.max(0, Math.min(el.offsetHeight, el.scrollHeight) - (getStyle(el, 'padding-top', true) || 0) - (getStyle(el, 'padding-bottom', true) || 0));
    }
    // Otherwise, get the computed style
    const css = win.getComputedStyle(el, void 0); // eslint-disable-line no-undefined
    if (css) {
        style = css.getPropertyValue(prop);
        if (pick(toInt, prop !== 'opacity')) {
            style = pInt(style);
        }
    }
    return style;
}
/**
 * Return the value of the first element in the array that satisfies the
 * provided testing function.
 *
 * @function Highcharts.find<T>
 *
 * @param {Array<T>} arr
 *        The array to test.
 *
 * @param {Function} callback
 *        The callback function. The function receives the item as the first
 *        argument. Return `true` if this item satisfies the condition.
 *
 * @return {T|undefined}
 *         The value of the element.
 */ const find = Array.prototype.find ? function(arr, callback) {
    return arr.find(callback);
} : // Legacy implementation. PhantomJS, IE <= 11 etc. #7223.
function(arr, callback) {
    let i;
    const length = arr.length;
    for(i = 0; i < length; i++){
        if (callback(arr[i], i)) {
            return arr[i];
        }
    }
};
/**
 * Get the element's offset position, corrected for `overflow: auto`.
 *
 * @function Highcharts.offset
 *
 * @param {global.Element} el
 *        The DOM element.
 *
 * @return {Highcharts.OffsetObject}
 *         An object containing `left` and `top` properties for the position in
 *         the page.
 */ function offset(el) {
    const docElem = doc.documentElement, box = el.parentElement || el.parentNode ? el.getBoundingClientRect() : {
        top: 0,
        left: 0,
        width: 0,
        height: 0
    };
    return {
        top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
        left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0),
        width: box.width,
        height: box.height
    };
}
/* eslint-disable valid-jsdoc */ /**
 * Iterate over object key pairs in an object.
 *
 * @function Highcharts.objectEach<T>
 *
 * @param {*} obj
 *        The object to iterate over.
 *
 * @param {Highcharts.ObjectEachCallbackFunction<T>} fn
 *        The iterator callback. It passes three arguments:
 *        * value - The property value.
 *        * key - The property key.
 *        * obj - The object that objectEach is being applied to.
 *
 * @param {T} [ctx]
 *        The context.
 */ function objectEach(obj, fn, ctx) {
    /* eslint-enable valid-jsdoc */ for(const key in obj){
        if (Object.hasOwnProperty.call(obj, key)) {
            fn.call(ctx || obj[key], obj[key], key, obj);
        }
    }
}
/* eslint-disable valid-jsdoc */ /**
 * Add an event listener.
 *
 * @function Highcharts.addEvent<T>
 *
 * @param  {Highcharts.Class<T>|T} el
 *         The element or object to add a listener to. It can be a
 *         {@link HTMLDOMElement}, an {@link SVGElement} or any other object.
 *
 * @param  {string} type
 *         The event type.
 *
 * @param  {Highcharts.EventCallbackFunction<T>|Function} fn
 *         The function callback to execute when the event is fired.
 *
 * @param  {Highcharts.EventOptionsObject} [options]
 *         Options for adding the event.
 *
 * @sample highcharts/members/addevent
 *         Use a general `render` event to draw shapes on a chart
 *
 * @return {Function}
 *         A callback function to remove the added event.
 */ function addEvent(el, type, fn, options = {}) {
    /* eslint-enable valid-jsdoc */ // Add hcEvents to either the prototype (in case we're running addEvent on a
    // class) or the instance. If hasOwnProperty('hcEvents') is false, it is
    // inherited down the prototype chain, in which case we need to set the
    // property on this instance (which may itself be a prototype).
    const owner = typeof el === 'function' && el.prototype || el;
    if (!Object.hasOwnProperty.call(owner, 'hcEvents')) {
        owner.hcEvents = {};
    }
    const events = owner.hcEvents;
    // Allow click events added to points, otherwise they will be prevented by
    // the TouchPointer.pinch function after a pinch zoom operation (#7091).
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Point && // Without H a dependency loop occurs
    el instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Point && el.series && el.series.chart) {
        el.series.chart.runTrackerClick = true;
    }
    // Handle DOM events
    // If the browser supports passive events, add it to improve performance
    // on touch events (#11353).
    const addEventListener = el.addEventListener;
    if (addEventListener) {
        addEventListener.call(el, type, fn, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].supportsPassiveEvents ? {
            passive: options.passive === void 0 ? type.indexOf('touch') !== -1 : options.passive,
            capture: false
        } : false);
    }
    if (!events[type]) {
        events[type] = [];
    }
    const eventObject = {
        fn,
        order: typeof options.order === 'number' ? options.order : Infinity
    };
    events[type].push(eventObject);
    // Order the calls
    events[type].sort((a, b)=>a.order - b.order);
    // Return a function that can be called to remove this event.
    return function() {
        removeEvent(el, type, fn);
    };
}
/* eslint-disable valid-jsdoc */ /**
 * Remove an event that was added with {@link Highcharts#addEvent}.
 *
 * @function Highcharts.removeEvent<T>
 *
 * @param {Highcharts.Class<T>|T} el
 *        The element to remove events on.
 *
 * @param {string} [type]
 *        The type of events to remove. If undefined, all events are removed
 *        from the element.
 *
 * @param {Highcharts.EventCallbackFunction<T>} [fn]
 *        The specific callback to remove. If undefined, all events that match
 *        the element and optionally the type are removed.
 *
 * @return {void}
 */ function removeEvent(el, type, fn) {
    /* eslint-enable valid-jsdoc */ /** @internal */ function removeOneEvent(type, fn) {
        const removeEventListener = el.removeEventListener;
        if (removeEventListener) {
            removeEventListener.call(el, type, fn, false);
        }
    }
    /** @internal */ function removeAllEvents(eventCollection) {
        let types, len;
        if (!el.nodeName) {
            return; // Break on non-DOM events
        }
        if (type) {
            types = {};
            types[type] = true;
        } else {
            types = eventCollection;
        }
        objectEach(types, function(_val, n) {
            if (eventCollection[n]) {
                len = eventCollection[n].length;
                while(len--){
                    removeOneEvent(n, eventCollection[n][len].fn);
                }
            }
        });
    }
    const owner = typeof el === 'function' && el.prototype || el;
    if (Object.hasOwnProperty.call(owner, 'hcEvents')) {
        const events = owner.hcEvents;
        if (type) {
            const typeEvents = events[type] || [];
            if (fn) {
                events[type] = typeEvents.filter(function(obj) {
                    return fn !== obj.fn;
                });
                removeOneEvent(type, fn);
            } else {
                removeAllEvents(events);
                events[type] = [];
            }
        } else {
            removeAllEvents(events);
            delete owner.hcEvents;
        }
    }
}
/* eslint-disable valid-jsdoc */ /**
 * Fire an event that was registered with {@link Highcharts#addEvent}.
 *
 * @function Highcharts.fireEvent<T>
 *
 * @param {T} el
 *        The object to fire the event on. It can be a {@link HTMLDOMElement},
 *        an {@link SVGElement} or any other object.
 *
 * @param {string} type
 *        The type of event.
 *
 * @param {Highcharts.Dictionary<*>|Event} [eventArguments]
 *        Custom event arguments that are passed on as an argument to the event
 *        handler.
 *
 * @param {Highcharts.EventCallbackFunction<T>|Function} [defaultFunction]
 *        The default function to execute if the other listeners haven't
 *        returned false.
 *
 * @return {void}
 */ function fireEvent(el, type, eventArguments, defaultFunction) {
    /* eslint-enable valid-jsdoc */ eventArguments = eventArguments || {};
    if (doc?.createEvent && (el.dispatchEvent || el.fireEvent && // Enable firing events on Highcharts instance.
    el !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])) {
        const e = doc.createEvent('Events');
        e.initEvent(type, true, true);
        eventArguments = extend(e, eventArguments);
        if (el.dispatchEvent) {
            el.dispatchEvent(eventArguments);
        } else {
            el.fireEvent(type, eventArguments);
        }
    } else if (el.hcEvents) {
        if (!eventArguments.target) {
            // We're running a custom event
            extend(eventArguments, {
                // Attach a simple preventDefault function to skip
                // default handler if called. The built-in
                // defaultPrevented property is not overwritable (#5112)
                preventDefault: function() {
                    eventArguments.defaultPrevented = true;
                },
                // Setting target to native events fails with clicking
                // the zoom-out button in Chrome.
                target: el,
                // If the type is not set, we're running a custom event
                // (#2297). If it is set, we're running a browser event.
                type: type
            });
        }
        const events = [];
        let object = el;
        let multilevel = false;
        // Recurse up the inheritance chain and collect hcEvents set as own
        // objects on the prototypes.
        while(object.hcEvents){
            if (Object.hasOwnProperty.call(object, 'hcEvents') && object.hcEvents[type]) {
                if (events.length) {
                    multilevel = true;
                }
                events.unshift.apply(events, object.hcEvents[type]);
            }
            object = Object.getPrototypeOf(object);
        }
        // For performance reasons, only sort the event handlers in case we are
        // dealing with multiple levels in the prototype chain. Otherwise, the
        // events are already sorted in the addEvent function.
        if (multilevel) {
            // Order the calls
            events.sort((a, b)=>a.order - b.order);
        }
        // Call the collected event handlers
        events.forEach((obj)=>{
            // If the event handler returns false, prevent the default handler
            // from executing
            if (obj.fn.call(el, eventArguments) === false) {
                eventArguments.preventDefault();
            }
        });
    }
    // Run the default if not prevented
    if (defaultFunction && !eventArguments.defaultPrevented) {
        defaultFunction.call(el, eventArguments);
    }
}
let serialMode;
/**
 * Get a unique key for using in internal element id's and pointers. The key is
 * composed of a random hash specific to this Highcharts instance, and a
 * counter.
 *
 * @example
 * let id = uniqueKey(); // => 'highcharts-x45f6hp-0'
 *
 * @function Highcharts.uniqueKey
 *
 * @return {string}
 * A unique key.
 */ const uniqueKey = function() {
    const hash = Math.random().toString(36).substring(2, 9) + '-';
    let id = 0;
    return function() {
        return 'highcharts-' + (serialMode ? '' : hash) + id++;
    };
}();
/**
 * Activates a serial mode for element IDs provided by
 * {@link Highcharts.uniqueKey}. This mode can be used in automated tests, where
 * a simple comparison of two rendered SVG graphics is needed.
 *
 * **Note:** This is only for testing purposes and will break functionality in
 * webpages with multiple charts.
 *
 * @example
 * if (
 *   process &&
 *   process.env.NODE_ENV === 'development'
 * ) {
 *   Highcharts.useSerialIds(true);
 * }
 *
 * @function Highcharts.useSerialIds
 *
 * @param {boolean} [mode]
 * Changes the state of serial mode.
 *
 * @return {boolean|undefined}
 * State of the serial mode.
 */ function useSerialIds(mode) {
    return serialMode = pick(mode, serialMode);
}
function isFunction(obj) {
    return typeof obj === 'function';
}
function ucfirst(s) {
    return isString(s) ? s.substring(0, 1).toUpperCase() + s.substring(1) : String(s);
}
/* *
 *
 *  External
 *
 * */ // Register Highcharts as a plugin in jQuery
if (win.jQuery) {
    /**
     * Highcharts-extended JQuery.
     *
     * @external JQuery
     */ /**
     * Helper function to return the chart of the current JQuery selector
     * element.
     *
     * @function external:JQuery#highcharts
     *
     * @return {Highcharts.Chart}
     *         The chart that is linked to the JQuery selector element.
     */ /**
    * Factory function to create a chart in the current JQuery selector
    * element.
    *
    * @function external:JQuery#highcharts
    *
    * @param {'Chart'|'Map'|'StockChart'|string} [className]
    *        Name of the factory class in the Highcharts namespace.
    *
    * @param {Highcharts.Options} [options]
    *        The chart options structure.
    *
    * @param {Highcharts.ChartCallbackFunction} [callback]
    *        Function to run when the chart has loaded and all external
    *        images are loaded. Defining a
    *        [chart.events.load](https://api.highcharts.com/highcharts/chart.events.load)
    *        handler is equivalent.
    *
    * @return {JQuery}
    *         The current JQuery selector.
    */ win.jQuery.fn.highcharts = function() {
        const args = [].slice.call(arguments);
        if (this[0]) {
            // Create the chart
            if (args[0]) {
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][// Constructor defaults to Chart
                isString(args[0]) ? args.shift() : 'Chart'](this[0], args[0], args[1]);
                return this;
            }
            // When called without parameters or with the return argument,
            // return an existing chart
            return charts[attr(this[0], 'data-highcharts-chart')];
        }
    };
}
// TODO use named exports when supported.
const Utilities = {
    addEvent,
    arrayMax,
    arrayMin,
    attr,
    clamp,
    clearTimeout: internalClearTimeout,
    correctFloat,
    createElement,
    crisp,
    css,
    defined,
    destroyObjectProperties,
    diffObjects,
    discardElement,
    erase,
    error,
    extend,
    extendClass,
    find,
    fireEvent,
    getAlignFactor,
    getClosestDistance,
    getMagnitude,
    getNestedProperty,
    getStyle,
    insertItem,
    isArray,
    isClass,
    isDOMElement,
    isFunction,
    isNumber,
    isObject,
    isString,
    merge,
    normalizeTickInterval,
    objectEach,
    offset,
    pad,
    pick,
    pInt,
    pushUnique,
    relativeLength,
    removeEvent,
    replaceNested,
    splat,
    stableSort,
    syncTimeout,
    timeUnits,
    ucfirst,
    uniqueKey,
    useSerialIds,
    wrap
};
const __TURBOPACK__default__export__ = Utilities;
/* *
 *
 *  API Declarations
 *
 * */ /**
 * Creates a frame for the animated SVG element.
 *
 * @callback Highcharts.AnimationStepCallbackFunction
 *
 * @param {Highcharts.SVGElement} this
 *        The SVG element to animate.
 *
 * @return {void}
 */ /**
 * Interface description for a class.
 *
 * @interface Highcharts.Class<T>
 * @extends Function
 */ /**
* Class constructor.
* @function Highcharts.Class<T>#new
* @param {...Array<*>} args
*        Constructor arguments.
* @return {T}
*         Class instance.
*/ /**
 * A style object with camel case property names to define visual appearance of
 * a SVG element or HTML element. The properties can be whatever styles are
 * supported on the given SVG or HTML element.
 *
 * @example
 * {
 *    fontFamily: 'monospace',
 *    fontSize: '1.2em'
 * }
 *
 * @interface Highcharts.CSSObject
 */ /**
* @name Highcharts.CSSObject#[key:string]
* @type {boolean|number|string|undefined}
*/ /**
* Background style for the element.
* @name Highcharts.CSSObject#background
* @type {string|undefined}
*/ /**
* Background color of the element.
* @name Highcharts.CSSObject#backgroundColor
* @type {Highcharts.ColorString|undefined}
*/ /**
* Border style for the element.
* @name Highcharts.CSSObject#border
* @type {string|undefined}
*/ /**
* Radius of the element border.
* @name Highcharts.CSSObject#borderRadius
* @type {number|undefined}
*/ /**
* Color used in the element. The 'contrast' option is a Highcharts custom
* property that results in black or white, depending on the background of the
* element.
* @name Highcharts.CSSObject#color
* @type {'contrast'|Highcharts.ColorString|undefined}
*/ /**
* Style of the mouse cursor when resting over the element.
* @name Highcharts.CSSObject#cursor
* @type {Highcharts.CursorValue|undefined}
*/ /**
* Font family of the element text. Multiple values have to be in decreasing
* preference order and separated by comma.
* @name Highcharts.CSSObject#fontFamily
* @type {string|undefined}
*/ /**
* Font size of the element text.
* @name Highcharts.CSSObject#fontSize
* @type {string|undefined}
*/ /**
* Font weight of the element text.
* @name Highcharts.CSSObject#fontWeight
* @type {string|undefined}
*/ /**
* Height of the element.
* @name Highcharts.CSSObject#height
* @type {number|undefined}
*/ /**
* The maximum number of lines. If lines are cropped away, an ellipsis will be
* added.
* @name Highcharts.CSSObject#lineClamp
* @type {number|undefined}
*/ /**
* Width of the element border.
* @name Highcharts.CSSObject#lineWidth
* @type {number|undefined}
*/ /**
* Opacity of the element.
* @name Highcharts.CSSObject#opacity
* @type {number|undefined}
*/ /**
* Space around the element content.
* @name Highcharts.CSSObject#padding
* @type {string|undefined}
*/ /**
* Behaviour of the element when the mouse cursor rests over it.
* @name Highcharts.CSSObject#pointerEvents
* @type {string|undefined}
*/ /**
* Positioning of the element.
* @name Highcharts.CSSObject#position
* @type {string|undefined}
*/ /**
* Alignment of the element text.
* @name Highcharts.CSSObject#textAlign
* @type {string|undefined}
*/ /**
* Additional decoration of the element text.
* @name Highcharts.CSSObject#textDecoration
* @type {string|undefined}
*/ /**
* Outline style of the element text.
* @name Highcharts.CSSObject#textOutline
* @type {string|undefined}
*/ /**
* Line break style of the element text. Highcharts SVG elements support
* `ellipsis` when a `width` is set.
* @name Highcharts.CSSObject#textOverflow
* @type {string|undefined}
*/ /**
* Top spacing of the element relative to the parent element.
* @name Highcharts.CSSObject#top
* @type {string|undefined}
*/ /**
* Animated transition of selected element properties.
* @name Highcharts.CSSObject#transition
* @type {string|undefined}
*/ /**
* Line break style of the element text.
* @name Highcharts.CSSObject#whiteSpace
* @type {string|undefined}
*/ /**
* Width of the element.
* @name Highcharts.CSSObject#width
* @type {number|undefined}
*/ /**
 * All possible cursor styles.
 *
 * @typedef {'alias'|'all-scroll'|'auto'|'cell'|'col-resize'|'context-menu'|'copy'|'crosshair'|'default'|'e-resize'|'ew-resize'|'grab'|'grabbing'|'help'|'move'|'n-resize'|'ne-resize'|'nesw-resize'|'no-drop'|'none'|'not-allowed'|'ns-resize'|'nw-resize'|'nwse-resize'|'pointer'|'progress'|'row-resize'|'s-resize'|'se-resize'|'sw-resize'|'text'|'vertical-text'|'w-resize'|'wait'|'zoom-in'|'zoom-out'} Highcharts.CursorValue
 */ /**
 * All possible dash styles.
 *
 * @typedef {'Dash'|'DashDot'|'Dot'|'LongDash'|'LongDashDot'|'LongDashDotDot'|'ShortDash'|'ShortDashDot'|'ShortDashDotDot'|'ShortDot'|'Solid'} Highcharts.DashStyleValue
 */ /**
 * Generic dictionary in TypeScript notation.
 * Use the native `AnyRecord` instead.
 *
 * @deprecated
 * @interface Highcharts.Dictionary<T>
 */ /**
* @name Highcharts.Dictionary<T>#[key:string]
* @type {T}
*/ /**
 * @typedef {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} Highcharts.DOMElementType
 */ /**
 * The function callback to execute when the event is fired. The `this` context
 * contains the instance, that fired the event.
 *
 * @callback Highcharts.EventCallbackFunction<T>
 *
 * @param {T} this
 *
 * @param {Highcharts.Dictionary<*>|Event} [eventArguments]
 *        Event arguments.
 *
 * @return {boolean|void}
 */ /**
 * The event options for adding function callback.
 *
 * @interface Highcharts.EventOptionsObject
 */ /**
* The order the event handler should be called. This opens for having one
* handler be called before another, independent of in which order they were
* added.
* @name Highcharts.EventOptionsObject#order
* @type {number}
*/ /**
* Whether an event should be passive or not.
* When set to `true`, the function specified by listener will never call
* `preventDefault()`.
* @name Highcharts.EventOptionsObject#passive
* @type boolean
*/ /**
 * Formats data as a string. Usually the data is accessible through the `this`
 * keyword.
 *
 * @callback Highcharts.FormatterCallbackFunction<T>
 *
 * @param {T} this
 *        Context to format
 *
 * @return {string}
 *         Formatted text
 */ /**
 * An object of key-value pairs for HTML attributes.
 *
 * @typedef {Highcharts.Dictionary<boolean|number|string|Function>} Highcharts.HTMLAttributes
 */ /**
 * An HTML DOM element. The type is a reference to the regular HTMLElement in
 * the global scope.
 *
 * @typedef {global.HTMLElement} Highcharts.HTMLDOMElement
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement
 */ /**
 * The iterator callback.
 *
 * @callback Highcharts.ObjectEachCallbackFunction<T>
 *
 * @param {T} this
 *        The context.
 *
 * @param {*} value
 *        The property value.
 *
 * @param {string} key
 *        The property key.
 *
 * @param {*} obj
 *        The object that objectEach is being applied to.
 */ /**
 * An object containing `left` and `top` properties for the position in the
 * page.
 *
 * @interface Highcharts.OffsetObject
 */ /**
* Left distance to the page border.
* @name Highcharts.OffsetObject#left
* @type {number}
*/ /**
* Top distance to the page border.
* @name Highcharts.OffsetObject#top
* @type {number}
*/ /**
 * Describes a range.
 *
 * @interface Highcharts.RangeObject
 */ /**
* Maximum number of the range.
* @name Highcharts.RangeObject#max
* @type {number}
*/ /**
* Minimum number of the range.
* @name Highcharts.RangeObject#min
* @type {number}
*/ /**
 * If a number is given, it defines the pixel length. If a percentage string is
 * given, like for example `'50%'`, the setting defines a length relative to a
 * base size, for example the size of a container.
 *
 * @typedef {number|string} Highcharts.RelativeSize
 */ /**
 * Proceed function to call original (wrapped) function.
 *
 * @callback Highcharts.WrapProceedFunction
 *
 * @param {*} [arg1]
 *        Optional argument. Without any arguments defaults to first argument of
 *        the wrapping function.
 *
 * @param {*} [arg2]
 *        Optional argument. Without any arguments defaults to second argument
 *        of the wrapping function.
 *
 * @param {*} [arg3]
 *        Optional argument. Without any arguments defaults to third argument of
 *        the wrapping function.
 *
 * @return {*}
 *         Return value of the original function.
 */ /**
 * The Highcharts object is the placeholder for all other members, and various
 * utility functions. The most important member of the namespace would be the
 * chart constructor.
 *
 * @example
 * let chart = Highcharts.chart('container', { ... });
 *
 * @namespace Highcharts
 */ ''; // Detach doclets above
}),
"[project]/node_modules/highcharts/es-modules/Shared/TimeBase.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Globals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Utilities.js [app-client] (ecmascript)");
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
;
const { pageLang, win } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
;
const { defined, error, extend, isNumber, isObject, isString, merge, objectEach, pad, splat, timeUnits, ucfirst } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
/* *
 *
 *  Constants
 *
 * */ // To do: Remove this when we no longer need support for Safari < v14.1
const hasOldSafariBug = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isSafari && win.Intl && !win.Intl.DateTimeFormat.prototype.formatRange;
const isDateTimeFormatOptions = (obj)=>obj.main === void 0;
/* *
 *
 *  Class
 *
 * */ /* eslint-disable no-invalid-this, valid-jsdoc */ /**
 * The Time class. Time settings are applied in general for each page using
 * `Highcharts.setOptions`, or individually for each Chart item through the
 * [time](https://api.highcharts.com/highcharts/time) options set.
 *
 * The Time object is available from {@link Highcharts.Chart#time}, which refers
 * to  `Highcharts.time` unless individual time settings are applied for each
 * chart.
 *
 * When configuring time settings for individual chart instances, be aware that
 * using `Highcharts.dateFormat` or `Highcharts.time.dateFormat` within
 * formatter callbacks relies on the global time object, which applies the
 * global language and time zone settings. To ensure charts with local time
 * settings function correctly, use `chart.time.dateFormat? instead. However,
 * the recommended best practice is to use `setOptions` to define global time
 * settings unless specific configurations are needed for each chart.
 *
 * @example
 * // Apply time settings globally
 * Highcharts.setOptions({
 *     time: {
 *         timezone: 'Europe/London'
 *     }
 * });
 *
 * // Apply time settings by instance
 * const chart = Highcharts.chart('container', {
 *     time: {
 *         timezone: 'America/New_York'
 *     },
 *     series: [{
 *         data: [1, 4, 3, 5]
 *     }]
 * });
 *
 * // Use the Time object of a chart instance
 * console.log(
 *        'Current time in New York',
 *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
 * );
 *
 * // Standalone use
 * const time = new Highcharts.Time({
 *    timezone: 'America/New_York'
 * });
 * const s = time.dateFormat('%Y-%m-%d %H:%M:%S', Date.UTC(2020, 0, 1));
 * console.log(s); // => 2019-12-31 19:00:00
 *
 * @since 6.0.5
 *
 * @class
 * @name Highcharts.Time
 *
 * @param {Highcharts.TimeOptions} [options] Time options as defined in
 * [chart.options.time](/highcharts/time).
 */ class TimeBase {
    /* *
     *
     *  Constructors
     *
     * */ constructor(options, lang){
        /* *
         *
         *  Properties
         *
         * */ this.options = {
            timezone: 'UTC'
        };
        this.variableTimezone = false;
        this.Date = win.Date;
        this.update(options);
        this.lang = lang;
    }
    /* *
     *
     *  Functions
     *
     * */ /**
     * Update the Time object with current options. It is called internally on
     * initializing Highcharts, after running `Highcharts.setOptions` and on
     * `Chart.update`.
     *
     * @internal
     * @function Highcharts.Time#update
     *
     * @param {Highcharts.TimeOptions} [options]
     *
     */ update(options = {}) {
        this.dTLCache = {};
        this.options = options = merge(true, this.options, options);
        const { timezoneOffset, useUTC, locale } = options;
        // Allow using a different Date class
        this.Date = options.Date || win.Date || Date;
        // Assign the time zone. Handle the legacy, deprecated `useUTC` option.
        let timezone = options.timezone;
        if (defined(useUTC)) {
            timezone = useUTC ? 'UTC' : void 0;
        }
        // The Etc/GMT time zones do not support offsets with half-hour
        // resolutions
        if (timezoneOffset && timezoneOffset % 60 === 0) {
            timezone = 'Etc/GMT' + (timezoneOffset > 0 ? '+' : '') + timezoneOffset / 60;
        }
        /*
         * The time object has options allowing for variable time zones, meaning
         * the axis ticks or series data needs to consider this.
         */ this.variableTimezone = timezone !== 'UTC' && timezone?.indexOf('Etc/GMT') !== 0;
        this.timezone = timezone;
        // Update locale.
        if (this.lang && locale) {
            this.lang.locale = locale;
        }
        // Assign default time formats from locale strings
        [
            'months',
            'shortMonths',
            'weekdays',
            'shortWeekdays'
        ].forEach((name)=>{
            const isMonth = /months/i.test(name), isShort = /short/.test(name), options = {
                timeZone: 'UTC'
            };
            options[isMonth ? 'month' : 'weekday'] = isShort ? 'short' : 'long';
            this[name] = (isMonth ? [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ] : [
                3,
                4,
                5,
                6,
                7,
                8,
                9
            ]).map((position)=>this.dateFormat(options, (isMonth ? 31 : 1) * 24 * 36e5 * position));
        });
    }
    /**
     * Get a date in terms of numbers (year, month, day etc) for further
     * processing. Takes the current `timezone` setting into account. Inverse of
     * `makeTime` and the native `Date` constructor and `Date.UTC`.
     *
     * The date is returned in array format with the following indices:
     *
     * 0: year,
     * 1: month (zero based),
     * 2: day,
     * 3: hours,
     * 4: minutes,
     * 5: seconds,
     * 6: milliseconds,
     * 7: weekday (Sunday as 0)
     *
     * @function Highcharts.Time#toParts
     *
     * @param {number|Date} [timestamp]
     *                 The timestamp in milliseconds since January 1st 1970.
     *                 A Date object is also accepted.
     *
     * @return {Array<number>} The date parts in array format.
     */ toParts(timestamp) {
        const [weekday, dayOfMonth, month, year, hours, minutes, seconds] = this.dateTimeFormat({
            weekday: 'narrow',
            day: 'numeric',
            month: 'numeric',
            year: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
            second: 'numeric'
        }, timestamp, 'es')// The ', ' splitter is for all modern browsers:
        //      L, 6/3/2023, 14:30:00
        // The ' ' splitter is for legacy Safari with no comma between date
        // and time (#22445):
        //      L, 6/3/2023 14:30:00
        .split(/(?:, | |\/|:)/g);
        return [
            year,
            +month - 1,
            dayOfMonth,
            hours,
            minutes,
            seconds,
            // Milliseconds
            Math.floor(Number(timestamp) || 0) % 1000,
            // Spanish weekday index
            'DLMXJVS'.indexOf(weekday)
        ].map(Number);
    }
    /**
     * Shorthand to get a cached `Intl.DateTimeFormat` instance.
     */ dateTimeFormat(options, timestamp, locale = this.options.locale || pageLang) {
        const cacheKey = JSON.stringify(options) + locale;
        if (isString(options)) {
            options = this.str2dtf(options);
        }
        let dTL = this.dTLCache[cacheKey];
        if (!dTL) {
            options.timeZone ?? (options.timeZone = this.timezone);
            try {
                dTL = new Intl.DateTimeFormat(locale, options);
            } catch (e) {
                if (/Invalid time zone/i.test(e.message)) {
                    error(34);
                    options.timeZone = 'UTC';
                    dTL = new Intl.DateTimeFormat(locale, options);
                } else {
                    error(e.message, false);
                }
            }
        }
        this.dTLCache[cacheKey] = dTL;
        return dTL?.format(timestamp) || '';
    }
    /**
     * Take a locale-aware string format and return a full DateTimeFormat in
     * object form.
     */ str2dtf(s, dtf = {}) {
        const mapping = {
            L: {
                fractionalSecondDigits: 3
            },
            S: {
                second: '2-digit'
            },
            M: {
                minute: 'numeric'
            },
            H: {
                hour: '2-digit'
            },
            k: {
                hour: 'numeric'
            },
            E: {
                weekday: 'narrow'
            },
            a: {
                weekday: 'short'
            },
            A: {
                weekday: 'long'
            },
            d: {
                day: '2-digit'
            },
            e: {
                day: 'numeric'
            },
            b: {
                month: 'short'
            },
            B: {
                month: 'long'
            },
            m: {
                month: '2-digit'
            },
            o: {
                month: 'numeric'
            },
            y: {
                year: '2-digit'
            },
            Y: {
                year: 'numeric'
            }
        };
        Object.keys(mapping).forEach((key)=>{
            if (s.indexOf(key) !== -1) {
                extend(dtf, mapping[key]);
            }
        });
        return dtf;
    }
    /**
     * Make a time and returns milliseconds. Similar to `Date.UTC`, but takes
     * the current `timezone` setting into account.
     *
     * @function Highcharts.Time#makeTime
     *
     * @param {number} year
     *        The year
     *
     * @param {number} month
     *        The month. Zero-based, so January is 0.
     *
     * @param {number} [date=1]
     *        The day of the month
     *
     * @param {number} [hours=0]
     *        The hour of the day, 0-23.
     *
     * @param {number} [minutes=0]
     *        The minutes
     *
     * @param {number} [seconds=0]
     *        The seconds
     *
     * @return {number}
     *         The time in milliseconds since January 1st 1970.
     */ makeTime(year, month, date = 1, hours = 0, minutes, seconds, milliseconds) {
        // eslint-disable-next-line new-cap
        let d = this.Date.UTC(year, month, date, hours, minutes || 0, seconds || 0, milliseconds || 0);
        if (this.timezone !== 'UTC') {
            const offset = this.getTimezoneOffset(d);
            d += offset;
            // Adjustments close to DST transitions
            if (// Optimize for speed by limiting the number of calls to
            // `getTimezoneOffset`. According to
            // https://en.wikipedia.org/wiki/Daylight_saving_time_by_country,
            // DST change may only occur in these months.
            [
                2,
                3,
                8,
                9,
                10,
                11
            ].indexOf(month) !== -1 && // DST transitions occur only in the night-time
            (hours < 5 || hours > 20)) {
                const newOffset = this.getTimezoneOffset(d);
                if (offset !== newOffset) {
                    d += newOffset - offset;
                // A special case for transitioning from summer time to winter
                // time. When the clock is set back, the same time is repeated
                // twice, i.e. 02:30 am is repeated since the clock is set back
                // from 3 am to 2 am. We need to make the same time as local
                // Date does.
                } else if (offset - 36e5 === this.getTimezoneOffset(d - 36e5) && !hasOldSafariBug) {
                    d -= 36e5;
                }
            }
        }
        return d;
    }
    /**
     * Parse a datetime string. Unless the string contains time zone
     * information, apply the current `timezone` from options. If the argument
     * is a number, return it.
     *
     * @function Highcharts.Time#parse
     * @param    {string|number|undefined} s The datetime string to parse
     * @return   {number|undefined}          Parsed JavaScript timestamp
     */ parse(s) {
        if (!isString(s)) {
            return s ?? void 0;
        }
        s = s// Firefox fails on YYYY/MM/DD
        .replace(/\//g, '-')// Replace some non-standard notations
        .replace(/(GMT|UTC)/, '');
        // Extend shorthand hour timezone offset like +02
        // .replace(/([+-][0-9]{2})$/, '$1:00');
        // Check if the string has time zone information
        const hasTimezone = s.indexOf('Z') > -1 || /([+-][0-9]{2}):?[0-9]{2}$/.test(s), // YYYY-MM-DD and YYYY-MM are always UTC
        isYYYYMMDD = /^[0-9]{4}-[0-9]{2}(-[0-9]{2}|)$/.test(s);
        if (!hasTimezone && !isYYYYMMDD) {
            s += 'Z';
        }
        const ts = Date.parse(s);
        if (isNumber(ts)) {
            // Unless the string contains time zone information, convert from
            // the local time result of `Date.parse` via UTC into the current
            // timezone of the time object.
            return ts + (!hasTimezone || isYYYYMMDD ? this.getTimezoneOffset(ts) : 0);
        }
    }
    /**
     * Get the time zone offset based on the current timezone information as
     * set in the global options.
     *
     * @function Highcharts.Time#getTimezoneOffset
     *
     * @param {number} timestamp
     *        The JavaScript timestamp to inspect.
     *
     * @return {number}
     *         The timezone offset in minutes compared to UTC.
     */ getTimezoneOffset(timestamp) {
        if (this.timezone !== 'UTC') {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const [date, gmt, hours, colon, minutes = 0] = this.dateTimeFormat({
                timeZoneName: 'shortOffset'
            }, timestamp, 'en').split(/(GMT|:)/).map(Number), offset = -(hours + minutes / 60) * 60 * 60000;
            // Possible future NaNs stop here
            if (isNumber(offset)) {
                return offset;
            }
        }
        return 0;
    }
    /**
     * Formats a JavaScript date timestamp (milliseconds since January 1 1970)
     * into a human readable date string.
     *
     * The `format` parameter accepts two types of values:
     * - An object containing settings that are passed directly on to
     *   [Intl.DateTimeFormat.prototype.format](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/format).
     * - A format string containing either individual or locale-aware format
     *   keys. **Individual keys**, for example `%Y-%m-%d`, are listed below.
     *   **Locale-aware keys** are grouped by square brackets, for example
     *   `%[Ymd]`. The order of keys within the square bracket doesn't affect
     *   the output, which is determined by the locale. See example below.
     *   Internally, the locale-aware format keys are just a shorthand for the
     *   full object formats, but are particularly practical in
     *   [templating](https://www.highcharts.com/docs/chart-concepts/templating)
     *   where full object definitions are not an option.
     *
     * The available string format keys are listed below. Additional formats can
     * be given in the {@link Highcharts.dateFormats} hook.
     *
     * Supported format keys:
     * | Key  | Description                     | Notes on locale-aware format |
     * -------|----------------------------------------------|-------|
     * | `%A` | Long weekday, like 'Monday'                  |       |
     * | `%a` | Short weekday, like 'Mon'                    |       |
     * | `%E` | Narrow weekday, single character             |       |
     * | `%d` | Two digit day of the month, 01 to 31         |       |
     * | `%e` | Day of the month, 1 through 31               |       |
     * | `%w` | Day of the week, 0 through 6                 | N/A   |
     * | `%v` | The prefix "week from", read from `lang.weekFrom` | N/A |
     * | `%b` | Short month, like 'Jan'                      |       |
     * | `%B` | Long month, like 'January'                   |       |
     * | `%m` | Two digit month number, 01 through 12        |       |
     * | `%o` | Month number, 1 through 12                   |       |
     * | `%y` | Two digits year, like 24 for 2024            |       |
     * | `%Y` | Four digits year, like 2024                  |       |
     * | `%H` | Two digits hours in 24h format, 00 through 23 | Depending on the locale, 12h format may be instered. |
     * | `%k` | Hours in 24h format, 0 through 23            | Depending on the locale, 12h format may be instered. |
     * | `%I` | Two digits hours in 12h format, 00 through 11 | N/A. The locale determines the hour format. |
     * | `%l` | Hours in 12h format, 1 through 12            | N/A. The locale determines the hour format. |
     * | `%M` | Two digits minutes, 00 through 59            |       |
     * | `%p` | Upper case AM or PM                          | N/A. The locale determines whether to add AM and PM. |
     * | `%P` | Lower case AM or PM                          | N/A. The locale determines whether to add AM and PM. |
     * | `%S` | Two digits seconds, 00 through 59            |       |
     * | `%L` | Milliseconds (naming from Ruby)              |       |
     *
     * @example
     * // Object format, US English
     * const time1 = new Highcharts.Time({ locale: 'en-US' });
     * console.log(
     *     time1.dateFormat({
     *         day: 'numeric',
     *         month: 'short',
     *         year: 'numeric',
     *         hour: 'numeric',
     *         minute: 'numeric'
     *     }, Date.UTC(2024, 11, 31))
     * ); // => Dec 31, 2024, 12:00 AM
     *
     * // Object format, British English
     * const time2 = new Highcharts.Time({ locale: 'en-GB' });
     * console.log(
     *     time2.dateFormat({
     *         day: 'numeric',
     *         month: 'short',
     *         year: 'numeric',
     *         hour: 'numeric',
     *         minute: 'numeric'
     *     }, Date.UTC(2024, 11, 31))
     * ); // => 31 Dec 2024, 00:00
     *
     * // Individual key string replacement
     * const time3 = new Highcharts.Time();
     * console.log(
     *     time3.dateFormat('%Y-%m-%d %H:%M:%S', Date.UTC(2024, 11, 31))
     * ); // => 2024-12-31 00:00:00
     *
     * // Locale-aware keys, US English
     * const time4 = new Highcharts.Time({ locale: 'en-US' });
     * console.log(
     *     time4.dateFormat('%[YebHM]', Date.UTC(2024, 11, 31))
     * ); // => Dec 31, 2024, 12:00 AM
     *
     * // Locale-aware keys, British English
     * const time5 = new Highcharts.Time({ locale: 'en-GB' });
     * console.log(
     *     time5.dateFormat('%[YebHM]', Date.UTC(2024, 11, 31))
     * ); // => 31 Dec 2024, 00:00
     *
     * // Mixed locale-aware and individual keys
     * console.log(
     *     time5.dateFormat('%[Yeb], %H:%M', Date.UTC(2024, 11, 31))
     * ); // => 31 Dec 2024, 00:00
     *
     * @function Highcharts.Time#dateFormat
     *
     * @param {string|Highcharts.DateTimeFormatOptions} format
     *        The desired string format where various time representations are
     *        prefixed with %, or an object representing the locale-aware format
     *        options.
     *
     * @param {number} [timestamp]
     *        The JavaScript timestamp.
     *
     * @param {boolean} [upperCaseFirst=false]
     *        Upper case first letter in the return.
     *
     * @return {string}
     *         The formatted date.
     */ dateFormat(format, timestamp, upperCaseFirst) {
        const lang = this.lang;
        if (!defined(timestamp) || isNaN(timestamp)) {
            return lang?.invalidDate || '';
        }
        format = format ?? '%Y-%m-%d %H:%M:%S';
        // First, identify and replace locale-aware formats like %[Ymd]
        if (isString(format)) {
            const localeAwareRegex = /%\[([a-zA-Z]+)\]/g;
            let match;
            while(match = localeAwareRegex.exec(format)){
                format = format.replace(match[0], this.dateTimeFormat(match[1], timestamp, lang?.locale));
            }
        }
        // Then, replace static formats like %Y, %m, %d etc.
        if (isString(format) && format.indexOf('%') !== -1) {
            const time = this, [fullYear, month, dayOfMonth, hours, minutes, seconds, milliseconds, weekday] = this.toParts(timestamp), langWeekdays = lang?.weekdays || this.weekdays, shortWeekdays = lang?.shortWeekdays || this.shortWeekdays, months = lang?.months || this.months, shortMonths = lang?.shortMonths || this.shortMonths, // List all format keys. Custom formats can be added from the
            // outside.
            replacements = extend({
                // Day
                // Short weekday, like 'Mon'
                a: shortWeekdays ? shortWeekdays[weekday] : langWeekdays[weekday].substr(0, 3),
                // Long weekday, like 'Monday'
                A: langWeekdays[weekday],
                // Two digit day of the month, 01 to 31
                d: pad(dayOfMonth),
                // Day of the month, 1 through 31
                e: pad(dayOfMonth, 2, ' '),
                // Day of the week, 0 through 6
                w: weekday,
                // Week (none implemented)
                // 'W': weekNumber(),
                v: lang?.weekFrom ?? '',
                // Month
                // Short month, like 'Jan'
                b: shortMonths[month],
                // Long month, like 'January'
                B: months[month],
                // Two digit month number, 01 through 12
                m: pad(month + 1),
                // Month number, 1 through 12 (#8150)
                o: month + 1,
                // Year
                // Two digits year, like 09 for 2009
                y: fullYear.toString().substr(2, 2),
                // Four digits year, like 2009
                Y: fullYear,
                // Time
                // Two digits hours in 24h format, 00 through 23
                H: pad(hours),
                // Hours in 24h format, 0 through 23
                k: hours,
                // Two digits hours in 12h format, 00 through 11
                I: pad(hours % 12 || 12),
                // Hours in 12h format, 1 through 12
                l: hours % 12 || 12,
                // Two digits minutes, 00 through 59
                M: pad(minutes),
                // Upper case AM or PM
                p: hours < 12 ? 'AM' : 'PM',
                // Lower case AM or PM
                P: hours < 12 ? 'am' : 'pm',
                // Two digits seconds, 00 through 59
                S: pad(seconds),
                // Milliseconds (naming from Ruby)
                L: pad(milliseconds, 3)
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dateFormats);
            // Do the replaces
            objectEach(replacements, function(val, key) {
                if (isString(format)) {
                    // Regex would do it in one line, but this is faster
                    while(format.indexOf('%' + key) !== -1){
                        format = format.replace('%' + key, typeof val === 'function' ? val.call(time, timestamp) : val);
                    }
                }
            });
        } else if (isObject(format)) {
            const tzHours = (this.getTimezoneOffset(timestamp) || 0) / (60000 * 60), timeZone = this.timezone || 'Etc/GMT' + (tzHours >= 0 ? '+' : '') + tzHours, { prefix = '', suffix = '' } = format;
            format = prefix + this.dateTimeFormat(extend({
                timeZone
            }, format), timestamp) + suffix;
        }
        // Optionally sentence-case the string and return
        return upperCaseFirst ? ucfirst(format) : format;
    }
    /**
     * Resolve legacy formats of dateTimeLabelFormats (strings and arrays) into
     * an object.
     * @internal
     * @param {string|Array<T>|Highcharts.Dictionary<T>} f
     * General format description
     * @return {Highcharts.Dictionary<T>}
     * The object definition
     */ resolveDTLFormat(f) {
        if (!isObject(f, true)) {
            f = splat(f);
            return {
                main: f[0],
                from: f[1],
                to: f[2]
            };
        }
        // Type-check DateTimeFormatOptions against DateTimeLabelFormatObject
        if (isObject(f, true) && isDateTimeFormatOptions(f)) {
            return {
                main: f
            };
        }
        return f;
    }
    /**
     * Get the optimal date format for a point, based on a range.
     *
     * @internal
     * @function Highcharts.Time#getDateFormat
     *
     * @param {number} range
     *        The time range
     *
     * @param {number} timestamp
     *        The timestamp of the date
     *
     * @param {number} startOfWeek
     *        An integer representing the first day of the week, where 0 is
     *        Sunday.
     *
     * @param {Highcharts.Dictionary<string>} dateTimeLabelFormats
     *        A map of time units to formats.
     *
     * @return {string}
     *         The optimal date format for a point.
     */ getDateFormat(range, timestamp, startOfWeek, dateTimeLabelFormats) {
        const dateStr = this.dateFormat('%m-%d %H:%M:%S.%L', timestamp), blank = '01-01 00:00:00.000', strpos = {
            millisecond: 15,
            second: 12,
            minute: 9,
            hour: 6,
            day: 3
        };
        let n = 'millisecond', // For sub-millisecond data, #4223
        lastN = n;
        for(n in timeUnits){
            // If the range is exactly one week and we're looking at a
            // Sunday/Monday, go for the week format
            if (range && range === timeUnits.week && +this.dateFormat('%w', timestamp) === startOfWeek && dateStr.substr(6) === blank.substr(6)) {
                n = 'week';
                break;
            }
            // The first format that is too great for the range
            if (range && timeUnits[n] > range) {
                n = lastN;
                break;
            }
            // If the point is placed every day at 23:59, we need to show
            // the minutes as well. #2637.
            if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
                break;
            }
            // Weeks are outside the hierarchy, only apply them on
            // Mondays/Sundays like in the first condition
            if (n !== 'week') {
                lastN = n;
            }
        }
        return this.resolveDTLFormat(dateTimeLabelFormats[n]).main;
    }
}
const __TURBOPACK__default__export__ = TimeBase;
/* *
 *
 * API Declarations
 *
 * */ /**
 * Normalized interval.
 *
 * @interface Highcharts.TimeNormalizedObject
 */ /**
* The count.
*
* @name Highcharts.TimeNormalizedObject#count
* @type {number|undefined}
*/ /**
* The interval in axis values (ms).
*
* @name Highcharts.TimeNormalizedObject#unitRange
* @type {number}
*/ /**
 * Function of an additional date format specifier.
 *
 * @callback Highcharts.TimeFormatCallbackFunction
 *
 * @param {number} timestamp
 *        The time to format.
 *
 * @return {string}
 *         The formatted portion of the date.
 */ /**
 * Time ticks.
 *
 * @interface Highcharts.AxisTickPositionsArray
 * @extends global.Array<number>
 */ /**
* @name Highcharts.AxisTickPositionsArray#info
* @type {Highcharts.TimeTicksInfoObject|undefined}
*/ /**
 * A callback to return the time zone offset for a given datetime. It
 * takes the timestamp in terms of milliseconds since January 1 1970,
 * and returns the timezone offset in minutes. This provides a hook
 * for drawing time based charts in specific time zones using their
 * local DST crossover dates, with the help of external libraries.
 *
 * @callback Highcharts.TimezoneOffsetCallbackFunction
 *
 * @param {number} timestamp
 * Timestamp in terms of milliseconds since January 1 1970.
 *
 * @return {number}
 * Timezone offset in minutes.
 */ /**
 * Options for formatting dates and times using the [Intl.DateTimeFormat](
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat
 * ) API, and extended with some custom options for Highcharts.
 *
 * @interface Highcharts.DateTimeFormatOptions
 */ /**
* The locale matching algorithm to use.
*
* @name Highcharts.DateTimeFormatOptions#localeMatcher
* @type {string|undefined}
*/ /**
* The time zone to use. The default is the browser's default time zone.
*
* @name Highcharts.DateTimeFormatOptions#timeZone
* @type {string|undefined}
*/ /**
* Whether to use 12-hour time (as opposed to 24-hour time).
*
* @name Highcharts.DateTimeFormatOptions#hour12
* @type {'auto'|'always'|'never'|undefined}
*/ /**
* The format matching algorithm to use.
*
* @name Highcharts.DateTimeFormatOptions#formatMatcher
* @type {string|undefined}
*/ /**
* The representation of the weekday.
*
* @name Highcharts.DateTimeFormatOptions#weekday
* @type {'narrow'|'short'|'long'|undefined}
*/ /**
* The representation of the era.
*
* @name Highcharts.DateTimeFormatOptions#era
* @type {'narrow'|'short'|'long'|undefined}
*/ /**
* The representation of the year.
*
* @name Highcharts.DateTimeFormatOptions#year
* @type {'numeric'|'2-digit'|undefined}
*/ /**
* The representation of the month.
* "narrow", "short", "long".
*
* @name Highcharts.DateTimeFormatOptions#month
* @type {'numeric'|'2-digit'|'narrow'|'short'|'long'|undefined}
*/ /**
* The representation of the day.
*
* @name Highcharts.DateTimeFormatOptions#day
* @type {'numeric'|'2-digit'|undefined}
*/ /**
* The representation of the hour.
*
* @name Highcharts.DateTimeFormatOptions#hour
* @type {'numeric'|'2-digit'|undefined}
*/ /**
* The representation of the minute.
*
* @name Highcharts.DateTimeFormatOptions#minute
* @type {'numeric'|'2-digit'|undefined}
*/ /**
* The representation of the second.
*
* @name Highcharts.DateTimeFormatOptions#second
* @type {'numeric'|'2-digit'|undefined}
*/ /**
* The number of fractional digits to use. 3 means milliseconds.
*
* @name Highcharts.DateTimeFormatOptions#fractionalSecondDigits
* @type {1|2|3|undefined}
*/ /**
* The representation of the time zone name.
*
* @name Highcharts.DateTimeFormatOptions#timeZoneName
* @type {'short'|'long'|undefined}
*/ /**
* A prefix for the time string. Custom Highcharts option.
*
* @name Highcharts.DateTimeFormatOptions#prefix
* @type {'string'|undefined}
*/ /**
* A suffix for the time string. Custom Highcharts option.
*
* @name Highcharts.DateTimeFormatOptions#suffix
* @type {'string'|undefined}
*/ ''; // Keeps doclets above in JS file
}),
"[project]/node_modules/highcharts/es-modules/Core/Time.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Shared$2f$TimeBase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Shared/TimeBase.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Utilities.js [app-client] (ecmascript)");
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
;
;
const { defined, extend, timeUnits } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
/* *
 *
 *  Constants
 *
 * */ class Time extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Shared$2f$TimeBase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    /**
     * Return an array with time positions distributed on round time values
     * right and right after min and max. Used in datetime axes as well as for
     * grouping data on a datetime axis.
     *
     * @function Highcharts.Time#getTimeTicks
     *
     * @param {Highcharts.TimeNormalizedObject} normalizedInterval
     *        The interval in axis values (ms) and the count
     *
     * @param {number} [min]
     *        The minimum in axis values
     *
     * @param {number} [max]
     *        The maximum in axis values
     *
     * @param {number} [startOfWeek=1]
     *
     * @return {Highcharts.AxisTickPositionsArray}
     * Time positions
     */ getTimeTicks(normalizedInterval, min, max, startOfWeek) {
        const time = this, tickPositions = [], higherRanks = {}, { count = 1, unitRange } = normalizedInterval;
        let [year, month, dayOfMonth, hours, minutes, seconds] = time.toParts(min), milliseconds = (min || 0) % 1000, variableDayLength;
        startOfWeek ?? (startOfWeek = 1);
        if (defined(min)) {
            milliseconds = unitRange >= timeUnits.second ? 0 : count * Math.floor(milliseconds / count);
            if (unitRange >= timeUnits.second) {
                seconds = unitRange >= timeUnits.minute ? 0 : count * Math.floor(seconds / count);
            }
            if (unitRange >= timeUnits.minute) {
                minutes = unitRange >= timeUnits.hour ? 0 : count * Math.floor(minutes / count);
            }
            if (unitRange >= timeUnits.hour) {
                hours = unitRange >= timeUnits.day ? 0 : count * Math.floor(hours / count);
            }
            if (unitRange >= timeUnits.day) {
                dayOfMonth = unitRange >= timeUnits.month ? 1 : Math.max(1, count * Math.floor(dayOfMonth / count));
            }
            if (unitRange >= timeUnits.month) {
                month = unitRange >= timeUnits.year ? 0 : count * Math.floor(month / count);
            }
            if (unitRange >= timeUnits.year) {
                year -= year % count;
            }
            // Week is a special case that runs outside the hierarchy
            if (unitRange === timeUnits.week) {
                if (count) {
                    min = time.makeTime(year, month, dayOfMonth, hours, minutes, seconds, milliseconds);
                }
                // Get start of current week, independent of count
                const weekday = this.dateTimeFormat({
                    timeZone: this.timezone,
                    weekday: 'narrow'
                }, min, 'es'), // Spanish weekday index
                weekdayNo = 'DLMXJVS'.indexOf(weekday);
                dayOfMonth += -weekdayNo + startOfWeek + // We don't want to skip days that are before
                // startOfWeek (#7051)
                (weekdayNo < startOfWeek ? -7 : 0);
            }
            min = time.makeTime(year, month, dayOfMonth, hours, minutes, seconds, milliseconds);
            // Handle local timezone offset
            if (time.variableTimezone && defined(max)) {
                // Detect whether we need to take the DST crossover into
                // consideration. If we're crossing over DST, the day length may
                // be 23h or 25h and we need to compute the exact clock time for
                // each tick instead of just adding hours. This comes at a cost,
                // so first we find out if it is needed (#4951).
                variableDayLength = // Long range, assume we're crossing over.
                max - min > 4 * timeUnits.month || // Short range, check if min and max are in different time
                // zones.
                time.getTimezoneOffset(min) !== time.getTimezoneOffset(max);
            }
            // Iterate and add tick positions at appropriate values
            let t = min, i = 1;
            while(t < max){
                tickPositions.push(t);
                // Increase the years
                if (unitRange === timeUnits.year) {
                    t = time.makeTime(year + i * count, 0);
                // Increase the months
                } else if (unitRange === timeUnits.month) {
                    t = time.makeTime(year, month + i * count);
                // If we're using local time, the interval is not fixed as it
                // jumps one hour at the DST crossover
                } else if (variableDayLength && (unitRange === timeUnits.day || unitRange === timeUnits.week)) {
                    t = time.makeTime(year, month, dayOfMonth + i * count * (unitRange === timeUnits.day ? 1 : 7));
                } else if (variableDayLength && unitRange === timeUnits.hour && count > 1) {
                    // Make sure higher ranks are preserved across DST (#6797,
                    // #7621)
                    t = time.makeTime(year, month, dayOfMonth, hours + i * count);
                // Else, the interval is fixed and we use simple addition
                } else {
                    t += unitRange * count;
                }
                i++;
            }
            // Push the last time
            tickPositions.push(t);
            // Handle higher ranks. Mark new days if the time is on midnight
            // (#950, #1649, #1760, #3349). Use a reasonable dropout threshold
            // to prevent looping over dense data grouping (#6156).
            if (unitRange <= timeUnits.hour && tickPositions.length < 10000) {
                tickPositions.forEach((t)=>{
                    if (// Speed optimization, no need to run dateFormat unless
                    // we're on a full or half hour
                    t % 1800000 === 0 && // Check for local or global midnight
                    time.dateFormat('%H%M%S%L', t) === '000000000') {
                        higherRanks[t] = 'day';
                    }
                });
            }
        }
        // Record information on the chosen unit - for dynamic label formatter
        tickPositions.info = extend(normalizedInterval, {
            higherRanks,
            totalRange: unitRange * count
        });
        return tickPositions;
    }
}
const __TURBOPACK__default__export__ = Time;
}),
"[project]/node_modules/highcharts/es-modules/Core/Defaults.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Chart$2f$ChartDefaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Chart/ChartDefaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Globals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Color$2f$Palettes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Color/Palettes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Time.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Utilities.js [app-client] (ecmascript)");
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
;
;
const { isTouchDevice } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
;
;
;
const { fireEvent, merge } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
/* *
 *
 *  API Options
 *
 * */ /**
 * Global default settings.
 *
 * @name Highcharts.defaultOptions
 * @type {Highcharts.Options}
 */ /**
* @optionparent
* @internal
*/ const defaultOptions = {
    /**
     * An array containing the default colors for the chart's series. When
     * all colors are used, new colors are pulled from the start again.
     *
     * Default colors can also be set on a series or series.type basis,
     * see [column.colors](#plotOptions.column.colors),
     * [pie.colors](#plotOptions.pie.colors).
     *
     * In styled mode, the colors option doesn't exist. Instead, colors
     * are defined in CSS and applied either through series or point class
     * names, or through the [chart.colorCount](#chart.colorCount) option.
     *
     * @sample {highcharts} highcharts/chart/colors/
     *         Assign a global color theme
     * @sample highcharts/members/theme-v10/
     *         Latest release styled like version 10
     *
     * @type    {Array<(Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject)>}
     * @default [
     *     "#2caffe",
     *     "#544fc5",
     *     "#00e272",
     *     "#fe6a35",
     *     "#6b8abc",
     *     "#d568fb",
     *     "#2ee0ca",
     *     "#fa4b42",
     *     "#feb56a",
     *     "#91e8e1"
     * ]
     */ colors: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Color$2f$Palettes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].colors,
    /**
     * Styled mode only. Configuration object for adding SVG definitions for
     * reusable elements. See [gradients, shadows and
     * patterns](https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns)
     * for more information and code examples.
     *
     * @type      {*}
     * @since     5.0.0
     * @apioption defs
     */ /**
     * @ignore-option
     */ symbols: [
        'circle',
        'diamond',
        'square',
        'triangle',
        'triangle-down'
    ],
    /**
     * An object containing language-related strings and settings. A typical
     * setup uses `Highcharts.setOptions` to make the options apply to all
     * charts in the same page.
     *
     * Some language options, like `months` and `weekdays`, are only used
     * with non-locale-aware date formats.
     *
     * ```js
     * Highcharts.setOptions({
     *     lang: {
     *         locale: 'fr'
     *     }
     * });
     * ```
     *
     * @optionparent lang
     */ lang: {
        weekFrom: 'week from',
        /**
         * The default chart title.
         *
         * @since 12.2.0
         */ chartTitle: 'Chart title',
        /**
         * The browser locale to use for date and number formatting. The actual
         * locale used for each chart is determined in three steps:
         * 1. If this `lang.locale` option is specified, it is used.
         * 2. Else, look for the closest ancestor HTML element with a `lang`
         *    attribute, typically the `<html>` element.
         * 3. If no 'lang' attribute is found, use the default browser locale.
         *
         * Use `en-GB`, British English, for approximate consistency with
         * Highcharts v < 12.
         *
         * @sample highcharts/lang/locale/
         *         Set the locale using the `lang.locale` option
         * @sample highcharts/lang/locale-attribute/
         *         Pick up the locale from the HTML `lang` attribute
         * @sample highcharts/members/highcharts-numberformat
         *         Arabic locale with digits and dates         *
         *
         * @since 12.0.0
         * @type {string|Array<string>}
         */ locale: void 0,
        /**
         * The loading text that appears when the chart is set into the loading
         * state following a call to `chart.showLoading`.
         */ loading: 'Loading...',
        /**
         * An array containing the months names. Corresponds to the `%B` format
         * in `Highcharts.dateFormat()`. Defaults to 'undefined',
         * meaning the default month names are used according to the
         * `lang.locale` or browser settings.
         *
         * @type    {Array<string>}
         */ months: void 0,
        /**
         * [Format string](https://www.highcharts.com/docs/chart-concepts/templating) for the default series name.
         *
         * @since 12.2.0
         */ seriesName: 'Series {add index 1}',
        /**
         * An array containing the months names in abbreviated form. Corresponds
         * to the `%b` format in `Highcharts.dateFormat()`. Defaults to
         * 'undefined', meaning the default short month names are used according
         * to the `lang.locale` or browser settings.
         *
         * @type    {Array<string>}
         */ shortMonths: void 0,
        /**
         * An array containing the weekday names. Corresponds
         * to the `%A` format in `Highcharts.dateFormat()`. Defaults to
         * 'undefined', meaning the default weekday names are used according to
         * the `lang.locale` or browser settings.
         *
         * @type    {Array<string>}
         */ weekdays: void 0,
        /**
         * Short week days, starting Sunday. Corresponds to the `%a` format in
         * `Highcharts.dateFormat()`. Defaults to 'undefined', meaning
         * the default short weekday names are used according to the
         * `lang.locale` or browser settings.
         *
         * @sample highcharts/lang/shortweekdays/
         *         Finnish two-letter abbreviations
         *
         * @type      {Array<string>}
         * @since     4.2.4
         * @apioption lang.shortWeekdays
         */ /**
         * What to show in a date field for invalid dates. Defaults to an empty
         * string.
         *
         * @type      {string}
         * @since     4.1.8
         * @product   highcharts highstock
         * @apioption lang.invalidDate
         */ /**
         * The title appearing on hovering the zoom in button. The text itself
         * defaults to "+" and can be changed in the button options.
         *
         * @type      {string}
         * @default   Zoom in
         * @product   highmaps
         * @apioption lang.zoomIn
         */ /**
         * The title appearing on hovering the zoom out button. The text itself
         * defaults to "-" and can be changed in the button options.
         *
         * @type      {string}
         * @default   Zoom out
         * @product   highmaps
         * @apioption lang.zoomOut
         */ /**
         * The default decimal point used in the `Highcharts.numberFormat`
         * method unless otherwise specified in the function arguments. Defaults
         * to the locale decimal point as determined by `lang.locale`.
         *
         * @type      {string}
         * @default   undefined
         * @since     1.2.2
         * @apioption lang.decimalPoint
         */ /**
         * [Metric prefixes](https://en.wikipedia.org/wiki/Metric_prefix) used
         * to shorten high numbers in axis labels. Replacing any of the
         * positions with `null` causes the full number to be written. Setting
         * `numericSymbols` to `undefined` disables shortening altogether.
         *
         * @sample {highcharts} highcharts/lang/numericsymbols/
         *         Replacing the symbols with text
         * @sample {highstock} highcharts/lang/numericsymbols/
         *         Replacing the symbols with text
         *
         * @type    {Array<string>}
         * @default ["k", "M", "G", "T", "P", "E"]
         * @since   2.3.0
         */ numericSymbols: [
            'k',
            'M',
            'G',
            'T',
            'P',
            'E'
        ],
        /**
         * The default name for a pie slice (point).
         * @since 12.2.0
         */ pieSliceName: 'Slice',
        /**
         * The magnitude of [numericSymbols](#lang.numericSymbol) replacements.
         * Use 10000 for Japanese, Korean and various Chinese locales, which
         * use symbols for 10^4, 10^8 and 10^12.
         *
         * @sample highcharts/lang/numericsymbolmagnitude/
         *         10000 magnitude for Japanese
         *
         * @type      {number}
         * @default   1000
         * @since     5.0.3
         * @apioption lang.numericSymbolMagnitude
         */ /**
         * The default thousands separator used in the `Highcharts.numberFormat`
         * method unless otherwise specified in the function arguments. Defaults
         * to the locale thousands separator as determined by `lang.locale`.
         *
         * @type      {string}
         * @default   undefined
         * @since     1.2.2
         * @apioption lang.thousandsSep
         */ /**
         * The text for the label appearing when a chart is zoomed.
         *
         * @since 1.2.4
         */ resetZoom: 'Reset zoom',
        /**
         * The default title of the Y axis
         *
         * @since 12.2.0
         */ yAxisTitle: 'Values',
        /**
         * The tooltip title for the label appearing when a chart is zoomed.
         *
         * @since 1.2.4
         */ resetZoomTitle: 'Reset zoom level 1:1'
    },
    /**
     * Global options that don't apply to each chart. These options must be set
     * using the `Highcharts.setOptions` method.
     *
     * ```js
     * Highcharts.setOptions({
     *     global: {
     *         buttonTheme: {
     *             fill: '#d0d0d0'
     *         }
     *     }
     * });
     * ```
     */ global: {
        /**
         * General theme for buttons. This applies to the zoom button, exporting
         * context menu, map navigation, range selector buttons and custom
         * buttons generated using the `SVGRenderer.button` function. However,
         * each of these may be overridden with more specific options.
         *
         * @sample highcharts/global/buttontheme
         *         General button theme
         * @since 11.4.2
         */ buttonTheme: {
            /**
             * The fill color for buttons
             */ fill: "#f7f7f7" /* Palette.neutralColor3 */ ,
            /**
             * The padding of buttons
             */ padding: 8,
            /**
             * The border radius for buttons
             */ r: 2,
            /**
             * The stroke color for buttons
             */ stroke: "#cccccc" /* Palette.neutralColor20 */ ,
            /**
             * The stroke width for buttons
             */ 'stroke-width': 1,
            /**
             * CSS styling for the buttons' text
             */ style: {
                color: "#333333" /* Palette.neutralColor80 */ ,
                cursor: 'pointer',
                fontSize: '0.8em',
                fontWeight: 'normal'
            },
            /**
             * State overrides for the buttons
             */ states: {
                /**
                 * Hover state overrides for the buttons are applied in addition
                 * to the normal state options
                 */ hover: {
                    fill: "#e6e6e6" /* Palette.neutralColor10 */ 
                },
                /**
                 * Select state overrides for the buttons are applied in
                 * addition to the normal state options
                 */ select: {
                    fill: "#e6e9ff" /* Palette.highlightColor10 */ ,
                    style: {
                        color: "#000000" /* Palette.neutralColor100 */ ,
                        fontWeight: 'bold'
                    }
                },
                /**
                 * Disabled state overrides for the buttons are applied in
                 * addition to the normal state options
                 */ disabled: {
                    /**
                     * Disabled state CSS style overrides for the buttons' text
                     */ style: {
                        color: "#cccccc" /* Palette.neutralColor20 */ 
                    }
                }
            }
        }
    },
    /**
     * Time options that can apply globally or to individual charts. These
     * settings affect how `datetime` axes are laid out, how tooltips are
     * formatted, how series
     * [pointIntervalUnit](#plotOptions.series.pointIntervalUnit) works and how
     * the Highcharts Stock range selector handles time.
     *
     * The common use case is that all charts in the same Highcharts object
     * share the same time settings, in which case the global settings are set
     * using `setOptions`.
     *
     * ```js
     * // Apply time settings globally
     * Highcharts.setOptions({
     *     time: {
     *         timezone: 'Europe/London'
     *     }
     * });
     * // Apply time settings by instance
     * const chart = Highcharts.chart('container', {
     *     time: {
     *         timezone: 'America/New_York'
     *     },
     *     series: [{
     *         data: [1, 4, 3, 5]
     *     }]
     * });
     *
     * // Use the Time object
     * console.log(
     *        'Current time in New York',
     *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
     * );
     * ```
     *
     * Since v6.0.5, the time options were moved from the `global` object to the
     * `time` object, and time options can be set on each individual chart.
     *
     * @sample {highcharts|highstock}
     *         highcharts/time/timezone/
     *         Set the timezone globally
     * @sample {highcharts}
     *         highcharts/time/individual/
     *         Set the timezone per chart instance
     * @sample {highstock}
     *         stock/time/individual/
     *         Set the timezone per chart instance
     *
     * @since     6.0.5
     * @optionparent time
     */ time: {
        /**
         * A custom `Date` class for advanced date handling. For example,
         * [JDate](https://github.com/tahajahangir/jdate) can be hooked in to
         * handle Jalali dates.
         *
         * @type      {*}
         * @since     4.0.4
         * @product   highcharts highstock gantt
         */ Date: void 0,
        /**
         * A named time zone. Supported time zone names rely on the browser
         * implementations, as described in the [mdn
         * docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat#timezone).
         * If the given time zone is not recognized by the browser, Highcharts
         * provides a warning and falls back to returning a 0 offset,
         * corresponding to the UTC time zone.
         *
         * The time zone affects axis scaling, tickmark placement and
         * time display in `Highcharts.dateFormat`.
         *
         * Setting `timezone` to `undefined` falls back to the default browser
         * timezone setting.
         *
         * Until v11.2.0, this option depended on moment.js.
         *
         * @sample {highcharts|highstock} highcharts/time/timezone/ Europe/Oslo
         *
         * @type      {string}
         * @since     5.0.7
         * @product   highcharts highstock gantt
         */ timezone: 'UTC',
        /**
         * The timezone offset in minutes. Positive values are west, negative
         * values are east of UTC, as in the ECMAScript
         * [getTimezoneOffset](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)
         * method. Use this to display UTC based data in a predefined time zone.
         *
         * This option is deprecated as of v11.4.1 and will be removed in a
         * future release. Use the [time.timezone](#time.timezone) option
         * instead.
         *
         * @see [time.getTimezoneOffset](#time.getTimezoneOffset)
         *
         * @sample {highcharts|highstock} highcharts/time/timezoneoffset/
         *         Timezone offset
         *
         * @since     3.0.8
         * @deprecated 11.4.2
         * @product   highcharts highstock gantt
         */ timezoneOffset: 0,
        /**
         * Whether to use UTC time for axis scaling, tickmark placement and
         * time display in `Highcharts.dateFormat`. Advantages of using UTC
         * is that the time displays equally regardless of the user agent's
         * time zone settings. Local time can be used when the data is loaded
         * in real time or when correct Daylight Saving Time transitions are
         * required.
         *
         * Setting `useUTC` to true is equivalent to setting `time.timezone` to
         * `"UTC"`. Setting `useUTC` to false is equivalent to setting
         * `time.timezone` to `undefined`.
         *
         * @see [timezone](#time.timezone)
         *
         * @sample {highcharts} highcharts/time/useutc-true/
         *         True by default
         * @sample {highcharts} highcharts/time/useutc-false/
         *         False
         *
         * @deprecated
         */ useUTC: void 0
    },
    chart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Chart$2f$ChartDefaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    /**
     * The chart's main title.
     *
     * @sample {highmaps} maps/title/title/
     *         Title options demonstrated
     * @sample {highcharts} highcharts/title/align-auto/
     *         Default title alignment
     */ title: {
        /**
         * When the title is floating, the plot area will not move to make space
         * for it.
         *
         * @sample {highcharts} highcharts/chart/zoomtype-none/
         *         False by default
         * @sample {highcharts} highcharts/title/floating/
         *         True - title on top of the plot area
         * @sample {highstock} stock/chart/title-floating/
         *         True - title on top of the plot area
         *
         * @type      {boolean}
         * @default   false
         * @since     2.1
         * @apioption title.floating
         */ /**
         * Whether to
         * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
         * to render the text.
         *
         * @type      {boolean}
         * @default   false
         * @apioption title.useHTML
         */ /**
         * The vertical alignment of the title. Can be one of `"top"`,
         * `"middle"` and `"bottom"`. When a value is given, the title behaves
         * as if [floating](#title.floating) were `true`.
         *
         * @sample {highcharts} highcharts/title/verticalalign/
         *         Chart title in bottom right corner
         * @sample {highstock} stock/chart/title-verticalalign/
         *         Chart title in bottom right corner
         *
         * @type      {Highcharts.VerticalAlignValue}
         * @since     2.1
         * @apioption title.verticalAlign
         */ /**
         * The x position of the title relative to the alignment within
         * `chart.spacingLeft` and `chart.spacingRight`.
         *
         * @sample {highcharts} highcharts/title/align/
         *         Aligned to the plot area (x = 70px = margin left - spacing
         *         left)
         * @sample {highstock} stock/chart/title-align/
         *         Aligned to the plot area (x = 50px = margin left - spacing
         *         left)
         *
         * @type      {number}
         * @default   0
         * @since     2.0
         * @apioption title.x
         */ /**
         * The y position of the title relative to the alignment within
         * [chart.spacingTop](#chart.spacingTop) and [chart.spacingBottom](
         * #chart.spacingBottom). By default it depends on the font size.
         *
         * @sample {highcharts} highcharts/title/y/
         *         Title inside the plot area
         * @sample {highstock} stock/chart/title-verticalalign/
         *         Chart title in bottom right corner
         *
         * @type      {number}
         * @since     2.0
         * @apioption title.y
         */ /**
         * CSS styles for the title. Use this for font styling, but use `align`,
         * `x` and `y` for text alignment.
         *
         * Note that the default [title.minScale](#title.minScale) option also
         * affects the rendered font size. In order to keep the font size fixed
         * regardless of title length, set `minScale` to 1.
         *
         * In styled mode, the title style is given in the `.highcharts-title`
         * class.
         *
         * @sample {highcharts} highcharts/title/style/
         *         Custom color and weight
         * @sample {highstock} stock/chart/title-style/
         *         Custom color and weight
         * @sample highcharts/css/titles/
         *         Styled mode
         *
         * @type      {Highcharts.CSSObject}
         * @default   {highcharts|highmaps} { "color": "#333333", "fontSize": "18px" }
         * @default   {highstock} { "color": "#333333", "fontSize": "16px" }
         */ style: {
            color: "#333333" /* Palette.neutralColor80 */ ,
            fontWeight: 'bold'
        },
        /**
         * The title of the chart. To disable the title, set the `text` to
         * `undefined`.
         *
         * @sample {highcharts} highcharts/title/text/
         *         Custom title
         * @sample {highstock} stock/chart/title-text/
         *         Custom title
         *
         * @default {highcharts|highmaps} Chart title
         * @default {highstock} undefined
         */ text: 'Chart title',
        /**
         * The horizontal alignment of the title. Can be one of "left", "center"
         * and "right".
         *
         * Since v12 it defaults to `undefined`, meaning the alignment is
         * computed for best fit. If the text fits in one line, it aligned to
         * the center, but if it is wrapped into multiple lines, it is aligned
         * to the left.
         *
         * @sample {highcharts} highcharts/title/align-auto/
         *         Default alignment, dynamic
         * @sample {highcharts} highcharts/title/align/
         *         Aligned to the plot area (x = 70px = margin left - spacing
         *         left)
         * @sample {highstock} stock/chart/title-align/
         *         Aligned to the plot area (x = 50px = margin left - spacing
         *         left)
         *
         * @type      {Highcharts.AlignValue}
         * @default   undefined
         * @since     2.0
         * @apioption title.align
         */ /**
         * The margin between the title and the plot area, or if a subtitle
         * is present, the margin between the subtitle and the plot area.
         *
         * @sample {highcharts} highcharts/title/margin-50/
         *         A chart title margin of 50
         * @sample {highcharts} highcharts/title/margin-subtitle/
         *         The same margin applied with a subtitle
         * @sample {highstock} stock/chart/title-margin/
         *         A chart title margin of 50
         *
         * @since 2.1
         */ margin: 15,
        /**
         * When the title is too wide to fit in the chart, the default behavior
         * is to scale it down to fit, or apply word wrap if it is scaled down
         * to `minScale` and still doesn't fit.
         *
         * The default value reflects the scale, when using default font sizes,
         * when the title font size matches that of the subtitle. The title
         * still stands out as it is bold by default.
         *
         * Set `minScale` to 1 to avoid downscaling.
         *
         * @sample {highcharts} highcharts/title/align-auto/
         *         Downscaling demonstrated
         *
         * @since 12.0.0
         */ minScale: 0.67
    },
    /**
     * The chart's subtitle. This can be used both to display a subtitle below
     * the main title, and to display random text anywhere in the chart. The
     * subtitle can be updated after chart initialization through the
     * `Chart.setTitle` method.
     *
     * @sample {highcharts} highcharts/title/align-auto/
     *         Default title alignment
     * @sample {highmaps} maps/title/subtitle/
     *         Subtitle options demonstrated
     */ subtitle: {
        /**
         * The horizontal alignment of the subtitle. Can be one of "left",
         * "center" and "right". Since v12, it defaults to `undefined`, meaning
         * the actual alignment is inherited from the alignment of the main
         * title.
         *
         * @sample {highcharts} highcharts/title/align-auto/
         *         Default title and subtitle alignment, dynamic
         * @sample {highcharts} highcharts/subtitle/align/
         *         Footnote at right of plot area
         * @sample {highstock} stock/chart/subtitle-footnote
         *         Footnote at bottom right of plot area
         *
         * @type  {Highcharts.AlignValue}
         * @default undefined
         * @since 2.0
         * @apioption subtitle.align
         */ /**
         * When the subtitle is floating, the plot area will not move to make
         * space for it.
         *
         * @sample {highcharts} highcharts/subtitle/floating/
         *         Floating title and subtitle
         * @sample {highstock} stock/chart/subtitle-footnote
         *         Footnote floating at bottom right of plot area
         *
         * @type      {boolean}
         * @default   false
         * @since     2.1
         * @apioption subtitle.floating
         */ /**
         * Whether to
         * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
         * to render the text.
         *
         * @type      {boolean}
         * @default   false
         * @apioption subtitle.useHTML
         */ /**
         * The vertical alignment of the title. Can be one of `"top"`,
         * `"middle"` and `"bottom"`. When middle, the subtitle behaves as
         * floating.
         *
         * @sample {highcharts} highcharts/subtitle/verticalalign/
         *         Footnote at the bottom right of plot area
         * @sample {highstock} stock/chart/subtitle-footnote
         *         Footnote at the bottom right of plot area
         *
         * @type      {Highcharts.VerticalAlignValue}
         * @since     2.1
         * @apioption subtitle.verticalAlign
         */ /**
         * The x position of the subtitle relative to the alignment within
         * `chart.spacingLeft` and `chart.spacingRight`.
         *
         * @sample {highcharts} highcharts/subtitle/align/
         *         Footnote at right of plot area
         * @sample {highstock} stock/chart/subtitle-footnote
         *         Footnote at the bottom right of plot area
         *
         * @type      {number}
         * @default   0
         * @since     2.0
         * @apioption subtitle.x
         */ /**
         * The y position of the subtitle relative to the alignment within
         * `chart.spacingTop` and `chart.spacingBottom`. By default the subtitle
         * is laid out below the title unless the title is floating.
         *
         * @sample {highcharts} highcharts/subtitle/verticalalign/
         *         Footnote at the bottom right of plot area
         * @sample {highstock} stock/chart/subtitle-footnote
         *         Footnote at the bottom right of plot area
         *
         * @type      {number}
         * @since     2.0
         * @apioption subtitle.y
         */ /**
         * CSS styles for the title.
         *
         * In styled mode, the subtitle style is given in the
         * `.highcharts-subtitle` class.
         *
         * @sample {highcharts} highcharts/subtitle/style/
         *         Custom color and weight
         * @sample {highcharts} highcharts/css/titles/
         *         Styled mode
         * @sample {highstock} stock/chart/subtitle-style
         *         Custom color and weight
         * @sample {highstock} highcharts/css/titles/
         *         Styled mode
         * @sample {highmaps} highcharts/css/titles/
         *         Styled mode
         *
         * @type      {Highcharts.CSSObject}
         * @default   {"color": "#666666"}
         */ style: {
            color: "#666666" /* Palette.neutralColor60 */ ,
            /**
             * @type {number|string}
             */ fontSize: '0.8em'
        },
        /**
         * The subtitle of the chart.
         *
         * @sample {highcharts|highstock} highcharts/subtitle/text/
         *         Custom subtitle
         * @sample {highcharts|highstock} highcharts/subtitle/text-formatted/
         *         Formatted and linked text.
         */ text: ''
    },
    /**
     * The chart's caption, which will render below the chart and will be part
     * of exported charts. The caption can be updated after chart initialization
     * through the `Chart.update` or `Chart.caption.update` methods.
     *
     * @sample highcharts/caption/text/
     *         A chart with a caption
     * @since  7.2.0
     */ caption: {
        /**
         * When the caption is floating, the plot area will not move to make
         * space for it.
         *
         * @type      {boolean}
         * @default   false
         * @apioption caption.floating
         */ /**
         * The margin between the caption and the plot area.
         */ margin: 15,
        /**
         * Whether to
         * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
         * to render the text.
         *
         * @type      {boolean}
         * @default   false
         * @apioption caption.useHTML
         */ /**
         * The x position of the caption relative to the alignment within
         * `chart.spacingLeft` and `chart.spacingRight`.
         *
         * @type      {number}
         * @default   0
         * @apioption caption.x
         */ /**
         * The y position of the caption relative to the alignment within
         * `chart.spacingTop` and `chart.spacingBottom`.
         *
         * @type      {number}
         * @apioption caption.y
         */ /**
         * CSS styles for the caption.
         *
         * In styled mode, the caption style is given in the
         * `.highcharts-caption` class.
         *
         * @sample {highcharts} highcharts/css/titles/
         *         Styled mode
         *
         * @type      {Highcharts.CSSObject}
         * @default   {"color": "#666666"}
         */ style: {
            color: "#666666" /* Palette.neutralColor60 */ ,
            /**
             * @type {number|string}
             */ fontSize: '0.8em'
        },
        /**
         * The caption text of the chart.
         *
         * @sample {highcharts} highcharts/caption/text/
         *         Custom caption
         */ text: '',
        /**
         * The horizontal alignment of the caption. Can be one of "left",
         *  "center" and "right".
         *
         * @type  {Highcharts.AlignValue}
         */ align: 'left',
        /**
         * The vertical alignment of the caption. Can be one of `"top"`,
         * `"middle"` and `"bottom"`. When middle, the caption behaves as
         * floating.
         *
         * @type      {Highcharts.VerticalAlignValue}
         */ verticalAlign: 'bottom'
    },
    /**
     * The plotOptions is a wrapper object for config objects for each series
     * type. The config objects for each series can also be overridden for
     * each series item as given in the series array.
     *
     * Configuration options for the series are given in three levels. Options
     * for all series in a chart are given in the [plotOptions.series](
     * #plotOptions.series) object. Then options for all series of a specific
     * type are given in the plotOptions of that type, for example
     * `plotOptions.line`. Next, options for one single series are given in
     * [the series array](#series).
     */ plotOptions: {},
    /**
     * The legend is a box containing a symbol and name for each series
     * item or point item in the chart. Each series (or points in case
     * of pie charts) is represented by a symbol and its name in the legend.
     *
     * It is possible to override the symbol creator function and create
     * [custom legend symbols](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/studies/legend-custom-symbol/).
     *
     * @productdesc {highmaps}
     * A Highmaps legend by default contains one legend item per series, but if
     * a `colorAxis` is defined, the axis will be displayed in the legend.
     * Either as a gradient, or as multiple legend items for `dataClasses`.
     */ legend: {
        /**
         * The background color of the legend.
         *
         * @see In styled mode, the legend background fill can be applied with
         *      the `.highcharts-legend-box` class.
         *
         * @sample {highcharts} highcharts/legend/backgroundcolor/
         *         Yellowish background
         * @sample {highstock} stock/legend/align/
         *         Various legend options
         * @sample {highmaps} maps/legend/border-background/
         *         Border and background options
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption legend.backgroundColor
         */ /**
         * The width of the drawn border around the legend.
         *
         * @see In styled mode, the legend border stroke width can be applied
         *      with the `.highcharts-legend-box` class.
         *
         * @sample {highcharts} highcharts/legend/borderwidth/
         *         2px border width
         * @sample {highstock} stock/legend/align/
         *         Various legend options
         * @sample {highmaps} maps/legend/border-background/
         *         Border and background options
         *
         * @type      {number}
         * @default   0
         * @apioption legend.borderWidth
         */ /**
         * Enable or disable the legend. There is also a series-specific option,
         * [showInLegend](#plotOptions.series.showInLegend), that can hide the
         * series from the legend. In some series types this is `false` by
         * default, so it must set to `true` in order to show the legend for the
         * series.
         *
         * @sample {highcharts} highcharts/legend/enabled-false/ Legend disabled
         * @sample {highstock} stock/legend/align/ Various legend options
         * @sample {highmaps} maps/legend/enabled-false/ Legend disabled
         *
         * @default {highstock} false
         * @default {highmaps} true
         * @default {gantt} false
         */ enabled: true,
        /**
         * The horizontal alignment of the legend box within the chart area.
         * Valid values are `left`, `center` and `right`.
         *
         * In the case that the legend is aligned in a corner position, the
         * `layout` option will determine whether to place it above/below
         * or on the side of the plot area.
         *
         * @sample {highcharts} highcharts/legend/align/
         *         Legend at the right of the chart
         * @sample {highstock} stock/legend/align/
         *         Various legend options
         * @sample {highmaps} maps/legend/alignment/
         *         Legend alignment
         *
         * @type  {Highcharts.AlignValue}
         * @since 2.0
         */ align: 'center',
        /**
         * If the [layout](legend.layout) is `horizontal` and the legend items
         * span over two lines or more, whether to align the items into vertical
         * columns. Setting this to `false` makes room for more items, but will
         * look more messy.
         *
         * @since 6.1.0
         */ alignColumns: true,
        /**
         * A CSS class name to apply to the legend group.
         */ className: 'highcharts-no-tooltip',
        /**
         * General event handlers for the legend. These event hooks can
         * also be attached to the legend at run time using the
         * `Highcharts.addEvent` function.
         *
         * @declare Highcharts.LegendEventsOptionsObject
         *
         * @internal
         */ events: {},
        /**
         * Fires when the legend item belonging to the series is clicked. One
         * parameter, `event`, is passed to the function. The default action
         * is to toggle the visibility of the series, point or data class. This
         * can be prevented by returning `false` or calling
         * `event.preventDefault()`.
         *
         * @sample {highcharts} highcharts/legend/itemclick/
         *         Confirm hiding and showing
         * @sample {highcharts} highcharts/legend/pie-legend-itemclick/
         *         Confirm toggle visibility of pie slices
         *
         * @type      {Highcharts.LegendItemClickCallbackFunction}
         * @context   Highcharts.Legend
         * @apioption legend.events.itemClick
         */ /**
         * When the legend is floating, the plot area ignores it and is allowed
         * to be placed below it.
         *
         * @sample {highcharts} highcharts/legend/floating-false/
         *         False by default
         * @sample {highcharts} highcharts/legend/floating-true/
         *         True
         * @sample {highmaps} maps/legend/alignment/
         *         Floating legend
         *
         * @type      {boolean}
         * @default   false
         * @since     2.1
         * @apioption legend.floating
         */ /**
         * The layout of the legend items. Can be one of `horizontal` or
         * `vertical` or `proximate`. When `proximate`, the legend items will be
         * placed as close as possible to the graphs they're representing,
         * except in inverted charts or when the legend position doesn't allow
         * it.
         *
         * @sample {highcharts} highcharts/legend/layout-horizontal/
         *         Horizontal by default
         * @sample {highcharts} highcharts/legend/layout-vertical/
         *         Vertical
         * @sample highcharts/legend/layout-proximate
         *         Labels proximate to the data
         * @sample {highstock} stock/legend/layout-horizontal/
         *         Horizontal by default
         * @sample {highmaps} maps/legend/padding-itemmargin/
         *         Vertical with data classes
         * @sample {highmaps} maps/legend/layout-vertical/
         *         Vertical with color axis gradient
         *
         * @validvalue ["horizontal", "vertical", "proximate"]
         */ layout: 'horizontal',
        /**
         * In a legend with horizontal layout, the itemDistance defines the
         * pixel distance between each item.
         *
         * @sample {highcharts} highcharts/legend/layout-horizontal/
         *         50px item distance
         * @sample {highstock} highcharts/legend/layout-horizontal/
         *         50px item distance
         *
         * @type      {number}
         * @default   {highcharts} 20
         * @default   {highstock} 20
         * @default   {highmaps} 8
         * @since     3.0.3
         * @apioption legend.itemDistance
         */ /**
         * The pixel bottom margin for each legend item.
         *
         * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
         *         Padding and item margins demonstrated
         * @sample {highmaps} maps/legend/padding-itemmargin/
         *         Padding and item margins demonstrated
         *
         * @since     2.2.0
         */ itemMarginBottom: 2,
        /**
         * The pixel top margin for each legend item.
         *
         * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
         *         Padding and item margins demonstrated
         * @sample {highmaps} maps/legend/padding-itemmargin/
         *         Padding and item margins demonstrated
         *
         * @since     2.2.0
         */ itemMarginTop: 2,
        /**
         * The width for each legend item. By default the items are laid out
         * successively. In a [horizontal layout](legend.layout), if the items
         * are laid out across two rows or more, they will be vertically aligned
         * depending on the [legend.alignColumns](legend.alignColumns) option.
         *
         * @sample {highcharts} highcharts/legend/itemwidth-default/
         *         Undefined by default
         * @sample {highcharts} highcharts/legend/itemwidth-80/
         *         80 for aligned legend items
         *
         * @type      {number}
         * @since     2.0
         * @apioption legend.itemWidth
         */ /**
         * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
         * for each legend label. Available variables relates to properties on
         * the series, or the point in case of pies.
         *
         * @type      {string}
         * @default   {name}
         * @since     1.3
         * @apioption legend.labelFormat
         */ /* eslint-disable valid-jsdoc */ /**
         * Callback function to format each of the series' labels. The `this`
         * keyword refers to the series object, or the point object in case of
         * pie charts. By default the series or point name is printed.
         *
         * @productdesc {highmaps}
         * In Highmaps the context can also be a data class in case of a
         * `colorAxis`.
         *
         * @sample {highcharts} highcharts/legend/labelformatter/
         *         Add text
         * @sample {highmaps} maps/legend/labelformatter/
         *         Data classes with label formatter
         *
         * @type {Highcharts.FormatterCallbackFunction<Point|Series>}
         */ labelFormatter: function() {
            // eslint-enable valid-jsdoc
            return this.name;
        },
        /**
         * Line height for the legend items. Deprecated as of 2.1\. Instead,
         * the line height for each item can be set using
         * `itemStyle.lineHeight`, and the padding between items using
         * `itemMarginTop` and `itemMarginBottom`.
         *
         * @sample {highcharts} highcharts/legend/lineheight/
         *         Setting padding
         *
         * @deprecated
         *
         * @type      {number}
         * @default   16
         * @since     2.0
         * @product   highcharts gantt
         * @apioption legend.lineHeight
         */ /**
         * If the plot area sized is calculated automatically and the legend is
         * not floating, the legend margin is the space between the legend and
         * the axis labels or plot area.
         *
         * @sample {highcharts} highcharts/legend/margin-default/
         *         12 pixels by default
         * @sample {highcharts} highcharts/legend/margin-30/
         *         30 pixels
         *
         * @type      {number}
         * @default   12
         * @since     2.1
         * @apioption legend.margin
         */ /**
         * Maximum width for the legend. Can be a percentage of the chart width,
         * or an integer representing how many pixels wide the legend can be.
         *
         * @sample {highcharts} highcharts/legend/maxwidth/
         *         Max width set to 7%
         *
         * @type      {number|string}
         * @apioption legend.maxWidth
         */ /**
         * Maximum pixel height for the legend. When the maximum height is
         * extended, navigation will show.
         *
         * @type      {number}
         * @since     2.3.0
         * @apioption legend.maxHeight
         */ /**
         * The color of the drawn border around the legend.
         *
         * @see In styled mode, the legend border stroke can be applied with the
         *      `.highcharts-legend-box` class.
         *
         * @sample {highcharts} highcharts/legend/bordercolor/
         *         Brown border
         * @sample {highstock} stock/legend/align/
         *         Various legend options
         * @sample {highmaps} maps/legend/border-background/
         *         Border and background options
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */ borderColor: "#999999" /* Palette.neutralColor40 */ ,
        /**
         * The border corner radius of the legend.
         *
         * @sample {highcharts} highcharts/legend/borderradius-default/
         *         Square by default
         * @sample {highcharts} highcharts/legend/borderradius-round/
         *         5px rounded
         * @sample {highmaps} maps/legend/border-background/
         *         Border and background options
         */ borderRadius: 0,
        /**
         * Options for the paging or navigation appearing when the legend is
         * overflown. Navigation works well on screen, but not in static
         * exported images. One way of working around that is to
         * [increase the chart height in
         * export](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/legend/navigation-enabled-false/).
         *
         * @sample highcharts/legend/scrollable-vertical/
         *         Legend with vertical scrollable extension
         * @sample highcharts/legend/scrollable-horizontal/
         *         Legend with horizontal scrollable extension
         *
         */ navigation: {
            /**
             * How to animate the pages when navigating up or down. A value of
             * `true` applies the default navigation given in the
             * `chart.animation` option. Additional options can be given as an
             * object containing values for easing and duration.
             *
             * @sample {highcharts} highcharts/legend/navigation/
             *         Legend page navigation demonstrated
             * @sample {highstock} highcharts/legend/navigation/
             *         Legend page navigation demonstrated
             *
             * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
             * @default   true
             * @since     2.2.4
             * @apioption legend.navigation.animation
             */ /**
             * The pixel size of the up and down arrows in the legend paging
             * navigation.
             *
             * @sample {highcharts} highcharts/legend/navigation/
             *         Legend page navigation demonstrated
             * @sample {highstock} highcharts/legend/navigation/
             *         Legend page navigation demonstrated
             *
             * @type      {number}
             * @default   12
             * @since     2.2.4
             * @apioption legend.navigation.arrowSize
             */ /**
             * Whether to enable the legend navigation. In most cases, disabling
             * the navigation results in an unwanted overflow.
             *
             * See also the
             * [adapt chart to legend](https://github.com/highcharts/adapt-chart-to-legend)
             * plugin for a solution to extend the chart height to make room for
             * the legend, optionally in exported charts only.
             *
             * @type      {boolean}
             * @default   true
             * @since     4.2.4
             * @apioption legend.navigation.enabled
             */ /**
             * Text styles for the legend page navigation.
             *
             * @see In styled mode, the navigation items are styled with the
             *      `.highcharts-legend-navigation` class.
             *
             * @sample {highcharts} highcharts/legend/navigation/
             *         Legend page navigation demonstrated
             * @sample {highstock} highcharts/legend/navigation/
             *         Legend page navigation demonstrated
             *
             * @type      {Highcharts.CSSObject}
             * @since     2.2.4
             * @apioption legend.navigation.style
             */ style: {
                /**
                 * @type {number|string}
                 */ fontSize: '0.8em'
            },
            /**
             * The color for the active up or down arrow in the legend page
             * navigation.
             *
             * @see In styled mode, the active arrow be styled with the
             *      `.highcharts-legend-nav-active` class.
             *
             * @sample  {highcharts} highcharts/legend/navigation/
             *          Legend page navigation demonstrated
             * @sample  {highstock} highcharts/legend/navigation/
             *          Legend page navigation demonstrated
             *
             * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @since 2.2.4
             */ activeColor: "#0022ff" /* Palette.highlightColor100 */ ,
            /**
             * The color of the inactive up or down arrow in the legend page
             * navigation. .
             *
             * @see In styled mode, the inactive arrow be styled with the
             *      `.highcharts-legend-nav-inactive` class.
             *
             * @sample {highcharts} highcharts/legend/navigation/
             *         Legend page navigation demonstrated
             * @sample {highstock} highcharts/legend/navigation/
             *         Legend page navigation demonstrated
             *
             * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @since 2.2.4
             */ inactiveColor: "#cccccc" /* Palette.neutralColor20 */ 
        },
        /**
         * The inner padding of the legend box.
         *
         * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
         *         Padding and item margins demonstrated
         * @sample {highmaps} maps/legend/padding-itemmargin/
         *         Padding and item margins demonstrated
         *
         * @type      {number}
         * @default   8
         * @since     2.2.0
         * @apioption legend.padding
         */ /**
         * Whether to reverse the order of the legend items compared to the
         * order of the series or points as defined in the configuration object.
         *
         * @see [yAxis.reversedStacks](#yAxis.reversedStacks),
         *      [series.legendIndex](#series.legendIndex)
         *
         * @sample {highcharts} highcharts/legend/reversed/
         *         Stacked bar with reversed legend
         *
         * @type      {boolean}
         * @default   false
         * @since     1.2.5
         * @apioption legend.reversed
         */ /**
         * Whether to show the symbol on the right side of the text rather than
         * the left side. This is common in Arabic and Hebrew.
         *
         * @sample {highcharts} highcharts/legend/rtl/
         *         Symbol to the right
         *
         * @type      {boolean}
         * @default   false
         * @since     2.2
         * @apioption legend.rtl
         */ /**
         * CSS styles for the legend area. In the 1.x versions the position
         * of the legend area was determined by CSS. In 2.x, the position is
         * determined by properties like `align`, `verticalAlign`, `x` and `y`,
         * but the styles are still parsed for backwards compatibility.
         *
         * @deprecated
         *
         * @type      {Highcharts.CSSObject}
         * @product   highcharts highstock
         * @apioption legend.style
         */ /**
         * CSS styles for each legend item. Only a subset of CSS is supported,
         * notably those options related to text. The default `textOverflow`
         * property makes long texts truncate. Set it to `undefined` to wrap
         * text instead. A `width` property can be added to control the text
         * width.
         *
         * @see In styled mode, the legend items can be styled with the
         *      `.highcharts-legend-item` class.
         *
         * @sample {highcharts} highcharts/legend/itemstyle/
         *         Bold black text
         * @sample {highmaps} maps/legend/itemstyle/
         *         Item text styles
         *
         * @type    {Highcharts.CSSObject}
         * @default {"color": "#333333", "cursor": "pointer", "fontSize": "0.8em", "fontWeight": "bold", "textOverflow": "ellipsis"}
         */ itemStyle: {
            /**
             * @ignore
             */ color: "#333333" /* Palette.neutralColor80 */ ,
            /**
             * @ignore
             */ cursor: 'pointer',
            /**
             * @ignore
             */ fontSize: '0.8em',
            /**
             * @ignore
             */ textDecoration: 'none',
            /**
             * @ignore
             */ textOverflow: 'ellipsis'
        },
        /**
         * CSS styles for each legend item in hover mode. Only a subset of
         * CSS is supported, notably those options related to text. Properties
         * are inherited from `style` unless overridden here.
         *
         * @see In styled mode, the hovered legend items can be styled with
         *      the `.highcharts-legend-item:hover` pseudo-class.
         *
         * @sample {highcharts} highcharts/legend/itemhoverstyle/
         *         Red on hover
         * @sample {highmaps} maps/legend/itemstyle/
         *         Item text styles
         *
         * @type    {Highcharts.CSSObject}
         * @default {"color": "#000000"}
         */ itemHoverStyle: {
            /**
             * @ignore
             */ color: "#000000" /* Palette.neutralColor100 */ 
        },
        /**
         * CSS styles for each legend item when the corresponding series or
         * point is hidden. Only a subset of CSS is supported, notably those
         * options related to text. Properties are inherited from `style`
         * unless overridden here.
         *
         * @see In styled mode, the hidden legend items can be styled with
         *      the `.highcharts-legend-item-hidden` class.
         *
         * @sample {highcharts} highcharts/legend/itemhiddenstyle/
         *         Darker gray color
         *
         * @type    {Highcharts.CSSObject}
         * @default {"color": "#cccccc"}
         */ itemHiddenStyle: {
            /**
             * @ignore
             */ color: "#666666" /* Palette.neutralColor60 */ ,
            /**
             * @ignore
             */ textDecoration: 'line-through'
        },
        /**
         * Whether to apply a drop shadow to the legend. A `backgroundColor`
         * also needs to be applied for this to take effect. The shadow can be
         * an object configuration containing `color`, `offsetX`, `offsetY`,
         * `opacity` and `width`.
         *
         * @sample {highcharts} highcharts/legend/shadow/
         *         White background and drop shadow
         * @sample {highstock} stock/legend/align/
         *         Various legend options
         * @sample {highmaps} maps/legend/border-background/
         *         Border and background options
         *
         * @type {boolean|Highcharts.CSSObject}
         */ shadow: false,
        /**
         * Default styling for the checkbox next to a legend item when
         * `showCheckbox` is true.
         *
         * @type {Highcharts.CSSObject}
         * @default {"width": "13px", "height": "13px", "position":"absolute"}
         */ itemCheckboxStyle: {
            /**
             * @ignore
             */ position: 'absolute',
            /**
             * @ignore
             */ width: '13px',
            /**
             * @ignore
             */ height: '13px'
        },
        /// itemWidth: undefined,
        /**
         * When this is true, the legend symbol width will be the same as
         * the symbol height, which in turn defaults to the font size of the
         * legend items.
         *
         * @since 5.0.0
         */ squareSymbol: true,
        /**
         * The pixel height of the symbol for series types that use a rectangle
         * in the legend. Defaults to the font size of legend items.
         *
         * Note: This option is a default source of color axis height, if the
         * [colorAxis.height](https://api.highcharts.com/highcharts/colorAxis.height)
         * option is not set.
         *
         * @productdesc {highmaps}
         * In Highmaps, when the symbol is the gradient of a vertical color
         * axis, the height defaults to 200.
         *
         * @sample {highmaps} maps/legend/layout-vertical-sized/
         *         Sized vertical gradient
         * @sample {highmaps} maps/legend/padding-itemmargin/
         *         No distance between data classes
         *
         * @type      {number}
         * @since     3.0.8
         * @apioption legend.symbolHeight
         */ /**
         * The border radius of the symbol for series types that use a rectangle
         * in the legend. Defaults to half the `symbolHeight`, effectively
         * creating a circle.
         *
         * For color axis scales, it defaults to 3.
         *
         * @sample {highcharts} highcharts/legend/symbolradius/
         *         Round symbols
         * @sample {highstock} highcharts/legend/symbolradius/
         *         Round symbols
         * @sample {highmaps} highcharts/legend/symbolradius/
         *         Round symbols
         *
         * @type      {number}
         * @since     3.0.8
         * @apioption legend.symbolRadius
         */ /**
         * The pixel width of the legend item symbol. When the `squareSymbol`
         * option is set, this defaults to the `symbolHeight`, otherwise 16.
         *
         * Note: This option is a default source of color axis width, if the
         * [colorAxis.width](https://api.highcharts.com/highcharts/colorAxis.width)
         * option is not set.
         *
         * @productdesc {highmaps}
         * In Highmaps, when the symbol is the gradient of a horizontal color
         * axis, the width defaults to 200.
         *
         * @sample {highcharts} highcharts/legend/symbolwidth/
         *         Greater symbol width and padding
         * @sample {highmaps} maps/legend/padding-itemmargin/
         *         Padding and item margins demonstrated
         * @sample {highmaps} maps/legend/layout-vertical-sized/
         *         Sized vertical gradient
         *
         * @type      {number}
         * @apioption legend.symbolWidth
         */ /**
         * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
         * to render the legend item texts.
         *
         * Prior to 4.1.7, when using HTML, [legend.navigation](
         * #legend.navigation) was disabled.
         *
         * @sample highcharts/legend/scrollable-vertical/
         *         Legend with vertical scrollable extension
         * @sample highcharts/legend/scrollable-horizontal/
         *         Legend with horizontal scrollable extension
         *
         * @type      {boolean}
         * @default   false
         * @apioption legend.useHTML
         */ /**
         * For a color axis with data classes, how many decimals to render in
         * the legend. The default preserves the decimals of the range numbers.
         *
         * @type      {number}
         * @default   -1
         * @product   highcharts highmaps
         * @apioption legend.valueDecimals
         */ /**
         * For a color axis with data classes, a suffix for the range numbers in
         * the legend.
         *
         * @type      {string}
         * @default   ''
         * @product   highcharts highmaps
         * @apioption legend.valueSuffix
         */ /**
         * The width of the legend box. If a number is set, it translates to
         * pixels. Since v7.0.2 it allows setting a percent string of the full
         * chart width, for example `40%`.
         *
         * Defaults to the full chart width for legends below or above the
         * chart, half the chart width for legends to the left and right.
         *
         * @sample {highcharts} highcharts/legend/width/
         *         Aligned to the plot area
         * @sample {highcharts} highcharts/legend/width-percent/
         *         A percent of the chart width
         *
         * @type      {number|string}
         * @since     2.0
         * @apioption legend.width
         */ /**
         * The pixel padding between the legend item symbol and the legend
         * item text.
         *
         * @sample {highcharts} highcharts/legend/symbolpadding/
         *         Greater symbol width and padding
         */ symbolPadding: 5,
        /**
         * The vertical alignment of the legend box. Can be one of `top`,
         * `middle` or `bottom`. Vertical position can be further determined
         * by the `y` option.
         *
         * In the case that the legend is aligned in a corner position, the
         * `layout` option will determine whether to place it above/below
         * or on the side of the plot area.
         *
         * When the [layout](#legend.layout) option is `proximate`, the
         * `verticalAlign` option doesn't apply.
         *
         * @sample {highcharts} highcharts/legend/verticalalign/
         *         Legend 100px from the top of the chart
         * @sample {highstock} stock/legend/align/
         *         Various legend options
         * @sample {highmaps} maps/legend/alignment/
         *         Legend alignment
         *
         * @type  {Highcharts.VerticalAlignValue}
         * @since 2.0
         */ verticalAlign: 'bottom',
        // Width: undefined,
        /**
         * The x offset of the legend relative to its horizontal alignment
         * `align` within chart.spacingLeft and chart.spacingRight. Negative
         * x moves it to the left, positive x moves it to the right.
         *
         * @sample {highcharts} highcharts/legend/width/
         *         Aligned to the plot area
         *
         * @since 2.0
         */ x: 0,
        /**
         * The vertical offset of the legend relative to it's vertical alignment
         * `verticalAlign` within chart.spacingTop and chart.spacingBottom.
         *  Negative y moves it up, positive y moves it down.
         *
         * @sample {highcharts} highcharts/legend/verticalalign/
         *         Legend 100px from the top of the chart
         * @sample {highstock} stock/legend/align/
         *         Various legend options
         * @sample {highmaps} maps/legend/alignment/
         *         Legend alignment
         *
         * @since 2.0
         */ y: 0,
        /**
         * A title to be added on top of the legend.
         *
         * @sample {highcharts} highcharts/legend/title/
         *         Legend title
         * @sample {highmaps} maps/legend/alignment/
         *         Legend with title
         *
         * @since 3.0
         */ title: {
            /**
             * A text or HTML string for the title.
             *
             * @type      {string}
             * @since     3.0
             * @apioption legend.title.text
             */ /**
             * Generic CSS styles for the legend title.
             *
             * @see In styled mode, the legend title is styled with the
             *      `.highcharts-legend-title` class.
             *
             * @type    {Highcharts.CSSObject}
             * @default {"fontSize": "0.8em", "fontWeight": "bold"}
             * @since   3.0
             */ style: {
                /**
                 * @ignore
                 */ color: "#333333" /* Palette.neutralColor80 */ ,
                /**
                 * @ignore
                 */ fontSize: '0.8em',
                /**
                 * @ignore
                 */ fontWeight: 'bold'
            }
        }
    },
    /**
     * The loading options control the appearance of the loading screen
     * that covers the plot area on chart operations. This screen only
     * appears after an explicit call to `chart.showLoading()`. It is a
     * utility for developers to communicate to the end user that something
     * is going on, for example while retrieving new data via an XHR connection.
     * The "Loading..." text itself is not part of this configuration
     * object, but part of the `lang` object.
     */ loading: {
        /**
         * The duration in milliseconds of the fade out effect.
         *
         * @sample highcharts/loading/hideduration/
         *         Fade in and out over a second
         *
         * @type      {number}
         * @default   100
         * @since     1.2.0
         * @apioption loading.hideDuration
         */ /**
         * The duration in milliseconds of the fade in effect.
         *
         * @sample highcharts/loading/hideduration/
         *         Fade in and out over a second
         *
         * @type      {number}
         * @default   100
         * @since     1.2.0
         * @apioption loading.showDuration
         */ /**
         * CSS styles for the loading label `span`.
         *
         * @see In styled mode, the loading label is styled with the
         *      `.highcharts-loading-inner` class.
         *
         * @sample {highcharts|highmaps} highcharts/loading/labelstyle/
         *         Vertically centered
         * @sample {highstock} stock/loading/general/
         *         Label styles
         *
         * @type    {Highcharts.CSSObject}
         * @default {"fontWeight": "bold", "position": "relative", "top": "45%"}
         * @since   1.2.0
         */ labelStyle: {
            /**
             * @ignore
             */ fontWeight: 'bold',
            /**
             * @ignore
             */ position: 'relative',
            /**
             * @ignore
             */ top: '45%'
        },
        /**
         * CSS styles for the loading screen that covers the plot area.
         *
         * In styled mode, the loading label is styled with the
         * `.highcharts-loading` class.
         *
         * @sample  {highcharts|highmaps} highcharts/loading/style/
         *          Gray plot area, white text
         * @sample  {highstock} stock/loading/general/
         *          Gray plot area, white text
         *
         * @type    {Highcharts.CSSObject}
         * @default {"position": "absolute", "backgroundColor": "#ffffff", "opacity": 0.5, "textAlign": "center"}
         * @since   1.2.0
         */ style: {
            /**
             * @ignore
             */ position: 'absolute',
            /**
             * @ignore
             */ backgroundColor: "#ffffff" /* Palette.backgroundColor */ ,
            /**
             * @ignore
             */ opacity: 0.5,
            /**
             * @ignore
             */ textAlign: 'center'
        }
    },
    /**
     * Options for the tooltip that appears when the user hovers over a
     * series or point.
     *
     * @declare Highcharts.TooltipOptions
     */ tooltip: {
        /**
         * The color of the tooltip border. When `undefined`, the border takes
         * the color of the corresponding series or point.
         *
         * Note that the [borderWidth](#tooltip.borderWidth) is usually 0 by
         * default, so the border color may not be visible until a border width
         * is set.
         *
         * @sample {highcharts} highcharts/tooltip/bordercolor-default/ Follow
         *         series by default
         * @sample {highcharts} highcharts/tooltip/bordercolor-black/ Black
         *         border
         * @sample {highstock} stock/tooltip/general/ Styled tooltip
         * @sample {highmaps} maps/tooltip/background-border/ Background and
         *         border demo
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption tooltip.borderColor
         */ /**
         * A CSS class name to apply to the tooltip, allowing unique CSS
         * styling for each chart.
         *
         * **Note:** The class is applied to the SVG element of the tooltip
         * (the tooltip label group), not to a container div. This allows you
         * to style the tooltip using CSS applicable to SVG elements.
         *
         * When [tooltip.outside](#tooltip.outside) is `true`, a separate
         * container div with class `highcharts-tooltip-container` is created
         * as the parent to the SVG tooltip element, but the `className` option
         * is still applied to the SVG element itself, not to the container.
         *
         * @type      {string}
         * @apioption tooltip.className
         */ /**
         * Since 4.1, the crosshair definitions are moved to the Axis object
         * in order for a better separation from the tooltip. See
         * [xAxis.crosshair](#xAxis.crosshair).
         *
         * @sample {highcharts} highcharts/tooltip/crosshairs-x/
         *         Enable a crosshair for the x value
         *
         * @deprecated
         *
         * @type      {*}
         * @default   true
         * @apioption tooltip.crosshairs
         */ /**
         * Distance from point to tooltip in pixels.
         *
         * @type      {number}
         * @default   16
         * @apioption tooltip.distance
         */ /**
         * Whether the tooltip should be fixed to one position in the chart, or
         * located next to the point or mouse. When the tooltip is fixed, the
         * position can be further specified with the
         * [tooltip.position](#tooltip.position) options set.
         *
         * @sample    highcharts/tooltip/fixed/
         *            Fixed tooltip and position options
         * @sample    {highstock} stock/tooltip/fixed/
         *            Stock chart with fixed tooltip
         * @sample    {highmaps} maps/tooltip/fixed/
         *            Map with fixed tooltip
         *
         * @type      {boolean}
         * @default   false
         * @since 12.2.0
         * @apioption tooltip.fixed
         */ /**
         * Whether the tooltip should follow the mouse as it moves across
         * columns, pie slices and other point types with an extent.
         * By default it behaves this way for pie, polygon, map, sankey
         * and wordcloud series by override in the `plotOptions`
         * for those series types.
         *
         * Does not apply if [split](#tooltip.split) is `true`.
         *
         * For touch moves to behave the same way, [followTouchMove](
         * #tooltip.followTouchMove) must be `true` also.
         *
         * @sample highcharts/tooltip/followpointer/
         *         Tooltip follow pointer comparison
         *
         * @type      {boolean}
         * @default   {highcharts} false
         * @default   {highstock} false
         * @default   {highmaps} true
         * @since     3.0
         * @apioption tooltip.followPointer
         */ /**
         * Whether the tooltip should update as the finger moves on a touch
         * device. If this is `true` and [chart.panning](#chart.panning) is
         * set,`followTouchMove` will take over one-finger touches, so the user
         * needs to use two fingers for zooming and panning.
         *
         * Note the difference to [followPointer](#tooltip.followPointer) that
         * only defines the _position_ of the tooltip. If `followPointer` is
         * false in for example a column series, the tooltip will show above or
         * below the column, but as `followTouchMove` is true, the tooltip will
         * jump from column to column as the user swipes across the plot area.
         *
         * @type      {boolean}
         * @default   {highcharts} true
         * @default   {highstock} true
         * @default   {highmaps} false
         * @since     3.0.1
         * @apioption tooltip.followTouchMove
         */ /**
         * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
         * for the whole shared tooltip. When format strings are a requirement,
         * it is usually more convenient to use `headerFormat`, `pointFormat`
         * and `footerFormat`, but the `format` option allows combining them
         * into one setting.
         *
         * The context of the format string is the same as that of the
         * `tooltip.formatter` callback.
         *
         * @sample {highcharts} highcharts/tooltip/format-shared/
         *         Format for shared tooltip
         *
         * @type      {string}
         * @default   undefined
         * @since     11.1.0
         * @apioption tooltip.format
         */ /**
         * Callback function to format the text of the tooltip from scratch. In
         * case of single or [shared](#tooltip.shared) tooltips, a string should
         * be returned. In case of [split](#tooltip.split) tooltips, it should
         * return an array where the first item is the header, and subsequent
         * items are mapped to the points. Return `false` to disable tooltip for
         * a specific point on series.
         *
         * A subset of HTML is supported. Unless `useHTML` is true, the HTML of
         * the tooltip is parsed and converted to SVG, therefore this isn't a
         * complete HTML renderer. The following HTML tags are supported: `b`,
         * `br`, `em`, `i`, `span`, `strong`. Spans can be styled with a `style`
         * attribute, but only text-related CSS, that is shared with SVG, is
         * handled.
         *
         * The context of the formatter (since v12) is the
         * [Point](https://api.highcharts.com/class-reference/Highcharts.Point)
         * instance. If the tooltip is shared or split, an array `this.points`
         * contains all points of the hovered x-value.
         *
         * Common properties from the Point to use in the formatter include:
         *
         * - **Point.percentage**:
         *   Stacked series and pies only. The point's percentage of the total.
         *
         * - **Point.points**:
         *   In a shared or split tooltip, this is an array containing all the
         *   hovered points.
         *
         * - **this.series**:
         *   The series object. The series name is available through
         *   `this.series.name`.
         *
         * - **this.total**:
         *   The total value at this point's x value in a stacked series, or the
         *   sum of all slices in a pie series.
         *
         * - **this.x**:
         *   The x value.
         *
         * - **this.y**:
         *   The y value.
         *
         * @sample {highcharts} highcharts/tooltip/formatter-simple/
         *         Simple string formatting
         * @sample {highcharts} highcharts/tooltip/formatter-shared/
         *         Formatting with shared tooltip
         * @sample {highcharts|highstock} highcharts/tooltip/formatter-split/
         *         Formatting with split tooltip
         * @sample highcharts/tooltip/formatter-conditional-default/
         *         Extending default formatter
         * @sample {highstock} stock/tooltip/formatter/
         *         Formatting with shared tooltip
         * @sample {highmaps} maps/tooltip/formatter/
         *         String formatting
         *
         * @type      {Highcharts.TooltipFormatterCallbackFunction}
         * @apioption tooltip.formatter
         */ /**
         * Callback function to format the text of the tooltip for
         * visible null points.
         * Works analogously to [formatter](#tooltip.formatter).
         *
         * @sample highcharts/plotoptions/series-nullformat
         *         Format data label and tooltip for null point.
         *
         * @type      {Highcharts.TooltipFormatterCallbackFunction}
         * @apioption tooltip.nullFormatter
         */ /**
         * Whether to allow the tooltip to render outside the chart's SVG
         * element box. By default (`false`), the tooltip is rendered within the
         * chart's SVG element, which results in the tooltip being aligned
         * inside the chart area. For small charts, this may result in clipping
         * or overlapping. When `true`, a separate SVG element is created and
         * overlaid on the page, allowing the tooltip to be aligned inside the
         * page itself. Beware that with this option active, CSS classes on the
         * chart's target container, with classnames matching the pattern
         * 'highcharts-*', will be set on the tooltip as well. This is done to
         * support theming for tooltips with this option.
         *
         * Defaults to `true` if `chart.scrollablePlotArea` is activated,
         * otherwise `false`.
         *
         * @sample highcharts/tooltip/outside
         *         Small charts with tooltips outside
         *
         * @type      {boolean|undefined}
         * @default   undefined
         * @since     6.1.1
         * @apioption tooltip.outside
         */ /**
         * A callback function for formatting the HTML output for a single point
         * in the tooltip. Like the `pointFormat` string, but with more
         * flexibility.
         *
         * @type      {Highcharts.FormatterCallbackFunction<Highcharts.Point>}
         * @since     4.1.0
         * @context   Highcharts.Point
         * @apioption tooltip.pointFormatter
         */ /**
         * A callback function to place the tooltip in a custom position. The
         * callback receives three parameters: `labelWidth`, `labelHeight` and
         * `point`, where point contains values for `plotX` and `plotY` telling
         * where the reference point is in the plot area. Add `chart.plotLeft`
         * and `chart.plotTop` to get the full coordinates.
         *
         * To find the actual hovered `Point` instance, use
         * `this.chart.hoverPoint`. For shared or split tooltips, all the hover
         * points are available in `this.chart.hoverPoints`.
         *
         * Since v7, when [tooltip.split](#tooltip.split) option is enabled,
         * positioner is called for each of the boxes separately, including
         * xAxis header. xAxis header is not a point, instead `point` argument
         * contains info: `{ plotX: Number, plotY: Number, isHeader: Boolean }`
         *
         * Since v12.2, the [tooltip.fixed](#tooltip.fixed) option combined with
         * [tooltip.position](#tooltip.position) covers most of the use cases
         * for custom tooltip positioning.
         *
         * The return should be an object containing x and y values, for example
         * `{ x: 100, y: 100 }`.
         *
         * @sample {highcharts} highcharts/tooltip/positioner/
         *         A fixed tooltip position
         * @sample {highstock} stock/tooltip/positioner/
         *         A fixed tooltip position on top of the chart
         * @sample {highmaps} maps/tooltip/positioner/
         *         A fixed tooltip position
         * @sample {highstock} stock/tooltip/split-positioner/
         *         Split tooltip with fixed positions
         * @sample {highstock} stock/tooltip/positioner-scrollable-plotarea/
         *         Scrollable plot area combined with tooltip positioner
         *
         * @see [position](#tooltip.position)
         *
         * @type      {Highcharts.TooltipPositionerCallbackFunction}
         * @since     2.2.4
         * @apioption tooltip.positioner
         */ /**
         * Shows tooltip for all points with the same X value. Splits the
         * tooltip into one label per series, with the header close to the axis.
         * This is recommended over [shared](#tooltip.shared)
         * tooltips for charts with multiple line series, generally making them
         * easier to read. This option takes precedence over `tooltip.shared`.
         *
         * Not supported for [polar](#chart.polar) and [inverted](#chart.inverted) charts.
         *
         * @productdesc {highstock} In Highcharts Stock, tooltips are split
         * by default since v6.0.0. Stock charts typically contain
         * multi-dimension points and multiple panes, making split tooltips
         * the preferred layout over
         * the previous `shared` tooltip.
         *
         * @sample highcharts/tooltip/split/
         *         Split tooltip
         * @sample {highcharts|highstock} highcharts/tooltip/formatter-split/
         *         Split tooltip and custom formatter callback
         *
         * @type      {boolean}
         * @default   {highcharts} false
         * @default   {highstock} true
         * @since     5.0.0
         * @product   highcharts highstock
         * @apioption tooltip.split
         */ /**
         * How many decimals to show in each series' y value. This is
         * overridable in each series' tooltip options object. The default is to
         * preserve all decimals.
         *
         * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
         *         Set decimals, prefix and suffix for the value
         * @sample {highmaps} maps/tooltip/valuedecimals/
         *         Set decimals, prefix and suffix for the value
         *
         * @type      {number|undefined}
         * @since     2.2
         * @apioption tooltip.valueDecimals
         */ /**
         * A string to prepend to each series' y value. Overridable in each
         * series' tooltip options object.
         *
         * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
         *         Set decimals, prefix and suffix for the value
         * @sample {highmaps} maps/tooltip/valuedecimals/
         *         Set decimals, prefix and suffix for the value
         *
         * @type      {string}
         * @since     2.2
         * @apioption tooltip.valuePrefix
         */ /**
         * A string to append to each series' y value. Overridable in each
         * series' tooltip options object.
         *
         * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
         *         Set decimals, prefix and suffix for the value
         * @sample {highmaps} maps/tooltip/valuedecimals/
         *         Set decimals, prefix and suffix for the value
         *
         * @type      {string}
         * @since     2.2
         * @apioption tooltip.valueSuffix
         */ /**
         * The format for the date in the tooltip header if the X axis is a
         * datetime axis. The default is a best guess based on the smallest
         * distance between points in the chart.
         *
         * @sample {highcharts} highcharts/tooltip/xdateformat/
         *         A different format
         *
         * @type      {string|Highcharts.DateTimeFormatOptions}
         * @product   highcharts highstock gantt
         * @apioption tooltip.xDateFormat
         */ /**
         * How many decimals to show for the `point.change`
         * or the `point.cumulativeSum` value when the `series.compare`
         * or the `series.cumulative` option is set.
         * This is overridable in each series' tooltip options object.
         *
         * @type      {number}
         * @default   2
         * @since     1.0.1
         * @product   highstock
         * @apioption tooltip.changeDecimals
         */ /**
         * Enable or disable the tooltip.
         *
         * @sample {highcharts} highcharts/tooltip/enabled/
         *         Disabled
         * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
         *         Disable tooltip and show values on chart instead
         */ enabled: true,
        /**
         * Enable or disable animation of the tooltip.
         *
         * @type       {boolean|Partial<Highcharts.AnimationOptionsObject>}
         * @since      2.3.0
         */ animation: {
            duration: 300,
            // EaseOutCirc
            easing: (x)=>Math.sqrt(1 - Math.pow(x - 1, 2))
        },
        /**
         * The radius of the rounded border corners.
         *
         * @sample {highcharts} highcharts/tooltip/bordercolor-default/
         *         Default border radius
         * @sample {highcharts} highcharts/tooltip/borderradius-0/
         *         Square borders
         * @sample {highmaps} maps/tooltip/background-border/
         *         Background and border demo
         */ borderRadius: 3,
        /**
         * For series on datetime axes, the date format in the tooltip's
         * header will by default be guessed based on the closest data points.
         * This member gives the default string representations used for
         * each unit. For an overview of the string or object configuration, see
         * [dateFormat](/class-reference/Highcharts.Time#dateFormat).
         *
         * @see [xAxis.dateTimeLabelFormats](#xAxis.dateTimeLabelFormats)
         *
         * @type    {Highcharts.Dictionary<string|Highcharts.DateTimeFormatOptions>}
         * @product highcharts highstock gantt
         */ dateTimeLabelFormats: {
            /** @internal */ millisecond: '%[AebHMSL]',
            /** @internal */ second: '%[AebHMS]',
            /** @internal */ minute: '%[AebHM]',
            /** @internal */ hour: '%[AebHM]',
            /** @internal */ day: '%[AebY]',
            /** @internal */ week: '%v %[AebY]',
            /** @internal */ month: '%[BY]',
            /** @internal */ year: '%Y'
        },
        /**
         * A string to append to the tooltip format.
         *
         * @sample {highcharts} highcharts/tooltip/footerformat/
         *         A table for value alignment
         * @sample {highmaps} maps/tooltip/format/
         *         Format demo
         *
         * @since 2.2
         */ footerFormat: '',
        /**
         * The name of a symbol to use for the border around the tooltip
         * header. Applies only when [tooltip.split](#tooltip.split) is
         * enabled.
         *
         * Custom callbacks for symbol path generation can also be added to
         * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
         * [series.marker.symbol](plotOptions.line.marker.symbol).
         *
         * @see [tooltip.shape](#tooltip.shape)
         *
         * @sample {highstock} stock/tooltip/split-positioner/
         *         Different shapes for header and split boxes
         *
         * @type       {Highcharts.TooltipShapeValue}
         * @validvalue ["callout", "rect"]
         * @since      7.0
         */ headerShape: 'callout',
        /**
         * The number of milliseconds to wait until the tooltip is hidden when
         * mouse out from a point or chart.
         *
         * @since 3.0
         */ hideDelay: 500,
        /**
         * Padding inside the tooltip, in pixels.
         *
         * @since 5.0.0
         */ padding: 8,
        /**
         * Positioning options for fixed tooltip, taking effect only when
         * [tooltip.fixed](#tooltip.fixed) is `true`.
         *
         * @sample {highcharts} highcharts/tooltip/fixed/
         *         Fixed tooltip and position options
         * @sample {highstock} stock/tooltip/fixed/
         *         Stock chart with fixed tooltip
         * @sample {highmaps} maps/tooltip/fixed/
         *         Map with fixed tooltip
         *
         * @since 12.2.0
         */ position: {
            /**
             * The horizontal alignment of the fixed tooltip.
             *
             * @sample highcharts/tooltip/fixed/
             *         Fixed tooltip
             * @sample {highstock} stock/tooltip/fixed/
             *         Stock chart with fixed tooltip
             *
             * @type {Highcharts.AlignValue}
             * @default left
             * @apioption tooltip.position.align
             */ /**
             * The vertical alignment of the fixed tooltip.
             *
             * @sample highcharts/tooltip/fixed/
             *         Fixed tooltip
             * @sample {highstock} stock/tooltip/fixed/
             *         Stock chart with fixed tooltip
             *
             * @type {Highcharts.VerticalAlignValue}
             * @default top
             * @apioption tooltip.position.verticalAlign
             */ /**
             * What the fixed tooltip alignment should be relative to.
             *
             * The default, `pane`, means that it is aligned within the plot
             * area for that given series. If the tooltip is split (as default
             * in Stock charts), each partial tooltip is aligned within the
             * series' pane.
             *
             * @sample highcharts/tooltip/fixed/
             *         Fixed tooltip
             * @sample {highstock} stock/tooltip/fixed/
             *         Stock chart with fixed tooltip
             *
             * @type {string}
             * @default pane
             * @validvalue ["pane", "chart", "plotBox", "spacingBox"]
             * @apioption tooltip.position.relativeTo
             */ /**
             * X pixel offset from the given position. Can be used to shy away
             * from axis lines, grid lines etc to avoid the tooltip overlapping
             * other elements.
             *
             * @sample highcharts/tooltip/fixed/
             *         Fixed tooltip
             * @sample {highstock} stock/tooltip/fixed/
             *         Stock chart with fixed tooltip
             */ x: 0,
            /**
             * Y pixel offset from the given position. Can be used to shy away
             * from axis lines, grid lines etc to avoid the tooltip overlapping
             * other elements.
             *
             * @sample highcharts/tooltip/fixed/
             *         Fixed tooltip
             * @sample {highstock} stock/tooltip/fixed/
             *         Stock chart with fixed tooltip
             */ y: 3
        },
        /**
         * The name of a symbol to use for the border around the tooltip. Can
         * be one of: `"callout"`, `"circle"` or `"rect"`. When
         * [tooltip.split](#tooltip.split)
         * option is enabled, shape is applied to all boxes except header, which
         * is controlled by
         * [tooltip.headerShape](#tooltip.headerShape).
         *
         * Custom callbacks for symbol path generation can also be added to
         * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
         * [series.marker.symbol](plotOptions.line.marker.symbol).
         *
         * Defaults to `callout` for floating tooltip, `rect` for
         * [fixed](#tooltip.fixed) tooltip.
         *
         * @type  {Highcharts.TooltipShapeValue}
         * @since 4.0
         * @default undefined
         * @apioption tooltip.shape
         */ /**
         * Shows information in the tooltip for all points with the same X
         * value. When the tooltip is shared, the entire plot area will capture
         * mouse movement or touch events. Tooltip texts for series types with
         * ordered data (not pie, scatter, flags etc) will be shown in a single
         * bubble. This is recommended for single series charts and for
         * tablet/mobile optimized charts.
         *
         * See also [tooltip.split](#tooltip.split), that is better suited for
         * charts with many series, especially line-type series. The
         * `tooltip.split` option takes precedence over `tooltip.shared`.
         *
         * @sample {highcharts} highcharts/tooltip/shared-false/
         *         False by default
         * @sample {highcharts} highcharts/tooltip/shared-true/
         *         True
         * @sample {highcharts} highcharts/tooltip/shared-x-crosshair/
         *         True with x axis crosshair
         * @sample {highcharts} highcharts/tooltip/shared-true-mixed-types/
         *         True with mixed series types
         *
         * @since   2.1
         * @product highcharts highstock
         */ shared: false,
        /**
         * Proximity snap for graphs or single points. It defaults to 10 for
         * mouse-powered devices and 25 for touch devices.
         *
         * Note that in most cases the whole plot area captures the mouse
         * movement, and in these cases `tooltip.snap` doesn't make sense. This
         * applies when [stickyTracking](#plotOptions.series.stickyTracking)
         * is `true` (default) and when the tooltip is [shared](#tooltip.shared)
         * or [split](#tooltip.split).
         *
         * @sample {highcharts} highcharts/tooltip/bordercolor-default/
         *         10 px by default
         * @sample {highcharts} highcharts/tooltip/snap-50/
         *         50 px on graph
         *
         * @type    {number}
         * @default 10/25
         * @since   1.2.0
         * @product highcharts highstock
         */ snap: isTouchDevice ? 25 : 10,
        /**
         * The HTML of the tooltip header line. The context is the
         * [Point class](https://api.highcharts.com/class-reference/Highcharts.Point).
         * Variables are enclosed in curly brackets. Examples of common
         * variables to include are `x`, `y`, `series.name` and `series.color`
         * and other properties on the same form. The `point.key` variable
         * contains the category name, x value or datetime string depending on
         * the type of axis. For datetime axes, the `point.key` date format can
         * be set using `tooltip.xDateFormat`.
         * In v12+, locale-aware date names follow the browser's casing and can
         * be lower-case, so use the `ucfirst` helper (for example
         * `{ucfirst point.key}`) if you want a capitalized header.
         *
         * @sample {highcharts} highcharts/tooltip/footerformat/
         *         An HTML table in the tooltip
         * @sample {highstock} highcharts/tooltip/footerformat/
         *         An HTML table in the tooltip
         * @sample {highmaps} maps/tooltip/format/
         *         Format demo
         *
         * @type      {string}
         * @apioption tooltip.headerFormat
         */ headerFormat: '<span style="font-size: 0.8em">{ucfirst point.key}</span><br/>',
        /**
         * The HTML of the null point's line in the tooltip. Works analogously
         * to [pointFormat](#tooltip.pointFormat).
         *
         * @sample {highcharts} highcharts/series/null-interaction
         *         Line chart with null interaction
         * @sample {highcharts} highcharts/plotoptions/series-nullformat
         *         Heatmap with null interaction
         *
         * @type      {string}
         * @apioption tooltip.nullFormat
         */ /**
         * The HTML of the point's line in the tooltip. The context is the
         * [Point class](https://api.highcharts.com/class-reference/Highcharts.Point).
         * Variables are enclosed in curly brackets. Examples of common
         * variables to include are `x`, `y`, `series.name` and `series.color`
         * and other properties on the same form. Furthermore, `y` can be
         * extended by the `tooltip.valuePrefix` and `tooltip.valueSuffix`
         * variables. This can also be overridden for each series, which makes
         * it a good hook for displaying units.
         *
         * In styled mode, the dot is colored by a class name rather than the
         * point color.
         *
         * @sample {highcharts} highcharts/tooltip/pointformat/
         *         A different point format with value suffix
         * @sample {highcharts|highstock} highcharts/tooltip/pointformat-extra-information/
         *         Show extra information about points in the tooltip
         * @sample {highmaps} maps/tooltip/format/
         *         Format demo
         *
         * @type       {string}
         * @since      2.2
         * @apioption  tooltip.pointFormat
         */ pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
        /**
         * The background color or gradient for the tooltip.
         *
         * In styled mode, the stroke width is set in the
         * `.highcharts-tooltip-box` class.
         *
         * @sample {highcharts} highcharts/tooltip/backgroundcolor-solid/
         *         Yellowish background
         * @sample {highcharts} highcharts/tooltip/backgroundcolor-gradient/
         *         Gradient
         * @sample {highcharts} highcharts/css/tooltip-border-background/
         *         Tooltip in styled mode
         * @sample {highstock} stock/tooltip/general/
         *         Custom tooltip
         * @sample {highstock} highcharts/css/tooltip-border-background/
         *         Tooltip in styled mode
         * @sample {highmaps} maps/tooltip/background-border/
         *         Background and border demo
         * @sample {highmaps} highcharts/css/tooltip-border-background/
         *         Tooltip in styled mode
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */ backgroundColor: "#ffffff" /* Palette.backgroundColor */ ,
        /**
         * The pixel width of the tooltip border. Defaults to 0 for single
         * tooltips and fixed tooltips, otherwise 1 for split tooltips.
         *
         * In styled mode, the stroke width is set in the
         * `.highcharts-tooltip-box` class.
         *
         * @sample {highcharts} highcharts/tooltip/bordercolor-default/
         *         2 pixels
         * @sample {highcharts} highcharts/tooltip/borderwidth/
         *         No border (shadow only)
         * @sample {highcharts} highcharts/css/tooltip-border-background/
         *         Tooltip in styled mode
         * @sample {highstock} stock/tooltip/general/
         *         Custom tooltip
         * @sample {highstock} highcharts/css/tooltip-border-background/
         *         Tooltip in styled mode
         * @sample {highmaps} maps/tooltip/background-border/
         *         Background and border demo
         * @sample {highmaps} highcharts/css/tooltip-border-background/
         *         Tooltip in styled mode
         *
         * @type {number}
         */ borderWidth: void 0,
        /**
         * Whether to apply a drop shadow to the tooltip. Defaults to true,
         * unless the tooltip is [fixed](#tooltip.fixed).
         *
         * @sample {highcharts} highcharts/tooltip/bordercolor-default/
         *         True by default
         * @sample {highcharts} highcharts/tooltip/shadow/
         *         False
         * @sample {highmaps} maps/tooltip/positioner/
         *         Fixed tooltip position, border and shadow disabled
         *
         * @type {boolean|Highcharts.ShadowOptionsObject}
         * @default undefined
         * @apioption tooltip.shadow
         */ /**
         * Prevents the tooltip from switching or closing, when touched or
         * pointed.
         *
         * @sample highcharts/tooltip/stickoncontact/
         *         Tooltip sticks on pointer contact
         *
         * @type      {boolean}
         * @since     8.0.1
         */ stickOnContact: false,
        /**
         * CSS styles for the tooltip. The tooltip can also be styled through
         * the CSS class `.highcharts-tooltip`.
         *
         * Note that the default `pointerEvents` style makes the tooltip ignore
         * mouse events, so in order to use clickable tooltips, this value must
         * be set to `auto`.
         *
         * @sample {highcharts} highcharts/tooltip/style/
         *         Greater padding, bold text
         *
         * @type {Highcharts.CSSObject}
         */ style: {
            /** @internal */ color: "#333333" /* Palette.neutralColor80 */ ,
            /** @internal */ cursor: 'default',
            /**
             * @type {number|string}
             */ fontSize: '0.8em'
        },
        /**
         * Use HTML to render the contents of the tooltip instead of SVG. Using
         * HTML allows advanced formatting like tables and images in the
         * tooltip. It is also recommended for rtl languages as it works around
         * rtl bugs in early Firefox.
         *
         * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
         *         A table for value alignment
         * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
         *         Full HTML tooltip
         * @sample {highmaps} maps/tooltip/usehtml/
         *         Pure HTML tooltip
         *
         * @since     2.2
         */ useHTML: false
    },
    /**
     * Highchart by default puts a credits label in the lower right corner
     * of the chart. This can be changed using these options.
     */ credits: {
        /**
         * Credits for map source to be concatenated with conventional credit
         * text. By default this is a format string that collects copyright
         * information from the map if available.
         *
         * @see [mapTextFull](#credits.mapTextFull)
         * @see [text](#credits.text)
         *
         * @type      {string}
         * @default   \u00a9 <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>
         * @since     4.2.2
         * @product   highmaps
         * @apioption credits.mapText
         */ /**
         * Detailed credits for map source to be displayed on hover of credits
         * text. By default this is a format string that collects copyright
         * information from the map if available.
         *
         * @see [mapText](#credits.mapText)
         * @see [text](#credits.text)
         *
         * @type      {string}
         * @default   {geojson.copyright}
         * @since     4.2.2
         * @product   highmaps
         * @apioption credits.mapTextFull
         */ /**
         * Whether to show the credits text.
         *
         * @sample {highcharts} highcharts/credits/enabled-false/
         *         Credits disabled
         * @sample {highstock} stock/credits/enabled/
         *         Credits disabled
         * @sample {highmaps} maps/credits/enabled-false/
         *         Credits disabled
         */ enabled: true,
        /**
         * The URL for the credits label.
         *
         * @sample {highcharts} highcharts/credits/href/
         *         Custom URL and text
         * @sample {highmaps} maps/credits/customized/
         *         Custom URL and text
         */ href: 'https://www.highcharts.com?credits',
        /**
         * Position configuration for the credits label.
         *
         * @sample {highcharts} highcharts/credits/position-left/
         *         Left aligned
         * @sample {highcharts} highcharts/credits/position-left/
         *         Left aligned
         * @sample {highmaps} maps/credits/customized/
         *         Left aligned
         * @sample {highmaps} maps/credits/customized/
         *         Left aligned
         *
         * @type    {Highcharts.AlignObject}
         * @since   2.1
         */ position: {
            /** @internal */ align: 'right',
            /** @internal */ x: -10,
            /** @internal */ verticalAlign: 'bottom',
            /** @internal */ y: -5
        },
        /**
         * CSS styles for the credits label.
         *
         * @see In styled mode, credits styles can be set with the
         *      `.highcharts-credits` class.
         *
         * @type {Highcharts.CSSObject}
         */ style: {
            /** @internal */ cursor: 'pointer',
            /** @internal */ color: "#999999" /* Palette.neutralColor40 */ ,
            /**
             * @type {number|string}
             */ fontSize: '0.6em'
        },
        /**
         * The text for the credits label.
         *
         * @productdesc {highmaps}
         * If a map is loaded as GeoJSON, the text defaults to
         * `Highcharts @ {map-credits}`. Otherwise, it defaults to
         * `Highcharts.com`.
         *
         * @sample {highcharts} highcharts/credits/href/
         *         Custom URL and text
         * @sample {highmaps} maps/credits/customized/
         *         Custom URL and text
         */ text: 'Highcharts.com'
    }
};
const defaultTime = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](defaultOptions.time, defaultOptions.lang);
/**
 * Get the updated default options. Until 3.0.7, merely exposing defaultOptions
 * for outside modules wasn't enough because the setOptions method created a new
 * object.
 *
 * @function Highcharts.getOptions
 *
 * @return {Highcharts.Options}
 * Default options.
 */ function getOptions() {
    return defaultOptions;
}
/**
 * Merge the default options with custom options and return the new options
 * structure. Commonly used for defining reusable templates.
 *
 * @sample highcharts/members/setoptions Applying a global theme
 *
 * @function Highcharts.setOptions
 *
 * @param {Highcharts.Options} options
 * The new custom chart options.
 *
 * @return {Highcharts.Options}
 * Updated options.
 */ function setOptions(options) {
    fireEvent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], 'setOptions', {
        options
    });
    // Copy in the default options
    merge(true, defaultOptions, options);
    // Update the time object
    if (options.time) {
        defaultTime.update(defaultOptions.time);
    }
    if (options.lang && 'locale' in options.lang) {
        defaultTime.update({
            locale: options.lang.locale
        });
    }
    if (options.lang?.chartTitle) {
        defaultOptions.title = {
            ...defaultOptions.title,
            text: options.lang.chartTitle
        };
    }
    return defaultOptions;
}
/* *
 *
 *  Default Export
 *
 * */ const DefaultOptions = {
    defaultOptions,
    defaultTime,
    getOptions,
    setOptions
};
const __TURBOPACK__default__export__ = DefaultOptions;
/* *
 *
 *  API Declarations
 *
 * */ /**
 * @typedef {"plotBox"|"spacingBox"} Highcharts.ButtonRelativeToValue
 */ /**
 * Gets fired when a series is added to the chart after load time, using the
 * `addSeries` method. Returning `false` prevents the series from being added.
 *
 * @callback Highcharts.ChartAddSeriesCallbackFunction
 *
 * @param {Highcharts.Chart} this
 *        The chart on which the event occurred.
 *
 * @param {Highcharts.ChartAddSeriesEventObject} event
 *        The event that occurred.
 */ /**
 * Contains common event information. Through the `options` property you can
 * access the series options that were passed to the `addSeries` method.
 *
 * @interface Highcharts.ChartAddSeriesEventObject
 */ /**
* The series options that were passed to the `addSeries` method.
* @name Highcharts.ChartAddSeriesEventObject#options
* @type {Highcharts.SeriesOptionsType}
*/ /**
* Prevents the default behaviour of the event.
* @name Highcharts.ChartAddSeriesEventObject#preventDefault
* @type {Function}
*/ /**
* The event target.
* @name Highcharts.ChartAddSeriesEventObject#target
* @type {Highcharts.Chart}
*/ /**
* The event type.
* @name Highcharts.ChartAddSeriesEventObject#type
* @type {"addSeries"}
*/ /**
 * Gets fired when clicking on the plot background.
 *
 * @callback Highcharts.ChartClickCallbackFunction
 *
 * @param {Highcharts.Chart} this
 *        The chart on which the event occurred.
 *
 * @param {Highcharts.PointerEventObject} event
 *        The event that occurred.
 */ /**
 * Contains an axes of the clicked spot.
 *
 * @interface Highcharts.ChartClickEventAxisObject
 */ /**
* Axis at the clicked spot.
* @name Highcharts.ChartClickEventAxisObject#axis
* @type {Highcharts.Axis}
*/ /**
* Axis value at the clicked spot.
* @name Highcharts.ChartClickEventAxisObject#value
* @type {number}
*/ /**
 * Contains information about the clicked spot on the chart. Remember the unit
 * of a datetime axis is milliseconds since 1970-01-01 00:00:00.
 *
 * @interface Highcharts.ChartClickEventObject
 * @extends Highcharts.PointerEventObject
 */ /**
* Information about the x-axis on the clicked spot.
* @name Highcharts.ChartClickEventObject#xAxis
* @type {Array<Highcharts.ChartClickEventAxisObject>}
*/ /**
* Information about the y-axis on the clicked spot.
* @name Highcharts.ChartClickEventObject#yAxis
* @type {Array<Highcharts.ChartClickEventAxisObject>}
*/ /**
* Information about the z-axis on the clicked spot.
* @name Highcharts.ChartClickEventObject#zAxis
* @type {Array<Highcharts.ChartClickEventAxisObject>|undefined}
*/ /**
 * Gets fired when the chart is finished loading.
 *
 * @callback Highcharts.ChartLoadCallbackFunction
 *
 * @param {Highcharts.Chart} this
 *        The chart on which the event occurred.
 *
 * @param {global.Event} event
 *        The event that occurred.
 */ /**
 * Fires when the chart is redrawn, either after a call to `chart.redraw()` or
 * after an axis, series or point is modified with the `redraw` option set to
 * `true`.
 *
 * @callback Highcharts.ChartRedrawCallbackFunction
 *
 * @param {Highcharts.Chart} this
 *        The chart on which the event occurred.
 *
 * @param {global.Event} event
 *        The event that occurred.
 */ /**
 * Gets fired after initial load of the chart (directly after the `load` event),
 * and after each redraw (directly after the `redraw` event).
 *
 * @callback Highcharts.ChartRenderCallbackFunction
 *
 * @param {Highcharts.Chart} this
 *        The chart on which the event occurred.
 *
 * @param {global.Event} event
 *        The event that occurred.
 */ /**
 * Gets fired when an area of the chart has been selected. The default action
 * for the selection event is to zoom the chart to the selected area. It can be
 * prevented by calling `event.preventDefault()` or return false.
 *
 * @callback Highcharts.ChartSelectionCallbackFunction
 *
 * @param {Highcharts.Chart} this
 *        The chart on which the event occurred.
 *
 * @param {Highcharts.SelectEventObject} event
 *        Event informations
 *
 * @return {boolean|undefined}
 *         Return false to prevent the default action, usually zoom.
 */ ''; // Detach doclets above
}),
"[project]/node_modules/highcharts/es-modules/Core/Renderer/HTML/AST.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Globals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Utilities.js [app-client] (ecmascript)");
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
;
const { SVG_NS, win } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
;
const { attr, createElement, css, error, isFunction, isString, objectEach, splat } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
const { trustedTypes } = win;
/* *
 *
 *  Constants
 *
 * */ // Create the trusted type policy. This should not be exposed.
const trustedTypesPolicy = trustedTypes && isFunction(trustedTypes.createPolicy) && trustedTypes.createPolicy('highcharts', {
    createHTML: (s)=>s
});
const emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
/* *
 *
 *  Class
 *
 * */ /**
 * The AST class represents an abstract syntax tree of HTML or SVG content. It
 * can take HTML as an argument, parse it, optionally transform it to SVG, then
 * perform sanitation before inserting it into the DOM.
 *
 * @class
 * @name Highcharts.AST
 *
 * @param {string|Array<Highcharts.ASTNode>} source
 * Either an HTML string or an ASTNode list to populate the tree.
 */ class AST {
    /* *
     *
     *  Static Functions
     *
     * */ /**
     * Filter an object of SVG or HTML attributes against the allow list.
     *
     * @static
     *
     * @function Highcharts.AST#filterUserAttributes
     *
     * @param {Highcharts.SVGAttributes} attributes The attributes to filter
     *
     * @return {Highcharts.SVGAttributes}
     * The filtered attributes
     */ static filterUserAttributes(attributes) {
        objectEach(attributes, (val, key)=>{
            let valid = true;
            if (AST.allowedAttributes.indexOf(key) === -1) {
                valid = false;
            }
            if ([
                'background',
                'dynsrc',
                'href',
                'lowsrc',
                'src'
            ].indexOf(key) !== -1) {
                valid = isString(val) && AST.allowedReferences.some((ref)=>val.indexOf(ref) === 0);
            }
            if (!valid) {
                error(33, false, void 0, {
                    'Invalid attribute in config': `${key}`
                });
                delete attributes[key];
            }
            // #17753, < is not allowed in SVG attributes
            if (isString(val) && attributes[key]) {
                attributes[key] = val.replace(/</g, '&lt;');
            }
        });
        return attributes;
    }
    /**
     * Utility function to parse a style string to a CSSObject.
     *
     * @internal
     * @param {string} style
     * The style string to parse.
     * @return {Highcharts.CSSObject}
     * The parsed CSSObject.
     */ static parseStyle(style) {
        return style.split(';').reduce((styles, line)=>{
            const pair = line.split(':').map((s)=>s.trim()), key = pair.shift();
            if (key && pair.length) {
                styles[key.replace(/-([a-z])/g, (g)=>g[1].toUpperCase())] = pair.join(':'); // #17146
            }
            return styles;
        }, {});
    }
    /**
     * Utility function to set html content for an element by passing in a
     * markup string. The markup is safely parsed by the AST class to avoid
     * XSS vulnerabilities. This function should be used instead of setting
     * `innerHTML` in all cases where the content is not fully trusted.
     *
     * @static
     * @function Highcharts.AST#setElementHTML
     *
     * @param {SVGDOMElement|HTMLDOMElement} el
     * Node to set content of.
     *
     * @param {string} html
     * Markup string
     */ static setElementHTML(el, html) {
        el.innerHTML = AST.emptyHTML; // Clear previous
        if (html) {
            const ast = new AST(html);
            ast.addToDOM(el);
        }
    }
    /* *
     *
     *  Constructor
     *
     * */ // Construct an AST from HTML markup, or wrap an array of existing AST nodes
    constructor(source){
        this.nodes = typeof source === 'string' ? this.parseMarkup(source) : source;
    }
    /* *
     *
     *  Functions
     *
     * */ /**
     * Add the tree defined as a hierarchical JS structure to the DOM
     *
     * @function Highcharts.AST#addToDOM
     *
     * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} parent
     * The node where it should be added
     *
     * @return {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement}
     * The inserted node.
     */ addToDOM(parent) {
        /**
         * @internal
         * @param {Highcharts.ASTNode} subtree
         * HTML/SVG definition.
         * @param {Element} [subParent]
         * Parent node.
         * @return {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement}
         * The inserted node.
         */ function recurse(subtree, subParent) {
            let ret;
            splat(subtree).forEach(function(item) {
                const tagName = item.tagName;
                const textNode = item.textContent ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].doc.createTextNode(item.textContent) : void 0;
                // Whether to ignore the AST filtering totally, #15345
                const bypassHTMLFiltering = AST.bypassHTMLFiltering;
                let node;
                if (tagName) {
                    if (tagName === '#text') {
                        node = textNode;
                    } else if (AST.allowedTags.indexOf(tagName) !== -1 || bypassHTMLFiltering) {
                        const NS = tagName === 'svg' ? SVG_NS : subParent.namespaceURI || SVG_NS;
                        const element = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].doc.createElementNS(NS, tagName);
                        const attributes = item.attributes || {};
                        // Apply attributes from root of AST node, legacy from
                        // from before TextBuilder
                        objectEach(item, function(val, key) {
                            if (key !== 'tagName' && key !== 'attributes' && key !== 'children' && key !== 'style' && key !== 'textContent') {
                                attributes[key] = val;
                            }
                        });
                        attr(element, bypassHTMLFiltering ? attributes : AST.filterUserAttributes(attributes));
                        if (item.style) {
                            css(element, item.style);
                        }
                        // Add text content
                        if (textNode) {
                            element.appendChild(textNode);
                        }
                        // Recurse
                        recurse(item.children || [], element);
                        node = element;
                    } else {
                        error(33, false, void 0, {
                            'Invalid tagName in config': tagName
                        });
                    }
                }
                // Add to the tree
                if (node) {
                    subParent.appendChild(node);
                }
                ret = node;
            });
            // Return last node added (on top level it's the only one)
            return ret;
        }
        return recurse(this.nodes, parent);
    }
    /**
     * Parse HTML/SVG markup into AST Node objects. Used internally from the
     * constructor.
     *
     * @internal
     * @param {string} markup
     * The markup string.
     * @return {Array<Highcharts.ASTNode>}
     * The parsed nodes.
     */ parseMarkup(markup) {
        const nodes = [];
        markup = markup.trim()// The style attribute throws a warning when parsing when CSP is
        // enabled (#6884), so use an alias and pick it up below
        // Make all quotation marks parse correctly to DOM (#17627)
        .replace(/ style=(["'])/g, ' data-style=$1');
        let doc;
        try {
            doc = new DOMParser().parseFromString(trustedTypesPolicy ? trustedTypesPolicy.createHTML(markup) : markup, 'text/html');
        } catch  {
        // There are two cases where this fails:
        // 1. IE9 and PhantomJS, where the DOMParser only supports parsing
        //    XML
        // 2. Due to a Chromium issue where chart redraws are triggered by
        //    a `beforeprint` event (#16931),
        //    https://issues.chromium.org/issues/40222135
        }
        if (!doc) {
            const body = createElement('div');
            body.innerHTML = markup;
            doc = {
                body
            };
        }
        const appendChildNodes = (node, addTo)=>{
            const tagName = node.nodeName.toLowerCase();
            // Add allowed tags
            const astNode = {
                tagName
            };
            if (tagName === '#text') {
                astNode.textContent = node.textContent || '';
            }
            const parsedAttributes = node.attributes;
            // Add attributes
            if (parsedAttributes) {
                const attributes = {};
                [].forEach.call(parsedAttributes, (attrib)=>{
                    if (attrib.name === 'data-style') {
                        astNode.style = AST.parseStyle(attrib.value);
                    } else {
                        attributes[attrib.name] = attrib.value;
                    }
                });
                astNode.attributes = attributes;
            }
            // Handle children
            if (node.childNodes.length) {
                const children = [];
                [].forEach.call(node.childNodes, (childNode)=>{
                    appendChildNodes(childNode, children);
                });
                if (children.length) {
                    astNode.children = children;
                }
            }
            addTo.push(astNode);
        };
        [].forEach.call(doc.body.childNodes, (childNode)=>appendChildNodes(childNode, nodes));
        return nodes;
    }
}
/* *
 *
 *  Static Properties
 *
 * */ /**
 * The list of allowed SVG or HTML attributes, used for sanitizing
 * potentially harmful content from the chart configuration before adding to
 * the DOM.
 *
 * @see [Source code with default values](
 * https://github.com/highcharts/highcharts/blob/master/ts/Core/Renderer/HTML/AST.ts#:~:text=public%20static%20allowedAttributes)
 *
 * @example
 * // Allow a custom, trusted attribute
 * Highcharts.AST.allowedAttributes.push('data-value');
 *
 * @name Highcharts.AST.allowedAttributes
 * @type {Array<string>}
 */ AST.allowedAttributes = [
    'alt',
    'aria-controls',
    'aria-describedby',
    'aria-expanded',
    'aria-haspopup',
    'aria-hidden',
    'aria-label',
    'aria-labelledby',
    'aria-live',
    'aria-pressed',
    'aria-readonly',
    'aria-roledescription',
    'aria-selected',
    'class',
    'clip-path',
    'color',
    'colspan',
    'cx',
    'cy',
    'd',
    'disabled',
    'dx',
    'dy',
    'fill',
    'filterUnits',
    'flood-color',
    'flood-opacity',
    'height',
    'href',
    'id',
    'in',
    'in2',
    'markerHeight',
    'markerWidth',
    'offset',
    'opacity',
    'operator',
    'orient',
    'padding',
    'paddingLeft',
    'paddingRight',
    'patternUnits',
    'r',
    'radius',
    'refX',
    'refY',
    'result',
    'role',
    'rowspan',
    'scope',
    'slope',
    'src',
    'startOffset',
    'stdDeviation',
    'stroke-linecap',
    'stroke-width',
    'stroke',
    'style',
    'summary',
    'tabindex',
    'tableValues',
    'target',
    'text-align',
    'text-anchor',
    'textAnchor',
    'textLength',
    'title',
    'type',
    'valign',
    'width',
    'x',
    'x1',
    'x2',
    'xlink:href',
    'y',
    'y1',
    'y2',
    'zIndex'
];
/**
 * The list of allowed references for referring attributes like `href` and
 * `src`. Attribute values will only be allowed if they start with one of
 * these strings.
 *
 * @see [Source code with default values](
 * https://github.com/highcharts/highcharts/blob/master/ts/Core/Renderer/HTML/AST.ts#:~:text=public%20static%20allowedReferences)
 *
 * @example
 * // Allow tel:
 * Highcharts.AST.allowedReferences.push('tel:');
 *
 * @name    Highcharts.AST.allowedReferences
 * @type    {Array<string>}
 */ AST.allowedReferences = [
    'https://',
    'http://',
    'mailto:',
    '/',
    '../',
    './',
    '#'
];
/**
 * The list of allowed SVG or HTML tags, used for sanitizing potentially
 * harmful content from the chart configuration before adding to the DOM.
 *
 * @see [Source code with default values](
 * https://github.com/highcharts/highcharts/blob/master/ts/Core/Renderer/HTML/AST.ts#:~:text=public%20static%20allowedTags)
 *
 * @example
 * // Allow a custom, trusted tag
 * Highcharts.AST.allowedTags.push('blink'); // ;)
 *
 * @name    Highcharts.AST.allowedTags
 * @type    {Array<string>}
 */ AST.allowedTags = [
    '#text',
    'a',
    'abbr',
    'b',
    'br',
    'button',
    'caption',
    'circle',
    'clipPath',
    'code',
    'dd',
    'defs',
    'div',
    'dl',
    'dt',
    'em',
    'feComponentTransfer',
    'feComposite',
    'feDropShadow',
    'feFlood',
    'feFuncA',
    'feFuncB',
    'feFuncG',
    'feFuncR',
    'feGaussianBlur',
    'feMerge',
    'feMergeNode',
    'feMorphology',
    'feOffset',
    'filter',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'hr',
    'i',
    'img',
    'li',
    'linearGradient',
    'marker',
    'ol',
    'p',
    'path',
    'pattern',
    'pre',
    'rect',
    'small',
    'span',
    'stop',
    'strong',
    'style',
    'sub',
    'sup',
    'svg',
    'table',
    'tbody',
    'td',
    'text',
    'textPath',
    'th',
    'thead',
    'title',
    'tr',
    'tspan',
    'u',
    'ul'
];
/** @internal */ AST.emptyHTML = emptyHTML;
/**
 * Allow all custom SVG and HTML attributes, references and tags (together
 * with potentially harmful ones) to be added to the DOM from the chart
 * configuration. In other words, disable the allow-listing which is the
 * primary functionality of the AST.
 *
 * WARNING: Setting this property to `true` while allowing untrusted user
 * data in the chart configuration will expose your application to XSS
 * security risks!
 *
 * Note that in case you want to allow a known set of tags or attributes,
 * you should allow-list them instead of disabling the filtering totally.
 * See [allowedAttributes](Highcharts.AST#.allowedAttributes),
 * [allowedReferences](Highcharts.AST#.allowedReferences) and
 * [allowedTags](Highcharts.AST#.allowedTags). The `bypassHTMLFiltering`
 * setting is intended only for those cases where allow-listing is not
 * practical, and the chart configuration already comes from a secure
 * source.
 *
 * @example
 * // Allow all custom attributes, references and tags (disable DOM XSS
 * // filtering)
 * Highcharts.AST.bypassHTMLFiltering = true;
 *
 * @name Highcharts.AST.bypassHTMLFiltering
 * @static
 */ AST.bypassHTMLFiltering = false;
const __TURBOPACK__default__export__ = AST;
/* *
 *
 *  API Declarations
 *
 * */ /**
 * Serialized form of an SVG/HTML definition, including children.
 *
 * @interface Highcharts.ASTNode
 */ /**
* @name Highcharts.ASTNode#attributes
* @type {Highcharts.SVGAttributes|undefined}
*/ /**
* @name Highcharts.ASTNode#children
* @type {Array<Highcharts.ASTNode>|undefined}
*/ /**
* @name Highcharts.ASTNode#tagName
* @type {string|undefined}
*/ /**
* @name Highcharts.ASTNode#textContent
* @type {string|undefined}
*/ ''; // Keeps doclets above in file
}),
"[project]/node_modules/highcharts/es-modules/Core/Color/Color.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Globals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Utilities.js [app-client] (ecmascript)");
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
;
const { win } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
;
const { isNumber, isString, merge, pInt, defined } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
/* *
 *
 *  Helpers
 *
 * */ const colorMix = (color1, color2, weight)=>`color-mix(in srgb,${color1},${color2} ${weight * 100}%)`;
const isStringColor = (color)=>isString(color) && !!color && color !== 'none';
/* *
 *
 *  Class
 *
 * */ /* eslint-disable valid-jsdoc */ /**
 * Handle color operations. Some object methods are chainable.
 *
 * @class
 * @name Highcharts.Color
 *
 * @param {Highcharts.ColorType} input
 * The input color.
 */ class Color {
    /* *
     *
     *  Static Functions
     *
     * */ /**
     * Creates a color instance out of a color string or object.
     *
     * @function Highcharts.Color.parse
     *
     * @param {Highcharts.ColorType} [input]
     * The input color.
     *
     * @return {Highcharts.Color}
     * Color instance.
     */ static parse(input) {
        return input ? new Color(input) : Color.None;
    }
    /* *
     *
     *  Constructor
     *
     * */ constructor(input){
        /**
         * The RGBA color components, if the color is a solid color.
         * @name Highcharts.Color#rgba
         * @type {Highcharts.RGBA}
         */ this.rgba = [
            NaN,
            NaN,
            NaN,
            NaN
        ];
        this.input = input;
        const GlobalColor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Color;
        // Backwards compatibility, allow class overwrite
        if (GlobalColor && GlobalColor !== Color) {
            return new GlobalColor(input);
        }
        let result, rgba, i, parser;
        // Gradients
        if (typeof input === 'object' && typeof input.stops !== 'undefined') {
            this.stops = input.stops.map((stop)=>new Color(stop[1]));
        // Solid colors
        } else if (typeof input === 'string') {
            this.input = input = Color.names[input.toLowerCase()] || input;
            i = Color.parsers.length;
            while(i-- && !rgba){
                parser = Color.parsers[i];
                result = parser.regex.exec(input);
                if (result) {
                    rgba = parser.parse(result);
                }
            }
        }
        if (rgba) {
            this.rgba = rgba;
        }
    }
    /* *
     *
     *  Functions
     *
     * */ /**
     * Return the color or gradient stops in the specified format
     *
     * @function Highcharts.Color#get
     *
     * @param {string} [format]
     * Possible values are 'a', 'rgb', 'rgba' (default).
     *
     * @return {Highcharts.ColorType}
     * This color as a string or gradient stops.
     */ get(format) {
        const input = this.input, rgba = this.rgba;
        if (this.output) {
            return this.output;
        }
        if (typeof input === 'object' && typeof this.stops !== 'undefined') {
            const ret = merge(input);
            ret.stops = [].slice.call(ret.stops);
            this.stops.forEach((stop, i)=>{
                ret.stops[i] = [
                    ret.stops[i][0],
                    stop.get(format)
                ];
            });
            return ret;
        }
        // It's NaN if gradient colors on a column chart
        if (rgba && isNumber(rgba[0])) {
            if (format === 'rgb' || !format && rgba[3] === 1) {
                return 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
            }
            if (format === 'a') {
                return `${rgba[3]}`;
            }
            return 'rgba(' + rgba.join(',') + ')';
        }
        return input;
    }
    /**
     * Brighten the color instance.
     *
     * @function Highcharts.Color#brighten
     *
     * @param {number} alpha
     * The alpha value.
     *
     * @return {Highcharts.Color}
     * This color with modifications.
     */ brighten(alpha) {
        const rgba = this.rgba;
        if (this.stops) {
            this.stops.forEach(function(stop) {
                stop.brighten(alpha);
            });
        } else if (isNumber(alpha) && alpha !== 0) {
            if (isNumber(rgba[0])) {
                for(let i = 0; i < 3; i++){
                    rgba[i] += pInt(alpha * 255);
                    if (rgba[i] < 0) {
                        rgba[i] = 0;
                    }
                    if (rgba[i] > 255) {
                        rgba[i] = 255;
                    }
                }
            } else if (Color.useColorMix && isStringColor(this.input)) {
                this.output = colorMix(this.input, alpha > 0 ? 'white' : 'black', Math.abs(alpha));
            }
        }
        return this;
    }
    /**
     * Set the color's opacity to a given alpha value.
     *
     * @function Highcharts.Color#setOpacity
     *
     * @param {number} alpha
     *        Opacity between 0 and 1.
     *
     * @return {Highcharts.Color}
     *         Color with modifications.
     */ setOpacity(alpha) {
        this.rgba[3] = alpha;
        return this;
    }
    /**
     * Return an intermediate color between two colors.
     *
     * @function Highcharts.Color#tweenTo
     *
     * @param {Highcharts.Color} to
     * The color object to tween to.
     *
     * @param {number} pos
     * The intermediate position, where 0 is the from color (current color
     * item), and 1 is the `to` color.
     *
     * @return {Highcharts.ColorType}
     * The intermediate color in rgba notation, or unsupported type.
     */ tweenTo(to, pos) {
        const fromRgba = this.rgba, toRgba = to.rgba;
        // Unsupported color, return to-color (#3920, #7034)
        if (!isNumber(fromRgba[0]) || !isNumber(toRgba[0])) {
            if (Color.useColorMix && isStringColor(this.input) && isStringColor(to.input) && pos < 0.99) {
                return colorMix(this.input, to.input, pos);
            }
            return to.input || 'none';
        }
        // Check for has alpha, because rgba colors perform worse due to
        // lack of support in WebKit.
        const hasAlpha = toRgba[3] !== 1 || fromRgba[3] !== 1, channel = (to, i)=>to + (fromRgba[i] - to) * (1 - pos), rgba = toRgba.slice(0, 3).map(channel).map(Math.round);
        if (hasAlpha) {
            rgba.push(channel(toRgba[3], 3));
        }
        return (hasAlpha ? 'rgba(' : 'rgb(') + rgba.join(',') + ')';
    }
}
/* *
 *
 *  Static Properties
 *
 * */ /**
 * Collection of named colors. Can be extended from the outside by adding
 * colors to Highcharts.Color.names.
 * @internal
 */ Color.names = {
    white: '#ffffff',
    black: '#000000'
};
/**
 * Collection of parsers. This can be extended from the outside by pushing
 * parsers to `Color.parsers`.
 * @internal
 */ Color.parsers = [
    {
        // RGBA color
        // eslint-disable-next-line max-len
        regex: /rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?(?:\.\d+)?)\s*\)/,
        parse: function(result) {
            return [
                pInt(result[1]),
                pInt(result[2]),
                pInt(result[3]),
                parseFloat(result[4], 10)
            ];
        }
    },
    {
        // RGB color
        regex: /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/,
        parse: function(result) {
            return [
                pInt(result[1]),
                pInt(result[2]),
                pInt(result[3]),
                1
            ];
        }
    },
    {
        // RGBA 3 & 4 digit hex color, e.g. #F0F, #F0FA
        regex: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i,
        parse: function(result) {
            // #abcd => #aabbccdd, hence result + result.
            return [
                pInt(result[1] + result[1], 16),
                pInt(result[2] + result[2], 16),
                pInt(result[3] + result[3], 16),
                !defined(result[4]) ? 1 : pInt(result[4] + result[4], 16) / 255
            ];
        }
    },
    {
        // RGBA 6 & 8 digit hex color, e.g. #FFCC00, #FFCC00FF
        regex: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i,
        parse: function(result) {
            return [
                pInt(result[1], 16),
                pInt(result[2], 16),
                pInt(result[3], 16),
                !defined(result[4]) ? 1 : pInt(result[4], 16) / 255
            ];
        }
    }
];
/**
 * Whether to use CSS `color-mix` for color handling (brightening,
 * tweening). This can be disabled from the outside.
 * @internal
 */ Color.useColorMix = win.CSS?.supports('color', 'color-mix(in srgb,red,blue 9%)');
/**
 * A static Color instance representing no color.
 * @name Highcharts.Color.None
 * @type {Highcharts.Color}
 * @internal
 */ Color.None = new Color(''); // Must be last static for init
const __TURBOPACK__default__export__ = Color;
/* *
 *
 *  API Declarations
 *
 * */ /**
 * A valid color to be parsed and handled by Highcharts.
 *
 * @typedef {string} Highcharts.ColorString
 */ /**
 * A valid color type than can be parsed and handled by Highcharts. It can be a
 * color string, a gradient object, or a pattern object.
 *
 * @typedef {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject} Highcharts.ColorType
 */ /**
 * Gradient options instead of a solid color.
 *
 * @example
 * // Linear gradient used as a color option
 * color: {
 *     linearGradient: { x1: 0, x2: 0, y1: 0, y2: 1 },
 *     stops: [
 *         [0, '#003399'], // start
 *         [0.5, '#ffffff'], // middle
 *         [1, '#3366AA'] // end
 *     ]
 * }
 *
 * @interface Highcharts.GradientColorObject
 */ /**
* Holds an object that defines the start position and the end position relative
* to the shape.
* @name Highcharts.GradientColorObject#linearGradient
* @type {Highcharts.LinearGradientColorObject|undefined}
*/ /**
* Holds an object that defines the center position and the radius.
* @name Highcharts.GradientColorObject#radialGradient
* @type {Highcharts.RadialGradientColorObject|undefined}
*/ /**
* The first item in each tuple is the position in the gradient, where 0 is the
* start of the gradient and 1 is the end of the gradient. Multiple stops can be
* applied. The second item is the color for each stop. This color can also be
* given in the rgba format.
* @name Highcharts.GradientColorObject#stops
* @type {Array<Highcharts.GradientColorStopObject>}
*/ /**
 * Color stop tuple.
 *
 * @see Highcharts.GradientColorObject
 *
 * @interface Highcharts.GradientColorStopObject
 */ /**
* @name Highcharts.GradientColorStopObject#0
* @type {number}
*/ /**
* @name Highcharts.GradientColorStopObject#1
* @type {Highcharts.ColorString}
*/ /**
* @name Highcharts.GradientColorStopObject#color
* @type {Highcharts.Color|undefined}
*/ /**
 * Defines the start position and the end position for a gradient relative
 * to the shape. Start position (x1, y1) and end position (x2, y2) are relative
 * to the shape, where 0 means top/left and 1 is bottom/right.
 *
 * @interface Highcharts.LinearGradientColorObject
 */ /**
* Start horizontal position of the gradient. Float ranges 0-1.
* @name Highcharts.LinearGradientColorObject#x1
* @type {number}
*/ /**
* End horizontal position of the gradient. Float ranges 0-1.
* @name Highcharts.LinearGradientColorObject#x2
* @type {number}
*/ /**
* Start vertical position of the gradient. Float ranges 0-1.
* @name Highcharts.LinearGradientColorObject#y1
* @type {number}
*/ /**
* End vertical position of the gradient. Float ranges 0-1.
* @name Highcharts.LinearGradientColorObject#y2
* @type {number}
*/ /**
 * Defines the center position and the radius for a gradient.
 *
 * @interface Highcharts.RadialGradientColorObject
 */ /**
* Center horizontal position relative to the shape. Float ranges 0-1.
* @name Highcharts.RadialGradientColorObject#cx
* @type {number}
*/ /**
* Center vertical position relative to the shape. Float ranges 0-1.
* @name Highcharts.RadialGradientColorObject#cy
* @type {number}
*/ /**
* Radius relative to the shape. Float ranges 0-1.
* @name Highcharts.RadialGradientColorObject#r
* @type {number}
*/ /**
 * @interface Highcharts.RGBA
 * @extends Array<number>
 */ /**
* @name Highcharts.RGBA#length
* @type {4}
*/ /**
 * Creates a color instance out of a color string.
 *
 * @function Highcharts.color
 *
 * @param {Highcharts.ColorType} input
 *        The input color.
 *
 * @return {Highcharts.Color}
 *         Color instance
 */ ''; // Detach doclets above
}),
"[project]/node_modules/highcharts/es-modules/Core/Animation/Fx.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Color$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Color/Color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Globals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Utilities.js [app-client] (ecmascript)");
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
;
const { parse: color } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Color$2f$Color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
;
const { win } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
;
const { isNumber, objectEach } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
/* eslint-disable no-invalid-this, valid-jsdoc */ /* *
 *
 *  Class
 *
 * */ /**
 * An animator object used internally. One instance applies to one property
 * (attribute or style prop) on one element. Animation is always initiated
 * through {@link SVGElement#animate}.
 *
 * @example
 * let rect = renderer.rect(0, 0, 10, 10).add();
 * rect.animate({ width: 100 });
 *
 * @internal
 * @class
 * @name Highcharts.Fx
 *
 * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} elem
 * The element to animate.
 *
 * @param {Partial<Highcharts.AnimationOptionsObject>} options
 * Animation options.
 *
 * @param {string} prop
 * The single attribute or CSS property to animate.
 */ class Fx {
    /* *
     *
     *  Constructors
     *
     * */ constructor(elem, options, prop){
        /**
         * Current position of the animation, a value between 0 and 1.
         * @internal
         */ this.pos = NaN;
        this.options = options;
        this.elem = elem;
        this.prop = prop;
    }
    /* *
     *
     *  Functions
     *
     * */ /**
     * Set the current step of a path definition on SVGElement.
     *
     * @function Highcharts.Fx#dSetter
     *
     */ dSetter() {
        const paths = this.paths, start = paths?.[0], end = paths?.[1], now = this.now || 0;
        let path = [];
        // Land on the final path without adjustment points appended in the ends
        if (now === 1 || !start || !end) {
            path = this.toD || [];
        } else if (start.length === end.length && now < 1) {
            for(let i = 0; i < end.length; i++){
                // Tween between the start segment and the end segment. Start
                // with a copy of the end segment and tween the appropriate
                // numerics
                const startSeg = start[i];
                const endSeg = end[i];
                const tweenSeg = [];
                for(let j = 0; j < endSeg.length; j++){
                    const startItem = startSeg[j];
                    const endItem = endSeg[j];
                    // Tween numbers
                    if (isNumber(startItem) && isNumber(endItem) && // Arc boolean flags
                    !(endSeg[0] === 'A' && (j === 4 || j === 5))) {
                        tweenSeg[j] = startItem + now * (endItem - startItem);
                    // Strings, take directly from the end segment
                    } else {
                        tweenSeg[j] = endItem;
                    }
                }
                path.push(tweenSeg);
            }
        // If animation is finished or length not matching, land on right value
        } else {
            path = end;
        }
        this.elem.attr('d', path, void 0, true);
    }
    /**
     * Update the element with the current animation step.
     *
     * @function Highcharts.Fx#update
     *
     */ update() {
        const elem = this.elem, prop = this.prop, now = this.now, step = this.options.step;
        // Animation setter defined from outside
        if (this[prop + 'Setter']) {
            this[prop + 'Setter']();
        // Other animations on SVGElement
        } else if (elem.attr) {
            if (elem.element) {
                elem.attr(prop, now, null, true);
            }
        // HTML styles, raw HTML content like container size
        } else {
            elem.style[prop] = now + this.unit;
        }
        if (step) {
            step.call(elem, now, this);
        }
    }
    /**
     * Run an animation.
     *
     * @function Highcharts.Fx#run
     *
     * @param {number} from
     *        The current value, value to start from.
     *
     * @param {number} to
     *        The end value, value to land on.
     *
     * @param {string} unit
     *        The property unit, for example `px`.
     *
     */ run(from, to, unit) {
        const self = this, options = self.options, timer = function(gotoEnd) {
            return timer.stopped ? false : self.step(gotoEnd);
        }, requestAnimationFrame = win.requestAnimationFrame || function(step) {
            setTimeout(step, 13);
        }, step = function() {
            for(let i = 0; i < Fx.timers.length; i++){
                if (!Fx.timers[i]()) {
                    Fx.timers.splice(i--, 1);
                }
            }
            if (Fx.timers.length) {
                requestAnimationFrame(step);
            }
        };
        if (from === to && !this.elem['forceAnimate:' + this.prop]) {
            delete options.curAnim[this.prop];
            if (options.complete && Object.keys(options.curAnim).length === 0) {
                options.complete.call(this.elem);
            }
        } else {
            this.startTime = +new Date();
            this.start = from;
            this.end = to;
            this.unit = unit;
            this.now = this.start;
            this.pos = 0;
            timer.elem = this.elem;
            timer.prop = this.prop;
            if (timer() && Fx.timers.push(timer) === 1) {
                requestAnimationFrame(step);
            }
        }
    }
    /**
     * Run a single step in the animation.
     *
     * @function Highcharts.Fx#step
     *
     * @param {boolean} [gotoEnd]
     *        Whether to go to the endpoint of the animation after abort.
     *
     * @return {boolean}
     *         Returns `true` if animation continues.
     */ step(gotoEnd) {
        const t = +new Date(), options = this.options, elem = this.elem, complete = options.complete, duration = options.duration, curAnim = options.curAnim;
        let ret, done;
        if (!!elem.attr && !elem.element) {
            ret = false;
        } else if (gotoEnd || t >= duration + this.startTime) {
            this.now = this.end;
            this.pos = 1;
            this.update();
            curAnim[this.prop] = true;
            done = true;
            objectEach(curAnim, function(val) {
                if (val !== true) {
                    done = false;
                }
            });
            if (done && complete) {
                complete.call(elem);
            }
            ret = false;
        } else {
            this.pos = options.easing((t - this.startTime) / duration);
            this.now = this.start + (this.end - this.start) * this.pos;
            this.update();
            ret = true;
        }
        return ret;
    }
    /**
     * Prepare start and end values so that the path can be animated one to one.
     *
     * @function Highcharts.Fx#initPath
     *
     * @param {Highcharts.SVGElement} elem
     *        The SVGElement item.
     *
     * @param {Highcharts.SVGPathArray|undefined} fromD
     *        Starting path definition.
     *
     * @param {Highcharts.SVGPathArray} toD
     *        Ending path definition.
     *
     * @return {Array<Highcharts.SVGPathArray,Highcharts.SVGPathArray>}
     *         An array containing start and end paths in array form so that
     *         they can be animated in parallel.
     */ initPath(elem, fromD, toD) {
        const startX = elem.startX, endX = elem.endX, end = toD.slice(), isArea = elem.isArea, positionFactor = isArea ? 2 : 1, disableAnimation = fromD && toD.length > fromD.length && toD.hasStackedCliffs; // #16925
        let shift, fullLength, i, reverse, start = fromD?.slice(); // Copy
        if (!start || disableAnimation) {
            return [
                end,
                end
            ];
        }
        /**
         * If shifting points, prepend a dummy point to the end path.
         * @internal
         */ function prepend(arr, other) {
            while(arr.length < fullLength){
                // Move to, line to or curve to?
                const moveSegment = arr[0], otherSegment = other[fullLength - arr.length];
                if (otherSegment && moveSegment[0] === 'M') {
                    if (otherSegment[0] === 'C') {
                        arr[0] = [
                            'C',
                            moveSegment[1],
                            moveSegment[2],
                            moveSegment[1],
                            moveSegment[2],
                            moveSegment[1],
                            moveSegment[2]
                        ];
                    } else {
                        arr[0] = [
                            'L',
                            moveSegment[1],
                            moveSegment[2]
                        ];
                    }
                }
                // Prepend a copy of the first point
                arr.unshift(moveSegment);
                // For areas, the bottom path goes back again to the left, so we
                // need to append a copy of the last point.
                if (isArea) {
                    const z = arr.pop();
                    arr.push(arr[arr.length - 1], z); // Append point and the Z
                }
            }
        }
        /**
         * Copy and append last point until the length matches the end length.
         * @internal
         */ function append(arr) {
            while(arr.length < fullLength){
                // Pull out the slice that is going to be appended or inserted.
                // In a line graph, the positionFactor is 1, and the last point
                // is sliced out. In an area graph, the positionFactor is 2,
                // causing the middle two points to be sliced out, since an area
                // path starts at left, follows the upper path then turns and
                // follows the bottom back.
                const segmentToAdd = arr[Math.floor(arr.length / positionFactor) - 1].slice();
                // Disable the first control point of curve segments
                if (segmentToAdd[0] === 'C') {
                    segmentToAdd[1] = segmentToAdd[5];
                    segmentToAdd[2] = segmentToAdd[6];
                }
                if (!isArea) {
                    arr.push(segmentToAdd);
                } else {
                    const lowerSegmentToAdd = arr[Math.floor(arr.length / positionFactor)].slice();
                    arr.splice(arr.length / 2, 0, segmentToAdd, lowerSegmentToAdd);
                }
            }
        }
        // For sideways animation, find out how much we need to shift to get the
        // start path Xs to match the end path Xs.
        if (startX && endX && endX.length) {
            for(i = 0; i < startX.length; i++){
                // Moving left, new points coming in on right
                if (startX[i] === endX[0]) {
                    shift = i;
                    break;
                // Moving right
                } else if (startX[0] === endX[endX.length - startX.length + i]) {
                    shift = i;
                    reverse = true;
                    break;
                // Fixed from the right side, "scaling" left
                } else if (startX[startX.length - 1] === endX[endX.length - startX.length + i]) {
                    shift = startX.length - i;
                    break;
                }
            }
            if (typeof shift === 'undefined') {
                start = [];
            }
        }
        if (start.length && isNumber(shift)) {
            // The common target length for the start and end array, where both
            // arrays are padded in opposite ends
            fullLength = end.length + shift * positionFactor;
            if (!reverse) {
                prepend(end, start);
                append(start);
            } else {
                prepend(start, end);
                append(end);
            }
        }
        return [
            start,
            end
        ];
    }
    /**
     * Handle animation of the color attributes directly.
     *
     * @function Highcharts.Fx#fillSetter
     *
     */ fillSetter() {
        Fx.prototype.strokeSetter.apply(this, arguments);
    }
    /**
     * Handle animation of the color attributes directly.
     *
     * @function Highcharts.Fx#strokeSetter
     *
     */ strokeSetter() {
        this.elem.attr(this.prop, color(this.start).tweenTo(color(this.end), this.pos), void 0, true);
    }
}
/* *
 *
 *  Static Properties
 *
 * */ /** @internal */ Fx.timers = [];
const __TURBOPACK__default__export__ = Fx;
}),
"[project]/node_modules/highcharts/es-modules/Core/Animation/AnimationUtilities.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Animation$2f$Fx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Animation/Fx.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Utilities.js [app-client] (ecmascript)");
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
;
;
const { defined, getStyle, isArray, isNumber, isObject, merge, objectEach, pick } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
/* *
 *
 *  Functions
 *
 * */ /**
 * Set the global animation to either a given value, or fall back to the given
 * chart's animation option.
 *
 * @function Highcharts.setAnimation
 *
 * @param {boolean|Partial<Highcharts.AnimationOptionsObject>|undefined} animation
 *        The animation object.
 *
 * @param {Highcharts.Chart} chart
 *        The chart instance.
 *
 * @todo
 * This function always relates to a chart, and sets a property on the renderer,
 * so it should be moved to the SVGRenderer.
 */ function setAnimation(animation, chart) {
    chart.renderer.globalAnimation = pick(animation, chart.options.chart.animation, true);
}
/**
 * Get the animation in object form, where a disabled animation is always
 * returned as `{ duration: 0 }`.
 *
 * @function Highcharts.animObject
 *
 * @param {boolean|Highcharts.AnimationOptionsObject} [animation=0]
 *        An animation setting. Can be an object with duration, complete and
 *        easing properties, or a boolean to enable or disable.
 *
 * @return {Highcharts.AnimationOptionsObject}
 *         An object with at least a duration property.
 */ function animObject(animation) {
    return isObject(animation) ? merge({
        duration: 500,
        defer: 0
    }, animation) : {
        duration: animation ? 500 : 0,
        defer: 0
    };
}
/**
 * Get the defer as a number value from series animation options.
 *
 * @function Highcharts.getDeferredAnimation
 *
 * @param {Highcharts.Chart} chart
 *        The chart instance.
 *
 * @param {boolean|Highcharts.AnimationOptionsObject} animation
 *        An animation setting. Can be an object with duration, complete and
 *        easing properties, or a boolean to enable or disable.
 *
 * @param {Highcharts.Series} [series]
 *        Series to defer animation.
 *
 * @return {number}
 *        The numeric value.
 */ function getDeferredAnimation(chart, animation, series) {
    const labelAnimation = animObject(animation), s = series ? [
        series
    ] : chart.series;
    let defer = 0, duration = 0;
    s.forEach((series)=>{
        const seriesAnim = animObject(series.options.animation);
        defer = isObject(animation) && defined(animation.defer) ? labelAnimation.defer : Math.max(defer, seriesAnim.duration + seriesAnim.defer);
        duration = Math.min(labelAnimation.duration, seriesAnim.duration);
    });
    // Disable defer for exporting
    if (chart.renderer.forExport) {
        defer = 0;
    }
    const anim = {
        defer: Math.max(0, defer - duration),
        duration: Math.min(defer, duration)
    };
    return anim;
}
/**
 * The global animate method, which uses Fx to create individual animators.
 *
 * @function Highcharts.animate
 *
 * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} el
 *        The element to animate.
 *
 * @param {Highcharts.CSSObject|Highcharts.SVGAttributes} params
 *        An object containing key-value pairs of the properties to animate.
 *        Supports numeric as pixel-based CSS properties for HTML objects and
 *        attributes for SVGElements.
 *
 * @param {Partial<Highcharts.AnimationOptionsObject>} [opt]
 *        Animation options.
 *
 * @return {void}
 */ function animate(el, params, opt) {
    let start, unit = '', end, fx, args;
    if (!isObject(opt)) {
        args = arguments;
        opt = {
            duration: args[2],
            easing: args[3],
            complete: args[4]
        };
    }
    if (!isNumber(opt.duration)) {
        opt.duration = 400;
    }
    opt.easing = typeof opt.easing === 'function' ? opt.easing : Math[opt.easing] || Math.easeInOutSine;
    opt.curAnim = merge(params);
    objectEach(params, function(val, prop) {
        // Stop current running animation of this property
        stop(el, prop);
        fx = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Animation$2f$Fx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](el, opt, prop);
        end = void 0;
        if (prop === 'd' && isArray(params.d)) {
            fx.paths = fx.initPath(el, el.pathArray, params.d);
            fx.toD = params.d;
            start = 0;
            end = 1;
        } else if (el.attr) {
            start = el.attr(prop);
        } else {
            start = parseFloat(getStyle(el, prop)) || 0;
            if (prop !== 'opacity') {
                unit = 'px';
            }
        }
        if (!end) {
            end = val;
        }
        if (typeof end === 'string' && end.match('px')) {
            end = end.replace(/px/g, ''); // #4351
        }
        fx.run(start, end, unit);
    });
}
/**
 * Stop running animation.
 *
 * @function Highcharts.stop
 *
 * @param {Highcharts.SVGElement} el
 *        The SVGElement to stop animation on.
 *
 * @param {string} [prop]
 *        The property to stop animating. If given, the stop method will stop a
 *        single property from animating, while others continue.
 *
 * @return {void}
 *
 * @todo
 * A possible extension to this would be to stop a single property, when
 * we want to continue animating others. Then assign the prop to the timer
 * in the Fx.run method, and check for the prop here. This would be an
 * improvement in all cases where we stop the animation from .attr. Instead of
 * stopping everything, we can just stop the actual attributes we're setting.
 */ function stop(el, prop) {
    let i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Animation$2f$Fx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].timers.length;
    // Remove timers related to this element (#4519)
    while(i--){
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Animation$2f$Fx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].timers[i].elem === el && (!prop || prop === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Animation$2f$Fx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].timers[i].prop)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Animation$2f$Fx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].timers[i].stopped = true; // #4667
        }
    }
}
const animationExports = {
    animate,
    animObject,
    getDeferredAnimation,
    setAnimation,
    stop
};
const __TURBOPACK__default__export__ = animationExports;
/* *
 *
 *  API Options
 *
 * */ /**
 * An animation configuration. Animation configurations can also be defined as
 * booleans, where `false` turns off animation and `true` defaults to a duration
 * of 500ms and defer of 0ms.
 *
 * @interface Highcharts.AnimationOptionsObject
 */ /**
* A callback function to execute when the animation finishes.
* @name Highcharts.AnimationOptionsObject#complete
* @type {Function|undefined}
*/ /**
* The animation defer in milliseconds.
* @name Highcharts.AnimationOptionsObject#defer
* @type {number|undefined}
*/ /**
* The animation duration in milliseconds.
* @name Highcharts.AnimationOptionsObject#duration
* @type {number|undefined}
*/ /**
* The name of an easing function as defined on the `Math` object.
* @name Highcharts.AnimationOptionsObject#easing
* @type {string|Function|undefined}
*/ /**
* A callback function to execute on each step of each attribute or CSS property
* that's being animated. The first argument contains information about the
* animation and progress.
* @name Highcharts.AnimationOptionsObject#step
* @type {Function|undefined}
*/ ''; // Keeps doclets in JS file
}),
"[project]/node_modules/highcharts/es-modules/Core/Templating.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Globals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Utilities.js [app-client] (ecmascript)");
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
;
const { defaultOptions, defaultTime } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
;
const { pageLang } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
;
const { extend, getNestedProperty, isArray, isNumber, isObject, isString, pick, ucfirst } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
/** @internal */ const helpers = {
    // Built-in helpers
    add: (a, b)=>a + b,
    divide: (a, b)=>b !== 0 ? a / b : '',
    // eslint-disable-next-line eqeqeq
    eq: (a, b)=>a == b,
    each: function(arr) {
        const match = arguments[arguments.length - 1];
        return isArray(arr) ? arr.map((item, i)=>format(match.body, extend(isObject(item) ? item : {
                '@this': item
            }, {
                '@index': i,
                '@first': i === 0,
                '@last': i === arr.length - 1
            }))).join('') : false;
    },
    ge: (a, b)=>a >= b,
    gt: (a, b)=>a > b,
    'if': (condition)=>!!condition,
    le: (a, b)=>a <= b,
    lt: (a, b)=>a < b,
    multiply: (a, b)=>a * b,
    // eslint-disable-next-line eqeqeq
    ne: (a, b)=>a != b,
    subtract: (a, b)=>a - b,
    ucfirst,
    unless: (condition)=>!condition
};
const numberFormatCache = {};
/* *
 *
 *  Functions
 *
 * */ /**
 * Internal convenience function.
 * @internal
 */ const isQuotedString = (str)=>/^["'].+["']$/.test(str);
/**
 * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970) into a
 * human readable date string. The format is a subset of the formats for PHP's
 * [strftime](https://www.php.net/manual/en/function.strftime.php) function.
 * Additional formats can be given in the {@link Highcharts.dateFormats} hook.
 *
 * Since v6.0.5, all internal dates are formatted through the
 * {@link Highcharts.Chart#time} instance to respect chart-level time settings.
 * The `Highcharts.dateFormat` function only reflects global time settings set
 * with `setOptions`.
 *
 * Supported format keys:
 * - `%a`: Short weekday, like 'Mon'
 * - `%A`: Long weekday, like 'Monday'
 * - `%d`: Two digit day of the month, 01 to 31
 * - `%e`: Day of the month, 1 through 31
 * - `%w`: Day of the week, 0 through 6
 * - `%b`: Short month, like 'Jan'
 * - `%B`: Long month, like 'January'
 * - `%m`: Two digit month number, 01 through 12
 * - `%y`: Two digits year, like 09 for 2009
 * - `%Y`: Four digits year, like 2009
 * - `%H`: Two digits hours in 24h format, 00 through 23
 * - `%k`: Hours in 24h format, 0 through 23
 * - `%I`: Two digits hours in 12h format, 00 through 11
 * - `%l`: Hours in 12h format, 1 through 12
 * - `%M`: Two digits minutes, 00 through 59
 * - `%p`: Upper case AM or PM
 * - `%P`: Lower case AM or PM
 * - `%S`: Two digits seconds, 00 through 59
 * - `%L`: Milliseconds (naming from Ruby)
 *
 * @function Highcharts.dateFormat
 *
 * @param {string} format
 *        The desired format where various time representations are prefixed
 *        with `%`.
 *
 * @param {number} timestamp
 *        The JavaScript timestamp.
 *
 * @param {boolean} [upperCaseFirst=false]
 *        Upper case first letter in the return.
 *
 * @return {string}
 *         The formatted date.
 */ function dateFormat(format, timestamp, upperCaseFirst) {
    return defaultTime.dateFormat(format, timestamp, upperCaseFirst);
}
/**
 * Format a string according to a subset of the rules of Python's String.format
 * method.
 *
 * @example
 * let s = Highcharts.format(
 *     'The {color} fox was {len:.2f} feet long',
 *     { color: 'red', len: Math.PI }
 * );
 * // => The red fox was 3.14 feet long
 *
 * @function Highcharts.format
 *
 * @param {string} str
 *        The string to format.
 *
 * @param {Record<string, *>} ctx
 *        The context, a collection of key-value pairs where each key is
 *        replaced by its value.
 *
 * @param {Highcharts.Chart} [owner]
 *        A `Chart` or `Grid` instance used to get numberFormatter and time.
 *
 * @return {string}
 *         The formatted string.
 */ function format(str = '', ctx, owner) {
    // eslint-disable-next-line prefer-regex-literals
    const regex = new RegExp('\\{([\\p{L}\\d:\\.,;\\-\\/<>\\[\\]%_@+"\'‚Äô= #\\(\\)]+)\\}', 'gu'), // The sub expression regex is the same as the top expression regex,
    // but except parens and block helpers (#), and surrounded by parens
    // instead of curly brackets.
    // eslint-disable-next-line prefer-regex-literals
    subRegex = new RegExp('\\(([\\p{L}\\d:\\.,;\\-\\/<>\\[\\]%_@+"\'= ]+)\\)', 'gu'), matches = [], floatRegex = /f$/, decRegex = /\.(\d)/, lang = owner?.options?.lang || defaultOptions.lang, time = owner?.time || defaultTime, numberFormatter = owner?.numberFormatter || numberFormat.bind(owner);
    /*
     * Get a literal or variable value inside a template expression. May be
     * extended with other types like string or null if needed, but keep it
     * small for now.
     */ const resolveProperty = (key = '')=>{
        let n;
        // Literals
        if (key === 'true') {
            return true;
        }
        if (key === 'false') {
            return false;
        }
        if ((n = Number(key)).toString() === key) {
            return n;
        }
        if (isQuotedString(key)) {
            return key.slice(1, -1);
        }
        // Variables and constants
        return getNestedProperty(key, ctx);
    };
    let match, currentMatch, depth = 0, hasSub;
    // Parse and create tree
    while((match = regex.exec(str)) !== null){
        // When a sub expression is found, it is evaluated first, and the
        // results recursively evaluated until no subexpression exists.
        const mainMatch = match, subMatch = subRegex.exec(match[1]);
        if (subMatch) {
            match = subMatch;
            hasSub = true;
        }
        if (!currentMatch?.isBlock) {
            currentMatch = {
                ctx,
                expression: match[1],
                find: match[0],
                isBlock: match[1].charAt(0) === '#',
                start: match.index,
                startInner: match.index + match[0].length,
                length: match[0].length
            };
        }
        // Identify helpers
        const fn = (currentMatch.isBlock ? mainMatch : match)[1].split(' ')[0].replace('#', '');
        if (helpers[fn]) {
            // Block helper, only 0 level is handled
            if (currentMatch.isBlock && fn === currentMatch.fn) {
                depth++;
            }
            if (!currentMatch.fn) {
                currentMatch.fn = fn;
            }
        }
        // Closing a block helper
        const startingElseSection = match[1] === 'else';
        if (currentMatch.isBlock && currentMatch.fn && (match[1] === `/${currentMatch.fn}` || startingElseSection)) {
            if (!depth) {
                const start = currentMatch.startInner, body = str.substr(start, match.index - start);
                // Either closing without an else section, or when encountering
                // an else section
                if (currentMatch.body === void 0) {
                    currentMatch.body = body;
                    currentMatch.startInner = match.index + match[0].length;
                // The body exists already, so this is the else section
                } else {
                    currentMatch.elseBody = body;
                }
                currentMatch.find += body + match[0];
                if (!startingElseSection) {
                    matches.push(currentMatch);
                    currentMatch = void 0;
                }
            } else if (!startingElseSection) {
                depth--;
            }
        // Common expression
        } else if (!currentMatch.isBlock) {
            matches.push(currentMatch);
        }
        // Evaluate sub-matches one by one to prevent orphaned block closers
        if (subMatch && !currentMatch?.isBlock) {
            break;
        }
    }
    // Execute
    matches.forEach((match)=>{
        const { body, elseBody, expression, fn } = match;
        let replacement, i;
        // Helper function
        if (fn) {
            // Pass the helpers the amount of arguments defined by the function,
            // then the match as the last argument.
            const args = [
                match
            ], parts = [], len = expression.length;
            let start = 0, startChar;
            for(i = 0; i <= len; i++){
                const char = expression.charAt(i);
                // Start of string
                if (!startChar && (char === '"' || char === '\'')) {
                    startChar = char;
                // End of string
                } else if (startChar === char) {
                    startChar = '';
                }
                if (!startChar && (char === ' ' || i === len)) {
                    parts.push(expression.substr(start, i - start));
                    start = i + 1;
                }
            }
            i = helpers[fn].length;
            while(i--){
                args.unshift(resolveProperty(parts[i + 1]));
            }
            replacement = helpers[fn].apply(ctx, args);
            // Block helpers may return true or false. They may also return a
            // string, like the `each` helper.
            if (match.isBlock && typeof replacement === 'boolean') {
                replacement = format(replacement ? body : elseBody, ctx, owner);
            }
        // Simple variable replacement
        } else {
            const valueAndFormat = isQuotedString(expression) ? [
                expression
            ] : expression.split(':');
            replacement = resolveProperty(valueAndFormat.shift() || '');
            // Format the replacement
            if (valueAndFormat.length && typeof replacement === 'number') {
                const segment = valueAndFormat.join(':');
                if (floatRegex.test(segment)) {
                    const decimals = parseInt((segment.match(decRegex) || [
                        '',
                        '-1'
                    ])[1], 10);
                    if (replacement !== null) {
                        replacement = numberFormatter(replacement, decimals, lang.decimalPoint, segment.indexOf(',') > -1 ? lang.thousandsSep : '');
                    }
                } else {
                    replacement = time.dateFormat(segment, replacement);
                }
            }
            // Use string literal in order to be preserved in the outer
            // expression
            subRegex.lastIndex = 0;
            if (subRegex.test(match.find) && isString(replacement)) {
                replacement = `"${replacement}"`;
            }
        }
        str = str.replace(match.find, pick(replacement, ''));
    });
    return hasSub ? format(str, ctx, owner) : str;
}
/**
 * Format a number and return a string based on input settings.
 *
 * @sample highcharts/members/highcharts-numberformat/
 *         Custom number format
 *
 * @function Highcharts.numberFormat
 *
 * @param {number} number
 *        The input number to format.
 *
 * @param {number} decimals
 *        The amount of decimals. A value of -1 preserves the amount in the
 *        input number.
 *
 * @param {string} [decimalPoint]
 *        The decimal point, defaults to the one given in the lang options, or
 *        a dot.
 *
 * @param {string} [thousandsSep]
 *        The thousands separator, defaults to the one given in the lang
 *        options, or a space character.
 *
 * @return {string}
 *         The formatted number.
 */ function numberFormat(number, decimals, decimalPoint, thousandsSep) {
    number = +number || 0;
    decimals = +decimals;
    let ret, fractionDigits, [mantissa, exp] = number.toString().split('e').map(Number);
    const lang = this?.options?.lang || defaultOptions.lang, origDec = (number.toString().split('.')[1] || '').split('e')[0].length, firstDecimals = decimals, options = {};
    decimalPoint ?? (decimalPoint = lang.decimalPoint);
    thousandsSep ?? (thousandsSep = lang.thousandsSep);
    if (decimals === -1) {
        // Preserve decimals. Not huge numbers (#3793).
        decimals = Math.min(origDec, 20);
    } else if (!isNumber(decimals)) {
        decimals = 2;
    } else if (decimals && exp < 0) {
        // Expose decimals from exponential notation (#7042)
        fractionDigits = decimals + exp;
        if (fractionDigits >= 0) {
            // Remove too small part of the number while keeping the notation
            mantissa = +mantissa.toExponential(fractionDigits).split('e')[0];
            decimals = fractionDigits;
        } else {
            // `fractionDigits < 0`
            mantissa = Math.floor(mantissa);
            if (decimals < 20) {
                // Use number instead of exponential notation (#7405)
                number = +(mantissa * Math.pow(10, exp)).toFixed(decimals);
            } else {
                // Or zero
                number = 0;
            }
            exp = 0;
        }
    }
    if (exp) {
        decimals ?? (decimals = 2);
        number = mantissa;
    }
    if (isNumber(decimals) && decimals >= 0) {
        options.minimumFractionDigits = decimals;
        options.maximumFractionDigits = decimals;
    }
    if (thousandsSep === '') {
        options.useGrouping = false;
    }
    const hasSeparators = thousandsSep || decimalPoint, locale = hasSeparators ? 'en' : this?.locale || lang.locale || pageLang, cacheKey = JSON.stringify(options) + locale, nf = numberFormatCache[cacheKey] ?? (numberFormatCache[cacheKey] = new Intl.NumberFormat(locale, options));
    ret = nf.format(number);
    // If thousandsSep or decimalPoint are set, fall back to using English
    // format with string replacement for the separators.
    if (hasSeparators) {
        ret = ret// Preliminary step to avoid re-swapping (#22402)
        .replace(/([,\.])/g, '_$1').replace(/_\,/g, thousandsSep ?? ',').replace('_.', decimalPoint ?? '.');
    }
    if (// Remove signed zero (#20564)
    !decimals && +ret === 0 || exp < 0 && !firstDecimals) {
        ret = '0';
    }
    if (exp && +ret !== 0) {
        ret += 'e' + (exp < 0 ? '' : '+') + exp;
    }
    return ret;
}
/* *
 *
 *  Default Export
 *
 * */ const Templating = {
    dateFormat,
    format,
    helpers,
    numberFormat
};
const __TURBOPACK__default__export__ = Templating;
/* *
 * API Declarations
 * */ /**
 * @interface Highcharts.Templating
 *
 * The Highcharts.Templating interface provides a structure for defining
 * helpers. Helpers can be used as conditional blocks or functions within
 * expressions. Highcharts includes several built-in helpers and supports
 * the addition of custom helpers.
 *
 * @see [More information](
 * https://www.highcharts.com/docs/chart-concepts/templating#helpers)
 *
 * @example
 * // Define a custom helper to return the absolute value of a number
 * Highcharts.Templating.helpers.abs = value => Math.abs(value);
 *
 * // Usage in a format string
 * format: 'Absolute value: {abs point.y}'
 *
 * @name Highcharts.Templating#helpers
 * @type {Record<string, Function>}
 */ ''; // Keeps doclets above in file
}),
"[project]/node_modules/highcharts/es-modules/Core/Series/Point.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Renderer$2f$HTML$2f$AST$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Renderer/HTML/AST.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Animation$2f$AnimationUtilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Animation/AnimationUtilities.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Templating$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Templating.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Utilities.js [app-client] (ecmascript)");
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
;
;
const { animObject } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Animation$2f$AnimationUtilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
;
const { defaultOptions } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
;
const { format } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Templating$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
;
const { addEvent, crisp, erase, extend, fireEvent, getNestedProperty, isArray, isFunction, isNumber, isObject, merge, pick, syncTimeout, removeEvent, uniqueKey } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
/* eslint-disable no-invalid-this, valid-jsdoc */ /* *
 *
 *  Class
 *
 * */ /**
 * The Point object. The point objects are generated from the `series.data`
 * configuration objects or raw numbers. They can be accessed from the
 * `Series.points` array. Other ways to instantiate points are through {@link
 * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.
 *
 * @class
 * @name Highcharts.Point
 *
 * @param {Highcharts.Series} series
 *        The series object containing this point.
 *
 * @param {Highcharts.PointOptionsType} options
 *        The data in either number, array or object format.
 *
 * @param {number} [x]
 *        Optionally, the X value of the point.
 *
 * @emits Highcharts.Point#event:afterInit
 */ class Point {
    /* *
     *
     *  Constructor
     *
     * */ constructor(series, options, x){
        /** @internal */ this.formatPrefix = 'point';
        /**
         * For certain series types, like pie charts, where individual points can
         * be shown or hidden.
         *
         * @name Highcharts.Point#visible
         * @type {boolean}
         * @default true
         */ this.visible = true;
        // For tooltip and data label formatting
        this.point = this;
        this.series = series;
        this.applyOptions(options, x);
        // Add a unique ID to the point if none is assigned
        this.id ?? (this.id = uniqueKey());
        this.resolveColor();
        this.dataLabelOnNull ?? (this.dataLabelOnNull = series.options.nullInteraction);
        series.chart.pointCount++;
        // Set point properties for convenient access in tooltip and data labels
        this.category = series.xAxis?.categories?.[this.x] ?? this.x;
        this.key = this.name ?? this.category;
        fireEvent(this, 'afterInit');
    }
    /* *
     *
     *  API JSDoc doclet copies for uninitialized properties
     *
     * */ /**
     * For categorized axes this property holds the category name for the
     * point. For other axes it holds the X value.
     *
     * @name Highcharts.Point#category
     * @type {number|string}
     */ /**
     * The point's current color.
     *
     * @name Highcharts.Point#color
     * @type {Highcharts.ColorType|undefined}
     */ /**
     * The point's current color index, used in styled mode instead of
     * `color`. The color index is inserted in class names used for styling.
     *
     * @name Highcharts.Point#colorIndex
     * @type {number|undefined}
     */ /**
     * SVG graphic representing the point in the chart. In some cases it may be
     * a hidden graphic to improve accessibility.
     *
     * Typically this is a simple shape, like a `rect` for column charts or
     * `path` for line markers, but for some complex series types like boxplot
     * or 3D charts, the graphic may be a `g` element containing other shapes.
     * The graphic is generated the first time {@link Series#drawPoints} runs,
     * and updated and moved on subsequent runs.
     *
     * @see Highcharts.Point#graphics
     *
     * @name Highcharts.Point#graphic
     * @type {Highcharts.SVGElement|undefined}
     */ /**
     * Array for multiple SVG graphics representing the point in the
     * chart. Only used in cases where the point can not be represented
     * by a single graphic.
     *
     * @see Highcharts.Point#graphic
     *
     * @name Highcharts.Point#graphics
     * @type {Array<Highcharts.SVGElement>|undefined}
     */ /**
     * The point's name if it is defined, or its category in case of a category,
     * otherwise the x value. Convenient for tooltip and data label formatting.
     *
     * @name Highcharts.Point#key
     * @type {number|string}
     */ /**
     * The name of the point. The name can be given as the first position of the
     * point configuration array, or as a `name` property in the configuration:
     *
     * @example
     * // Array config
     * data: [
     *     ['John', 1],
     *     ['Jane', 2]
     * ]
     *
     * // Object config
     * data: [{
     *        name: 'John',
     *        y: 1
     * }, {
     *     name: 'Jane',
     *     y: 2
     * }]
     *
     * @name Highcharts.Point#name
     * @type {string}
     */ /**
     * The point's options as applied in the initial configuration, or
     * extended through `Point.update`.
     *
     * In TypeScript you have to extend `PointOptionsObject` via an
     * additional interface to allow custom data options:
     *
     * ```
     * declare interface PointOptionsObject {
     *     customProperty: string;
     * }
     * ```
     *
     * @name Highcharts.Point#options
     * @type {Highcharts.PointOptionsObject}
     */ /**
     * The percentage for points in a stacked series, pies or gauges.
     *
     * @name Highcharts.Point#percentage
     * @type {number|undefined}
     */ /**
     * Array of all hovered points when using shared tooltips.
     *
     * @name Highcharts.Point#points
     * @type {Array<Highcharts.Point>|undefined}
     */ /**
     * Whether the point is selected or not.
     *
     * @see Point#select
     * @see Chart#getSelectedPoints
     *
     * @name Highcharts.Point#selected
     * @type {boolean}
     */ /**
     * The series object associated with the point.
     *
     * @name Highcharts.Point#series
     * @type {Highcharts.Series}
     */ /**
     * The attributes of the rendered SVG shape like in `column` or `pie`
     * series.
     *
     * @readonly
     * @name Highcharts.Point#shapeArgs
     * @type {Readonly<Highcharts.SVGAttributes>|undefined}
     */ /**
     * Defines the tooltip's position for a data point in a chart. It is an
     * array of numbers representing the coordinates for the tooltip's
     * placement, allowing for precise control over its location.
     *
     * @readonly
     * @name Highcharts.Point#tooltipPos
     * @type {Readonly<Array<number>>|undefined}
     */ /**
     * The total of values in either a stack for stacked series, or a pie in a
     * pie series.
     *
     * @name Highcharts.Point#total
     * @type {number|undefined}
     */ /**
     * The x value of the point.
     *
     * @name Highcharts.Point#x
     * @type {number}
     */ /**
     * The y value of the point.
     *
     * @name Highcharts.Point#y
     * @type {number|undefined}
     */ /* *
     *
     *  Functions
     *
     * */ /**
     * Animate SVG elements associated with the point.
     *
     * @internal
     * @function Highcharts.Point#animateBeforeDestroy
     */ animateBeforeDestroy() {
        const point = this, animateParams = {
            x: point.startXPos,
            opacity: 0
        }, graphicalProps = point.getGraphicalProps();
        graphicalProps.singular.forEach(function(prop) {
            const isDataLabel = prop === 'dataLabel';
            point[prop] = point[prop].animate(isDataLabel ? {
                x: point[prop].startXPos,
                y: point[prop].startYPos,
                opacity: 0
            } : animateParams);
        });
        graphicalProps.plural.forEach(function(plural) {
            point[plural].forEach(function(item) {
                if (item.element) {
                    item.animate(extend({
                        x: point.startXPos
                    }, item.startYPos ? {
                        x: item.startXPos,
                        y: item.startYPos
                    } : {}));
                }
            });
        });
    }
    /**
     * Apply the options containing the x and y data and possible some extra
     * properties. Called on point init or from point.update.
     *
     * @internal
     * @function Highcharts.Point#applyOptions
     *
     * @param {Highcharts.PointOptionsType} options
     *        The point options as defined in series.data.
     *
     * @param {number} [x]
     *        Optionally, the x value.
     *
     * @return {Highcharts.Point}
     *         The Point instance.
     */ applyOptions(options, x) {
        const point = this, series = point.series, pointValKey = series.options.pointValKey || series.pointValKey;
        options = Point.prototype.optionsToObject.call(this, options);
        // Copy options directly to point
        extend(point, options);
        point.options = point.options ? extend(point.options, options) : options;
        // Since options are copied into the Point instance, some accidental
        // options must be shielded (#5681)
        if (options.group) {
            delete point.group;
        }
        if (options.dataLabels) {
            delete point.dataLabels;
        }
        // For higher dimension series types. For instance, for ranges, point.y
        // is mapped to point.low.
        if (pointValKey) {
            point.y = Point.prototype.getNestedProperty.call(point, pointValKey);
        }
        // The point is initially selected by options (#5777)
        if (point.selected) {
            point.state = 'select';
        }
        // If no x is set by now, get auto incremented value. All points must
        // have an x value, however the y value can be null to create a gap in
        // the series
        if ('name' in point && typeof x === 'undefined' && series.xAxis && series.xAxis.hasNames) {
            point.x = series.xAxis.nameToX(point);
        }
        if (typeof point.x === 'undefined' && series) {
            point.x = x ?? series.autoIncrement();
        } else if (isNumber(options.x) && series.options.relativeXValue) {
            point.x = series.autoIncrement(options.x);
        // If x is a string, try to parse it to a datetime
        } else if (typeof point.x === 'string') {
            x ?? (x = series.chart.time.parse(point.x));
            if (isNumber(x)) {
                point.x = x;
            }
        }
        point.isNull = this.isValid && !this.isValid();
        point.formatPrefix = point.isNull ? 'null' : 'point'; // #9233, #10874
        return point;
    }
    /**
     * Destroy a point to clear memory. Its reference still stays in
     * `series.data`.
     *
     * @internal
     * @function Highcharts.Point#destroy
     */ destroy() {
        if (!this.destroyed) {
            const point = this, series = point.series, chart = series.chart, dataSorting = series.options.dataSorting, hoverPoints = chart.hoverPoints, globalAnimation = point.series.chart.renderer.globalAnimation, animation = animObject(globalAnimation);
            /**
             * Allow to call after animation.
             * @internal
             */ const destroyPoint = ()=>{
                // Remove all events and elements
                if (point.graphic || point.graphics || point.dataLabel || point.dataLabels) {
                    removeEvent(point);
                    point.destroyElements();
                }
                for(const prop in point){
                    delete point[prop];
                }
            };
            if (point.legendItem) {
                // Pies have legend items
                chart.legend.destroyItem(point);
            }
            if (hoverPoints) {
                point.setState();
                erase(hoverPoints, point);
                if (!hoverPoints.length) {
                    chart.hoverPoints = null;
                }
            }
            if (point === chart.hoverPoint) {
                point.onMouseOut();
            }
            // Remove properties after animation
            if (!dataSorting?.enabled) {
                destroyPoint();
            } else {
                this.animateBeforeDestroy();
                syncTimeout(destroyPoint, animation.duration);
            }
            chart.pointCount--;
        }
        this.destroyed = true;
    }
    /**
     * Destroy SVG elements associated with the point.
     *
     * @internal
     * @function Highcharts.Point#destroyElements
     *
     * @param {Highcharts.Dictionary<number>} [kinds]
     * Kinds of elements to destroy
     */ destroyElements(kinds) {
        const point = this, props = point.getGraphicalProps(kinds);
        props.singular.forEach(function(prop) {
            point[prop] = point[prop].destroy();
        });
        props.plural.forEach(function(plural) {
            point[plural].forEach(function(item) {
                if (item?.element) {
                    item.destroy();
                }
            });
            delete point[plural];
        });
    }
    /**
     * Fire an event on the Point object.
     *
     * @internal
     * @function Highcharts.Point#firePointEvent
     *
     * @param {string} eventType
     *        Type of the event.
     *
     * @param {Highcharts.Dictionary<any>|Event} [eventArgs]
     *        Additional event arguments.
     *
     * @param {Highcharts.EventCallbackFunction<Highcharts.Point>|Function} [defaultFunction]
     *        Default event handler.
     *
     * @emits Highcharts.Point#event:*
     */ firePointEvent(eventType, eventArgs, defaultFunction) {
        const point = this, series = this.series, seriesOptions = series.options;
        // Load event handlers on demand to save time on mouseover/out
        point.manageEvent(eventType);
        // Add default handler if in selection mode
        if (eventType === 'click' && seriesOptions.allowPointSelect) {
            defaultFunction = function(event) {
                // Control key is for Windows, meta (= Cmd key) for Mac, Shift
                // for Opera.
                if (!point.destroyed && point.select) {
                    point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
                }
            };
        }
        fireEvent(point, eventType, eventArgs, defaultFunction);
    }
    /**
     * Get the CSS class names for individual points. Used internally where the
     * returned value is set on every point.
     *
     * @function Highcharts.Point#getClassName
     *
     * @return {string}
     *         The class names.
     */ getClassName() {
        const point = this;
        return 'highcharts-point' + (point.selected ? ' highcharts-point-select' : '') + (point.negative ? ' highcharts-negative' : '') + (point.isNull ? ' highcharts-null-point' : '') + (typeof point.colorIndex !== 'undefined' ? ' highcharts-color-' + point.colorIndex : '') + (point.options.className ? ' ' + point.options.className : '') + (point.zone?.className ? ' ' + point.zone.className.replace('highcharts-negative', '') : '');
    }
    /**
     * Get props of all existing graphical point elements.
     *
     * @internal
     * @function Highcharts.Point#getGraphicalProps
     */ getGraphicalProps(kinds) {
        const point = this, props = [], graphicalProps = {
            singular: [],
            plural: []
        };
        let prop, i;
        kinds = kinds || {
            graphic: 1,
            dataLabel: 1
        };
        if (kinds.graphic) {
            props.push('graphic', 'connector' // Used by dumbbell
            );
        }
        if (kinds.dataLabel) {
            props.push('dataLabel', 'dataLabelPath', 'dataLabelUpper');
        }
        i = props.length;
        while(i--){
            prop = props[i];
            if (point[prop]) {
                graphicalProps.singular.push(prop);
            }
        }
        [
            'graphic',
            'dataLabel'
        ].forEach(function(prop) {
            const plural = prop + 's';
            if (kinds[prop] && point[plural]) {
                graphicalProps.plural.push(plural);
            }
        });
        return graphicalProps;
    }
    /**
     * Returns the value of the point property for a given value.
     * @internal
     */ getNestedProperty(key) {
        if (!key) {
            return;
        }
        if (key.indexOf('custom.') === 0) {
            return getNestedProperty(key, this.options);
        }
        return this[key];
    }
    /**
     * In a series with `zones`, return the zone that the point belongs to.
     *
     * @function Highcharts.Point#getZone
     *
     * @return {Highcharts.SeriesZonesOptionsObject}
     *         The zone item.
     */ getZone() {
        const series = this.series, zones = series.zones, zoneAxis = series.zoneAxis || 'y';
        let zone, i = 0;
        zone = zones[i];
        while(this[zoneAxis] >= zone.value){
            zone = zones[++i];
        }
        // For resetting or reusing the point (#8100)
        if (!this.nonZonedColor) {
            this.nonZonedColor = this.color;
        }
        if (zone?.color && !this.options.color) {
            this.color = zone.color;
        } else {
            this.color = this.nonZonedColor;
        }
        return zone;
    }
    /**
     * Utility to check if point has new shape type. Used in column series and
     * all others that are based on column series.
     * @internal
     */ hasNewShapeType() {
        const point = this;
        const oldShapeType = point.graphic && (point.graphic.symbolName || point.graphic.element.nodeName);
        return oldShapeType !== this.shapeType;
    }
    /**
     * Determine if point is valid.
     *
     * @internal
     * @function Highcharts.Point#isValid
     */ isValid() {
        return (isNumber(this.x) || this.x instanceof Date) && isNumber(this.y);
    }
    /**
     * Transform number or array configs into objects. Also called for object
     * configs. Used internally to unify the different configuration formats for
     * points. For example, a simple number `10` in a line series will be
     * transformed to `{ y: 10 }`, and an array config like `[1, 10]` in a
     * scatter series will be transformed to `{ x: 1, y: 10 }`.
     *
     * @function Highcharts.Point#optionsToObject
     *
     * @param {Highcharts.PointOptionsType} options
     * Series data options.
     *
     * @return {Highcharts.Dictionary<*>}
     * Transformed point options.
     */ optionsToObject(options) {
        const series = this.series, keys = series.options.keys, pointArrayMap = keys || series.pointArrayMap || [
            'y'
        ], valueCount = pointArrayMap.length;
        let ret = {}, firstItemType, i = 0, j = 0;
        if (isNumber(options) || options === null) {
            ret[pointArrayMap[0]] = options;
        } else if (isArray(options)) {
            // With leading x value
            if (!keys && options.length > valueCount) {
                firstItemType = typeof options[0];
                if (firstItemType === 'string') {
                    if (series.xAxis?.dateTime) {
                        ret.x = series.chart.time.parse(options[0]);
                    } else {
                        ret.name = options[0];
                    }
                } else if (firstItemType === 'number') {
                    ret.x = options[0];
                }
                i++;
            }
            while(j < valueCount){
                // Skip undefined positions for keys
                if (!keys || typeof options[i] !== 'undefined') {
                    if (pointArrayMap[j].indexOf('.') > 0) {
                        // Handle nested keys, e.g. ['color.pattern.image']
                        // Avoid function call unless necessary.
                        Point.prototype.setNestedProperty(ret, options[i], pointArrayMap[j]);
                    } else {
                        ret[pointArrayMap[j]] = options[i];
                    }
                }
                i++;
                j++;
            }
        } else if (typeof options === 'object') {
            ret = options;
            // This is the fastest way to detect if there are individual point
            // dataLabels that need to be considered in drawDataLabels. These
            // can only occur in object configs.
            if (options.dataLabels) {
                // Override the prototype function to always return true,
                // regardless of whether data labels are enabled series-wide
                series.hasDataLabels = ()=>true;
            }
            // Same approach as above for markers
            if (options.marker) {
                series._hasPointMarkers = true;
            }
        }
        return ret;
    }
    /**
     * Get the pixel position of the point relative to the plot area.
     *
     * @function Highcharts.Point#pos
     *
     * @sample highcharts/point/position
     *         Get point's position in pixels.
     *
     * @param {boolean} chartCoordinates
     * If true, the returned position is relative to the full chart area.
     * If false, it is relative to the plot area determined by the axes.
     *
     * @param {number|undefined} plotY
     * A custom plot y position to be computed. Used internally for some
     * series types that have multiple `y` positions, like area range (low
     * and high values).
     *
     * @return {Array<number>|undefined}
     * Coordinates of the point if the point exists.
     */ pos(chartCoordinates, plotY = this.plotY) {
        if (!this.destroyed) {
            const { plotX, series } = this, { chart, xAxis, yAxis } = series;
            let posX = 0, posY = 0;
            if (isNumber(plotX) && isNumber(plotY)) {
                if (chartCoordinates) {
                    posX = xAxis ? xAxis.pos : chart.plotLeft;
                    posY = yAxis ? yAxis.pos : chart.plotTop;
                }
                return chart.inverted && xAxis && yAxis ? [
                    yAxis.len - plotY + posY,
                    xAxis.len - plotX + posX
                ] : [
                    plotX + posX,
                    plotY + posY
                ];
            }
        }
    }
    /**
     * Resolve the color of a point.
     *
     * @internal
     * @function Highcharts.Point#resolveColor
     */ resolveColor() {
        const series = this.series, optionsChart = series.chart.options.chart, styledMode = series.chart.styledMode;
        let color, colors, colorCount = optionsChart.colorCount, colorIndex;
        // Remove points nonZonedColor for later recalculation
        delete this.nonZonedColor;
        if (series.options.colorByPoint) {
            if (!styledMode) {
                colors = series.options.colors || series.chart.options.colors;
                color = colors[series.colorCounter];
                colorCount = colors.length;
            }
            colorIndex = series.colorCounter;
            series.colorCounter++;
            // Loop back to zero
            if (series.colorCounter === colorCount) {
                series.colorCounter = 0;
            }
        } else {
            if (!styledMode) {
                color = series.color;
            }
            colorIndex = series.colorIndex;
        }
        this.colorIndex = pick(this.options.colorIndex, colorIndex);
        this.color = pick(this.options.color, color);
    }
    /**
     * Set a value in an object, on the property defined by key. The key
     * supports nested properties using dot notation. The function modifies the
     * input object and does not make a copy.
     *
     * @function Highcharts.Point#setNestedProperty<T>
     *
     * @param {T} object
     *        The object to set the value on.
     *
     * @param {*} value
     *        The value to set.
     *
     * @param {string} key
     *        Key to the property to set.
     *
     * @return {T}
     *         The modified object.
     */ setNestedProperty(object, value, key) {
        const nestedKeys = key.split('.');
        nestedKeys.reduce(function(result, key, i, arr) {
            const isLastKey = arr.length - 1 === i;
            result[key] = isLastKey ? value : isObject(result[key], true) ? result[key] : {};
            return result[key];
        }, object);
        return object;
    }
    /** @internal */ shouldDraw() {
        return !this.isNull;
    }
    /**
     * Extendable method for formatting each point's tooltip line.
     *
     * @function Highcharts.Point#tooltipFormatter
     *
     * @param {string} pointFormat
     *        The point format.
     *
     * @return {string}
     *         A string to be concatenated in to the common tooltip text.
     */ tooltipFormatter(pointFormat) {
        // Insert options for valueDecimals, valuePrefix, and valueSuffix
        const { chart, pointArrayMap = [
            'y'
        ], tooltipOptions } = this.series, { valueDecimals = '', valuePrefix = '', valueSuffix = '' } = tooltipOptions;
        // Replace default point style with class name
        if (chart.styledMode) {
            pointFormat = chart.tooltip?.styledModeFormat(pointFormat) || pointFormat;
        }
        // Loop over the point array map and replace unformatted values with
        // sprintf formatting markup
        pointArrayMap.forEach((key)=>{
            key = '{point.' + key; // Without the closing bracket
            if (valuePrefix || valueSuffix) {
                pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), valuePrefix + key + '}' + valueSuffix);
            }
            pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), key + ':,.' + valueDecimals + 'f}');
        });
        return format(pointFormat, this, chart);
    }
    /**
     * Update point with new options (typically x/y data) and optionally redraw
     * the series.
     *
     * @sample highcharts/members/point-update-column/
     *         Update column value
     * @sample highcharts/members/point-update-pie/
     *         Update pie slice
     * @sample maps/members/point-update/
     *         Update map area value in Highmaps
     *
     * @function Highcharts.Point#update
     *
     * @param {Highcharts.PointOptionsType} options
     *        The point options. Point options are handled as described under
     *        the `series.type.data` item for each series type. For example
     *        for a line series, if options is a single number, the point will
     *        be given that number as the marin y value. If it is an array, it
     *        will be interpreted as x and y values respectively. If it is an
     *        object, advanced options are applied.
     *
     * @param {boolean} [redraw=true]
     *        Whether to redraw the chart after the point is updated. If doing
     *        more operations on the chart, it is best practice to set
     *        `redraw` to false and call `chart.redraw()` after.
     *
     * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=true]
     *        Whether to apply animation, and optionally animation
     *        configuration.
     *
     * @emits Highcharts.Point#event:update
     */ update(options, redraw, animation, runEvent) {
        const point = this, series = point.series, graphic = point.graphic, chart = series.chart, seriesOptions = series.options;
        let i;
        redraw = pick(redraw, true);
        /**
         * Perform the actual update of the point.
         *
         * @internal
         */ function update() {
            point.applyOptions(options);
            // Update visuals, #4146
            // Handle mock graphic elements for a11y, #12718
            const hasMockGraphic = graphic && point.hasMockGraphic;
            const shouldDestroyGraphic = point.y === null ? !hasMockGraphic : hasMockGraphic;
            if (graphic && shouldDestroyGraphic) {
                point.graphic = graphic.destroy();
                delete point.hasMockGraphic;
            }
            if (isObject(options, true)) {
                // Destroy so we can get new elements
                if (graphic?.element) {
                    // "null" is also a valid symbol
                    if (options && options.marker && typeof options.marker.symbol !== 'undefined') {
                        point.graphic = graphic.destroy();
                    }
                }
                if (options?.dataLabels && point.dataLabel) {
                    point.dataLabel = point.dataLabel.destroy(); // #2468
                }
            }
            // Record changes in the data table
            i = point.index;
            const row = {};
            for (const key of series.dataColumnKeys()){
                row[key] = point[key];
            }
            series.dataTable.setRow(row, i);
            // Record the options to options.data. If the old or the new config
            // is an object, use point options, otherwise use raw options
            // (#4701, #4916).
            seriesOptions.data[i] = isObject(seriesOptions.data[i], true) || isObject(options, true) ? point.options : pick(options, seriesOptions.data[i]);
            // Redraw
            series.isDirty = series.isDirtyData = true;
            if (!series.fixedBox && series.hasCartesianSeries) {
                chart.isDirtyBox = true;
            }
            if (seriesOptions.legendType === 'point') {
                chart.isDirtyLegend = true;
            }
            if (redraw) {
                chart.redraw(animation);
            }
        }
        // Fire the event with a default handler of doing the update
        if (runEvent === false) {
            update();
        } else {
            point.firePointEvent('update', {
                options: options
            }, update);
        }
    }
    /**
     * Remove a point and optionally redraw the series and if necessary the axes
     *
     * @sample highcharts/plotoptions/series-point-events-remove/
     *         Remove point and confirm
     * @sample highcharts/members/point-remove/
     *         Remove pie slice
     * @sample maps/members/point-remove/
     *         Remove selected points in Highmaps
     *
     * @function Highcharts.Point#remove
     *
     * @param {boolean} [redraw=true]
     *        Whether to redraw the chart or wait for an explicit call. When
     *        doing more operations on the chart, for example running
     *        `point.remove()` in a loop, it is best practice to set `redraw`
     *        to false and call `chart.redraw()` after.
     *
     * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=false]
     *        Whether to apply animation, and optionally animation
     *        configuration.
     */ remove(redraw, animation) {
        this.series.removePoint(this.series.data.indexOf(this), redraw, animation);
    }
    /**
     * Toggle the selection status of a point.
     *
     * @see Highcharts.Chart#getSelectedPoints
     *
     * @sample highcharts/members/point-select/
     *         Select a point from a button
     * @sample highcharts/members/point-select-lasso/
     *         Lasso selection
     * @sample highcharts/chart/events-selection-points/
     *         Rectangle selection
     * @sample maps/series/data-id/
     *         Select a point in Highmaps
     *
     * @function Highcharts.Point#select
     *
     * @param {boolean} [selected]
     * When `true`, the point is selected. When `false`, the point is
     * unselected. When `null` or `undefined`, the selection state is toggled.
     *
     * @param {boolean} [accumulate=false]
     * When `true`, the selection is added to other selected points.
     * When `false`, other selected points are deselected. Internally in
     * Highcharts, when
     * [allowPointSelect](https://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect)
     * is `true`, selected points are accumulated on Control, Shift or Cmd
     * clicking the point.
     *
     * @emits Highcharts.Point#event:select
     * @emits Highcharts.Point#event:unselect
     */ select(selected, accumulate) {
        const point = this, series = point.series, chart = series.chart;
        selected = pick(selected, !point.selected);
        this.selectedStaging = selected;
        // Fire the event with the default handler
        point.firePointEvent(selected ? 'select' : 'unselect', {
            accumulate: accumulate
        }, function() {
            point.selected = point.options.selected = selected;
            series.options.data[series.data.indexOf(point)] = point.options;
            point.setState(selected && 'select');
            // Unselect all other points unless Ctrl or Cmd + click
            if (!accumulate) {
                chart.getSelectedPoints().forEach(function(loopPoint) {
                    const loopSeries = loopPoint.series;
                    if (loopPoint.selected && loopPoint !== point) {
                        loopPoint.selected = loopPoint.options.selected = false;
                        loopSeries.options.data[loopSeries.data.indexOf(loopPoint)] = loopPoint.options;
                        // Programmatically selecting a point should restore
                        // normal state, but when click happened on other
                        // point, set inactive state to match other points
                        loopPoint.setState(chart.hoverPoints && loopSeries.options.inactiveOtherPoints ? 'inactive' : '');
                        loopPoint.firePointEvent('unselect');
                    }
                });
            }
        });
        delete this.selectedStaging;
    }
    /**
     * Runs on mouse over the point. Called internally from mouse and touch
     * events.
     *
     * @function Highcharts.Point#onMouseOver
     *
     * @param {Highcharts.PointerEventObject} [e]
     *        The event arguments.
     */ onMouseOver(e) {
        const point = this, series = point.series, { inverted, pointer } = series.chart;
        if (pointer) {
            e = e ? pointer.normalize(e) : // In cases where onMouseOver is called directly without an
            // event
            pointer.getChartCoordinatesFromPoint(point, inverted);
            pointer.runPointActions(e, point);
        }
    }
    /**
     * Runs on mouse out from the point. Called internally from mouse and touch
     * events.
     *
     * @function Highcharts.Point#onMouseOut
     * @emits Highcharts.Point#event:mouseOut
     */ onMouseOut() {
        const point = this, chart = point.series.chart;
        point.firePointEvent('mouseOut');
        if (!point.series.options.inactiveOtherPoints) {
            (chart.hoverPoints || []).forEach(function(p) {
                p.setState();
            });
        }
        chart.hoverPoints = chart.hoverPoint = null;
    }
    /**
     * Manage specific event from the series' and point's options. Only do it on
     * demand, to save processing time on hovering.
     *
     * @internal
     * @function Highcharts.Point#importEvents
     */ manageEvent(eventType) {
        const point = this, options = merge(point.series.options.point, point.options), userEvent = options.events?.[eventType];
        if (isFunction(userEvent) && (!point.hcEvents?.[eventType] || // Some HC modules, like marker-clusters, draggable-poins etc.
        // use events in their logic, so we need to be sure, that
        // callback function is different
        point.hcEvents?.[eventType]?.map((el)=>el.fn).indexOf(userEvent) === -1)) {
            // While updating the existing callback event the old one should be
            // removed
            point.importedUserEvent?.();
            point.importedUserEvent = addEvent(point, eventType, userEvent);
            if (point.hcEvents) {
                point.hcEvents[eventType].userEvent = true;
            }
        } else if (point.importedUserEvent && !userEvent && point.hcEvents?.[eventType] && point.hcEvents?.[eventType].userEvent) {
            removeEvent(point, eventType);
            delete point.hcEvents[eventType];
            if (!Object.keys(point.hcEvents)) {
                delete point.importedUserEvent;
            }
        }
    }
    /**
     * Set the point's state.
     *
     * @function Highcharts.Point#setState
     *
     * @param {Highcharts.PointStateValue|""} [state]
     *        The new state, can be one of `'hover'`, `'select'`, `'inactive'`,
     *        or `''` (an empty string), `'normal'` or `undefined` to set to
     *        normal state.
     * @param {boolean} [move]
     *        State for animation.
     *
     * @emits Highcharts.Point#event:afterSetState
     */ setState(state, move) {
        const point = this, series = point.series, previousState = point.state, stateOptions = series.options.states[state || 'normal'] || {}, markerOptions = defaultOptions.plotOptions[series.type].marker && series.options.marker, normalDisabled = markerOptions && markerOptions.enabled === false, markerStateOptions = markerOptions?.states?.[state || 'normal'] || {}, stateDisabled = markerStateOptions.enabled === false, pointMarker = point.marker || {}, chart = series.chart, hasMarkers = markerOptions && series.markerAttribs;
        let halo = series.halo, markerAttribs, pointAttribs, pointAttribsAnimation, stateMarkerGraphic = series.stateMarkerGraphic, newSymbol;
        state = state || ''; // Empty string
        if (// Already has this state
        state === point.state && !move || point.selected && state !== 'select' || stateOptions.enabled === false || state && (stateDisabled || normalDisabled && markerStateOptions.enabled === false) || state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false // #1610
        ) {
            return;
        }
        point.state = state;
        if (hasMarkers) {
            markerAttribs = series.markerAttribs(point, state);
        }
        // Apply hover styles to the existing point
        // Prevent from mocked null points (#14966)
        if (point.graphic && !point.hasMockGraphic) {
            if (previousState) {
                point.graphic.removeClass('highcharts-point-' + previousState);
            }
            if (state) {
                point.graphic.addClass('highcharts-point-' + state);
            }
            if (!chart.styledMode) {
                pointAttribs = series.pointAttribs(point, state);
                pointAttribsAnimation = pick(chart.options.chart.animation, stateOptions.animation);
                const opacity = pointAttribs.opacity;
                // Some inactive points (e.g. slices in pie) should apply
                // opacity also for their labels
                if (series.options.inactiveOtherPoints && isNumber(opacity)) {
                    (point.dataLabels || []).forEach(function(label) {
                        if (label && !label.hasClass('highcharts-data-label-hidden')) {
                            label.animate({
                                opacity
                            }, pointAttribsAnimation);
                            if (label.connector) {
                                label.connector.animate({
                                    opacity
                                }, pointAttribsAnimation);
                            }
                        }
                    });
                }
                point.graphic.animate(pointAttribs, pointAttribsAnimation);
            }
            if (markerAttribs) {
                point.graphic.animate(markerAttribs, pick(// Turn off globally:
                chart.options.chart.animation, markerStateOptions.animation, markerOptions.animation));
            }
            // Zooming in from a range with no markers to a range with markers
            if (stateMarkerGraphic) {
                stateMarkerGraphic.hide();
            }
        } else {
            // If a graphic is not applied to each point in the normal state,
            // create a shared graphic for the hover state
            if (state && markerStateOptions) {
                newSymbol = pointMarker.symbol || series.symbol;
                // If the point has another symbol than the previous one, throw
                // away the state marker graphic and force a new one (#1459)
                if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
                    stateMarkerGraphic = stateMarkerGraphic.destroy();
                }
                // Add a new state marker graphic
                if (markerAttribs) {
                    if (!stateMarkerGraphic) {
                        if (newSymbol) {
                            series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, merge(markerOptions, markerStateOptions)).add(series.markerGroup);
                            stateMarkerGraphic.currentSymbol = newSymbol;
                        }
                    // Move the existing graphic
                    } else {
                        stateMarkerGraphic[move ? 'animate' : 'attr']({
                            x: markerAttribs.x,
                            y: markerAttribs.y
                        });
                    }
                }
                if (!chart.styledMode && stateMarkerGraphic && point.state !== 'inactive') {
                    stateMarkerGraphic.attr(series.pointAttribs(point, state));
                }
            }
            if (stateMarkerGraphic) {
                stateMarkerGraphic[state && point.isInside ? 'show' : 'hide'](); // #2450
                stateMarkerGraphic.element.point = point; // #4310
                stateMarkerGraphic.addClass(point.getClassName(), true);
            }
        }
        // Show me your halo
        const haloOptions = stateOptions.halo;
        const markerGraphic = point.graphic || stateMarkerGraphic;
        const markerVisibility = markerGraphic?.visibility || 'inherit';
        if (haloOptions?.size && markerGraphic && markerVisibility !== 'hidden' && !point.isCluster) {
            if (!halo) {
                series.halo = halo = chart.renderer.path()// #5818, #5903, #6705
                .add(markerGraphic.parentGroup);
            }
            halo.show()[move ? 'animate' : 'attr']({
                d: point.haloPath(haloOptions.size)
            });
            halo.attr({
                'class': 'highcharts-halo highcharts-color-' + pick(point.colorIndex, series.colorIndex) + (point.className ? ' ' + point.className : ''),
                'visibility': markerVisibility,
                'zIndex': -1 // #4929, #8276
            });
            halo.point = point; // #6055
            if (!chart.styledMode) {
                halo.attr(extend({
                    'fill': point.color || series.color,
                    'fill-opacity': haloOptions.opacity
                }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Renderer$2f$HTML$2f$AST$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].filterUserAttributes(haloOptions.attributes || {})));
            }
        } else if (halo?.point?.haloPath && !halo.point.destroyed) {
            // Animate back to 0 on the current halo point (#6055)
            halo.animate({
                d: halo.point.haloPath(0)
            }, null, // Hide after unhovering. The `complete` callback runs in the
            // halo's context (#7681).
            halo.hide);
        }
        fireEvent(point, 'afterSetState', {
            state
        });
    }
    /**
     * Get the path definition for the halo, which is usually a shadow-like
     * circle around the currently hovered point.
     *
     * @function Highcharts.Point#haloPath
     *
     * @param {number} size
     *        The radius of the circular halo.
     *
     * @return {Highcharts.SVGPathArray}
     *         The path definition.
     */ haloPath(size) {
        const pos = this.pos();
        return pos ? this.series.chart.renderer.symbols.circle(crisp(pos[0], 1) - size, pos[1] - size, size * 2, size * 2) : [];
    }
}
const __TURBOPACK__default__export__ = Point;
/* *
 *
 *  API Declarations
 *
 * */ /**
 * Function callback when a series point is clicked. Return false to cancel the
 * action.
 *
 * @callback Highcharts.PointClickCallbackFunction
 *
 * @param {Highcharts.Point} this
 *        The point where the event occurred.
 *
 * @param {Highcharts.PointClickEventObject} event
 *        Event arguments.
 */ /**
 * Common information for a click event on a series point.
 *
 * @interface Highcharts.PointClickEventObject
 * @extends Highcharts.PointerEventObject
 */ /**
* Clicked point.
* @name Highcharts.PointClickEventObject#point
* @type {Highcharts.Point}
*/ /**
 * Gets fired when the mouse leaves the area close to the point.
 *
 * @callback Highcharts.PointMouseOutCallbackFunction
 *
 * @param {Highcharts.Point} this
 *        Point where the event occurred.
 *
 * @param {global.PointerEvent} event
 *        Event that occurred.
 */ /**
 * Gets fired when the mouse enters the area close to the point.
 *
 * @callback Highcharts.PointMouseOverCallbackFunction
 *
 * @param {Highcharts.Point} this
 *        Point where the event occurred.
 *
 * @param {global.Event} event
 *        Event that occurred.
 */ /**
 * The generic point options for all series.
 *
 * In TypeScript you have to extend `PointOptionsObject` with an additional
 * declaration to allow custom data options:
 *
 * ```
 * declare interface PointOptionsObject {
 *     customProperty: string;
 * }
 * ```
 *
 * @interface Highcharts.PointOptionsObject
 */ /**
 * Possible option types for a data point. Use `null` to indicate a gap.
 *
 * @typedef {number|string|Highcharts.PointOptionsObject|Array<(number|string|null)>|null} Highcharts.PointOptionsType
 */ /**
 * Gets fired when the point is removed using the `.remove()` method.
 *
 * @callback Highcharts.PointRemoveCallbackFunction
 *
 * @param {Highcharts.Point} this
 *        Point where the event occurred.
 *
 * @param {global.Event} event
 *        Event that occurred.
 */ /**
 * Possible key values for the point state options.
 *
 * @typedef {"hover"|"inactive"|"normal"|"select"} Highcharts.PointStateValue
 */ /**
 * Gets fired when the point is updated programmatically through the `.update()`
 * method.
 *
 * @callback Highcharts.PointUpdateCallbackFunction
 *
 * @param {Highcharts.Point} this
 *        Point where the event occurred.
 *
 * @param {Highcharts.PointUpdateEventObject} event
 *        Event that occurred.
 */ /**
 * Information about the update event.
 *
 * @interface Highcharts.PointUpdateEventObject
 * @extends global.Event
 */ /**
* Options data of the update event.
* @name Highcharts.PointUpdateEventObject#options
* @type {Highcharts.PointOptionsType}
*/ /**
 * @interface Highcharts.PointEventsOptionsObject
 */ /**
* Fires when the point is selected either programmatically or following a click
* on the point. One parameter, `event`, is passed to the function. Returning
* `false` cancels the operation.
* @name Highcharts.PointEventsOptionsObject#select
* @type {Highcharts.PointSelectCallbackFunction|undefined}
*/ /**
* Fires when the point is unselected either programmatically or following a
* click on the point. One parameter, `event`, is passed to the function.
* Returning `false` cancels the operation.
* @name Highcharts.PointEventsOptionsObject#unselect
* @type {Highcharts.PointUnselectCallbackFunction|undefined}
*/ /**
 * Information about the select/unselect event.
 *
 * @interface Highcharts.PointInteractionEventObject
 * @extends global.Event
 */ /**
* @name Highcharts.PointInteractionEventObject#accumulate
* @type {boolean}
*/ /**
 * Gets fired when the point is selected either programmatically or following a
 * click on the point.
 *
 * @callback Highcharts.PointSelectCallbackFunction
 *
 * @param {Highcharts.Point} this
 *        Point where the event occurred.
 *
 * @param {Highcharts.PointInteractionEventObject} event
 *        Event that occurred.
 */ /**
 * Fires when the point is unselected either programmatically or following a
 * click on the point.
 *
 * @callback Highcharts.PointUnselectCallbackFunction
 *
 * @param {Highcharts.Point} this
 *        Point where the event occurred.
 *
 * @param {Highcharts.PointInteractionEventObject} event
 *        Event that occurred.
 */ ''; // Keeps doclets above in JS file.
}),
"[project]/node_modules/highcharts/es-modules/Core/Series/SeriesRegistry.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Globals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Defaults.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Series$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Series/Point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Utilities.js [app-client] (ecmascript)");
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
;
;
const { defaultOptions } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Defaults$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
;
;
const { extend, extendClass, merge } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
/* *
 *
 *  Namespace
 *
 * */ var SeriesRegistry;
(function(SeriesRegistry) {
    /* *
     *
     *  Properties
     *
     * */ /**
     * @internal
     * @todo Move `Globals.seriesTypes` code to her.
     */ SeriesRegistry.seriesTypes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].seriesTypes;
    /* *
     *
     *  Functions
     *
     * */ /**
     * Registers class pattern of a series.
     *
     * @internal
     */ function registerSeriesType(seriesType, SeriesClass) {
        const defaultPlotOptions = defaultOptions.plotOptions || {}, seriesOptions = SeriesClass.defaultOptions, seriesProto = SeriesClass.prototype;
        seriesProto.type = seriesType;
        if (!seriesProto.pointClass) {
            seriesProto.pointClass = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Series$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
        }
        if (SeriesRegistry.seriesTypes[seriesType]) {
            return false;
        }
        if (seriesOptions) {
            defaultPlotOptions[seriesType] = seriesOptions;
        }
        SeriesRegistry.seriesTypes[seriesType] = SeriesClass;
        return true;
    }
    SeriesRegistry.registerSeriesType = registerSeriesType;
    /**
     * Old factory to create new series prototypes.
     *
     * @deprecated
     * @function Highcharts.seriesType
     *
     * @param {string} type
     * The series type name.
     *
     * @param {string} parent
     * The parent series type name. Use `line` to inherit from the basic
     * {@link Series} object.
     *
     * @param {Highcharts.SeriesOptionsType|Highcharts.Dictionary<*>} options
     * The additional default options that are merged with the parent's options.
     *
     * @param {Highcharts.Dictionary<*>} [props]
     * The properties (functions and primitives) to set on the new prototype.
     *
     * @param {Highcharts.Dictionary<*>} [pointProps]
     * Members for a series-specific extension of the {@link Point} prototype if
     * needed.
     *
     * @return {Highcharts.Series}
     * The newly created prototype as extended from {@link Series} or its
     * derivatives.
     */ function seriesType(type, parent, options, seriesProto, pointProto) {
        const defaultPlotOptions = defaultOptions.plotOptions || {};
        parent = parent || '';
        // Merge the options
        defaultPlotOptions[type] = merge(defaultPlotOptions[parent], options);
        // Create the class
        delete SeriesRegistry.seriesTypes[type];
        const parentClass = SeriesRegistry.seriesTypes[parent] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Series, childClass = extendClass(parentClass, seriesProto);
        registerSeriesType(type, childClass);
        SeriesRegistry.seriesTypes[type].prototype.type = type;
        // Create the point class if needed
        if (pointProto) {
            class PointClass extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Series$2f$Point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
            }
            extend(PointClass.prototype, pointProto);
            SeriesRegistry.seriesTypes[type].prototype.pointClass = PointClass;
        }
        return SeriesRegistry.seriesTypes[type];
    }
    SeriesRegistry.seriesType = seriesType;
})(SeriesRegistry || (SeriesRegistry = {}));
const __TURBOPACK__default__export__ = SeriesRegistry;
}),
"[project]/node_modules/highcharts/es-modules/Series/AreaRange/AreaRangePoint.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Series$2f$SeriesRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Series/SeriesRegistry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Utilities.js [app-client] (ecmascript)");
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
;
const { area: { prototype: { pointClass: AreaPoint, pointClass: { prototype: areaProto } } } } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Series$2f$SeriesRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].seriesTypes;
;
const { defined, isNumber } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
/* *
 *
 *  Class
 *
 * */ class AreaRangePoint extends AreaPoint {
    /* *
     *
     *  Functions
     *
     * */ /**
     * @private
     */ setState() {
        const prevState = this.state, series = this.series, isPolar = series.chart.polar;
        if (!defined(this.plotHigh)) {
            // Boost doesn't calculate plotHigh
            this.plotHigh = series.yAxis.toPixels(this.high, true);
        }
        if (!defined(this.plotLow)) {
            // Boost doesn't calculate plotLow
            this.plotLow = this.plotY = series.yAxis.toPixels(this.low, true);
        }
        series.lowerStateMarkerGraphic = series.stateMarkerGraphic;
        series.stateMarkerGraphic = series.upperStateMarkerGraphic;
        // Change state also for the top marker
        this.graphic = this.graphics && this.graphics[1];
        this.plotY = this.plotHigh;
        if (isPolar && isNumber(this.plotHighX)) {
            this.plotX = this.plotHighX;
        }
        // Top state:
        areaProto.setState.apply(this, arguments);
        this.state = prevState;
        // Now restore defaults
        this.plotY = this.plotLow;
        this.graphic = this.graphics && this.graphics[0];
        if (isPolar && isNumber(this.plotLowX)) {
            this.plotX = this.plotLowX;
        }
        series.upperStateMarkerGraphic = series.stateMarkerGraphic;
        series.stateMarkerGraphic = series.lowerStateMarkerGraphic;
        // Lower marker is stored at stateMarkerGraphic
        // to avoid reference duplication (#7021)
        series.lowerStateMarkerGraphic = void 0;
        const originalSettings = series.modifyMarkerSettings();
        // Bottom state
        areaProto.setState.apply(this, arguments);
        // Restore previous state
        series.restoreMarkerSettings(originalSettings);
    }
    haloPath() {
        const isPolar = this.series.chart.polar;
        let path = [];
        // Bottom halo
        this.plotY = this.plotLow;
        if (isPolar && isNumber(this.plotLowX)) {
            this.plotX = this.plotLowX;
        }
        if (this.isInside) {
            path = areaProto.haloPath.apply(this, arguments);
        }
        // Top halo
        this.plotY = this.plotHigh;
        if (isPolar && isNumber(this.plotHighX)) {
            this.plotX = this.plotHighX;
        }
        if (this.isTopInside) {
            path = path.concat(areaProto.haloPath.apply(this, arguments));
        }
        return path;
    }
    isValid() {
        return isNumber(this.low) && isNumber(this.high);
    }
}
const __TURBOPACK__default__export__ = AreaRangePoint;
/* *
 *
 *  API Options
 *
 * */ /**
 * Range series only. The high or maximum value for each data point.
 *
 * @name Highcharts.Point#high
 * @type {number|undefined}
 */ /**
 * Range series only. The low or minimum value for each data point.
 *
 * @name Highcharts.Point#low
 * @type {number|undefined}
 */ ''; // Keeps doclets above in JS file.
}),
"[project]/node_modules/highcharts/es-modules/Series/AreaRange/AreaRangeSeries.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Series$2f$AreaRange$2f$AreaRangePoint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Series/AreaRange/AreaRangePoint.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Globals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Series$2f$SeriesRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Series/SeriesRegistry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/highcharts/es-modules/Core/Utilities.js [app-client] (ecmascript)");
/* *
 *
 *  (c) 2010-2026 Highsoft AS
 *  Author: Torstein Honsi
 *
 *  A commercial license may be required depending on use.
 *  See www.highcharts.com/license
 *
 *
 * */ 'use strict';
;
;
const { noop } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
;
const { area: AreaSeries, area: { prototype: areaProto }, column: { prototype: columnProto } } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Series$2f$SeriesRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].seriesTypes;
;
const { addEvent, defined, extend, isArray, isNumber, pick, merge } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
/* *
 *
 *  Constants
 *
 * */ /**
 * The area range series is a carteseian series with higher and lower values for
 * each point along an X axis, where the area between the values is shaded.
 *
 * @sample {highcharts} highcharts/demo/arearange/
 *         Area range chart
 * @sample {highstock} stock/demo/arearange/
 *         Area range chart
 *
 * @extends      plotOptions.area
 * @product      highcharts highstock
 * @excluding    stack, stacking
 * @requires     highcharts-more
 * @optionparent plotOptions.arearange
 *
 * @private
 */ const areaRangeSeriesOptions = {
    /**
     * @see [fillColor](#plotOptions.arearange.fillColor)
     * @see [fillOpacity](#plotOptions.arearange.fillOpacity)
     *
     * @apioption plotOptions.arearange.color
     */ /**
     * @default   low
     * @apioption plotOptions.arearange.colorKey
     */ /**
     * @see [color](#plotOptions.arearange.color)
     * @see [fillOpacity](#plotOptions.arearange.fillOpacity)
     *
     * @apioption plotOptions.arearange.fillColor
     */ /**
     * @see [color](#plotOptions.arearange.color)
     * @see [fillColor](#plotOptions.arearange.fillColor)
     *
     * @default   {highcharts} 0.75
     * @default   {highstock} 0.75
     * @apioption plotOptions.arearange.fillOpacity
     */ /**
     * Whether to apply a drop shadow to the graph line. Since 2.3 the
     * shadow can be an object configuration containing `color`, `offsetX`,
     * `offsetY`, `opacity` and `width`.
     *
     * @type      {boolean|Highcharts.ShadowOptionsObject}
     * @product   highcharts
     * @apioption plotOptions.arearange.shadow
     */ /**
     * Pixel width of the arearange graph line.
     *
     * @since 2.3.0
     *
     * @private
     */ lineWidth: 1,
    /**
     * @type {number|null}
     */ threshold: null,
    tooltip: {
        pointFormat: '<span style="color:{series.color}">\u25CF</span> ' + '{series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
    },
    /**
     * Whether the whole area or just the line should respond to mouseover
     * tooltips and other mouse or touch events.
     *
     * @since 2.3.0
     *
     * @private
     */ trackByArea: true,
    /**
     * Extended data labels for range series types. Range series data
     * labels use no `x` and `y` options. Instead, they have `xLow`,
     * `xHigh`, `yLow` and `yHigh` options to allow the higher and lower
     * data label sets individually.
     *
     * @declare Highcharts.SeriesAreaRangeDataLabelsOptionsObject
     * @exclude x, y
     * @since   2.3.0
     * @product highcharts highstock
     *
     * @private
     */ dataLabels: {
        align: void 0,
        verticalAlign: void 0,
        /**
         * X offset of the lower data labels relative to the point value.
         *
         * @sample highcharts/plotoptions/arearange-datalabels/
         *         Data labels on range series
         * @sample highcharts/plotoptions/arearange-datalabels/
         *         Data labels on range series
         */ xLow: 0,
        /**
         * X offset of the higher data labels relative to the point value.
         *
         * @sample highcharts/plotoptions/arearange-datalabels/
         *         Data labels on range series
         */ xHigh: 0,
        /**
         * Y offset of the lower data labels relative to the point value.
         *
         * @sample highcharts/plotoptions/arearange-datalabels/
         *         Data labels on range series
         */ yLow: 0,
        /**
         * Y offset of the higher data labels relative to the point value.
         *
         * @sample highcharts/plotoptions/arearange-datalabels/
         *         Data labels on range series
         */ yHigh: 0
    }
};
/* *
 *
 *  Class
 *
 * */ /**
 * The AreaRange series type.
 *
 * @private
 * @class
 * @name Highcharts.seriesTypes.arearange
 *
 * @augments Highcharts.Series
 */ class AreaRangeSeries extends AreaSeries {
    /* *
     *
     *  Functions
     *
     * */ toYData(point) {
        return [
            point.low,
            point.high
        ];
    }
    /**
     * Translate a point's plotHigh from the internal angle and radius measures
     * to true plotHigh coordinates. This is an addition of the toXY method
     * found in Polar.js, because it runs too early for arearanges to be
     * considered (#3419).
     * @private
     */ highToXY(point) {
        // Find the polar plotX and plotY
        const chart = this.chart, xy = this.xAxis.postTranslate(point.rectPlotX || 0, this.yAxis.len - (point.plotHigh || 0));
        point.plotHighX = xy.x - chart.plotLeft;
        point.plotHigh = xy.y - chart.plotTop;
        point.plotLowX = point.plotX;
    }
    /**
     * Extend the line series' getSegmentPath method by applying the segment
     * path to both lower and higher values of the range.
     * @private
     */ getGraphPath(points) {
        const highPoints = [], highAreaPoints = [], getGraphPath = areaProto.getGraphPath, options = this.options, polar = this.chart.polar, connectEnds = polar && options.connectEnds !== false, connectNulls = options.connectNulls;
        let i, point, pointShim, step = options.step;
        points = points || this.points;
        // Create the top line and the top part of the area fill. The area fill
        // compensates for null points by drawing down to the lower graph,
        // moving across the null gap and starting again at the lower graph.
        i = points.length;
        while(i--){
            point = points[i];
            // Support for polar
            const highAreaPoint = polar ? {
                plotX: point.rectPlotX,
                plotY: point.yBottom,
                doCurve: false // #5186, gaps in areasplinerange fill
            } : {
                plotX: point.plotX,
                plotY: point.plotY,
                doCurve: false // #5186, gaps in areasplinerange fill
            };
            if (!point.isNull && !connectEnds && !connectNulls && (!points[i + 1] || points[i + 1].isNull)) {
                highAreaPoints.push(highAreaPoint);
            }
            pointShim = {
                polarPlotY: point.polarPlotY,
                rectPlotX: point.rectPlotX,
                yBottom: point.yBottom,
                // `plotHighX` is for polar charts
                plotX: pick(point.plotHighX, point.plotX),
                plotY: point.plotHigh,
                isNull: point.isNull
            };
            highAreaPoints.push(pointShim);
            highPoints.push(pointShim);
            if (!point.isNull && !connectEnds && !connectNulls && (!points[i - 1] || points[i - 1].isNull)) {
                highAreaPoints.push(highAreaPoint);
            }
        }
        // Get the paths
        const lowerPath = getGraphPath.call(this, points);
        if (step) {
            if (step === true) {
                step = 'left';
            }
            options.step = ({
                left: 'right',
                center: 'center',
                right: 'left'
            })[step]; // Swap for reading in getGraphPath
        }
        const higherPath = getGraphPath.call(this, highPoints);
        const higherAreaPath = getGraphPath.call(this, highAreaPoints);
        options.step = step;
        // Create a line on both top and bottom of the range
        const linePath = [].concat(lowerPath, higherPath);
        // For the area path, we need to change the 'move' statement into
        // 'lineTo'
        if (!this.chart.polar && higherAreaPath[0] && higherAreaPath[0][0] === 'M') {
            // This probably doesn't work for spline
            higherAreaPath[0] = [
                'L',
                higherAreaPath[0][1],
                higherAreaPath[0][2]
            ];
        }
        this.graphPath = linePath;
        this.areaPath = lowerPath.concat(higherAreaPath);
        // Prepare for sideways animation
        linePath.isArea = true;
        linePath.xMap = lowerPath.xMap;
        this.areaPath.xMap = lowerPath.xMap;
        return linePath;
    }
    /**
     * Extend the basic drawDataLabels method by running it for both lower and
     * higher values.
     * @private
     */ drawDataLabels() {
        const data = this.points, length = data.length, originalDataLabels = [], dataLabelOptions = this.options.dataLabels, inverted = this.chart.inverted;
        let i, point, up, upperDataLabelOptions, lowerDataLabelOptions;
        if (dataLabelOptions) {
            // Split into upper and lower options. If data labels is an array,
            // the first element is the upper label, the second is the lower.
            //
            // TODO: We want to change this and allow multiple labels for both
            // upper and lower values in the future - introducing some options
            // for which point value to use as Y for the dataLabel, so that this
            // could be handled in Series.drawDataLabels. This would also
            // improve performance since we now have to loop over all the points
            // multiple times to work around the data label logic.
            if (isArray(dataLabelOptions)) {
                upperDataLabelOptions = dataLabelOptions[0] || {
                    enabled: false
                };
                lowerDataLabelOptions = dataLabelOptions[1] || {
                    enabled: false
                };
            } else {
                // Make copies
                upperDataLabelOptions = extend({}, dataLabelOptions);
                upperDataLabelOptions.x = dataLabelOptions.xHigh;
                upperDataLabelOptions.y = dataLabelOptions.yHigh;
                lowerDataLabelOptions = extend({}, dataLabelOptions);
                lowerDataLabelOptions.x = dataLabelOptions.xLow;
                lowerDataLabelOptions.y = dataLabelOptions.yLow;
            }
            // Draw upper labels
            if (upperDataLabelOptions.enabled || this.hasDataLabels?.()) {
                // Set preliminary values for plotY and dataLabel
                // and draw the upper labels
                i = length;
                while(i--){
                    point = data[i];
                    if (point) {
                        const { plotHigh = 0, plotLow = 0 } = point;
                        up = upperDataLabelOptions.inside ? plotHigh < plotLow : plotHigh > plotLow;
                        point.y = point.high;
                        point._plotY = point.plotY;
                        point.plotY = plotHigh;
                        // Store original data labels and set preliminary label
                        // objects to be picked up in the uber method
                        originalDataLabels[i] = point.dataLabel;
                        point.dataLabel = point.dataLabelUpper;
                        // Set the default offset
                        point.below = up;
                        if (inverted) {
                            if (!upperDataLabelOptions.align) {
                                upperDataLabelOptions.align = up ? 'right' : 'left';
                            }
                        } else {
                            if (!upperDataLabelOptions.verticalAlign) {
                                upperDataLabelOptions.verticalAlign = up ? 'top' : 'bottom';
                            }
                        }
                    }
                }
                this.options.dataLabels = upperDataLabelOptions;
                if (areaProto.drawDataLabels) {
                    // #1209:
                    areaProto.drawDataLabels.apply(this, arguments);
                }
                // Reset state after the upper labels were created. Move
                // it to point.dataLabelUpper and reassign the originals.
                // We do this here to support not drawing a lower label.
                i = length;
                while(i--){
                    point = data[i];
                    if (point) {
                        point.dataLabelUpper = point.dataLabel;
                        point.dataLabel = originalDataLabels[i];
                        delete point.dataLabels;
                        point.y = point.low;
                        point.plotY = point._plotY;
                    }
                }
            }
            // Draw lower labels
            if (lowerDataLabelOptions.enabled || this.hasDataLabels?.()) {
                i = length;
                while(i--){
                    point = data[i];
                    if (point) {
                        const { plotHigh = 0, plotLow = 0 } = point;
                        up = lowerDataLabelOptions.inside ? plotHigh < plotLow : plotHigh > plotLow;
                        // Set the default offset
                        point.below = !up;
                        if (inverted) {
                            if (!lowerDataLabelOptions.align) {
                                lowerDataLabelOptions.align = up ? 'left' : 'right';
                            }
                        } else {
                            if (!lowerDataLabelOptions.verticalAlign) {
                                lowerDataLabelOptions.verticalAlign = up ? 'bottom' : 'top';
                            }
                        }
                    }
                }
                this.options.dataLabels = lowerDataLabelOptions;
                if (areaProto.drawDataLabels) {
                    areaProto.drawDataLabels.apply(this, arguments);
                }
            }
            // Merge upper and lower into point.dataLabels for later destroying
            if (upperDataLabelOptions.enabled) {
                i = length;
                while(i--){
                    point = data[i];
                    if (point) {
                        point.dataLabels = [
                            point.dataLabelUpper,
                            point.dataLabel
                        ].filter(function(label) {
                            return !!label;
                        });
                    }
                }
            }
            // Reset options
            this.options.dataLabels = dataLabelOptions;
        }
    }
    alignDataLabel() {
        columnProto.alignDataLabel.apply(this, arguments);
    }
    modifyMarkerSettings() {
        const series = this, originalMarkerSettings = {
            marker: series.options.marker,
            symbol: series.symbol
        };
        if (series.options.lowMarker) {
            const { options: { marker, lowMarker } } = series;
            series.options.marker = merge(marker, lowMarker);
            if (lowMarker.symbol) {
                series.symbol = lowMarker.symbol;
            }
        }
        return originalMarkerSettings;
    }
    restoreMarkerSettings(originalSettings) {
        const series = this;
        series.options.marker = originalSettings.marker;
        series.symbol = originalSettings.symbol;
    }
    drawPoints() {
        const series = this, pointLength = series.points.length;
        let i, point;
        const originalSettings = series.modifyMarkerSettings();
        // Draw bottom points
        areaProto.drawPoints.apply(series, arguments);
        // Restore previous state
        series.restoreMarkerSettings(originalSettings);
        // Prepare drawing top points
        i = 0;
        while(i < pointLength){
            point = series.points[i];
            point.graphics = point.graphics || [];
            // Save original props to be overridden by temporary props for top
            // points
            point.origProps = {
                plotY: point.plotY,
                plotX: point.plotX,
                isInside: point.isInside,
                negative: point.negative,
                zone: point.zone,
                y: point.y
            };
            if (point.graphic || point.graphics[0]) {
                point.graphics[0] = point.graphic;
            }
            point.graphic = point.graphics[1];
            point.plotY = point.plotHigh;
            if (defined(point.plotHighX)) {
                point.plotX = point.plotHighX;
            }
            point.y = pick(point.high, point.origProps.y); // #15523
            point.negative = point.y < (series.options.threshold || 0);
            if (series.zones.length) {
                point.zone = point.getZone();
            }
            if (!series.chart.polar) {
                point.isInside = point.isTopInside = typeof point.plotY !== 'undefined' && point.plotY >= 0 && point.plotY <= series.yAxis.len && // #3519
                point.plotX >= 0 && point.plotX <= series.xAxis.len;
            }
            i++;
        }
        // Draw top points
        areaProto.drawPoints.apply(series, arguments);
        // Reset top points preliminary modifications
        i = 0;
        while(i < pointLength){
            point = series.points[i];
            point.graphics = point.graphics || [];
            if (point.graphic || point.graphics[1]) {
                point.graphics[1] = point.graphic;
            }
            point.graphic = point.graphics[0];
            if (point.origProps) {
                extend(point, point.origProps);
                delete point.origProps;
            }
            i++;
        }
    }
    hasMarkerChanged(options, oldOptions) {
        const lowMarker = options.lowMarker, oldMarker = oldOptions.lowMarker || {};
        return lowMarker && (lowMarker.enabled === false || oldMarker.symbol !== lowMarker.symbol || // #10870, #15946
        oldMarker.height !== lowMarker.height || // #16274
        oldMarker.width !== lowMarker.width // #16274
        ) || super.hasMarkerChanged(options, oldOptions);
    }
}
/**
 *
 *  Static Properties
 *
 */ AreaRangeSeries.defaultOptions = merge(AreaSeries.defaultOptions, areaRangeSeriesOptions);
addEvent(AreaRangeSeries, 'afterTranslate', function() {
    // Set plotLow and plotHigh
    // Rules out lollipop, but lollipop should not inherit range series in the
    // first place
    if (this.pointArrayMap.join(',') === 'low,high') {
        this.points.forEach((point)=>{
            const high = point.high, plotY = point.plotY;
            if (point.isNull) {
                point.plotY = void 0;
            } else {
                point.plotLow = plotY;
                // Calculate plotHigh value based on each yAxis scale (#15752)
                point.plotHigh = isNumber(high) ? this.yAxis.translate(this.dataModify ? this.dataModify.modifyValue(high) : high, false, true, void 0, true) : void 0;
                if (this.dataModify) {
                    point.yBottom = point.plotHigh;
                }
            }
        });
    }
}, {
    order: 0
});
addEvent(AreaRangeSeries, 'afterTranslate', function() {
    this.points.forEach((point)=>{
        // Postprocessing after the PolarComposition's afterTranslate
        if (this.chart.polar) {
            this.highToXY(point);
            point.plotLow = point.plotY;
            point.tooltipPos = [
                ((point.plotHighX || 0) + (point.plotLowX || 0)) / 2,
                ((point.plotHigh || 0) + (point.plotLow || 0)) / 2
            ];
        // Put the tooltip in the middle of the range
        } else {
            const tooltipPos = point.pos(false, point.plotLow), posHigh = point.pos(false, point.plotHigh);
            if (tooltipPos && posHigh) {
                tooltipPos[0] = (tooltipPos[0] + posHigh[0]) / 2;
                tooltipPos[1] = (tooltipPos[1] + posHigh[1]) / 2;
            }
            point.tooltipPos = tooltipPos;
        }
    });
}, {
    order: 3
});
extend(AreaRangeSeries.prototype, {
    deferTranslatePolar: true,
    pointArrayMap: [
        'low',
        'high'
    ],
    pointClass: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Series$2f$AreaRange$2f$AreaRangePoint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    pointValKey: 'low',
    setStackedPoints: noop
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$highcharts$2f$es$2d$modules$2f$Core$2f$Series$2f$SeriesRegistry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].registerSeriesType('arearange', AreaRangeSeries);
const __TURBOPACK__default__export__ = AreaRangeSeries;
}),
]);

//# sourceMappingURL=node_modules_cd340ea4._.js.map