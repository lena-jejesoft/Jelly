{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Extensions/ScrollablePlotArea.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n *  Highcharts feature to make the Y axis stay fixed when scrolling the chart\n *  horizontally on mobile devices. Supports left and right side axes.\n */\n'use strict';\nimport A from '../Core/Animation/AnimationUtilities.js';\nconst { stop } = A;\nimport H from '../Core/Globals.js';\nconst { composed } = H;\nimport RendererRegistry from '../Core/Renderer/RendererRegistry.js';\nimport U from '../Core/Utilities.js';\nconst { addEvent, createElement, css, defined, erase, merge, pushUnique } = U;\n/* *\n *\n *  Functions\n *\n * */\n/** @internal */\nfunction onChartRender() {\n    let scrollablePlotArea = this.scrollablePlotArea;\n    if ((this.scrollablePixelsX || this.scrollablePixelsY) &&\n        !scrollablePlotArea) {\n        this.scrollablePlotArea = scrollablePlotArea = new ScrollablePlotArea(this);\n    }\n    scrollablePlotArea?.applyFixed();\n}\n/** @internal */\nfunction markDirty() {\n    if (this.chart.scrollablePlotArea) {\n        this.chart.scrollablePlotArea.isDirty = true;\n    }\n}\nclass ScrollablePlotArea {\n    static compose(AxisClass, ChartClass, SeriesClass) {\n        if (pushUnique(composed, this.compose)) {\n            addEvent(AxisClass, 'afterInit', markDirty);\n            addEvent(ChartClass, 'afterSetChartSize', (e) => this.afterSetSize(e.target, e));\n            addEvent(ChartClass, 'render', onChartRender);\n            addEvent(SeriesClass, 'show', markDirty);\n        }\n    }\n    /** @internal */\n    static afterSetSize(chart, e) {\n        const { minWidth, minHeight } = chart.options.chart.scrollablePlotArea || {}, { clipBox, plotBox, inverted, renderer } = chart;\n        let scrollablePixelsX, scrollablePixelsY, recalculateHoriz;\n        // Skip for exporting\n        if (renderer.forExport) {\n            return;\n        }\n        // The amount of pixels to scroll, the difference between chart width\n        // and scrollable width\n        if (minWidth) {\n            chart.scrollablePixelsX = scrollablePixelsX = Math.max(0, minWidth - chart.chartWidth);\n            if (scrollablePixelsX) {\n                chart.scrollablePlotBox = merge(chart.plotBox);\n                plotBox.width = chart.plotWidth += scrollablePixelsX;\n                clipBox[inverted ? 'height' : 'width'] += scrollablePixelsX;\n                recalculateHoriz = true;\n            }\n            // Currently we can only do either X or Y\n        }\n        else if (minHeight) {\n            chart.scrollablePixelsY = scrollablePixelsY = Math.max(0, minHeight - chart.chartHeight);\n            if (defined(scrollablePixelsY)) {\n                chart.scrollablePlotBox = merge(chart.plotBox);\n                plotBox.height = chart.plotHeight += scrollablePixelsY;\n                clipBox[inverted ? 'width' : 'height'] += scrollablePixelsY;\n                recalculateHoriz = false;\n            }\n        }\n        if (defined(recalculateHoriz)) {\n            if (!e.skipAxes) {\n                for (const axis of chart.axes) {\n                    // Apply the corrected plot size to the axes of the other\n                    // orientation than the scrolling direction\n                    if (axis.horiz === recalculateHoriz ||\n                        // Or parallel axes\n                        (chart.hasParallelCoordinates && axis.coll === 'yAxis')) {\n                        axis.setAxisSize();\n                        axis.setAxisTranslation();\n                    }\n                }\n            }\n        }\n        else {\n            // Clear (potential) old box when a new one was not set\n            delete chart.scrollablePlotBox;\n        }\n    }\n    constructor(chart) {\n        const chartOptions = chart.options.chart, Renderer = RendererRegistry.getRendererType(), scrollableOptions = chartOptions.scrollablePlotArea || {}, moveFixedElements = this.moveFixedElements.bind(this), styles = {\n            WebkitOverflowScrolling: 'touch',\n            overflowX: 'hidden',\n            overflowY: 'hidden'\n        };\n        if (chart.scrollablePixelsX) {\n            styles.overflowX = 'auto';\n        }\n        if (chart.scrollablePixelsY) {\n            styles.overflowY = 'auto';\n        }\n        this.chart = chart;\n        // Insert a container with relative position that scrolling and fixed\n        // container renders to (#10555)\n        const parentDiv = this.parentDiv = createElement('div', {\n            className: 'highcharts-scrolling-parent'\n        }, {\n            position: 'relative'\n        }, chart.renderTo), \n        // Add the necessary divs to provide scrolling\n        scrollingContainer = this.scrollingContainer = createElement('div', {\n            'className': 'highcharts-scrolling'\n        }, styles, parentDiv), innerContainer = this.innerContainer = createElement('div', {\n            'className': 'highcharts-inner-container'\n        }, void 0, scrollingContainer), fixedDiv = this.fixedDiv = createElement('div', {\n            className: 'highcharts-fixed'\n        }, {\n            position: 'absolute',\n            overflow: 'hidden',\n            pointerEvents: 'none',\n            zIndex: (chartOptions.style?.zIndex || 0) + 2,\n            top: 0\n        }, void 0, true), fixedRenderer = this.fixedRenderer = new Renderer(fixedDiv, chart.chartWidth, chart.chartHeight, chartOptions.style);\n        // Mask\n        this.mask = fixedRenderer\n            .path()\n            .attr({\n            fill: chartOptions.backgroundColor || '#fff',\n            'fill-opacity': scrollableOptions.opacity ?? 0.85,\n            zIndex: -1\n        })\n            .addClass('highcharts-scrollable-mask')\n            .add();\n        scrollingContainer.parentNode.insertBefore(fixedDiv, scrollingContainer);\n        css(chart.renderTo, { overflow: 'visible' });\n        addEvent(chart, 'afterShowResetZoom', moveFixedElements);\n        addEvent(chart, 'afterApplyDrilldown', moveFixedElements);\n        addEvent(chart, 'afterLayOutTitles', moveFixedElements);\n        // On scroll, reset the chart position because it applies to the\n        // scrolled container\n        let lastHoverPoint;\n        addEvent(scrollingContainer, 'scroll', () => {\n            const { pointer, hoverPoint } = chart;\n            if (pointer) {\n                delete pointer.chartPosition;\n                if (hoverPoint) {\n                    lastHoverPoint = hoverPoint;\n                }\n                pointer.runPointActions(void 0, lastHoverPoint, true);\n            }\n        });\n        // Now move the container inside\n        innerContainer.appendChild(chart.container);\n    }\n    applyFixed() {\n        const { chart, fixedRenderer, isDirty, scrollingContainer } = this, { axisOffset, chartWidth, chartHeight, container, plotHeight, plotLeft, plotTop, plotWidth, scrollablePixelsX = 0, scrollablePixelsY = 0 } = chart, chartOptions = chart.options.chart, scrollableOptions = chartOptions.scrollablePlotArea || {}, { scrollPositionX = 0, scrollPositionY = 0 } = scrollableOptions, scrollableWidth = chartWidth + scrollablePixelsX, scrollableHeight = chartHeight + scrollablePixelsY;\n        // Set the size of the fixed renderer to the visible width\n        fixedRenderer.setSize(chartWidth, chartHeight);\n        if (isDirty ?? true) {\n            this.isDirty = false;\n            this.moveFixedElements();\n        }\n        // Increase the size of the scrollable renderer and background\n        stop(chart.container);\n        css(container, {\n            width: `${scrollableWidth}px`,\n            height: `${scrollableHeight}px`\n        });\n        chart.renderer.boxWrapper.attr({\n            width: scrollableWidth,\n            height: scrollableHeight,\n            viewBox: [0, 0, scrollableWidth, scrollableHeight].join(' ')\n        });\n        chart.chartBackground?.attr({\n            width: scrollableWidth,\n            height: scrollableHeight\n        });\n        css(scrollingContainer, {\n            width: `${chartWidth}px`,\n            height: `${chartHeight}px`\n        });\n        // Set scroll position the first time (this.isDirty was undefined at\n        // the top of this function)\n        if (!defined(isDirty)) {\n            scrollingContainer.scrollLeft = scrollablePixelsX * scrollPositionX;\n            scrollingContainer.scrollTop = scrollablePixelsY * scrollPositionY;\n        }\n        // Mask behind the left and right side\n        const maskTop = plotTop - axisOffset[0] - 1, maskLeft = plotLeft - axisOffset[3] - 1, maskBottom = plotTop + plotHeight + axisOffset[2] + 1, maskRight = plotLeft + plotWidth + axisOffset[1] + 1, maskPlotRight = plotLeft + plotWidth - scrollablePixelsX, maskPlotBottom = plotTop + plotHeight - scrollablePixelsY;\n        let d = [['M', 0, 0]];\n        if (scrollablePixelsX) {\n            d = [\n                // Left side\n                ['M', 0, maskTop],\n                ['L', plotLeft - 1, maskTop],\n                ['L', plotLeft - 1, maskBottom],\n                ['L', 0, maskBottom],\n                ['Z'],\n                // Right side\n                ['M', maskPlotRight, maskTop],\n                ['L', chartWidth, maskTop],\n                ['L', chartWidth, maskBottom],\n                ['L', maskPlotRight, maskBottom],\n                ['Z']\n            ];\n        }\n        else if (scrollablePixelsY) {\n            d = [\n                // Top side\n                ['M', maskLeft, 0],\n                ['L', maskLeft, plotTop - 1],\n                ['L', maskRight, plotTop - 1],\n                ['L', maskRight, 0],\n                ['Z'],\n                // Bottom side\n                ['M', maskLeft, maskPlotBottom],\n                ['L', maskLeft, chartHeight],\n                ['L', maskRight, chartHeight],\n                ['L', maskRight, maskPlotBottom],\n                ['Z']\n            ];\n        }\n        if (chart.redrawTrigger !== 'adjustHeight') {\n            this.mask.attr({ d });\n        }\n    }\n    /**\n     * These elements are moved over to the fixed renderer and stay fixed when\n     * the user scrolls the chart\n     * @internal\n     */\n    moveFixedElements() {\n        const { container, inverted, scrollablePixelsX, scrollablePixelsY } = this.chart, fixedRenderer = this.fixedRenderer, fixedSelectors = ScrollablePlotArea.fixedSelectors;\n        let axisClass;\n        if (scrollablePixelsX && !inverted) {\n            axisClass = '.highcharts-yaxis';\n        }\n        else if (scrollablePixelsX && inverted) {\n            axisClass = '.highcharts-xaxis';\n        }\n        else if (scrollablePixelsY && !inverted) {\n            axisClass = '.highcharts-xaxis';\n        }\n        else if (scrollablePixelsY && inverted) {\n            axisClass = '.highcharts-yaxis';\n        }\n        if (axisClass && !(this.chart.hasParallelCoordinates &&\n            axisClass === '.highcharts-yaxis')) {\n            // Add if not added yet\n            for (const className of [\n                `${axisClass}:not(.highcharts-radial-axis)`,\n                `${axisClass}-labels:not(.highcharts-radial-axis-labels)`\n            ]) {\n                pushUnique(fixedSelectors, className);\n            }\n        }\n        else {\n            // Clear all axis related selectors\n            for (const classBase of [\n                '.highcharts-xaxis',\n                '.highcharts-yaxis'\n            ]) {\n                for (const className of [\n                    `${classBase}:not(.highcharts-radial-axis)`,\n                    `${classBase}-labels:not(.highcharts-radial-axis-labels)`\n                ]) {\n                    erase(fixedSelectors, className);\n                }\n            }\n        }\n        for (const className of fixedSelectors) {\n            [].forEach.call(container.querySelectorAll(className), (elem) => {\n                (elem.namespaceURI === fixedRenderer.SVG_NS ?\n                    fixedRenderer.box :\n                    fixedRenderer.box.parentNode).appendChild(elem);\n                elem.style.pointerEvents = 'auto';\n            });\n        }\n    }\n}\n/** @internal */\nScrollablePlotArea.fixedSelectors = [\n    '.highcharts-breadcrumbs-group',\n    '.highcharts-contextbutton',\n    '.highcharts-caption',\n    '.highcharts-credits',\n    '.highcharts-drillup-button',\n    '.highcharts-legend',\n    '.highcharts-legend-checkbox',\n    '.highcharts-navigator-series',\n    '.highcharts-navigator-xaxis',\n    '.highcharts-navigator-yaxis',\n    '.highcharts-navigator',\n    '.highcharts-range-selector-group',\n    '.highcharts-reset-zoom',\n    '.highcharts-scrollbar',\n    '.highcharts-subtitle',\n    '.highcharts-title'\n];\n/* *\n *\n *  Default Export\n *\n * */\nexport default ScrollablePlotArea;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Options for a scrollable plot area. This feature provides a minimum size for\n * the plot area of the chart. If the size gets smaller than this, typically\n * on mobile devices, a native browser scrollbar is presented. This scrollbar\n * provides smooth scrolling for the contents of the plot area, whereas the\n * title, legend and unaffected axes are fixed.\n *\n * Since v7.1.2, a scrollable plot area can be defined for either horizontal or\n * vertical scrolling, depending on whether the `minWidth` or `minHeight`\n * option is set.\n *\n * @sample highcharts/chart/scrollable-plotarea\n *         Scrollable plot area\n * @sample highcharts/chart/scrollable-plotarea-vertical\n *         Vertically scrollable plot area\n * @sample {gantt} gantt/chart/scrollable-plotarea-vertical\n *         Gantt chart with vertically scrollable plot area\n *\n * @since     6.1.0\n * @product   highcharts gantt\n * @apioption chart.scrollablePlotArea\n */\n/**\n * The minimum height for the plot area. If it gets smaller than this, the plot\n * area will become scrollable.\n *\n * @type      {number}\n * @since     7.1.2\n * @apioption chart.scrollablePlotArea.minHeight\n */\n/**\n * The minimum width for the plot area. If it gets smaller than this, the plot\n * area will become scrollable.\n *\n * @type      {number}\n * @since     6.1.0\n * @apioption chart.scrollablePlotArea.minWidth\n */\n/**\n * The initial scrolling position of the scrollable plot area. Ranges from 0 to\n * 1, where 0 aligns the plot area to the left and 1 aligns it to the right.\n * Typically we would use 1 if the chart has right aligned Y axes.\n *\n * @type      {number}\n * @since     6.1.0\n * @apioption chart.scrollablePlotArea.scrollPositionX\n */\n/**\n * The initial scrolling position of the scrollable plot area. Ranges from 0 to\n * 1, where 0 aligns the plot area to the top and 1 aligns it to the bottom.\n *\n * @type      {number}\n * @since     7.1.2\n * @apioption chart.scrollablePlotArea.scrollPositionY\n */\n/**\n * The opacity of mask applied on one of the sides of the plot\n * area.\n *\n * @sample {highcharts} highcharts/chart/scrollable-plotarea-opacity\n *         Disabled opacity for the mask\n *\n * @type        {number}\n * @default     0.85\n * @since       7.1.1\n * @apioption   chart.scrollablePlotArea.opacity\n */\n(''); // Keep doclets above in transpiled file\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 452, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Extensions/BorderRadius.js"],"sourcesContent":["/* *\n *\n *  Highcharts Border Radius module\n *\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport D from '../Core/Defaults.js';\nconst { defaultOptions } = D;\nimport H from '../Core/Globals.js';\nconst { noop } = H;\nimport U from '../Core/Utilities.js';\nconst { addEvent, extend, isObject, merge, relativeLength } = U;\n/* *\n *\n *  Constants\n *\n * */\nconst defaultBorderRadiusOptions = {\n    radius: 0,\n    scope: 'stack',\n    where: void 0\n};\n/* *\n *\n *  Variables\n *\n * */\nlet oldArc = noop;\nlet oldRoundedRect = noop;\n/* *\n *\n *  Functions\n *\n * */\n/** @internal */\nfunction applyBorderRadius(path, i, r) {\n    const a = path[i];\n    let b = path[i + 1];\n    if (b[0] === 'Z') {\n        b = path[0];\n    }\n    let line, arc, fromLineToArc;\n    // From straight line to arc\n    if ((a[0] === 'M' || a[0] === 'L') && b[0] === 'A') {\n        line = a;\n        arc = b;\n        fromLineToArc = true;\n        // From arc to straight line\n    }\n    else if (a[0] === 'A' && (b[0] === 'M' || b[0] === 'L')) {\n        line = b;\n        arc = a;\n    }\n    if (line && arc && arc.params) {\n        const bigR = arc[1], \n        // In our use cases, outer pie slice arcs are clockwise and inner\n        // arcs (donut/sunburst etc) are anti-clockwise\n        clockwise = arc[5], params = arc.params, { start, end, cx, cy } = params;\n        // Some geometric constants\n        const relativeR = clockwise ? (bigR - r) : (bigR + r), \n        // The angle, on the big arc, that the border radius arc takes up\n        angleOfBorderRadius = relativeR ? Math.asin(r / relativeR) : 0, angleOffset = clockwise ?\n            angleOfBorderRadius :\n            -angleOfBorderRadius, \n        // The distance along the radius of the big arc to the starting\n        // point of the small border radius arc\n        distanceBigCenterToStartArc = (Math.cos(angleOfBorderRadius) *\n            relativeR);\n        // From line to arc\n        if (fromLineToArc) {\n            // Update the cache\n            params.start = start + angleOffset;\n            // First move to the start position at the radial line. We want to\n            // start one borderRadius closer to the center.\n            line[1] = cx + distanceBigCenterToStartArc * Math.cos(start);\n            line[2] = cy + distanceBigCenterToStartArc * Math.sin(start);\n            // Now draw an arc towards the point where the small circle touches\n            // the great circle.\n            path.splice(i + 1, 0, [\n                'A',\n                r,\n                r,\n                0, // Slanting,\n                0, // Long arc\n                1, // Clockwise\n                cx + bigR * Math.cos(params.start),\n                cy + bigR * Math.sin(params.start)\n            ]);\n            // From arc to line\n        }\n        else {\n            // Update the cache\n            params.end = end - angleOffset;\n            // End the big arc a bit earlier\n            arc[6] = cx + bigR * Math.cos(params.end);\n            arc[7] = cy + bigR * Math.sin(params.end);\n            // Draw a small arc towards a point on the end angle, but one\n            // borderRadius closer to the center relative to the perimeter.\n            path.splice(i + 1, 0, [\n                'A',\n                r,\n                r,\n                0,\n                0,\n                1,\n                cx + distanceBigCenterToStartArc * Math.cos(end),\n                cy + distanceBigCenterToStartArc * Math.sin(end)\n            ]);\n        }\n        // Long or short arc must be reconsidered because we have modified the\n        // start and end points\n        arc[4] = Math.abs(params.end - params.start) < Math.PI ? 0 : 1;\n    }\n}\n/**\n * Extend arc with borderRadius.\n * @internal\n */\nfunction arc(x, y, w, h, options = {}) {\n    const path = oldArc(x, y, w, h, options), { brStart = true, brEnd = true, innerR = 0, r = w, start = 0, end = 0 } = options;\n    if (options.open || !options.borderRadius) {\n        return path;\n    }\n    const alpha = end - start, sinHalfAlpha = Math.sin(alpha / 2), borderRadius = Math.max(Math.min(relativeLength(options.borderRadius || 0, r - innerR), \n    // Cap to half the sector radius\n    (r - innerR) / 2, \n    // For smaller pie slices, cap to the largest small circle that\n    // can be fitted within the sector\n    (r * sinHalfAlpha) / (1 + sinHalfAlpha)), 0), \n    // For the inner radius, we need an extra cap because the inner arc\n    // is shorter than the outer arc\n    innerBorderRadius = Math.min(borderRadius, 2 * (alpha / Math.PI) * innerR);\n    // Apply turn-by-turn border radius. Start at the end since we're\n    // splicing in arc segments.\n    let i = path.length - 1;\n    while (i--) {\n        if ((!brStart && (i === 0 || i === 3)) ||\n            (!brEnd && (i === 1 || i === 2))) {\n            continue;\n        }\n        applyBorderRadius(path, i, i > 1 ? innerBorderRadius : borderRadius);\n    }\n    return path;\n}\n/** @internal */\nfunction seriesOnAfterColumnTranslate() {\n    if (this.options.borderRadius &&\n        !(this.chart.is3d && this.chart.is3d())) {\n        const { options, yAxis } = this, percent = options.stacking === 'percent', seriesDefault = defaultOptions.plotOptions?.[this.type]\n            ?.borderRadius, borderRadius = optionsToObject(options.borderRadius, isObject(seriesDefault) ? seriesDefault : {}), reversed = yAxis.options.reversed;\n        for (const point of this.points) {\n            const { shapeArgs } = point;\n            if (point.shapeType === 'roundedRect' && shapeArgs) {\n                const { width = 0, height = 0, y = 0 } = shapeArgs;\n                let brBoxY = y, brBoxHeight = height;\n                // It would be nice to refactor StackItem.getStackBox/\n                // setOffset so that we could get a reliable box out of\n                // it. Currently it is close if we remove the label\n                // offset, but we still need to run crispCol and also\n                // flip it if inverted, so atm it is simpler to do it\n                // like the below.\n                if (borderRadius.scope === 'stack' &&\n                    point.stackTotal) {\n                    const stackEnd = yAxis.translate(percent ? 100 : point.stackTotal, false, true, false, true), stackThreshold = yAxis.translate(options.threshold || 0, false, true, false, true), box = this.crispCol(0, Math.min(stackEnd, stackThreshold), 0, Math.abs(stackEnd - stackThreshold));\n                    brBoxY = box.y;\n                    brBoxHeight = box.height;\n                }\n                const flip = (point.negative ? -1 : 1) *\n                    (reversed ? -1 : 1) === -1;\n                // Handle the where option\n                let where = borderRadius.where;\n                // Waterfall, hanging columns should have rounding on\n                // all sides\n                if (!where &&\n                    this.is('waterfall') &&\n                    Math.abs((point.yBottom || 0) -\n                        (this.translatedThreshold || 0)) > this.borderWidth) {\n                    where = 'all';\n                }\n                if (!where) {\n                    where = 'end';\n                }\n                // Get the radius\n                const r = Math.min(relativeLength(borderRadius.radius, width), width / 2, \n                // Cap to the height, but not if where is `end`\n                where === 'all' ? height / 2 : Infinity) || 0;\n                // If the `where` option is 'end', cut off the\n                // rectangles by making the border-radius box one r\n                // greater, so that the imaginary radius falls outside\n                // the rectangle.\n                if (where === 'end') {\n                    if (flip) {\n                        brBoxY -= r;\n                        brBoxHeight += r;\n                    }\n                    else {\n                        brBoxHeight += r;\n                    }\n                }\n                extend(shapeArgs, { brBoxHeight, brBoxY, r });\n            }\n        }\n    }\n}\n/** @internal */\nfunction compose(SeriesClass, SVGElementClass, SVGRendererClass) {\n    const PieSeriesClass = SeriesClass.types.pie;\n    if (!SVGElementClass.symbolCustomAttribs.includes('borderRadius')) {\n        const symbols = SVGRendererClass.prototype.symbols;\n        addEvent(SeriesClass, 'afterColumnTranslate', seriesOnAfterColumnTranslate, {\n            // After columnrange and polar column modifications\n            order: 9\n        });\n        addEvent(PieSeriesClass, 'afterTranslate', pieSeriesOnAfterTranslate);\n        SVGElementClass.symbolCustomAttribs.push('borderRadius', 'brBoxHeight', 'brBoxY', 'brEnd', 'brStart');\n        oldArc = symbols.arc;\n        oldRoundedRect = symbols.roundedRect;\n        symbols.arc = arc;\n        symbols.roundedRect = roundedRect;\n    }\n}\n/** @internal */\nfunction optionsToObject(options, seriesBROptions) {\n    if (!isObject(options)) {\n        options = { radius: options || 0 };\n    }\n    return merge(defaultBorderRadiusOptions, seriesBROptions, options);\n}\n/** @internal */\nfunction pieSeriesOnAfterTranslate() {\n    const borderRadius = optionsToObject(this.options.borderRadius);\n    for (const point of this.points) {\n        const shapeArgs = point.shapeArgs;\n        if (shapeArgs) {\n            shapeArgs.borderRadius = relativeLength(borderRadius.radius, (shapeArgs.r || 0) - ((shapeArgs.innerR) || 0));\n        }\n    }\n}\n/**\n * Extend roundedRect with individual cutting through rOffset.\n * @internal\n */\nfunction roundedRect(x, y, width, height, options = {}) {\n    const path = oldRoundedRect(x, y, width, height, options), { r = 0, brBoxHeight = height, brBoxY = y } = options, brOffsetTop = y - brBoxY, brOffsetBtm = (brBoxY + brBoxHeight) - (y + height), \n    // When the distance to the border-radius box is greater than the r\n    // itself, it means no border radius. The -0.1 accounts for float\n    // rounding errors.\n    rTop = (brOffsetTop - r) > -0.1 ? 0 : r, rBtm = (brOffsetBtm - r) > -0.1 ? 0 : r, cutTop = Math.max(rTop && brOffsetTop, 0), cutBtm = Math.max(rBtm && brOffsetBtm, 0);\n    /*\n\n    The naming of control points:\n\n      / a -------- b \\\n     /                \\\n    h                  c\n    |                  |\n    |                  |\n    |                  |\n    g                  d\n     \\                /\n      \\ f -------- e /\n\n    */\n    const a = [x + rTop, y], b = [x + width - rTop, y], c = [x + width, y + rTop], d = [\n        x + width, y + height - rBtm\n    ], e = [\n        x + width - rBtm,\n        y + height\n    ], f = [x + rBtm, y + height], g = [x, y + height - rBtm], h = [x, y + rTop];\n    const applyPythagoras = (r, altitude) => Math.sqrt(Math.pow(r, 2) - Math.pow(altitude, 2));\n    // Inside stacks, cut off part of the top\n    if (cutTop) {\n        const base = applyPythagoras(rTop, rTop - cutTop);\n        a[0] -= base;\n        b[0] += base;\n        c[1] = h[1] = y + rTop - cutTop;\n    }\n    // Column is lower than the radius. Cut off bottom inside the top\n    // radius.\n    if (height < rTop - cutTop) {\n        const base = applyPythagoras(rTop, rTop - cutTop - height);\n        c[0] = d[0] = x + width - rTop + base;\n        e[0] = Math.min(c[0], e[0]);\n        f[0] = Math.max(d[0], f[0]);\n        g[0] = h[0] = x + rTop - base;\n        c[1] = h[1] = y + height;\n    }\n    // Inside stacks, cut off part of the bottom\n    if (cutBtm) {\n        const base = applyPythagoras(rBtm, rBtm - cutBtm);\n        e[0] += base;\n        f[0] -= base;\n        d[1] = g[1] = y + height - rBtm + cutBtm;\n    }\n    // Cut off top inside the bottom radius\n    if (height < rBtm - cutBtm) {\n        const base = applyPythagoras(rBtm, rBtm - cutBtm - height);\n        c[0] = d[0] = x + width - rBtm + base;\n        b[0] = Math.min(c[0], b[0]);\n        a[0] = Math.max(d[0], a[0]);\n        g[0] = h[0] = x + rBtm - base;\n        d[1] = g[1] = y;\n    }\n    // Preserve the box for data labels\n    path.length = 0;\n    path.push(['M', ...a], \n    // Top side\n    ['L', ...b], \n    // Top right corner\n    ['A', rTop, rTop, 0, 0, 1, ...c], \n    // Right side\n    ['L', ...d], \n    // Bottom right corner\n    ['A', rBtm, rBtm, 0, 0, 1, ...e], \n    // Bottom side\n    ['L', ...f], \n    // Bottom left corner\n    ['A', rBtm, rBtm, 0, 0, 1, ...g], \n    // Left side\n    ['L', ...h], \n    // Top left corner\n    ['A', rTop, rTop, 0, 0, 1, ...a], ['Z']);\n    return path;\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst BorderRadius = {\n    compose,\n    optionsToObject\n};\nexport default BorderRadius;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Detailed options for border radius.\n *\n * @sample  {highcharts} highcharts/plotoptions/column-borderradius/\n *          Rounded columns\n * @sample  highcharts/plotoptions/series-border-radius\n *          Column and pie with rounded border\n *\n * @interface Highcharts.BorderRadiusOptionsObject\n */ /**\n* The border radius. A number signifies pixels. A percentage string, like for\n* example `50%`, signifies a relative size. For columns this is relative to the\n* column width, for pies it is relative to the radius and the inner radius.\n*\n* @name Highcharts.BorderRadiusOptionsObject#radius\n* @type {string|number}\n*/ /**\n* The scope of the rounding for column charts. In a stacked column chart, the\n* value `point` means each single point will get rounded corners. The value\n* `stack` means the rounding will apply to the full stack, so that only points\n* close to the top or bottom will receive rounding.\n*\n* @name Highcharts.BorderRadiusOptionsObject#scope\n* @validvalue [\"point\", \"stack\"]\n* @type {string}\n*/ /**\n* For column charts, where in the point or stack to apply rounding. The `end`\n* value means only those corners at the point value will be rounded, leaving\n* the corners at the base or threshold unrounded. This is the most intuitive\n* behaviour. The `all` value means also the base will be rounded.\n*\n* @name Highcharts.BorderRadiusOptionsObject#where\n* @validvalue [\"all\", \"end\"]\n* @type {string}\n* @default end\n*/\n(''); // Keeps doclets above in JS file\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 874, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Extensions/DataGrouping/ApproximationRegistry.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\n/* *\n *\n *  Constants\n *\n * */\n/**\n * Define the available approximation types. The data grouping\n * approximations takes an array or numbers as the first parameter. In case\n * of ohlc, four arrays are sent in as four parameters. Each array consists\n * only of numbers. In case null values belong to the group, the property\n * .hasNulls will be set to true on the array.\n *\n * @product highstock\n *\n * @internal\n */\nconst ApproximationRegistry = {\n// Approximations added programmatically\n};\n/* *\n *\n *  Default Export\n *\n * */\n/** @internal */\nexport default ApproximationRegistry;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;GASG,GACH;AACA;;;;GAIG,GACH;;;;;;;;;;CAUC,GACD,MAAM,wBAAwB;AAE9B;uCAOe","ignoreList":[0]}},
    {"offset": {"line": 909, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Extensions/DataGrouping/ApproximationDefaults.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport ApproximationRegistry from './ApproximationRegistry.js';\nimport U from '../../Core/Utilities.js';\nconst { arrayMax, arrayMin, correctFloat, extend, isNumber } = U;\n/* *\n *\n *  Functions\n *\n * */\nfunction average(arr) {\n    const len = arr.length;\n    let ret = sum(arr);\n    // If we have a number, return it divided by the length. If not,\n    // return null or undefined based on what the sum method finds.\n    if (isNumber(ret) && len) {\n        ret = correctFloat(ret / len);\n    }\n    return ret;\n}\n/**\n * The same as average, but for series with multiple values, like area ranges.\n */\nfunction averages() {\n    const ret = [];\n    [].forEach.call(arguments, function (arr) {\n        ret.push(average(arr));\n    });\n    // Return undefined when first elem. is undefined and let\n    // sum method handle null (#7377)\n    return typeof ret[0] === 'undefined' ? void 0 : ret;\n}\nfunction close(arr) {\n    return arr.length ?\n        arr[arr.length - 1] :\n        (arr.hasNulls ? null : void 0);\n}\nfunction high(arr) {\n    return arr.length ?\n        arrayMax(arr) :\n        (arr.hasNulls ? null : void 0);\n}\n/**\n * HLC, OHLC and range are special cases where a multidimensional array is input\n * and an array is output.\n */\nfunction hlc(high, low, close) {\n    high = ApproximationRegistry.high(high);\n    low = ApproximationRegistry.low(low);\n    close = ApproximationRegistry.close(close);\n    if (isNumber(high) ||\n        isNumber(low) ||\n        isNumber(close)) {\n        return [high, low, close];\n    }\n}\nfunction low(arr) {\n    return arr.length ?\n        arrayMin(arr) :\n        (arr.hasNulls ? null : void 0);\n}\nfunction ohlc(open, high, low, close) {\n    open = ApproximationRegistry.open(open);\n    high = ApproximationRegistry.high(high);\n    low = ApproximationRegistry.low(low);\n    close = ApproximationRegistry.close(close);\n    if (isNumber(open) ||\n        isNumber(high) ||\n        isNumber(low) ||\n        isNumber(close)) {\n        return [open, high, low, close];\n    }\n}\nfunction open(arr) {\n    return arr.length ? arr[0] : (arr.hasNulls ? null : void 0);\n}\nfunction range(low, high) {\n    low = ApproximationRegistry.low(low);\n    high = ApproximationRegistry.high(high);\n    if (isNumber(low) || isNumber(high)) {\n        return [low, high];\n    }\n    if (low === null && high === null) {\n        return null;\n    }\n    // Else, return is undefined\n}\nfunction sum(arr) {\n    let len = arr.length, ret;\n    // 1. it consists of nulls exclusive\n    if (!len && arr.hasNulls) {\n        ret = null;\n        // 2. it has a length and real values\n    }\n    else if (len) {\n        ret = 0;\n        while (len--) {\n            ret += arr[len];\n        }\n    }\n    // 3. it has zero length, so just return undefined\n    // => doNothing()\n    return ret;\n}\n/* *\n *\n *  Default Export\n *\n * */\n/** @internal */\nconst ApproximationDefaults = {\n    average,\n    averages,\n    close,\n    high,\n    hlc,\n    low,\n    ohlc,\n    open,\n    range,\n    sum\n};\nextend(ApproximationRegistry, ApproximationDefaults);\n/** @internal */\nexport default ApproximationDefaults;\n"],"names":[],"mappings":";;;;AAWA;AACA;AAZA;;;;;;;;;GASG,GACH;;;AAGA,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,8KAAC;AAChE;;;;GAIG,GACH,SAAS,QAAQ,GAAG;IAChB,MAAM,MAAM,IAAI,MAAM;IACtB,IAAI,MAAM,IAAI;IACd,gEAAgE;IAChE,+DAA+D;IAC/D,IAAI,SAAS,QAAQ,KAAK;QACtB,MAAM,aAAa,MAAM;IAC7B;IACA,OAAO;AACX;AACA;;CAEC,GACD,SAAS;IACL,MAAM,MAAM,EAAE;IACd,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,SAAU,GAAG;QACpC,IAAI,IAAI,CAAC,QAAQ;IACrB;IACA,yDAAyD;IACzD,iCAAiC;IACjC,OAAO,OAAO,GAAG,CAAC,EAAE,KAAK,cAAc,KAAK,IAAI;AACpD;AACA,SAAS,MAAM,GAAG;IACd,OAAO,IAAI,MAAM,GACb,GAAG,CAAC,IAAI,MAAM,GAAG,EAAE,GAClB,IAAI,QAAQ,GAAG,OAAO,KAAK;AACpC;AACA,SAAS,KAAK,GAAG;IACb,OAAO,IAAI,MAAM,GACb,SAAS,OACR,IAAI,QAAQ,GAAG,OAAO,KAAK;AACpC;AACA;;;CAGC,GACD,SAAS,IAAI,IAAI,EAAE,GAAG,EAAE,KAAK;IACzB,OAAO,gNAAqB,CAAC,IAAI,CAAC;IAClC,MAAM,gNAAqB,CAAC,GAAG,CAAC;IAChC,QAAQ,gNAAqB,CAAC,KAAK,CAAC;IACpC,IAAI,SAAS,SACT,SAAS,QACT,SAAS,QAAQ;QACjB,OAAO;YAAC;YAAM;YAAK;SAAM;IAC7B;AACJ;AACA,SAAS,IAAI,GAAG;IACZ,OAAO,IAAI,MAAM,GACb,SAAS,OACR,IAAI,QAAQ,GAAG,OAAO,KAAK;AACpC;AACA,SAAS,KAAK,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK;IAChC,OAAO,gNAAqB,CAAC,IAAI,CAAC;IAClC,OAAO,gNAAqB,CAAC,IAAI,CAAC;IAClC,MAAM,gNAAqB,CAAC,GAAG,CAAC;IAChC,QAAQ,gNAAqB,CAAC,KAAK,CAAC;IACpC,IAAI,SAAS,SACT,SAAS,SACT,SAAS,QACT,SAAS,QAAQ;QACjB,OAAO;YAAC;YAAM;YAAM;YAAK;SAAM;IACnC;AACJ;AACA,SAAS,KAAK,GAAG;IACb,OAAO,IAAI,MAAM,GAAG,GAAG,CAAC,EAAE,GAAI,IAAI,QAAQ,GAAG,OAAO,KAAK;AAC7D;AACA,SAAS,MAAM,GAAG,EAAE,IAAI;IACpB,MAAM,gNAAqB,CAAC,GAAG,CAAC;IAChC,OAAO,gNAAqB,CAAC,IAAI,CAAC;IAClC,IAAI,SAAS,QAAQ,SAAS,OAAO;QACjC,OAAO;YAAC;YAAK;SAAK;IACtB;IACA,IAAI,QAAQ,QAAQ,SAAS,MAAM;QAC/B,OAAO;IACX;AACA,4BAA4B;AAChC;AACA,SAAS,IAAI,GAAG;IACZ,IAAI,MAAM,IAAI,MAAM,EAAE;IACtB,oCAAoC;IACpC,IAAI,CAAC,OAAO,IAAI,QAAQ,EAAE;QACtB,MAAM;IACN,qCAAqC;IACzC,OACK,IAAI,KAAK;QACV,MAAM;QACN,MAAO,MAAO;YACV,OAAO,GAAG,CAAC,IAAI;QACnB;IACJ;IACA,kDAAkD;IAClD,iBAAiB;IACjB,OAAO;AACX;AACA;;;;GAIG,GACH,cAAc,GACd,MAAM,wBAAwB;IAC1B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACJ;AACA,OAAO,gNAAqB,EAAE;uCAEf","ignoreList":[0]}},
    {"offset": {"line": 1046, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Extensions/DataGrouping/DataGroupingDefaults.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\n/* *\n *\n *  Constants\n *\n * */\n/**\n * Common options\n * @internal\n */\nconst common = {\n    /// enabled: null, // (true for stock charts, false for basic),\n    // forced: undefined,\n    groupPixelWidth: 2,\n    // The first one is the point or start value, the second is the start\n    // value if we're dealing with range, the third one is the end value if\n    // dealing with a range\n    dateTimeLabelFormats: {\n        millisecond: [\n            '%[AebHMSL]',\n            '%[AebHMSL]',\n            '-%[HMSL]'\n        ],\n        second: [\n            '%[AebHMS]',\n            '%[AebHMS]',\n            '-%[HMS]'\n        ],\n        minute: [\n            '%[AebHM]',\n            '%[AebHM]',\n            '-%[HM]'\n        ],\n        hour: [\n            '%[AebHM]',\n            '%[AebHM]',\n            '-%[HM]'\n        ],\n        day: [\n            '%[AebY]',\n            '%[Aeb]',\n            '-%[AebY]'\n        ],\n        week: [\n            '%v %[AebY]',\n            '%[Aeb]',\n            '-%[AebY]'\n        ],\n        month: [\n            '%[BY]',\n            '%[B]',\n            '-%[BY]'\n        ],\n        year: [\n            '%Y',\n            '%Y',\n            '-%Y'\n        ]\n    }\n    /// smoothed = false, // enable this for navigator series only\n};\n/**\n * Extends common options\n * @internal\n */\nconst seriesSpecific = {\n    line: {},\n    spline: {},\n    area: {},\n    areaspline: {},\n    arearange: {},\n    column: {\n        groupPixelWidth: 10\n    },\n    columnrange: {\n        groupPixelWidth: 10\n    },\n    candlestick: {\n        groupPixelWidth: 10\n    },\n    ohlc: {\n        groupPixelWidth: 5\n    },\n    hlc: {\n        groupPixelWidth: 5\n        // Move to HeikinAshiSeries.ts after refactoring data grouping.\n    },\n    heikinashi: {\n        groupPixelWidth: 10\n    }\n};\n/**\n * Units are defined in a separate array to allow complete overriding in\n * case of a user option.\n * @internal\n */\nconst units = [\n    [\n        'millisecond', // Unit name\n        [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // Allowed multiples\n    ], [\n        'second',\n        [1, 2, 5, 10, 15, 30]\n    ], [\n        'minute',\n        [1, 2, 5, 10, 15, 30]\n    ], [\n        'hour',\n        [1, 2, 3, 4, 6, 8, 12]\n    ], [\n        'day',\n        [1]\n    ], [\n        'week',\n        [1]\n    ], [\n        'month',\n        [1, 3, 6]\n    ], [\n        'year',\n        null\n    ]\n];\n/* *\n *\n *  Default Export\n *\n * */\n/** @internal */\nconst DataGroupingDefaults = {\n    common,\n    seriesSpecific,\n    units\n};\n/** @internal */\nexport default DataGroupingDefaults;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;GASG,GACH;AACA;;;;GAIG,GACH;;;CAGC,GACD,MAAM,SAAS;IACX,+DAA+D;IAC/D,qBAAqB;IACrB,iBAAiB;IACjB,qEAAqE;IACrE,uEAAuE;IACvE,uBAAuB;IACvB,sBAAsB;QAClB,aAAa;YACT;YACA;YACA;SACH;QACD,QAAQ;YACJ;YACA;YACA;SACH;QACD,QAAQ;YACJ;YACA;YACA;SACH;QACD,MAAM;YACF;YACA;YACA;SACH;QACD,KAAK;YACD;YACA;YACA;SACH;QACD,MAAM;YACF;YACA;YACA;SACH;QACD,OAAO;YACH;YACA;YACA;SACH;QACD,MAAM;YACF;YACA;YACA;SACH;IACL;AAEJ;AACA;;;CAGC,GACD,MAAM,iBAAiB;IACnB,MAAM,CAAC;IACP,QAAQ,CAAC;IACT,MAAM,CAAC;IACP,YAAY,CAAC;IACb,WAAW,CAAC;IACZ,QAAQ;QACJ,iBAAiB;IACrB;IACA,aAAa;QACT,iBAAiB;IACrB;IACA,aAAa;QACT,iBAAiB;IACrB;IACA,MAAM;QACF,iBAAiB;IACrB;IACA,KAAK;QACD,iBAAiB;IAErB;IACA,YAAY;QACR,iBAAiB;IACrB;AACJ;AACA;;;;CAIC,GACD,MAAM,QAAQ;IACV;QACI;QACA;YAAC;YAAG;YAAG;YAAG;YAAI;YAAI;YAAI;YAAI;YAAK;YAAK;SAAI,CAAC,oBAAoB;KAChE;IAAE;QACC;QACA;YAAC;YAAG;YAAG;YAAG;YAAI;YAAI;SAAG;KACxB;IAAE;QACC;QACA;YAAC;YAAG;YAAG;YAAG;YAAI;YAAI;SAAG;KACxB;IAAE;QACC;QACA;YAAC;YAAG;YAAG;YAAG;YAAG;YAAG;YAAG;SAAG;KACzB;IAAE;QACC;QACA;YAAC;SAAE;KACN;IAAE;QACC;QACA;YAAC;SAAE;KACN;IAAE;QACC;QACA;YAAC;YAAG;YAAG;SAAE;KACZ;IAAE;QACC;QACA;KACH;CACJ;AACD;;;;GAIG,GACH,cAAc,GACd,MAAM,uBAAuB;IACzB;IACA;IACA;AACJ;uCAEe","ignoreList":[0]}},
    {"offset": {"line": 1238, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Extensions/DataGrouping/DataGroupingAxisComposition.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport DataGroupingDefaults from './DataGroupingDefaults.js';\nimport U from '../../Core/Utilities.js';\nconst { addEvent, extend, merge, pick } = U;\n/* *\n *\n *  Variables\n *\n * */\nlet AxisConstructor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Check the groupPixelWidth and apply the grouping if needed.\n * Fired only after processing the data.\n *\n * @product highstock\n *\n * @function Highcharts.Axis#applyGrouping\n */\nfunction applyGrouping(e) {\n    const axis = this, series = axis.series;\n    // Reset the groupPixelWidth for all series, #17141.\n    series.forEach(function (series) {\n        series.groupPixelWidth = void 0; // #2110\n    });\n    series.forEach(function (series) {\n        series.groupPixelWidth = (axis.getGroupPixelWidth &&\n            axis.getGroupPixelWidth());\n        if (series.groupPixelWidth) {\n            series.hasProcessed = true; // #2692\n        }\n        // Fire independing on series.groupPixelWidth to always set a proper\n        // dataGrouping state, (#16238)\n        series.applyGrouping(!!e.hasExtremesChanged);\n    });\n}\nfunction compose(AxisClass) {\n    AxisConstructor = AxisClass;\n    const axisProto = AxisClass.prototype;\n    if (!axisProto.applyGrouping) {\n        addEvent(AxisClass, 'afterSetScale', onAfterSetScale);\n        // When all series are processed, calculate the group pixel width and\n        // then if this value is different than zero apply groupings.\n        addEvent(AxisClass, 'postProcessData', applyGrouping);\n        extend(axisProto, {\n            applyGrouping,\n            getGroupPixelWidth,\n            setDataGrouping\n        });\n    }\n}\n/**\n * Get the data grouping pixel width based on the greatest defined individual\n * width of the axis' series, and if whether one of the axes need grouping.\n * @internal\n */\nfunction getGroupPixelWidth() {\n    const series = this.series;\n    let i = series.length, groupPixelWidth = 0, doGrouping = false, dataLength, dgOptions;\n    // If one of the series needs grouping, apply it to all (#1634)\n    while (i--) {\n        dgOptions = series[i].options.dataGrouping;\n        if (dgOptions) { // #2692\n            // If multiple series are compared on the same x axis, give them the\n            // same group pixel width (#334)\n            groupPixelWidth = Math.max(groupPixelWidth, \n            // Fallback to commonOptions (#9693)\n            pick(dgOptions.groupPixelWidth, DataGroupingDefaults.common.groupPixelWidth));\n            dataLength = (series[i].dataTable.getModified() ||\n                series[i].dataTable).rowCount;\n            // Execute grouping if the amount of points is greater than the\n            // limit defined in groupPixelWidth\n            if (series[i].groupPixelWidth ||\n                (dataLength >\n                    (this.chart.plotSizeX / groupPixelWidth)) ||\n                (dataLength && dgOptions.forced)) {\n                doGrouping = true;\n            }\n        }\n    }\n    return doGrouping ? groupPixelWidth : 0;\n}\n/**\n * When resetting the scale reset the hasProcessed flag to avoid taking\n * previous data grouping of neighbour series into account when determining\n * group pixel width (#2692).\n * @internal\n */\nfunction onAfterSetScale() {\n    this.series.forEach(function (series) {\n        series.hasProcessed = false;\n    });\n}\n/**\n * Highcharts Stock only. Force data grouping on all the axis' series.\n *\n * @product highstock\n *\n * @function Highcharts.Axis#setDataGrouping\n *\n * @param {boolean|Highcharts.DataGroupingOptionsObject} [dataGrouping]\n *        A `dataGrouping` configuration. Use `false` to disable data grouping\n *        dynamically.\n *\n * @param {boolean} [redraw=true]\n *        Whether to redraw the chart or wait for a later call to\n *        {@link Chart#redraw}.\n */\nfunction setDataGrouping(dataGrouping, redraw) {\n    const axis = this;\n    let i;\n    redraw = pick(redraw, true);\n    if (!dataGrouping) {\n        dataGrouping = {\n            forced: false,\n            units: null\n        };\n    }\n    // Axis is instantiated, update all series\n    if (this instanceof AxisConstructor) {\n        i = this.series.length;\n        while (i--) {\n            this.series[i].update({\n                dataGrouping: dataGrouping\n            }, false);\n        }\n        // Axis not yet instantiated, alter series options\n    }\n    else {\n        this.chart.options.series.forEach(function (seriesOptions) {\n            // Merging dataGrouping options with already defined options #16759\n            seriesOptions.dataGrouping = typeof dataGrouping === 'boolean' ?\n                dataGrouping :\n                merge(dataGrouping, seriesOptions.dataGrouping);\n        });\n    }\n    // Clear ordinal slope, so we won't accidentally use the old one (#7827)\n    if (axis.ordinal) {\n        axis.ordinal.slope = void 0;\n    }\n    if (redraw) {\n        this.chart.redraw();\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\n/** @internal */\nconst DataGroupingAxisComposition = {\n    compose\n};\n/** @internal */\nexport default DataGroupingAxisComposition;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1398, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Extensions/DataGrouping/DataGroupingSeriesComposition.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport ApproximationRegistry from './ApproximationRegistry.js';\nimport DataGroupingDefaults from './DataGroupingDefaults.js';\nimport DataTableCore from '../../Data/DataTableCore.js';\nimport DateTimeAxis from '../../Core/Axis/DateTimeAxis.js';\nimport D from '../../Core/Defaults.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { series: { prototype: seriesProto } } = SeriesRegistry;\nimport U from '../../Core/Utilities.js';\nconst { addEvent, defined, error, extend, isNumber, merge, pick, splat } = U;\n/* *\n *\n *  Constants\n *\n * */\nconst baseGeneratePoints = seriesProto.generatePoints;\n/* *\n *\n *  Functions\n *\n * */\n/** @internal */\nfunction adjustExtremes(xAxis, groupedXData) {\n    // Make sure the X axis extends to show the first group (#2533)\n    // But only for visible series (#5493, #6393)\n    if (defined(groupedXData[0]) &&\n        isNumber(xAxis.min) &&\n        isNumber(xAxis.dataMin) &&\n        groupedXData[0] < xAxis.min) {\n        if ((!defined(xAxis.options.min) &&\n            xAxis.min <= xAxis.dataMin) ||\n            xAxis.min === xAxis.dataMin) {\n            xAxis.min = Math.min(groupedXData[0], xAxis.min);\n        }\n        xAxis.dataMin = Math.min(groupedXData[0], xAxis.dataMin);\n    }\n    // When the last anchor set, change the extremes that\n    // the last point is visible (#12455).\n    if (defined(groupedXData[groupedXData.length - 1]) &&\n        isNumber(xAxis.max) &&\n        isNumber(xAxis.dataMax) &&\n        groupedXData[groupedXData.length - 1] > xAxis.max) {\n        if ((!defined(xAxis.options.max) &&\n            isNumber(xAxis.dataMax) &&\n            xAxis.max >= xAxis.dataMax) || xAxis.max === xAxis.dataMax) {\n            xAxis.max = Math.max(groupedXData[groupedXData.length - 1], xAxis.max);\n        }\n        xAxis.dataMax = Math.max(groupedXData[groupedXData.length - 1], xAxis.dataMax);\n    }\n}\n/** @internal */\nfunction anchorPoints(series, groupedXData, xMax) {\n    const options = series.options, dataGroupingOptions = options.dataGrouping, totalRange = (series.currentDataGrouping && series.currentDataGrouping.gapSize), xData = series.getColumn('x');\n    if (!(dataGroupingOptions &&\n        xData.length &&\n        totalRange &&\n        series.groupMap)) {\n        return;\n    }\n    const groupedDataLastIndex = groupedXData.length - 1, anchor = dataGroupingOptions.anchor, firstAnchor = dataGroupingOptions.firstAnchor, lastAnchor = dataGroupingOptions.lastAnchor;\n    let anchorIndexIterator = groupedXData.length - 1, anchorFirstIndex = 0;\n    // Change the first point position, but only when it is\n    // the first point in the data set not in the current zoom.\n    if (firstAnchor && xData[0] >= groupedXData[0]) {\n        anchorFirstIndex++;\n        const groupStart = series.groupMap[0].start, groupLength = series.groupMap[0].length;\n        let firstGroupEnd;\n        if (isNumber(groupStart) && isNumber(groupLength)) {\n            firstGroupEnd = groupStart + (groupLength - 1);\n        }\n        groupedXData[0] = {\n            start: groupedXData[0],\n            middle: groupedXData[0] + 0.5 * totalRange,\n            end: groupedXData[0] + totalRange,\n            firstPoint: xData[0],\n            lastPoint: firstGroupEnd && xData[firstGroupEnd]\n        }[firstAnchor];\n    }\n    // Change the last point position but only when it is\n    // the last point in the data set not in the current zoom,\n    // or if it is not the 1st point simultaneously.\n    if (groupedDataLastIndex > 0 &&\n        lastAnchor &&\n        totalRange &&\n        groupedXData[groupedDataLastIndex] >= xMax - totalRange) {\n        anchorIndexIterator--;\n        const lastGroupStart = series.groupMap[series.groupMap.length - 1].start;\n        groupedXData[groupedDataLastIndex] = {\n            start: groupedXData[groupedDataLastIndex],\n            middle: groupedXData[groupedDataLastIndex] + 0.5 * totalRange,\n            end: groupedXData[groupedDataLastIndex] + totalRange,\n            firstPoint: lastGroupStart && xData[lastGroupStart],\n            lastPoint: xData[xData.length - 1]\n        }[lastAnchor];\n    }\n    if (anchor && anchor !== 'start') {\n        const shiftInterval = (totalRange *\n            { middle: 0.5, end: 1 }[anchor]);\n        // Anchor the rest of the points apart from the ones, that were\n        // previously moved.\n        while (anchorIndexIterator >= anchorFirstIndex) {\n            groupedXData[anchorIndexIterator] += shiftInterval;\n            anchorIndexIterator--;\n        }\n    }\n}\n/**\n * For the processed data, calculate the grouped data if needed.\n *\n * @internal\n * @function Highcharts.Series#applyGrouping\n */\nfunction applyGrouping(hasExtremesChanged) {\n    const series = this, chart = series.chart, options = series.options, dataGroupingOptions = options.dataGrouping, groupingEnabled = series.allowDG !== false && dataGroupingOptions &&\n        pick(dataGroupingOptions.enabled, chart.options.isStock), reserveSpace = series.reserveSpace(), lastDataGrouping = this.currentDataGrouping;\n    let currentDataGrouping, croppedData, revertRequireSorting = false;\n    // Data needs to be sorted for dataGrouping\n    if (groupingEnabled && !series.requireSorting) {\n        series.requireSorting = revertRequireSorting = true;\n    }\n    // Skip if skipDataGrouping method returns false or if grouping is disabled\n    // (in that order).\n    const skip = skipDataGrouping(series, hasExtremesChanged) === false || !groupingEnabled;\n    // Revert original requireSorting value if changed\n    if (revertRequireSorting) {\n        series.requireSorting = false;\n    }\n    if (skip) {\n        return;\n    }\n    series.destroyGroupedData();\n    const table = dataGroupingOptions.groupAll ?\n        series.dataTable :\n        series.dataTable.getModified() || series.dataTable, processedXData = series.getColumn('x', !dataGroupingOptions.groupAll), xData = processedXData, plotSizeX = chart.plotSizeX, xAxis = series.xAxis, extremes = xAxis.getExtremes(), ordinal = xAxis.options.ordinal, groupPixelWidth = series.groupPixelWidth;\n    let i, hasGroupedData;\n    // Execute grouping if the amount of points is greater than the limit\n    // defined in groupPixelWidth\n    if (groupPixelWidth &&\n        xData &&\n        table.rowCount &&\n        plotSizeX &&\n        isNumber(extremes.min)) {\n        hasGroupedData = true;\n        // Force recreation of point instances in series.translate, #5699\n        series.isDirty = true;\n        series.points = null; // #6709\n        const xMin = extremes.min, xMax = extremes.max, groupIntervalFactor = (ordinal &&\n            xAxis.ordinal &&\n            xAxis.ordinal.getGroupIntervalFactor(xMin, xMax, series)) || 1, interval = (groupPixelWidth * (xMax - xMin) / plotSizeX) *\n            groupIntervalFactor, groupPositions = xAxis.getTimeTicks(DateTimeAxis.Additions.prototype.normalizeTimeTickInterval(interval, dataGroupingOptions.units ||\n            DataGroupingDefaults.units), \n        // Processed data may extend beyond axis (#4907)\n        Math.min(xMin, xData[0]), Math.max(xMax, xData[xData.length - 1]), xAxis.options.startOfWeek, processedXData, series.closestPointRange), groupedData = seriesProto.groupData.apply(series, [\n            table,\n            groupPositions,\n            dataGroupingOptions.approximation\n        ]);\n        let modified = groupedData.modified, groupedXData = modified.getColumn('x', true), gapSize = 0;\n        // The smoothed option is deprecated, instead, there is a fallback\n        // to the new anchoring mechanism. #12455.\n        if (dataGroupingOptions?.smoothed &&\n            modified.rowCount) {\n            dataGroupingOptions.firstAnchor = 'firstPoint';\n            dataGroupingOptions.anchor = 'middle';\n            dataGroupingOptions.lastAnchor = 'lastPoint';\n            error(32, false, chart, {\n                'dataGrouping.smoothed': 'use dataGrouping.anchor'\n            });\n        }\n        // Record what data grouping values were used\n        for (i = 1; i < groupPositions.length; i++) {\n            // The grouped gapSize needs to be the largest distance between\n            // the group to capture varying group sizes like months or DST\n            // crossing (#10000). Also check that the gap is not at the\n            // start of a segment.\n            if (!groupPositions.info.segmentStarts ||\n                groupPositions.info.segmentStarts.indexOf(i) === -1) {\n                gapSize = Math.max(groupPositions[i] - groupPositions[i - 1], gapSize);\n            }\n        }\n        currentDataGrouping = groupPositions.info;\n        currentDataGrouping.gapSize = gapSize;\n        series.closestPointRange = groupPositions.info.totalRange;\n        series.groupMap = groupedData.groupMap;\n        series.currentDataGrouping = currentDataGrouping;\n        anchorPoints(series, groupedXData || [], xMax);\n        if (reserveSpace && groupedXData) {\n            adjustExtremes(xAxis, groupedXData);\n        }\n        // We calculated all group positions but we should render only the ones\n        // within the visible range\n        if (dataGroupingOptions.groupAll) {\n            // Keep the reference to all grouped points for further calculation,\n            // used in Heikin-Ashi and hollow candlestick series.\n            series.allGroupedTable = modified;\n            croppedData = series.cropData(modified, xAxis.min || 0, xAxis.max || 0);\n            modified = croppedData.modified;\n            groupedXData = modified.getColumn('x');\n            series.cropStart = croppedData.start; // #15005\n        }\n        // Set the modified table\n        series.dataTable.modified = modified;\n    }\n    else {\n        series.groupMap = void 0;\n        series.currentDataGrouping = void 0;\n    }\n    series.hasGroupedData = hasGroupedData;\n    series.preventGraphAnimation =\n        (lastDataGrouping && lastDataGrouping.totalRange) !==\n            (currentDataGrouping && currentDataGrouping.totalRange);\n}\n/** @internal */\nfunction compose(SeriesClass) {\n    const seriesProto = SeriesClass.prototype;\n    if (!seriesProto.applyGrouping) {\n        const PointClass = SeriesClass.prototype.pointClass;\n        // Override point prototype to throw a warning when trying to update\n        // grouped points.\n        addEvent(PointClass, 'update', function () {\n            if (this.dataGroup) {\n                error(24, false, this.series.chart);\n                return false;\n            }\n        });\n        addEvent(SeriesClass, 'afterSetOptions', onAfterSetOptions);\n        addEvent(SeriesClass, 'destroy', destroyGroupedData);\n        extend(seriesProto, {\n            applyGrouping,\n            destroyGroupedData,\n            generatePoints,\n            getDGApproximation,\n            groupData\n        });\n    }\n}\n/**\n * Destroy the grouped data points. #622, #740\n * @internal\n */\nfunction destroyGroupedData() {\n    // Clear previous groups\n    if (this.groupedData) {\n        this.groupedData.forEach(function (point, i) {\n            if (point) {\n                this.groupedData[i] = point.destroy ?\n                    point.destroy() : null;\n            }\n        }, this);\n        // Clears all:\n        // - `this.groupedData`\n        // - `this.points`\n        // - `preserve` object in series.update()\n        this.groupedData.length = 0;\n        delete this.allGroupedTable;\n    }\n}\n/**\n * Override the generatePoints method by adding a reference to grouped data\n * @internal\n */\nfunction generatePoints() {\n    baseGeneratePoints.apply(this);\n    // Record grouped data in order to let it be destroyed the next time\n    // processData runs\n    this.destroyGroupedData(); // #622\n    this.groupedData = this.hasGroupedData ? this.points : null;\n}\n/**\n * Set default approximations to the prototypes if present. Properties are\n * inherited down. Can be overridden for individual series types.\n * @internal\n */\nfunction getDGApproximation() {\n    if (this.is('arearange')) {\n        return 'range';\n    }\n    if (this.is('ohlc')) {\n        return 'ohlc';\n    }\n    if (this.is('hlc')) {\n        return 'hlc';\n    }\n    if (\n    // #18974, default approximation for cumulative\n    // should be `sum` when `dataGrouping` is enabled\n    this.is('column') ||\n        this.options.cumulative) {\n        return 'sum';\n    }\n    return 'average';\n}\n/**\n * Highcharts Stock only. Takes parallel arrays of x and y data and groups the\n * data into intervals defined by groupPositions, a collection of starting x\n * values for each group.\n *\n * @product highstock\n *\n * @function Highcharts.Series#groupData\n * @param {Highcharts.DataTable} table\n *        The series data table.\n * @param {Array<number>} groupPositions\n *        Group positions.\n * @param {string|Function} [approximation]\n *        Approximation to use.\n * @return {Highcharts.DataGroupingResultObject}\n *         Mapped groups.\n */\nfunction groupData(table, groupPositions, approximation) {\n    const xData = table.getColumn('x', true) || [], yData = table.getColumn('y', true), series = this, data = series.data, dataOptions = series.options && series.options.data, groupedXData = [], modified = new DataTableCore(), groupMap = [], dataLength = table.rowCount, \n    // When grouping the fake extended axis for panning, we don't need to\n    // consider y\n    handleYData = !!yData, values = [], pointArrayMap = series.pointArrayMap, pointArrayMapLength = pointArrayMap && pointArrayMap.length, extendedPointArrayMap = ['x'].concat(pointArrayMap || ['y']), \n    // Data columns to be applied to the modified data table at the end\n    valueColumns = (pointArrayMap || ['y']).map(() => []), groupAll = (this.options.dataGrouping &&\n        this.options.dataGrouping.groupAll);\n    let pointX, pointY, groupedY, pos = 0, start = 0;\n    const approximationFn = (typeof approximation === 'function' ?\n        approximation :\n        approximation && ApproximationRegistry[approximation] ?\n            ApproximationRegistry[approximation] :\n            ApproximationRegistry[(series.getDGApproximation && series.getDGApproximation() ||\n                'average')]);\n    // Calculate values array size from pointArrayMap length\n    if (pointArrayMapLength) {\n        let len = pointArrayMap.length;\n        while (len--) {\n            values.push([]);\n        }\n    }\n    else {\n        values.push([]);\n    }\n    const valuesLen = pointArrayMapLength || 1;\n    for (let i = 0; i <= dataLength; i++) {\n        // Start with the first point within the X axis range (#2696)\n        if (xData[i] < groupPositions[0]) {\n            continue; // With next point\n        }\n        // When a new group is entered, summarize and initialize\n        // the previous group\n        while ((typeof groupPositions[pos + 1] !== 'undefined' &&\n            xData[i] >= groupPositions[pos + 1]) ||\n            i === dataLength) { // Get the last group\n            // get group x and y\n            pointX = groupPositions[pos];\n            series.dataGroupInfo = {\n                start: groupAll ? start : (series.cropStart + start),\n                length: values[0].length,\n                groupStart: pointX\n            };\n            groupedY = approximationFn.apply(series, values);\n            // By default, let options of the first grouped point be passed over\n            // to the grouped point. This allows preserving properties like\n            // `name` and `color` or custom properties. Implementers can\n            // override this from the approximation function, where they can\n            // write custom options to `this.dataGroupInfo.options`.\n            if (series.pointClass && !defined(series.dataGroupInfo.options)) {\n                // Convert numbers and arrays into objects\n                series.dataGroupInfo.options = merge(series.pointClass.prototype\n                    .optionsToObject.call({ series: series }, series.options.data[series.cropStart + start]));\n                // Make sure the raw data (x, y, open, high etc) is not copied\n                // over and overwriting approximated data.\n                extendedPointArrayMap.forEach(function (key) {\n                    delete series.dataGroupInfo.options[key];\n                });\n            }\n            // Push the grouped data\n            if (typeof groupedY !== 'undefined') {\n                groupedXData.push(pointX);\n                // Push the grouped values to the parallel columns\n                const groupedValuesArr = splat(groupedY);\n                for (let j = 0; j < groupedValuesArr.length; j++) {\n                    valueColumns[j].push(groupedValuesArr[j]);\n                }\n                groupMap.push(series.dataGroupInfo);\n            }\n            // Reset the aggregate arrays\n            start = i;\n            for (let j = 0; j < valuesLen; j++) {\n                values[j].length = 0; // Faster than values[j] = []\n                values[j].hasNulls = false;\n            }\n            // Advance on the group positions\n            pos += 1;\n            // Don't loop beyond the last group\n            if (i === dataLength) {\n                break;\n            }\n        }\n        // Break out\n        if (i === dataLength) {\n            break;\n        }\n        // For each raw data point, push it to an array that contains all values\n        // for this specific group\n        if (pointArrayMap) {\n            const index = groupAll ? i : series.cropStart + i, point = (data && data[index]) ||\n                series.pointClass.prototype.applyOptions.apply({\n                    series: series\n                }, [dataOptions[index]]);\n            let val;\n            for (let j = 0; j < pointArrayMapLength; j++) {\n                val = point[pointArrayMap[j]];\n                if (isNumber(val)) {\n                    values[j].push(val);\n                }\n                else if (val === null) {\n                    values[j].hasNulls = true;\n                }\n            }\n        }\n        else {\n            pointY = handleYData ? yData[i] : null;\n            if (isNumber(pointY)) {\n                values[0].push(pointY);\n            }\n            else if (pointY === null) {\n                values[0].hasNulls = true;\n            }\n        }\n    }\n    const columns = {\n        x: groupedXData\n    };\n    (pointArrayMap || ['y']).forEach((key, i) => {\n        columns[key] = valueColumns[i];\n    });\n    modified.setColumns(columns);\n    return {\n        groupMap,\n        modified\n    };\n}\n/**\n * Handle default options for data grouping. This must be set at runtime because\n * some series types are defined after this.\n * @internal\n */\nfunction onAfterSetOptions(e) {\n    const options = e.options, type = this.type, plotOptions = this.chart.options.plotOptions, \n    // External series, for example technical indicators should also inherit\n    // commonOptions which are not available outside this module\n    baseOptions = (this.useCommonDataGrouping &&\n        DataGroupingDefaults.common), seriesSpecific = DataGroupingDefaults.seriesSpecific;\n    let defaultOptions = D.defaultOptions.plotOptions[type].dataGrouping;\n    if (plotOptions && (seriesSpecific[type] || baseOptions)) { // #1284\n        const rangeSelector = this.chart.rangeSelector;\n        if (!defaultOptions) {\n            defaultOptions = merge(DataGroupingDefaults.common, seriesSpecific[type]);\n        }\n        options.dataGrouping = merge(baseOptions, defaultOptions, plotOptions.series && plotOptions.series.dataGrouping, // #1228\n        // Set by the StockChart constructor:\n        plotOptions[type].dataGrouping, this.userOptions.dataGrouping, !options.isInternal &&\n            rangeSelector &&\n            isNumber(rangeSelector.selected) &&\n            rangeSelector.buttonOptions[rangeSelector.selected].dataGrouping);\n    }\n}\n/** @internal */\nfunction skipDataGrouping(series, force) {\n    return !(series.isCartesian &&\n        !series.isDirty &&\n        !series.xAxis.isDirty &&\n        !series.yAxis.isDirty &&\n        !force);\n}\n/* *\n *\n *  Default Export\n *\n * */\n/** @internal */\nconst DataGroupingSeriesComposition = {\n    compose,\n    groupData\n};\n/** @internal */\nexport default DataGroupingSeriesComposition;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1839, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Extensions/DataGrouping/DataGrouping.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport DataGroupingAxisComposition from './DataGroupingAxisComposition.js';\nimport DataGroupingDefaults from './DataGroupingDefaults.js';\nimport DataGroupingSeriesComposition from './DataGroupingSeriesComposition.js';\nimport F from '../../Core/Templating.js';\nconst { format } = F;\nimport H from '../../Core/Globals.js';\nconst { composed } = H;\nimport U from '../../Core/Utilities.js';\nconst { addEvent, extend, isNumber, pick, pushUnique } = U;\n/* *\n *\n *  Functions\n *\n * */\nfunction compose(AxisClass, SeriesClass, TooltipClass) {\n    DataGroupingAxisComposition.compose(AxisClass);\n    DataGroupingSeriesComposition.compose(SeriesClass);\n    if (TooltipClass &&\n        pushUnique(composed, 'DataGrouping')) {\n        addEvent(TooltipClass, 'headerFormatter', onTooltipHeaderFormatter);\n    }\n}\n/**\n * Extend the original method, make the tooltip's header reflect the grouped\n * range.\n * @internal\n */\nfunction onTooltipHeaderFormatter(e) {\n    const chart = this.chart, time = chart.time, point = e.point, series = point.series, options = series.options, tooltipOptions = series.tooltipOptions, dataGroupingOptions = options.dataGrouping, xAxis = series.xAxis;\n    let xDateFormat = tooltipOptions.xDateFormat || '', xDateFormatEnd, currentDataGrouping, dateTimeLabelFormats, labelFormats, formattedKey, formatString = tooltipOptions[e.isFooter ? 'footerFormat' : 'headerFormat'];\n    // Apply only to grouped series\n    if (xAxis &&\n        xAxis.options.type === 'datetime' &&\n        dataGroupingOptions &&\n        isNumber(point.key)) {\n        // Set variables\n        currentDataGrouping = series.currentDataGrouping;\n        dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats ||\n            // Fallback to commonOptions (#9693)\n            DataGroupingDefaults.common.dateTimeLabelFormats;\n        // If we have grouped data, use the grouping information to get the\n        // right format\n        if (currentDataGrouping) {\n            labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];\n            if (currentDataGrouping.count === 1) {\n                xDateFormat = labelFormats[0];\n            }\n            else {\n                xDateFormat = labelFormats[1];\n                xDateFormatEnd = labelFormats[2];\n            }\n            // If not grouped, and we don't have set the xDateFormat option, get the\n            // best fit, so if the least distance between points is one minute, show\n            // it, but if the least distance is one day, skip hours and minutes etc.\n        }\n        else if (!xDateFormat && dateTimeLabelFormats && xAxis.dateTime) {\n            xDateFormat = xAxis.dateTime.getXDateFormat(point.x, tooltipOptions.dateTimeLabelFormats);\n        }\n        const groupStart = pick(series.groupMap?.[point.index].groupStart, point.key), groupEnd = groupStart + (currentDataGrouping?.totalRange || 0) - 1;\n        formattedKey = time.dateFormat(xDateFormat, groupStart);\n        if (xDateFormatEnd) {\n            formattedKey += time.dateFormat(xDateFormatEnd, groupEnd);\n        }\n        // Replace default header style with class name\n        if (series.chart.styledMode) {\n            formatString = this.styledModeFormat(formatString);\n        }\n        // Return the replaced format\n        e.text = format(formatString, {\n            point: extend(point, { key: formattedKey }),\n            series\n        }, chart);\n        e.preventDefault();\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\n/** @internal */\nconst DataGroupingComposition = {\n    compose,\n    groupData: DataGroupingSeriesComposition.groupData\n};\n/** @internal */\nexport default DataGroupingComposition;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * @typedef {\"average\"|\"averages\"|\"close\"|\"high\"|\"hlc\"|\"low\"|\"ohlc\"|\"open\"|\"range\"|\"sum\"} Highcharts.DataGroupingApproximationValue\n */\n/**\n * The position of the point inside the group.\n *\n * @typedef    {\"start\"|\"middle\"|\"end\"} Highcharts.DataGroupingAnchor\n */\n/**\n * The position of the first or last point in the series inside the group.\n *\n * @typedef    {\"start\"|\"middle\"|\"end\"|\"firstPoint\"|\"lastPoint\"} Highcharts.DataGroupingAnchorExtremes\n */\n/**\n * Highcharts Stock only.\n *\n * @product highstock\n * @interface Highcharts.DataGroupingInfoObject\n */ /**\n* @name Highcharts.DataGroupingInfoObject#length\n* @type {number}\n*/ /**\n* @name Highcharts.DataGroupingInfoObject#options\n* @type {Highcharts.SeriesOptionsType|undefined}\n*/ /**\n* @name Highcharts.DataGroupingInfoObject#start\n* @type {number}\n*/\n/**\n * Highcharts Stock only.\n *\n * @product highstock\n * @interface Highcharts.DataGroupingResultObject\n */ /**\n* @name Highcharts.DataGroupingResultObject#modified\n* @type {Highcharts.DataTableCore}\n*/ /**\n* @name Highcharts.DataGroupingResultObject#groupMap\n* @type {Array<DataGroupingInfoObject>}\n*/\n/**\n * Highcharts Stock only. If a point object is created by data\n * grouping, it doesn't reflect actual points in the raw\n * data. In this case, the `dataGroup` property holds\n * information that points back to the raw data.\n *\n * - `dataGroup.start` is the index of the first raw data\n *   point in the group.\n *\n * - `dataGroup.length` is the amount of points in the\n *   group.\n *\n * @sample stock/members/point-datagroup\n *         Click to inspect raw data points\n *\n * @product highstock\n *\n * @name Highcharts.Point#dataGroup\n * @type {Highcharts.DataGroupingInfoObject|undefined}\n */\n(''); // Detach doclets above\n/* *\n *\n *  API Options\n *\n * */\n/**\n * Data grouping is the concept of sampling the data values into larger\n * blocks in order to ease readability and increase performance of the\n * JavaScript charts. Highcharts Stock by default applies data grouping when\n * the points become closer than a certain pixel value, determined by\n * the `groupPixelWidth` option.\n *\n * If data grouping is applied, the grouping information of grouped\n * points can be read from the [Point.dataGroup](\n * /class-reference/Highcharts.Point#dataGroup). If point options other than\n * the data itself are set, for example `name` or `color` or custom properties,\n * the grouping logic doesn't know how to group it. In this case the options of\n * the first point instance are copied over to the group point. This can be\n * altered through a custom `approximation` callback function.\n *\n * @declare   Highcharts.DataGroupingOptionsObject\n * @product   highstock\n * @requires  modules/stock\n * @apioption plotOptions.series.dataGrouping\n */\n/**\n * Specifies how the points should be located on the X axis inside the group.\n * Points that are extremes can be set separately. Available options:\n *\n * - `start` places the point at the beginning of the group\n * (e.g. range 00:00:00 - 23:59:59 -> 00:00:00)\n *\n * - `middle` places the point in the middle of the group\n * (e.g. range 00:00:00 - 23:59:59 -> 12:00:00)\n *\n * - `end` places the point at the end of the group\n * (e.g. range 00:00:00 - 23:59:59 -> 23:59:59)\n *\n * @sample {highstock} stock/plotoptions/series-datagrouping-anchor\n *         Changing the point x-coordinate inside the group.\n *\n * @see [dataGrouping.firstAnchor](#plotOptions.series.dataGrouping.firstAnchor)\n * @see [dataGrouping.lastAnchor](#plotOptions.series.dataGrouping.lastAnchor)\n *\n * @type       {Highcharts.DataGroupingAnchor}\n * @since 9.1.0\n * @default    start\n * @apioption  plotOptions.series.dataGrouping.anchor\n */\n/**\n * The method of approximation inside a group. When for example 30 days\n * are grouped into one month, this determines what value should represent\n * the group. Possible values are \"average\", \"averages\", \"open\", \"high\",\n * \"low\", \"close\" and \"sum\". For OHLC and candlestick series the approximation\n * is \"ohlc\" by default, which finds the open, high, low and close values\n * within all the grouped data. For ranges, the approximation is \"range\",\n * which finds the low and high values. For multi-dimensional data,\n * like ranges and OHLC, \"averages\" will compute the average for each\n * dimension.\n *\n * Custom aggregate methods can be added by assigning a callback function\n * as the approximation. This function takes a numeric array as the\n * argument and should return a single numeric value or `null`. Note\n * that the numeric array will never contain null values, only true\n * numbers. Instead, if null values are present in the raw data, the\n * numeric array will have an `.hasNulls` property set to `true`. For\n * single-value data sets the data is available in the first argument\n * of the callback function. For OHLC data sets, all the open values\n * are in the first argument, all high values in the second etc.\n *\n * Since v4.2.7, grouping meta data is available in the approximation\n * callback from `this.dataGroupInfo`. It can be used to extract information\n * from the raw data.\n *\n * Defaults to `average` for line-type series, `sum` for columns, `range`\n * for range series, `hlc` for HLC, and `ohlc` for OHLC and candlestick.\n *\n * @sample {highstock} stock/plotoptions/series-datagrouping-approximation\n *         Approximation callback with custom data\n * @sample {highstock} stock/plotoptions/series-datagrouping-simple-approximation\n *         Simple approximation demo\n *\n * @type       {Highcharts.DataGroupingApproximationValue|Function}\n * @apioption  plotOptions.series.dataGrouping.approximation\n */\n/**\n * Datetime formats for the header of the tooltip in a stock chart.\n * The format can vary within a chart depending on the currently selected\n * time range and the current data grouping.\n *\n * The default formats are:\n * ```js\n * {\n *     millisecond: [\n *         '%A, %e %b, %H:%M:%S.%L', '%A, %e %b, %H:%M:%S.%L', '-%H:%M:%S.%L'\n *     ],\n *     second: ['%A, %e %b, %H:%M:%S', '%A, %e %b, %H:%M:%S', '-%H:%M:%S'],\n *     minute: ['%A, %e %b, %H:%M', '%A, %e %b, %H:%M', '-%H:%M'],\n *     hour: ['%A, %e %b, %H:%M', '%A, %e %b, %H:%M', '-%H:%M'],\n *     day: ['%A, %e %b %Y', '%A, %e %b', '-%A, %e %b %Y'],\n *     week: ['%v %A, %e %b %Y', '%A, %e %b', '-%A, %e %b %Y'],\n *     month: ['%B %Y', '%B', '-%B %Y'],\n *     year: ['%Y', '%Y', '-%Y']\n * }\n * ```\n *\n * For each of these array definitions, the first item is the format\n * used when the active time span is one unit. For instance, if the\n * current data applies to one week, the first item of the week array\n * is used. The second and third items are used when the active time\n * span is more than two units. For instance, if the current data applies\n * to two weeks, the second and third item of the week array are used,\n *  and applied to the start and end date of the time span.\n *\n * @type      {Object}\n * @apioption plotOptions.series.dataGrouping.dateTimeLabelFormats\n */\n/**\n * Enable or disable data grouping.\n *\n * @type      {boolean}\n * @default   true\n * @apioption plotOptions.series.dataGrouping.enabled\n */\n/**\n * Specifies how the first grouped point is positioned on the xAxis.\n * If firstAnchor and/or lastAnchor are defined, then those options take\n * precedence over anchor for the first and/or last grouped points.\n * Available options:\n *\n * -`start` places the point at the beginning of the group\n * (e.g. range 00:00:00 - 23:59:59 -> 00:00:00)\n *\n * -`middle` places the point in the middle of the group\n * (e.g. range 00:00:00 - 23:59:59 -> 12:00:00)\n *\n * -`end` places the point at the end of the group\n * (e.g. range 00:00:00 - 23:59:59 -> 23:59:59)\n *\n * -`firstPoint` the first point in the group\n * (e.g. points at 00:13, 00:35, 00:59 -> 00:13)\n *\n * -`lastPoint` the last point in the group\n * (e.g. points at 00:13, 00:35, 00:59 -> 00:59)\n *\n * @sample {highstock} stock/plotoptions/series-datagrouping-first-anchor\n *         Applying first and last anchor.\n *\n * @see [dataGrouping.anchor](#plotOptions.series.dataGrouping.anchor)\n *\n * @type       {Highcharts.DataGroupingAnchorExtremes}\n * @since 9.1.0\n * @default    start\n * @apioption  plotOptions.series.dataGrouping.firstAnchor\n */\n/**\n * When data grouping is forced, it runs no matter how small the intervals\n * are. This can be handy for example when the sum should be calculated\n * for values appearing at random times within each hour.\n *\n * @type      {boolean}\n * @default   false\n * @apioption plotOptions.series.dataGrouping.forced\n */\n/**\n * By default only points within the visible range are grouped. Enabling this\n * option will force data grouping to calculate all grouped points for a given\n * dataset. That option prevents for example a column series from calculating\n * a grouped point partially. The effect is similar to\n * [Series.getExtremesFromAll](#plotOptions.series.getExtremesFromAll) but does\n * not affect yAxis extremes.\n *\n * @sample {highstock} stock/plotoptions/series-datagrouping-groupall/\n *         Two series with the same data but different groupAll setting\n *\n * @type      {boolean}\n * @default   false\n * @since     6.1.0\n * @apioption plotOptions.series.dataGrouping.groupAll\n */\n/**\n * The approximate pixel width of each group. If for example a series\n * with 30 points is displayed over a 600 pixel wide plot area, no grouping\n * is performed. If however the series contains so many points that\n * the spacing is less than the groupPixelWidth, Highcharts will try\n * to group it into appropriate groups so that each is more or less\n * two pixels wide. If multiple series with different group pixel widths\n * are drawn on the same x axis, all series will take the greatest width.\n * For example, line series have 2px default group width, while column\n * series have 10px. If combined, both the line and the column will\n * have 10px by default.\n *\n * @type      {number}\n * @default   2\n * @apioption plotOptions.series.dataGrouping.groupPixelWidth\n */\n/**\n * Specifies how the last grouped point is positioned on the xAxis.\n * If firstAnchor and/or lastAnchor are defined, then those options take\n * precedence over anchor for the first and/or last grouped points.\n * Available options:\n *\n * -`start` places the point at the beginning of the group\n * (e.g. range 00:00:00 - 23:59:59 -> 00:00:00)\n *\n * -`middle` places the point in the middle of the group\n * (e.g. range 00:00:00 - 23:59:59 -> 12:00:00)\n *\n * -`end` places the point at the end of the group\n * (e.g. range 00:00:00 - 23:59:59 -> 23:59:59)\n *\n * -`firstPoint` the first point in the group\n * (e.g. points at 00:13, 00:35, 00:59 -> 00:13)\n *\n * -`lastPoint` the last point in the group\n * (e.g. points at 00:13, 00:35, 00:59 -> 00:59)\n *\n * @sample {highstock} stock/plotoptions/series-datagrouping-first-anchor\n *         Applying first and last anchor.\n *\n * @sample {highstock} stock/plotoptions/series-datagrouping-last-anchor\n *         Applying the last anchor in the chart with live data.\n *\n * @see [dataGrouping.anchor](#plotOptions.series.dataGrouping.anchor)\n *\n * @type       {Highcharts.DataGroupingAnchorExtremes}\n * @since 9.1.0\n * @default    start\n * @apioption  plotOptions.series.dataGrouping.lastAnchor\n */\n/**\n * Normally, a group is indexed by the start of that group, so for example\n * when 30 daily values are grouped into one month, that month's x value\n * will be the 1st of the month. This apparently shifts the data to\n * the left. When the smoothed option is true, this is compensated for.\n * The data is shifted to the middle of the group, and min and max\n * values are preserved. Internally, this is used in the Navigator series.\n *\n * @type      {boolean}\n * @default   false\n * @deprecated\n * @apioption plotOptions.series.dataGrouping.smoothed\n */\n/**\n * An array determining what time intervals the data is allowed to be\n * grouped to. Each array item is an array where the first value is\n * the time unit and the second value another array of allowed multiples.\n *\n * Defaults to:\n * ```js\n * units: [[\n *     'millisecond', // unit name\n *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n * ], [\n *     'second',\n *     [1, 2, 5, 10, 15, 30]\n * ], [\n *     'minute',\n *     [1, 2, 5, 10, 15, 30]\n * ], [\n *     'hour',\n *     [1, 2, 3, 4, 6, 8, 12]\n * ], [\n *     'day',\n *     [1]\n * ], [\n *     'week',\n *     [1]\n * ], [\n *     'month',\n *     [1, 3, 6]\n * ], [\n *     'year',\n *     null\n * ]]\n * ```\n *\n * @type      {Array<Array<string,(Array<number>|null)>>}\n * @apioption plotOptions.series.dataGrouping.units\n */\n/**\n * The approximate pixel width of each group. If for example a series\n * with 30 points is displayed over a 600 pixel wide plot area, no grouping\n * is performed. If however the series contains so many points that\n * the spacing is less than the groupPixelWidth, Highcharts will try\n * to group it into appropriate groups so that each is more or less\n * two pixels wide. Defaults to `10`.\n *\n * @sample {highstock} stock/plotoptions/series-datagrouping-grouppixelwidth/\n *         Two series with the same data density but different groupPixelWidth\n *\n * @type      {number}\n * @default   10\n * @apioption plotOptions.column.dataGrouping.groupPixelWidth\n */\n''; // Required by JSDoc parsing\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2281, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Extensions/Annotations/NavigationBindingsUtilities.js"],"sourcesContent":["/* *\n *\n *  (c) 2009-2026 Highsoft AS\n *  Author: Highsoft, Black Label\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport U from '../../Core/Utilities.js';\nconst { defined, isNumber, pick } = U;\n/* *\n *\n *  Constants\n *\n * */\n/**\n * Define types for editable fields per annotation. There is no need to define\n * numbers, because they won't change their type to string.\n * @internal\n */\nconst annotationsFieldsTypes = {\n    backgroundColor: 'string',\n    borderColor: 'string',\n    borderRadius: 'string',\n    color: 'string',\n    fill: 'string',\n    fontSize: 'string',\n    labels: 'string',\n    name: 'string',\n    stroke: 'string',\n    title: 'string'\n};\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Returns the first xAxis or yAxis that was clicked with its value.\n *\n * @internal\n *\n * @param {Array<Highcharts.PointerAxisCoordinateObject>} coords\n *        All the chart's x or y axes with a current pointer's axis value.\n *\n * @return {Highcharts.PointerAxisCoordinateObject}\n *         Object with a first found axis and its value that pointer\n *         is currently pointing.\n */\nfunction getAssignedAxis(coords) {\n    return coords.filter((coord) => {\n        const extremes = coord.axis.getExtremes(), axisMin = extremes.min, axisMax = extremes.max, \n        // Correct axis edges when axis has series\n        // with pointRange (like column)\n        minPointOffset = pick(coord.axis.minPointOffset, 0);\n        return isNumber(axisMin) && isNumber(axisMax) &&\n            coord.value >= (axisMin - minPointOffset) &&\n            coord.value <= (axisMax + minPointOffset) &&\n            // Don't count navigator axis\n            !coord.axis.options.isInternal;\n    })[0]; // If the axes overlap, return the first axis that was found.\n}\n/**\n * Get field type according to value\n *\n * @internal\n *\n * @param {'boolean'|'number'|'string'} value\n * Atomic type (one of: string, number, boolean)\n *\n * @return {'checkbox'|'number'|'text'}\n * Field type (one of: text, number, checkbox)\n */\nfunction getFieldType(key, value) {\n    const predefinedType = annotationsFieldsTypes[key];\n    let fieldType = typeof value;\n    if (defined(predefinedType)) {\n        fieldType = predefinedType;\n    }\n    return {\n        'string': 'text',\n        'number': 'number',\n        'boolean': 'checkbox'\n    }[fieldType];\n}\n/* *\n *\n *  Default Export\n *\n * */\n/** @internal */\nconst NavigationBindingUtilities = {\n    annotationsFieldsTypes,\n    getAssignedAxis,\n    getFieldType\n};\n/** @internal */\nexport default NavigationBindingUtilities;\n"],"names":[],"mappings":";;;;AAWA;AAXA;;;;;;;;;GASG,GACH;;AAEA,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAG,8KAAC;AACrC;;;;GAIG,GACH;;;;CAIC,GACD,MAAM,yBAAyB;IAC3B,iBAAiB;IACjB,aAAa;IACb,cAAc;IACd,OAAO;IACP,MAAM;IACN,UAAU;IACV,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,OAAO;AACX;AACA;;;;GAIG,GACH;;;;;;;;;;;CAWC,GACD,SAAS,gBAAgB,MAAM;IAC3B,OAAO,OAAO,MAAM,CAAC,CAAC;QAClB,MAAM,WAAW,MAAM,IAAI,CAAC,WAAW,IAAI,UAAU,SAAS,GAAG,EAAE,UAAU,SAAS,GAAG,EACzF,0CAA0C;QAC1C,gCAAgC;QAChC,iBAAiB,KAAK,MAAM,IAAI,CAAC,cAAc,EAAE;QACjD,OAAO,SAAS,YAAY,SAAS,YACjC,MAAM,KAAK,IAAK,UAAU,kBAC1B,MAAM,KAAK,IAAK,UAAU,kBAC1B,6BAA6B;QAC7B,CAAC,MAAM,IAAI,CAAC,OAAO,CAAC,UAAU;IACtC,EAAE,CAAC,EAAE,EAAE,6DAA6D;AACxE;AACA;;;;;;;;;;CAUC,GACD,SAAS,aAAa,GAAG,EAAE,KAAK;IAC5B,MAAM,iBAAiB,sBAAsB,CAAC,IAAI;IAClD,IAAI,YAAY,OAAO;IACvB,IAAI,QAAQ,iBAAiB;QACzB,YAAY;IAChB;IACA,OAAO,CAAA;QACH,UAAU;QACV,UAAU;QACV,WAAW;IACf,CAAA,CAAC,CAAC,UAAU;AAChB;AACA;;;;GAIG,GACH,cAAc,GACd,MAAM,6BAA6B;IAC/B;IACA;IACA;AACJ;uCAEe","ignoreList":[0]}},
    {"offset": {"line": 2378, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Extensions/MouseWheelZoom/MouseWheelZoom.js"],"sourcesContent":["/* *\n *\n *  (c) 2023-2026 Highsoft AS\n *  Author: Torstein Honsi, Askel Eirik Johansson\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport U from '../../Core/Utilities.js';\nconst { addEvent, isObject, pick, defined, merge } = U;\nimport NBU from '../Annotations/NavigationBindingsUtilities.js';\nconst { getAssignedAxis } = NBU;\n/* *\n *\n *  Constants\n *\n * */\nconst composedClasses = [], defaultOptions = {\n    enabled: true,\n    sensitivity: 1.1,\n    showResetButton: false\n};\nlet wheelTimer;\n/* *\n *\n *  Functions\n *\n * */\n/** @internal */\nconst optionsToObject = (options) => {\n    if (!isObject(options)) {\n        options = {\n            enabled: options ?? true\n        };\n    }\n    return merge(defaultOptions, options);\n};\n/** @internal */\nconst zoomBy = function (chart, howMuch, xAxis, yAxis, mouseX, mouseY, options) {\n    const type = pick(options.type, chart.zooming.type, '');\n    let axes = [];\n    if (type === 'x') {\n        axes = xAxis;\n    }\n    else if (type === 'y') {\n        axes = yAxis;\n    }\n    else if (type === 'xy') {\n        axes = chart.axes;\n    }\n    const hasZoomed = chart.transform({\n        axes,\n        // Create imaginary reference and target rectangles around the mouse\n        // point that scales up or down with `howMuch`;\n        to: {\n            x: mouseX - 5,\n            y: mouseY - 5,\n            // Must use 10 to get passed the limit for too small reference.\n            // Below this, the transform will default to a pan.\n            width: 10,\n            height: 10\n        },\n        from: {\n            x: mouseX - 5 * howMuch,\n            y: mouseY - 5 * howMuch,\n            width: 10 * howMuch,\n            height: 10 * howMuch\n        },\n        trigger: 'mousewheel',\n        allowResetButton: options.showResetButton\n    });\n    if (hasZoomed) {\n        if (defined(wheelTimer)) {\n            clearTimeout(wheelTimer);\n        }\n        // Some time after the last mousewheel event, run drop. In case any of\n        // the affected axes had `startOnTick` or `endOnTick`, they will be\n        // re-adjusted now.\n        wheelTimer = setTimeout(() => {\n            chart.pointer?.drop();\n        }, 400);\n    }\n    return hasZoomed;\n};\n/** @internal */\nfunction onAfterGetContainer() {\n    const wheelZoomOptions = optionsToObject(this.zooming.mouseWheel);\n    if (wheelZoomOptions.enabled) {\n        addEvent(this.container, 'wheel', (e) => {\n            e = this.pointer?.normalize(e) || e;\n            const { pointer } = this, allowZoom = pointer && !pointer.inClass(e.target, 'highcharts-no-mousewheel');\n            // Firefox uses e.detail, WebKit and IE uses deltaX, deltaY, deltaZ.\n            if (this.isInsidePlot(e.chartX - this.plotLeft, e.chartY - this.plotTop) && allowZoom) {\n                const wheelSensitivity = wheelZoomOptions.sensitivity || 1.1, delta = e.detail || ((e.deltaY || 0) / 120), xAxisCoords = getAssignedAxis(pointer.getCoordinates(e).xAxis), yAxisCoords = getAssignedAxis(pointer.getCoordinates(e).yAxis);\n                const hasZoomed = zoomBy(this, Math.pow(wheelSensitivity, delta), xAxisCoords ? [xAxisCoords.axis] : this.xAxis, yAxisCoords ? [yAxisCoords.axis] : this.yAxis, e.chartX, e.chartY, wheelZoomOptions);\n                // Prevent page scroll\n                if (hasZoomed) {\n                    e.preventDefault?.();\n                }\n            }\n        });\n    }\n}\n/** @internal */\nfunction compose(ChartClass) {\n    if (composedClasses.indexOf(ChartClass) === -1) {\n        composedClasses.push(ChartClass);\n        addEvent(ChartClass, 'afterGetContainer', onAfterGetContainer);\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst MouseWheelZoomComposition = {\n    compose\n};\nexport default MouseWheelZoomComposition;\n/* *\n *\n *  API Options\n *\n * */\n/**\n * The mouse wheel zoom is a feature included in Highcharts Stock, but is also\n * available for Highcharts Core as a module. Zooming with the mouse wheel is\n * enabled by default in Highcharts Stock. In Highcharts Core it is enabled if\n * [chart.zooming.type](chart.zooming.type) is set. It can be disabled by\n * setting this option to `false`.\n *\n * @type      {boolean|object}\n * @since 11.1.0\n * @requires  modules/mouse-wheel-zoom\n * @sample    {highcharts} highcharts/mouse-wheel-zoom/enabled\n *            Enable or disable\n * @sample    {highstock} stock/mouse-wheel-zoom/enabled\n *            Enable or disable\n * @apioption chart.zooming.mouseWheel\n */\n/**\n * Zooming with the mouse wheel can be disabled by setting this option to\n * `false`.\n *\n * @type      {boolean}\n * @default   true\n * @since 11.1.0\n * @requires  modules/mouse-wheel-zoom\n * @apioption chart.zooming.mouseWheel.enabled\n */\n/**\n * Adjust the sensitivity of the zoom. Sensitivity of mouse wheel or trackpad\n * scrolling. `1` is no sensitivity, while with `2`, one mouse wheel delta will\n * zoom in `50%`.\n *\n * @type      {number}\n * @default   1.1\n * @since 11.1.0\n * @requires  modules/mouse-wheel-zoom\n * @sample    {highcharts} highcharts/mouse-wheel-zoom/sensitivity\n *            Change mouse wheel zoom sensitivity\n * @sample    {highstock} stock/mouse-wheel-zoom/sensitivity\n *            Change mouse wheel zoom sensitivity\n * @apioption chart.zooming.mouseWheel.sensitivity\n */\n/**\n * Decides in what dimensions the user can zoom scrolling the wheel. Can be one\n * of `x`, `y` or `xy`. In Highcharts Core, if not specified here, it will\n * inherit the type from [chart.zooming.type](chart.zooming.type). In Highcharts\n * Stock, it defaults to `x`.\n *\n * Note that particularly with mouse wheel in the y direction, the zoom is\n * affected by the default [yAxis.startOnTick](#yAxis.startOnTick) and\n * [endOnTick]((#yAxis.endOnTick)) settings. In order to respect these settings,\n * the zoom level will adjust after the user has stopped zooming. To prevent\n * this, consider setting `startOnTick` and `endOnTick` to `false`.\n *\n * @type      {string}\n * @default   {highcharts} undefined\n * @default   {highstock} x\n * @validvalue [\"x\", \"y\", \"xy\"]\n * @since 11.1.0\n * @requires  modules/mouse-wheel-zoom\n * @apioption chart.zooming.mouseWheel.type\n */\n/**\n * Whether to enable the reset zoom button when zooming with the mouse wheel.\n *\n * @type      {boolean}\n * @default   false\n * @since {next}\n * @requires  modules/mouse-wheel-zoom\n * @sample    {highcharts} highcharts/mouse-wheel-zoom/reset-zoom-button\n *            Enable reset zoom button for mouse wheel zooming\n * @sample    {highstock} stock/mouse-wheel-zoom/reset-zoom-button\n *            Enable reset zoom button for mouse wheel zooming\n * @apioption chart.zooming.mouseWheel.showResetButton\n */\n(''); // Keeps doclets above in JS file\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2578, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Extensions/Pane/PaneComposition.js"],"sourcesContent":["/* *\n *\n *  Imports\n *\n * */\nimport U from '../../Core/Utilities.js';\nconst { addEvent, correctFloat, defined, pick } = U;\n/* *\n *\n *  Functions\n *\n * */\n/** @internal */\nfunction chartGetHoverPane(eventArgs) {\n    const chart = this;\n    let hoverPane;\n    if (eventArgs) {\n        chart.pane.forEach((pane) => {\n            const x = eventArgs.chartX - chart.plotLeft, y = eventArgs.chartY - chart.plotTop;\n            if (isInsidePane(x, y, pane.center)) {\n                hoverPane = pane;\n            }\n        });\n    }\n    return hoverPane;\n}\n/**\n * Adjusts the clipBox based on the position of panes.\n * @internal\n */\nfunction onSetClip({ clipBox }) {\n    if (!this.xAxis ||\n        !this.yAxis ||\n        (!this.chart.angular && !this.chart.polar)) {\n        return;\n    }\n    const { plotWidth, plotHeight } = this.chart, smallestSize = Math.min(plotWidth, plotHeight), xPane = this.xAxis.pane, yPane = this.yAxis.pane;\n    if (xPane && xPane.axis) {\n        clipBox.x += xPane.center[0] -\n            (xPane.center[2] / smallestSize) * plotWidth / 2;\n    }\n    if (yPane && yPane.axis) {\n        clipBox.y += yPane.center[1] -\n            (yPane.center[2] / smallestSize) * plotHeight / 2;\n    }\n}\n/** @internal */\nfunction compose(ChartClass, PointerClass, SeriesClass) {\n    const chartProto = ChartClass.prototype;\n    if (!chartProto.getHoverPane) {\n        chartProto.collectionsWithUpdate.push('pane');\n        chartProto.getHoverPane = chartGetHoverPane;\n        addEvent(ChartClass, 'afterIsInsidePlot', onChartAfterIsInsiderPlot);\n        addEvent(PointerClass, 'afterGetHoverData', onPointerAfterGetHoverData);\n        addEvent(PointerClass, 'beforeGetHoverData', onPointerBeforeGetHoverData);\n        addEvent(SeriesClass, 'setClip', onSetClip);\n    }\n}\n/**\n * Check whether element is inside or outside pane.\n * @internal\n * @param  {number} x\n * Element's x coordinate\n * @param  {number} y\n * Element's y coordinate\n * @param  {Array<number>} center\n * Pane's center (x, y) and diameter\n * @param  {number} startAngle\n * Pane's normalized start angle in radians (<-PI, PI>)\n * @param  {number} endAngle\n * Pane's normalized end angle in radians (<-PI, PI>)\n */\nfunction isInsidePane(x, y, center, startAngle, endAngle) {\n    let insideSlice = true;\n    const cx = center[0], cy = center[1], twoPi = 2 * Math.PI;\n    const distance = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(y - cy, 2));\n    if (defined(startAngle) && defined(endAngle)) {\n        // Round angle to N-decimals to avoid numeric errors\n        let angle = Math.atan2(correctFloat(y - cy, 8), correctFloat(x - cx, 8));\n        // Normalize angle to [0, 2)\n        angle = (angle + twoPi) % (twoPi);\n        startAngle = (startAngle + twoPi) % (twoPi);\n        endAngle = (endAngle + twoPi) % (twoPi);\n        // Ignore full circle panes:\n        if (Math.abs(endAngle - startAngle) > 1e-6) {\n            // If the normalized start angle is greater than the end angle,\n            // it means the arc wraps around 0. In this case, we check\n            // if the angle falls into either [startAngle, 2) or [0, endAngle].\n            if (startAngle > endAngle) {\n                insideSlice = (angle >= startAngle ||\n                    angle <= endAngle);\n            }\n            else {\n                // In this case, we simply check if angle is within the\n                // [startAngle, endAngle] range\n                insideSlice = angle >= startAngle &&\n                    angle <= endAngle;\n            }\n        }\n    }\n    else {\n        // If no start/end angles are defined, treat it as a full circle\n        insideSlice = true;\n    }\n    // Round up radius because x and y values are rounded\n    return distance <= Math.ceil(center[2] / 2) && insideSlice;\n}\n/**\n * Check if (x, y) position is within pane for polar.\n * @internal\n */\nfunction onChartAfterIsInsiderPlot(e) {\n    const chart = this;\n    if (chart.polar) {\n        if (e.options.inverted) {\n            [e.x, e.y] = [e.y, e.x];\n        }\n        e.isInsidePlot = chart.pane.some((pane) => isInsidePane(e.x, e.y, pane.center, pane.axis && pane.axis.normalizedStartAngleRad, pane.axis && pane.axis.normalizedEndAngleRad));\n    }\n}\n/**\n *\n */\nfunction onPointerAfterGetHoverData(eventArgs) {\n    const chart = this.chart;\n    if (eventArgs.hoverPoint &&\n        eventArgs.hoverPoint.plotX &&\n        eventArgs.hoverPoint.plotY &&\n        chart.hoverPane &&\n        !isInsidePane(eventArgs.hoverPoint.plotX, eventArgs.hoverPoint.plotY, chart.hoverPane.center)) {\n        eventArgs.hoverPoint = void 0;\n    }\n}\n/** @internal */\nfunction onPointerBeforeGetHoverData(eventArgs) {\n    const chart = this.chart;\n    if (chart.polar) {\n        // Find pane we are currently hovering over.\n        chart.hoverPane = chart.getHoverPane(eventArgs);\n        // Edit filter method to handle polar\n        eventArgs.filter = function (s) {\n            return (s.visible &&\n                !(!eventArgs.shared && s.directTouch) && // #3821\n                pick(s.options.enableMouseTracking, true) &&\n                (!chart.hoverPane || s.xAxis.pane === chart.hoverPane));\n        };\n    }\n    else {\n        chart.hoverPane = void 0;\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst PaneComposition = {\n    compose\n};\nexport default PaneComposition;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2725, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Extensions/Pane/PaneDefaults.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport D from '../../Core/Defaults.js';\nconst { defaultOptions } = D;\n/* *\n *\n *  API Options\n *\n * */\n/**\n * A background item or an array of such for the pane. When used in\n * `Highcharts.setOptions` for theming, the background must be a single item.\n *\n * @sample {highcharts} highcharts/demo/gauge-speedometer/\n *         Speedometer gauge with multiple backgrounds\n *\n * @type         {Array<*>}\n * @optionparent pane.background\n */\nconst background = {\n    /**\n     * The class name for this background.\n     *\n     * @sample {highcharts} highcharts/css/pane/\n     *         Panes styled by CSS\n     * @sample {highstock} highcharts/css/pane/\n     *         Panes styled by CSS\n     * @sample {highmaps} highcharts/css/pane/\n     *         Panes styled by CSS\n     *\n     * @type      {string}\n     * @default   highcharts-pane\n     * @since     5.0.0\n     * @apioption pane.background.className\n     */\n    /**\n     * The shape of the pane background. When `solid`, the background\n     * is circular. When `arc`, the background extends only from the min\n     * to the max of the value axis.\n     *\n     * @type    {Highcharts.PaneBackgroundShapeValue}\n     * @since   2.3.0\n     * @product highcharts\n     */\n    shape: 'circle',\n    /**\n     * The border radius of the pane background when the shape is `arc`. Can be\n     * a number (pixels) or a percentage string.\n     *\n     * @since 11.4.2\n     * @sample  highcharts/series-solidgauge/pane-borderradius\n     *          Circular gauge and pane with equal border radius\n     * @product highcharts\n     * @type    {number|string}\n     */\n    borderRadius: 0,\n    /**\n     * The pixel border width of the pane background.\n     *\n     * @since 2.3.0\n     * @product highcharts\n     */\n    borderWidth: 1,\n    /**\n     * The pane background border color.\n     *\n     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @since   2.3.0\n     * @product highcharts\n     */\n    borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n    /**\n     * The background color or gradient for the pane.\n     *\n     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @default { linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 }, stops: [[0, #ffffff], [1, #e6e6e6]] }\n     * @since   2.3.0\n     * @product highcharts\n     */\n    backgroundColor: {\n        /** @ignore-option */\n        linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },\n        /** @ignore-option */\n        stops: [\n            [0, \"#ffffff\" /* Palette.backgroundColor */],\n            [1, \"#e6e6e6\" /* Palette.neutralColor10 */]\n        ]\n    },\n    /** @ignore-option */\n    from: -Number.MAX_VALUE, // Corrected to axis min\n    /**\n     * The inner radius of the pane background. Can be either numeric\n     * (pixels) or a percentage string.\n     *\n     * @type    {number|string}\n     * @since   2.3.0\n     * @product highcharts\n     */\n    innerRadius: 0,\n    /** @ignore-option */\n    to: Number.MAX_VALUE, // Corrected to axis max\n    /**\n     * The outer radius of the circular pane background. Can be either\n     * numeric (pixels) or a percentage string.\n     *\n     * @type     {number|string}\n     * @since    2.3.0\n     * @product  highcharts\n     */\n    outerRadius: '105%'\n};\n/**\n * The pane serves as a container for axes and backgrounds for circular\n * gauges and polar charts.\n *\n * When used in `Highcharts.setOptions` for theming, the pane must be a single\n * object, otherwise arrays are supported.\n *\n * @type         {*|Array<*>}\n * @since        2.3.0\n * @product      highcharts\n * @requires     highcharts-more\n * @optionparent pane\n */\nconst pane = {\n    background,\n    /**\n     * The end angle of the polar X axis or gauge value axis, given in\n     * degrees where 0 is north. Defaults to [startAngle](#pane.startAngle)\n     * + 360.\n     *\n     * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n     *         VU-meter with custom start and end angle\n     *\n     * @type      {number}\n     * @since     2.3.0\n     * @product   highcharts\n     * @apioption pane.endAngle\n     */\n    /**\n     * The center of a polar chart or angular gauge, given as an array\n     * of [x, y] positions. Positions can be given as integers that\n     * transform to pixels, or as percentages of the plot area size.\n     *\n     * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n     *         Two gauges with different center\n     *\n     * @type    {Array<string|number>}\n     * @default [\"50%\", \"50%\"]\n     * @since   2.3.0\n     * @product highcharts\n     */\n    center: ['50%', '50%'],\n    /**\n     * The size of the pane, either as a number defining pixels, or a\n     * percentage defining a percentage of the available plot area (the\n     * smallest of the plot height or plot width).\n     *\n     * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n     *         Smaller size\n     *\n     * @type    {number|string}\n     * @product highcharts\n     */\n    size: '85%',\n    /**\n     * The inner size of the pane, either as a number defining pixels, or a\n     * percentage defining a percentage of the pane's size.\n     *\n     * @sample {highcharts} highcharts/series-polar/column-inverted-inner\n     *         The inner size set to 20%\n     *\n     * @type    {number|string}\n     * @product highcharts\n     */\n    innerSize: '0%',\n    /**\n     * The start angle of the polar X axis or gauge axis, given in degrees\n     * where 0 is north. Defaults to 0.\n     *\n     * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n     *         VU-meter with custom start and end angle\n     *\n     * @since   2.3.0\n     * @product highcharts\n     */\n    startAngle: 0\n};\ndefaultOptions.pane = pane;\n/* *\n *\n *  Default Export\n *\n * */\nconst PaneDefaults = {\n    pane,\n    background\n};\nexport default PaneDefaults;\n"],"names":[],"mappings":";;;;AAWA;AAXA;;;;;;;;;GASG,GACH;;AAEA,MAAM,EAAE,cAAc,EAAE,GAAG,6KAAC;AAC5B;;;;GAIG,GACH;;;;;;;;;CASC,GACD,MAAM,aAAa;IACf;;;;;;;;;;;;;;KAcC,GACD;;;;;;;;KAQC,GACD,OAAO;IACP;;;;;;;;;KASC,GACD,cAAc;IACd;;;;;KAKC,GACD,aAAa;IACb;;;;;;KAMC,GACD,aAAa,UAAU,0BAA0B;IACjD;;;;;;;KAOC,GACD,iBAAiB;QACb,mBAAmB,GACnB,gBAAgB;YAAE,IAAI;YAAG,IAAI;YAAG,IAAI;YAAG,IAAI;QAAE;QAC7C,mBAAmB,GACnB,OAAO;YACH;gBAAC;gBAAG,UAAU,2BAA2B;aAAG;YAC5C;gBAAC;gBAAG,UAAU,0BAA0B;aAAG;SAC9C;IACL;IACA,mBAAmB,GACnB,MAAM,CAAC,OAAO,SAAS;IACvB;;;;;;;KAOC,GACD,aAAa;IACb,mBAAmB,GACnB,IAAI,OAAO,SAAS;IACpB;;;;;;;KAOC,GACD,aAAa;AACjB;AACA;;;;;;;;;;;;CAYC,GACD,MAAM,OAAO;IACT;IACA;;;;;;;;;;;;KAYC,GACD;;;;;;;;;;;;KAYC,GACD,QAAQ;QAAC;QAAO;KAAM;IACtB;;;;;;;;;;KAUC,GACD,MAAM;IACN;;;;;;;;;KASC,GACD,WAAW;IACX;;;;;;;;;KASC,GACD,YAAY;AAChB;AACA,eAAe,IAAI,GAAG;AACtB;;;;GAIG,GACH,MAAM,eAAe;IACjB;IACA;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 2934, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Extensions/Pane/Pane.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport CU from '../../Series/CenteredUtilities.js';\nimport PaneComposition from './PaneComposition.js';\nimport PaneDefaults from './PaneDefaults.js';\nimport U from '../../Core/Utilities.js';\nconst { extend, merge, splat } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * The Pane object allows options that are common to a set of X and Y axes.\n *\n * In the future, this can be extended to basic Highcharts and Highcharts Stock.\n *\n * @internal\n * @class\n * @name Highcharts.Pane\n * @param {Highcharts.PaneOptions} options\n * @param {Highcharts.Chart} chart\n */\nclass Pane {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    constructor(options, chart) {\n        this.coll = 'pane'; // Member of chart.pane\n        this.init(options, chart);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Initialize the Pane object\n     *\n     * @internal\n     * @function Highcharts.Pane#init\n     *\n     * @param {Highcharts.PaneOptions} options\n     *\n     * @param {Highcharts.Chart} chart\n     */\n    init(options, chart) {\n        this.chart = chart;\n        this.background = [];\n        chart.pane.push(this);\n        this.setOptions(options);\n    }\n    /**\n     * @internal\n     * @function Highcharts.Pane#setOptions\n     *\n     * @param {Highcharts.PaneOptions} options\n     */\n    setOptions(options) {\n        // Set options. Angular charts have a default background (#3318)\n        this.options = options = merge(PaneDefaults.pane, { background: this.chart.angular ? {} : void 0 }, options);\n    }\n    /**\n     * Render the pane with its backgrounds.\n     *\n     * @internal\n     * @function Highcharts.Pane#render\n     */\n    render() {\n        const options = this.options, renderer = this.chart.renderer;\n        if (!this.group) {\n            this.group = renderer.g('pane-group')\n                .attr({ zIndex: options.zIndex || 0 })\n                .add();\n        }\n        this.updateCenter();\n        let backgroundOption = this.options.background;\n        // Render the backgrounds\n        if (backgroundOption) {\n            backgroundOption = splat(backgroundOption);\n            const len = Math.max(backgroundOption.length, this.background.length || 0);\n            for (let i = 0; i < len; i++) {\n                // #6641 - if axis exists, chart is circular and apply\n                // background\n                if (backgroundOption[i] && this.axis) {\n                    this.renderBackground(merge(PaneDefaults.background, backgroundOption[i]), i);\n                }\n                else if (this.background[i]) {\n                    this.background[i] = this.background[i].destroy();\n                    this.background.splice(i, 1);\n                }\n            }\n        }\n    }\n    /**\n     * Render an individual pane background.\n     *\n     * @internal\n     * @function Highcharts.Pane#renderBackground\n     *\n     * @param {Highcharts.PaneBackgroundOptions} backgroundOptions\n     *        Background options\n     *\n     * @param {number} i\n     *        The index of the background in this.backgrounds\n     */\n    renderBackground(backgroundOptions, i) {\n        const attribs = {\n            'class': 'highcharts-pane ' + (backgroundOptions.className || '')\n        };\n        let method = 'animate';\n        if (!this.chart.styledMode) {\n            extend(attribs, {\n                'fill': backgroundOptions.backgroundColor,\n                'stroke': backgroundOptions.borderColor,\n                'stroke-width': backgroundOptions.borderWidth\n            });\n        }\n        if (!this.background[i]) {\n            this.background[i] = this.chart.renderer\n                .path()\n                .add(this.group);\n            method = 'attr';\n        }\n        this.background[i][method]({\n            'd': this.axis.getPlotBandPath(backgroundOptions.from, backgroundOptions.to, backgroundOptions)\n        }).attr(attribs);\n    }\n    /**\n     * Gets the center for the pane and its axis.\n     *\n     * @internal\n     * @function Highcharts.Pane#updateCenter\n     * @param {Highcharts.Axis} [axis]\n     */\n    updateCenter(axis) {\n        this.center = (axis ||\n            this.axis ||\n            {}).center = CU.getCenter.call(this);\n    }\n    /**\n     * Destroy the pane item\n     *\n     * @ignore\n     * @internal\n     * @function Highcharts.Pane#destroy\n     * /\n    destroy: function () {\n        erase(this.chart.pane, this);\n        this.background.forEach(function (background) {\n            background.destroy();\n        });\n        this.background.length = 0;\n        this.group = this.group.destroy();\n    },\n    */\n    /**\n     * Update the pane item with new options\n     *\n     * @internal\n     * @function Highcharts.Pane#update\n     * @param {Highcharts.PaneOptions} options\n     *        New pane options\n     * @param {boolean} [redraw]\n     */\n    update(options, redraw) {\n        merge(true, this.options, options);\n        this.setOptions(this.options);\n        this.render();\n        this.chart.axes.forEach(function (axis) {\n            if (axis.pane === this) {\n                axis.pane = null;\n                axis.update({}, redraw);\n            }\n        }, this);\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nPane.compose = PaneComposition.compose;\n/* *\n *\n *  Default Export\n *\n * */\nexport default Pane;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * @typedef {\"arc\"|\"circle\"|\"solid\"} Highcharts.PaneBackgroundShapeValue\n */\n''; // Keeps doclets above in JS file\n"],"names":[],"mappings":";;;;AAWA;AACA;AACA;AACA;AAdA;;;;;;;;;GASG,GACH;;;;;AAKA,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,8KAAC;AAClC;;;;GAIG,GACH;;;;;;;;;;CAUC,GACD,MAAM;IACF;;;;OAIG,GACH,YAAY,OAAO,EAAE,KAAK,CAAE;QACxB,IAAI,CAAC,IAAI,GAAG,QAAQ,uBAAuB;QAC3C,IAAI,CAAC,IAAI,CAAC,SAAS;IACvB;IACA;;;;OAIG,GACH;;;;;;;;;KASC,GACD,KAAK,OAAO,EAAE,KAAK,EAAE;QACjB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,UAAU,GAAG,EAAE;QACpB,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI;QACpB,IAAI,CAAC,UAAU,CAAC;IACpB;IACA;;;;;KAKC,GACD,WAAW,OAAO,EAAE;QAChB,gEAAgE;QAChE,IAAI,CAAC,OAAO,GAAG,UAAU,MAAM,+LAAY,CAAC,IAAI,EAAE;YAAE,YAAY,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,CAAC,IAAI,KAAK;QAAE,GAAG;IACxG;IACA;;;;;KAKC,GACD,SAAS;QACL,MAAM,UAAU,IAAI,CAAC,OAAO,EAAE,WAAW,IAAI,CAAC,KAAK,CAAC,QAAQ;QAC5D,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACb,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,CAAC,cACnB,IAAI,CAAC;gBAAE,QAAQ,QAAQ,MAAM,IAAI;YAAE,GACnC,GAAG;QACZ;QACA,IAAI,CAAC,YAAY;QACjB,IAAI,mBAAmB,IAAI,CAAC,OAAO,CAAC,UAAU;QAC9C,yBAAyB;QACzB,IAAI,kBAAkB;YAClB,mBAAmB,MAAM;YACzB,MAAM,MAAM,KAAK,GAAG,CAAC,iBAAiB,MAAM,EAAE,IAAI,CAAC,UAAU,CAAC,MAAM,IAAI;YACxE,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IAAK;gBAC1B,sDAAsD;gBACtD,aAAa;gBACb,IAAI,gBAAgB,CAAC,EAAE,IAAI,IAAI,CAAC,IAAI,EAAE;oBAClC,IAAI,CAAC,gBAAgB,CAAC,MAAM,+LAAY,CAAC,UAAU,EAAE,gBAAgB,CAAC,EAAE,GAAG;gBAC/E,OACK,IAAI,IAAI,CAAC,UAAU,CAAC,EAAE,EAAE;oBACzB,IAAI,CAAC,UAAU,CAAC,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,OAAO;oBAC/C,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG;gBAC9B;YACJ;QACJ;IACJ;IACA;;;;;;;;;;;KAWC,GACD,iBAAiB,iBAAiB,EAAE,CAAC,EAAE;QACnC,MAAM,UAAU;YACZ,SAAS,qBAAqB,CAAC,kBAAkB,SAAS,IAAI,EAAE;QACpE;QACA,IAAI,SAAS;QACb,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;YACxB,OAAO,SAAS;gBACZ,QAAQ,kBAAkB,eAAe;gBACzC,UAAU,kBAAkB,WAAW;gBACvC,gBAAgB,kBAAkB,WAAW;YACjD;QACJ;QACA,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,EAAE;YACrB,IAAI,CAAC,UAAU,CAAC,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CACnC,IAAI,GACJ,GAAG,CAAC,IAAI,CAAC,KAAK;YACnB,SAAS;QACb;QACA,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,OAAO,CAAC;YACvB,KAAK,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,kBAAkB,IAAI,EAAE,kBAAkB,EAAE,EAAE;QACjF,GAAG,IAAI,CAAC;IACZ;IACA;;;;;;KAMC,GACD,aAAa,IAAI,EAAE;QACf,IAAI,CAAC,MAAM,GAAG,CAAC,QACX,IAAI,CAAC,IAAI,IACT,CAAC,CAAC,EAAE,MAAM,GAAG,wLAAE,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI;IAC3C;IACA;;;;;;;;;;;;;;;IAeA,GACA;;;;;;;;KAQC,GACD,OAAO,OAAO,EAAE,MAAM,EAAE;QACpB,MAAM,MAAM,IAAI,CAAC,OAAO,EAAE;QAC1B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO;QAC5B,IAAI,CAAC,MAAM;QACX,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,SAAU,IAAI;YAClC,IAAI,KAAK,IAAI,KAAK,IAAI,EAAE;gBACpB,KAAK,IAAI,GAAG;gBACZ,KAAK,MAAM,CAAC,CAAC,GAAG;YACpB;QACJ,GAAG,IAAI;IACX;AACJ;AACA;;;;GAIG,GACH,KAAK,OAAO,GAAG,kMAAe,CAAC,OAAO;uCAMvB;AACf;;;;GAIG,GACH;;CAEC,GACD,IAAI,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 3132, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Extensions/TextPath.js"],"sourcesContent":["/* *\n *\n *  Highcharts module with textPath functionality.\n *\n *  (c) 2009-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport H from '../Core/Globals.js';\nimport U from '../Core/Utilities.js';\nconst { deg2rad } = H;\nconst { addEvent, merge, uniqueKey, defined, extend } = U;\n/**\n * Set a text path for a `text` or `label` element, allowing the text to\n * flow along a path.\n *\n * In order to unset the path for an existing element, call `setTextPath`\n * with `{ enabled: false }` as the second argument.\n *\n * Text path support is not bundled into `highcharts.js`, and requires the\n * `modules/textpath.js` file. However, it is included in the script files of\n * those series types that use it by default\n *\n * @sample highcharts/members/renderer-textpath/ Text path demonstrated\n *\n * @function Highcharts.SVGElement#setTextPath\n *\n * @param {Highcharts.SVGElement|undefined} path\n *        Path to follow. If undefined, it allows changing options for the\n *        existing path.\n *\n * @param {Highcharts.DataLabelsTextPathOptionsObject} textPathOptions\n *        Options.\n *\n * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.\n */\nfunction setTextPath(path, textPathOptions) {\n    // Defaults\n    textPathOptions = merge(true, {\n        enabled: true,\n        attributes: {\n            dy: -5,\n            startOffset: '50%',\n            textAnchor: 'middle'\n        }\n    }, textPathOptions);\n    const url = this.renderer.url, textWrapper = this.text || this, textPath = textWrapper.textPath, { attributes, enabled } = textPathOptions;\n    path = path || (textPath && textPath.path);\n    // Remove previously added event\n    if (textPath) {\n        textPath.undo();\n    }\n    if (path && enabled) {\n        const undo = addEvent(textWrapper, 'afterModifyTree', (e) => {\n            if (path && enabled) {\n                // Set ID for the path\n                let textPathId = path.attr('id');\n                if (!textPathId) {\n                    path.attr('id', textPathId = uniqueKey());\n                }\n                // Set attributes for the <text>\n                const textAttribs = {\n                    // `dx`/`dy` options must by set on <text> (parent), the\n                    // rest should be set on <textPath>\n                    x: 0,\n                    y: 0\n                };\n                if (defined(attributes.dx)) {\n                    textAttribs.dx = attributes.dx;\n                    delete attributes.dx;\n                }\n                if (defined(attributes.dy)) {\n                    textAttribs.dy = attributes.dy;\n                    delete attributes.dy;\n                }\n                textWrapper.attr(textAttribs);\n                // Handle label properties\n                this.attr({ transform: '' });\n                if (this.box) {\n                    this.box = this.box.destroy();\n                }\n                // Wrap the nodes in a textPath\n                const children = e.nodes.slice(0);\n                e.nodes.length = 0;\n                e.nodes[0] = {\n                    tagName: 'textPath',\n                    attributes: extend(attributes, {\n                        'text-anchor': attributes.textAnchor,\n                        href: `${url}#${textPathId}`\n                    }),\n                    children\n                };\n            }\n        });\n        // Set the reference\n        textWrapper.textPath = { path, undo };\n    }\n    else {\n        textWrapper.attr({ dx: 0, dy: 0 });\n        delete textWrapper.textPath;\n    }\n    if (this.added) {\n        // Rebuild text after added\n        textWrapper.textCache = '';\n        this.renderer.buildText(textWrapper);\n    }\n    return this;\n}\n/**\n * Attach a polygon to a bounding box if the element contains a textPath.\n *\n * @function Highcharts.SVGElement#setPolygon\n *\n * @param {any} event\n *        An event containing a bounding box object\n *\n * @return {Highcharts.BBoxObject} Returns the bounding box object.\n */\nfunction setPolygon(event) {\n    const bBox = event.bBox, tp = this.element?.querySelector('textPath');\n    if (tp) {\n        const polygon = [], { b, h } = this.renderer.fontMetrics(this.element), descender = h - b, lineCleanerRegex = new RegExp('(<tspan>|' +\n            '<tspan(?!\\\\sclass=\"highcharts-br\")[^>]*>|' +\n            '<\\\\/tspan>)', 'g'), lines = tp\n            .innerHTML\n            .replace(lineCleanerRegex, '')\n            .split(/<tspan class=\"highcharts-br\"[^>]*>/), numOfLines = lines.length;\n        // Calculate top and bottom coordinates for\n        // either the start or the end of a single\n        // character, and append it to the polygon.\n        const appendTopAndBottom = (charIndex, positionOfChar) => {\n            const { x, y } = positionOfChar, rotation = (tp.getRotationOfChar(charIndex) - 90) * deg2rad, cosRot = Math.cos(rotation), sinRot = Math.sin(rotation);\n            return [\n                [\n                    x - descender * cosRot,\n                    y - descender * sinRot\n                ],\n                [\n                    x + b * cosRot,\n                    y + b * sinRot\n                ]\n            ];\n        };\n        for (let i = 0, lineIndex = 0; lineIndex < numOfLines; lineIndex++) {\n            const line = lines[lineIndex], lineLen = line.length;\n            for (let lineCharIndex = 0; lineCharIndex < lineLen; lineCharIndex += 5) {\n                try {\n                    const srcCharIndex = (i +\n                        lineCharIndex +\n                        lineIndex), [lower, upper] = appendTopAndBottom(srcCharIndex, tp.getStartPositionOfChar(srcCharIndex));\n                    if (lineCharIndex === 0) {\n                        polygon.push(upper);\n                        polygon.push(lower);\n                    }\n                    else {\n                        if (lineIndex === 0) {\n                            polygon.unshift(upper);\n                        }\n                        if (lineIndex === numOfLines - 1) {\n                            polygon.push(lower);\n                        }\n                    }\n                }\n                catch {\n                    // Safari fails on getStartPositionOfChar even if the\n                    // character is within the `textContent.length`\n                    break;\n                }\n            }\n            i += lineLen - 1;\n            try {\n                const srcCharIndex = i + lineIndex, charPos = tp.getEndPositionOfChar(srcCharIndex), [lower, upper] = appendTopAndBottom(srcCharIndex, charPos);\n                polygon.unshift(upper);\n                polygon.unshift(lower);\n            }\n            catch {\n                // Safari fails on getStartPositionOfChar even if the character\n                // is within the `textContent.length`\n                break;\n            }\n        }\n        // Close it\n        if (polygon.length) {\n            polygon.push(polygon[0].slice());\n        }\n        bBox.polygon = polygon;\n    }\n    return bBox;\n}\n/**\n * Draw text along a textPath for a dataLabel.\n *\n * @function Highcharts.SVGElement#setTextPath\n *\n * @param {any} event\n *        An event containing label options\n *\n * @return {void}\n */\nfunction drawTextPath(event) {\n    const labelOptions = event.labelOptions, point = event.point, textPathOptions = (labelOptions[point.formatPrefix + 'TextPath'] ||\n        labelOptions.textPath);\n    if (textPathOptions && !labelOptions.useHTML) {\n        this.setTextPath(point.getDataLabelPath?.(this) || point.graphic, textPathOptions);\n        if (point.dataLabelPath &&\n            !textPathOptions.enabled) {\n            // Clean the DOM\n            point.dataLabelPath = (point.dataLabelPath.destroy());\n        }\n    }\n}\nfunction compose(SVGElementClass) {\n    addEvent(SVGElementClass, 'afterGetBBox', setPolygon);\n    addEvent(SVGElementClass, 'beforeAddingDataLabel', drawTextPath);\n    const svgElementProto = SVGElementClass.prototype;\n    if (!svgElementProto.setTextPath) {\n        svgElementProto.setTextPath = setTextPath;\n    }\n}\nconst TextPath = {\n    compose\n};\nexport default TextPath;\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}