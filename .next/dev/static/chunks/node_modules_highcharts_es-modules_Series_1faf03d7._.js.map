{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/CenteredUtilities.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport H from '../Core/Globals.js';\nconst { deg2rad } = H;\nimport Series from '../Core/Series/Series.js';\nimport U from '../Core/Utilities.js';\nconst { fireEvent, isNumber, pick, relativeLength } = U;\n/**\n * @private\n */\nvar CenteredUtilities;\n(function (CenteredUtilities) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * Get the center of the pie based on the size and center options relative\n     * to the plot area. Borrowed by the polar and gauge series types.\n     *\n     * @private\n     * @function Highcharts.CenteredSeriesMixin.getCenter\n     */\n    function getCenter() {\n        const options = this.options, chart = this.chart, slicingRoom = 2 * (options.slicedOffset || 0), plotWidth = chart.plotWidth - 2 * slicingRoom, plotHeight = chart.plotHeight - 2 * slicingRoom, centerOption = options.center, smallestSize = Math.min(plotWidth, plotHeight), thickness = options.thickness;\n        let handleSlicingRoom, size = options.size, innerSize = options.innerSize || 0, i, value;\n        if (typeof size === 'string') {\n            size = parseFloat(size);\n        }\n        if (typeof innerSize === 'string') {\n            innerSize = parseFloat(innerSize);\n        }\n        const positions = [\n            pick(centerOption?.[0], '50%'),\n            pick(centerOption?.[1], '50%'),\n            // Prevent from negative values\n            pick(size && size < 0 ? void 0 : options.size, '100%'),\n            pick(innerSize && innerSize < 0 ? void 0 : options.innerSize || 0, '0%')\n        ];\n        // No need for inner size in angular (gauges) series but still required\n        // for pie series\n        if (chart.angular && !(this instanceof Series)) {\n            positions[3] = 0;\n        }\n        for (i = 0; i < 4; ++i) {\n            value = positions[i];\n            handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));\n            // I == 0: centerX, relative to width\n            // i == 1: centerY, relative to height\n            // i == 2: size, relative to smallestSize\n            // i == 3: innerSize, relative to size\n            positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) + (handleSlicingRoom ? slicingRoom : 0);\n        }\n        // Inner size cannot be larger than size (#3632)\n        if (positions[3] > positions[2]) {\n            positions[3] = positions[2];\n        }\n        // Thickness overrides innerSize, need to be less than pie size (#6647)\n        if (isNumber(thickness) &&\n            thickness * 2 < positions[2] && thickness > 0) {\n            positions[3] = positions[2] - thickness * 2;\n        }\n        fireEvent(this, 'afterGetCenter', { positions });\n        return positions;\n    }\n    CenteredUtilities.getCenter = getCenter;\n    /**\n     * GetStartAndEndRadians - Calculates start and end angles in radians.\n     * Used in series types such as pie and sunburst.\n     *\n     * @private\n     * @function Highcharts.CenteredSeriesMixin.getStartAndEndRadians\n     *\n     * @param {number} [start]\n     *        Start angle in degrees.\n     *\n     * @param {number} [end]\n     *        Start angle in degrees.\n     *\n     * @return {Highcharts.RadianAngles}\n     *         Returns an object containing start and end angles as radians.\n     */\n    function getStartAndEndRadians(start, end) {\n        const startAngle = isNumber(start) ? start : 0, // Must be a number\n        endAngle = ((isNumber(end) && // Must be a number\n            end > startAngle && // Must be larger than the start angle\n            // difference must be less than 360 degrees\n            (end - startAngle) < 360) ?\n            end :\n            startAngle + 360), correction = -90;\n        return {\n            start: deg2rad * (startAngle + correction),\n            end: deg2rad * (endAngle + correction)\n        };\n    }\n    CenteredUtilities.getStartAndEndRadians = getStartAndEndRadians;\n})(CenteredUtilities || (CenteredUtilities = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default CenteredUtilities;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * @private\n * @interface Highcharts.RadianAngles\n */ /**\n* @name Highcharts.RadianAngles#end\n* @type {number}\n*/ /**\n* @name Highcharts.RadianAngles#start\n* @type {number}\n*/\n''; // Keeps doclets above in JS file\n"],"names":[],"mappings":";;;;AAWA;AAEA;AACA;AAdA;;;;;;;;;GASG,GACH;;AAEA,MAAM,EAAE,OAAO,EAAE,GAAG,4KAAC;;;AAGrB,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,IAAI,EAAE,cAAc,EAAE,GAAG,8KAAC;AACvD;;CAEC,GACD,IAAI;AACJ,CAAC,SAAU,iBAAiB;IACxB;;;;OAIG,GACH;;;;OAIG,GACH,8BAA8B,GAC9B;;;;;;KAMC,GACD,SAAS;QACL,MAAM,UAAU,IAAI,CAAC,OAAO,EAAE,QAAQ,IAAI,CAAC,KAAK,EAAE,cAAc,IAAI,CAAC,QAAQ,YAAY,IAAI,CAAC,GAAG,YAAY,MAAM,SAAS,GAAG,IAAI,aAAa,aAAa,MAAM,UAAU,GAAG,IAAI,aAAa,eAAe,QAAQ,MAAM,EAAE,eAAe,KAAK,GAAG,CAAC,WAAW,aAAa,YAAY,QAAQ,SAAS;QAC7S,IAAI,mBAAmB,OAAO,QAAQ,IAAI,EAAE,YAAY,QAAQ,SAAS,IAAI,GAAG,GAAG;QACnF,IAAI,OAAO,SAAS,UAAU;YAC1B,OAAO,WAAW;QACtB;QACA,IAAI,OAAO,cAAc,UAAU;YAC/B,YAAY,WAAW;QAC3B;QACA,MAAM,YAAY;YACd,KAAK,cAAc,CAAC,EAAE,EAAE;YACxB,KAAK,cAAc,CAAC,EAAE,EAAE;YACxB,+BAA+B;YAC/B,KAAK,QAAQ,OAAO,IAAI,KAAK,IAAI,QAAQ,IAAI,EAAE;YAC/C,KAAK,aAAa,YAAY,IAAI,KAAK,IAAI,QAAQ,SAAS,IAAI,GAAG;SACtE;QACD,uEAAuE;QACvE,iBAAiB;QACjB,IAAI,MAAM,OAAO,IAAI,CAAC,CAAC,IAAI,YAAY,qLAAM,GAAG;YAC5C,SAAS,CAAC,EAAE,GAAG;QACnB;QACA,IAAK,IAAI,GAAG,IAAI,GAAG,EAAE,EAAG;YACpB,QAAQ,SAAS,CAAC,EAAE;YACpB,oBAAoB,IAAI,KAAM,MAAM,KAAK,KAAK,IAAI,CAAC;YACnD,qCAAqC;YACrC,sCAAsC;YACtC,yCAAyC;YACzC,sCAAsC;YACtC,SAAS,CAAC,EAAE,GAAG,eAAe,OAAO;gBAAC;gBAAW;gBAAY;gBAAc,SAAS,CAAC,EAAE;aAAC,CAAC,EAAE,IAAI,CAAC,oBAAoB,cAAc,CAAC;QACvI;QACA,gDAAgD;QAChD,IAAI,SAAS,CAAC,EAAE,GAAG,SAAS,CAAC,EAAE,EAAE;YAC7B,SAAS,CAAC,EAAE,GAAG,SAAS,CAAC,EAAE;QAC/B;QACA,uEAAuE;QACvE,IAAI,SAAS,cACT,YAAY,IAAI,SAAS,CAAC,EAAE,IAAI,YAAY,GAAG;YAC/C,SAAS,CAAC,EAAE,GAAG,SAAS,CAAC,EAAE,GAAG,YAAY;QAC9C;QACA,UAAU,IAAI,EAAE,kBAAkB;YAAE;QAAU;QAC9C,OAAO;IACX;IACA,kBAAkB,SAAS,GAAG;IAC9B;;;;;;;;;;;;;;;KAeC,GACD,SAAS,sBAAsB,KAAK,EAAE,GAAG;QACrC,MAAM,aAAa,SAAS,SAAS,QAAQ,GAC7C,WAAY,AAAC,SAAS,QAAQ,mBAAmB;QAC7C,MAAM,cAAc,sCAAsC;QAC1D,2CAA2C;QAC1C,MAAM,aAAc,MACrB,MACA,aAAa,KAAM,aAAa,CAAC;QACrC,OAAO;YACH,OAAO,UAAU,CAAC,aAAa,UAAU;YACzC,KAAK,UAAU,CAAC,WAAW,UAAU;QACzC;IACJ;IACA,kBAAkB,qBAAqB,GAAG;AAC9C,CAAC,EAAE,qBAAqB,CAAC,oBAAoB,CAAC,CAAC;uCAMhC;AACf;;;;GAIG,GACH;;;CAGC,GAAG;;;AAGJ,GAAG;;;AAGH,GACA,IAAI,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/AreaRange/AreaRangePoint.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { area: { prototype: { pointClass: AreaPoint, pointClass: { prototype: areaProto } } } } = SeriesRegistry.seriesTypes;\nimport U from '../../Core/Utilities.js';\nconst { defined, isNumber } = U;\n/* *\n *\n *  Class\n *\n * */\nclass AreaRangePoint extends AreaPoint {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * @private\n     */\n    setState() {\n        const prevState = this.state, series = this.series, isPolar = series.chart.polar;\n        if (!defined(this.plotHigh)) {\n            // Boost doesn't calculate plotHigh\n            this.plotHigh = series.yAxis.toPixels(this.high, true);\n        }\n        if (!defined(this.plotLow)) {\n            // Boost doesn't calculate plotLow\n            this.plotLow = this.plotY = series.yAxis.toPixels(this.low, true);\n        }\n        series.lowerStateMarkerGraphic = series.stateMarkerGraphic;\n        series.stateMarkerGraphic = series.upperStateMarkerGraphic;\n        // Change state also for the top marker\n        this.graphic = this.graphics && this.graphics[1];\n        this.plotY = this.plotHigh;\n        if (isPolar && isNumber(this.plotHighX)) {\n            this.plotX = this.plotHighX;\n        }\n        // Top state:\n        areaProto.setState.apply(this, arguments);\n        this.state = prevState;\n        // Now restore defaults\n        this.plotY = this.plotLow;\n        this.graphic = this.graphics && this.graphics[0];\n        if (isPolar && isNumber(this.plotLowX)) {\n            this.plotX = this.plotLowX;\n        }\n        series.upperStateMarkerGraphic = series.stateMarkerGraphic;\n        series.stateMarkerGraphic = series.lowerStateMarkerGraphic;\n        // Lower marker is stored at stateMarkerGraphic\n        // to avoid reference duplication (#7021)\n        series.lowerStateMarkerGraphic = void 0;\n        const originalSettings = series.modifyMarkerSettings();\n        // Bottom state\n        areaProto.setState.apply(this, arguments);\n        // Restore previous state\n        series.restoreMarkerSettings(originalSettings);\n    }\n    haloPath() {\n        const isPolar = this.series.chart.polar;\n        let path = [];\n        // Bottom halo\n        this.plotY = this.plotLow;\n        if (isPolar && isNumber(this.plotLowX)) {\n            this.plotX = this.plotLowX;\n        }\n        if (this.isInside) {\n            path = areaProto.haloPath.apply(this, arguments);\n        }\n        // Top halo\n        this.plotY = this.plotHigh;\n        if (isPolar && isNumber(this.plotHighX)) {\n            this.plotX = this.plotHighX;\n        }\n        if (this.isTopInside) {\n            path = path.concat(areaProto.haloPath.apply(this, arguments));\n        }\n        return path;\n    }\n    isValid() {\n        return isNumber(this.low) && isNumber(this.high);\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nexport default AreaRangePoint;\n/* *\n *\n *  API Options\n *\n * */\n/**\n * Range series only. The high or maximum value for each data point.\n *\n * @name Highcharts.Point#high\n * @type {number|undefined}\n */\n/**\n * Range series only. The low or minimum value for each data point.\n *\n * @name Highcharts.Point#low\n * @type {number|undefined}\n */\n''; // Keeps doclets above in JS file.\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 253, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/AreaRange/AreaRangeSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport AreaRangePoint from './AreaRangePoint.js';\nimport H from '../../Core/Globals.js';\nconst { noop } = H;\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { area: AreaSeries, area: { prototype: areaProto }, column: { prototype: columnProto } } = SeriesRegistry.seriesTypes;\nimport U from '../../Core/Utilities.js';\nconst { addEvent, defined, extend, isArray, isNumber, pick, merge } = U;\n/* *\n *\n *  Constants\n *\n * */\n/**\n * The area range series is a carteseian series with higher and lower values for\n * each point along an X axis, where the area between the values is shaded.\n *\n * @sample {highcharts} highcharts/demo/arearange/\n *         Area range chart\n * @sample {highstock} stock/demo/arearange/\n *         Area range chart\n *\n * @extends      plotOptions.area\n * @product      highcharts highstock\n * @excluding    stack, stacking\n * @requires     highcharts-more\n * @optionparent plotOptions.arearange\n *\n * @private\n */\nconst areaRangeSeriesOptions = {\n    /**\n     * @see [fillColor](#plotOptions.arearange.fillColor)\n     * @see [fillOpacity](#plotOptions.arearange.fillOpacity)\n     *\n     * @apioption plotOptions.arearange.color\n     */\n    /**\n     * @default   low\n     * @apioption plotOptions.arearange.colorKey\n     */\n    /**\n     * @see [color](#plotOptions.arearange.color)\n     * @see [fillOpacity](#plotOptions.arearange.fillOpacity)\n     *\n     * @apioption plotOptions.arearange.fillColor\n     */\n    /**\n     * @see [color](#plotOptions.arearange.color)\n     * @see [fillColor](#plotOptions.arearange.fillColor)\n     *\n     * @default   {highcharts} 0.75\n     * @default   {highstock} 0.75\n     * @apioption plotOptions.arearange.fillOpacity\n     */\n    /**\n     * Whether to apply a drop shadow to the graph line. Since 2.3 the\n     * shadow can be an object configuration containing `color`, `offsetX`,\n     * `offsetY`, `opacity` and `width`.\n     *\n     * @type      {boolean|Highcharts.ShadowOptionsObject}\n     * @product   highcharts\n     * @apioption plotOptions.arearange.shadow\n     */\n    /**\n     * Pixel width of the arearange graph line.\n     *\n     * @since 2.3.0\n     *\n     * @private\n     */\n    lineWidth: 1,\n    /**\n     * @type {number|null}\n     */\n    threshold: null,\n    tooltip: {\n        pointFormat: '<span style=\"color:{series.color}\">\\u25CF</span> ' +\n            '{series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n    },\n    /**\n     * Whether the whole area or just the line should respond to mouseover\n     * tooltips and other mouse or touch events.\n     *\n     * @since 2.3.0\n     *\n     * @private\n     */\n    trackByArea: true,\n    /**\n     * Extended data labels for range series types. Range series data\n     * labels use no `x` and `y` options. Instead, they have `xLow`,\n     * `xHigh`, `yLow` and `yHigh` options to allow the higher and lower\n     * data label sets individually.\n     *\n     * @declare Highcharts.SeriesAreaRangeDataLabelsOptionsObject\n     * @exclude x, y\n     * @since   2.3.0\n     * @product highcharts highstock\n     *\n     * @private\n     */\n    dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        /**\n         * X offset of the lower data labels relative to the point value.\n         *\n         * @sample highcharts/plotoptions/arearange-datalabels/\n         *         Data labels on range series\n         * @sample highcharts/plotoptions/arearange-datalabels/\n         *         Data labels on range series\n         */\n        xLow: 0,\n        /**\n         * X offset of the higher data labels relative to the point value.\n         *\n         * @sample highcharts/plotoptions/arearange-datalabels/\n         *         Data labels on range series\n         */\n        xHigh: 0,\n        /**\n         * Y offset of the lower data labels relative to the point value.\n         *\n         * @sample highcharts/plotoptions/arearange-datalabels/\n         *         Data labels on range series\n         */\n        yLow: 0,\n        /**\n         * Y offset of the higher data labels relative to the point value.\n         *\n         * @sample highcharts/plotoptions/arearange-datalabels/\n         *         Data labels on range series\n         */\n        yHigh: 0\n    }\n};\n/* *\n *\n *  Class\n *\n * */\n/**\n * The AreaRange series type.\n *\n * @private\n * @class\n * @name Highcharts.seriesTypes.arearange\n *\n * @augments Highcharts.Series\n */\nclass AreaRangeSeries extends AreaSeries {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    toYData(point) {\n        return [point.low, point.high];\n    }\n    /**\n     * Translate a point's plotHigh from the internal angle and radius measures\n     * to true plotHigh coordinates. This is an addition of the toXY method\n     * found in Polar.js, because it runs too early for arearanges to be\n     * considered (#3419).\n     * @private\n     */\n    highToXY(point) {\n        // Find the polar plotX and plotY\n        const chart = this.chart, xy = this.xAxis.postTranslate(point.rectPlotX || 0, this.yAxis.len - (point.plotHigh || 0));\n        point.plotHighX = xy.x - chart.plotLeft;\n        point.plotHigh = xy.y - chart.plotTop;\n        point.plotLowX = point.plotX;\n    }\n    /**\n     * Extend the line series' getSegmentPath method by applying the segment\n     * path to both lower and higher values of the range.\n     * @private\n     */\n    getGraphPath(points) {\n        const highPoints = [], highAreaPoints = [], getGraphPath = areaProto.getGraphPath, options = this.options, polar = this.chart.polar, connectEnds = polar && options.connectEnds !== false, connectNulls = options.connectNulls;\n        let i, point, pointShim, step = options.step;\n        points = points || this.points;\n        // Create the top line and the top part of the area fill. The area fill\n        // compensates for null points by drawing down to the lower graph,\n        // moving across the null gap and starting again at the lower graph.\n        i = points.length;\n        while (i--) {\n            point = points[i];\n            // Support for polar\n            const highAreaPoint = polar ? {\n                plotX: point.rectPlotX,\n                plotY: point.yBottom,\n                doCurve: false // #5186, gaps in areasplinerange fill\n            } : {\n                plotX: point.plotX,\n                plotY: point.plotY,\n                doCurve: false // #5186, gaps in areasplinerange fill\n            };\n            if (!point.isNull &&\n                !connectEnds &&\n                !connectNulls &&\n                (!points[i + 1] || points[i + 1].isNull)) {\n                highAreaPoints.push(highAreaPoint);\n            }\n            pointShim = {\n                polarPlotY: point.polarPlotY,\n                rectPlotX: point.rectPlotX,\n                yBottom: point.yBottom,\n                // `plotHighX` is for polar charts\n                plotX: pick(point.plotHighX, point.plotX),\n                plotY: point.plotHigh,\n                isNull: point.isNull\n            };\n            highAreaPoints.push(pointShim);\n            highPoints.push(pointShim);\n            if (!point.isNull &&\n                !connectEnds &&\n                !connectNulls &&\n                (!points[i - 1] || points[i - 1].isNull)) {\n                highAreaPoints.push(highAreaPoint);\n            }\n        }\n        // Get the paths\n        const lowerPath = getGraphPath.call(this, points);\n        if (step) {\n            if (step === true) {\n                step = 'left';\n            }\n            options.step = {\n                left: 'right',\n                center: 'center',\n                right: 'left'\n            }[step]; // Swap for reading in getGraphPath\n        }\n        const higherPath = getGraphPath.call(this, highPoints);\n        const higherAreaPath = getGraphPath.call(this, highAreaPoints);\n        options.step = step;\n        // Create a line on both top and bottom of the range\n        const linePath = [].concat(lowerPath, higherPath);\n        // For the area path, we need to change the 'move' statement into\n        // 'lineTo'\n        if (!this.chart.polar &&\n            higherAreaPath[0] &&\n            higherAreaPath[0][0] === 'M') {\n            // This probably doesn't work for spline\n            higherAreaPath[0] = [\n                'L',\n                higherAreaPath[0][1],\n                higherAreaPath[0][2]\n            ];\n        }\n        this.graphPath = linePath;\n        this.areaPath = lowerPath.concat(higherAreaPath);\n        // Prepare for sideways animation\n        linePath.isArea = true;\n        linePath.xMap = lowerPath.xMap;\n        this.areaPath.xMap = lowerPath.xMap;\n        return linePath;\n    }\n    /**\n     * Extend the basic drawDataLabels method by running it for both lower and\n     * higher values.\n     * @private\n     */\n    drawDataLabels() {\n        const data = this.points, length = data.length, originalDataLabels = [], dataLabelOptions = this.options.dataLabels, inverted = this.chart.inverted;\n        let i, point, up, upperDataLabelOptions, lowerDataLabelOptions;\n        if (dataLabelOptions) {\n            // Split into upper and lower options. If data labels is an array,\n            // the first element is the upper label, the second is the lower.\n            //\n            // TODO: We want to change this and allow multiple labels for both\n            // upper and lower values in the future - introducing some options\n            // for which point value to use as Y for the dataLabel, so that this\n            // could be handled in Series.drawDataLabels. This would also\n            // improve performance since we now have to loop over all the points\n            // multiple times to work around the data label logic.\n            if (isArray(dataLabelOptions)) {\n                upperDataLabelOptions = dataLabelOptions[0] || {\n                    enabled: false\n                };\n                lowerDataLabelOptions = dataLabelOptions[1] || {\n                    enabled: false\n                };\n            }\n            else {\n                // Make copies\n                upperDataLabelOptions = extend({}, dataLabelOptions);\n                upperDataLabelOptions.x = dataLabelOptions.xHigh;\n                upperDataLabelOptions.y = dataLabelOptions.yHigh;\n                lowerDataLabelOptions = extend({}, dataLabelOptions);\n                lowerDataLabelOptions.x = dataLabelOptions.xLow;\n                lowerDataLabelOptions.y = dataLabelOptions.yLow;\n            }\n            // Draw upper labels\n            if (upperDataLabelOptions.enabled || this.hasDataLabels?.()) {\n                // Set preliminary values for plotY and dataLabel\n                // and draw the upper labels\n                i = length;\n                while (i--) {\n                    point = data[i];\n                    if (point) {\n                        const { plotHigh = 0, plotLow = 0 } = point;\n                        up = upperDataLabelOptions.inside ?\n                            plotHigh < plotLow :\n                            plotHigh > plotLow;\n                        point.y = point.high;\n                        point._plotY = point.plotY;\n                        point.plotY = plotHigh;\n                        // Store original data labels and set preliminary label\n                        // objects to be picked up in the uber method\n                        originalDataLabels[i] = point.dataLabel;\n                        point.dataLabel = point.dataLabelUpper;\n                        // Set the default offset\n                        point.below = up;\n                        if (inverted) {\n                            if (!upperDataLabelOptions.align) {\n                                upperDataLabelOptions.align = up ?\n                                    'right' : 'left';\n                            }\n                        }\n                        else {\n                            if (!upperDataLabelOptions.verticalAlign) {\n                                upperDataLabelOptions.verticalAlign = up ?\n                                    'top' :\n                                    'bottom';\n                            }\n                        }\n                    }\n                }\n                this.options.dataLabels = upperDataLabelOptions;\n                if (areaProto.drawDataLabels) {\n                    // #1209:\n                    areaProto.drawDataLabels.apply(this, arguments);\n                }\n                // Reset state after the upper labels were created. Move\n                // it to point.dataLabelUpper and reassign the originals.\n                // We do this here to support not drawing a lower label.\n                i = length;\n                while (i--) {\n                    point = data[i];\n                    if (point) {\n                        point.dataLabelUpper = point.dataLabel;\n                        point.dataLabel = originalDataLabels[i];\n                        delete point.dataLabels;\n                        point.y = point.low;\n                        point.plotY = point._plotY;\n                    }\n                }\n            }\n            // Draw lower labels\n            if (lowerDataLabelOptions.enabled || this.hasDataLabels?.()) {\n                i = length;\n                while (i--) {\n                    point = data[i];\n                    if (point) {\n                        const { plotHigh = 0, plotLow = 0 } = point;\n                        up = lowerDataLabelOptions.inside ?\n                            plotHigh < plotLow :\n                            plotHigh > plotLow;\n                        // Set the default offset\n                        point.below = !up;\n                        if (inverted) {\n                            if (!lowerDataLabelOptions.align) {\n                                lowerDataLabelOptions.align = up ?\n                                    'left' : 'right';\n                            }\n                        }\n                        else {\n                            if (!lowerDataLabelOptions.verticalAlign) {\n                                lowerDataLabelOptions.verticalAlign = up ?\n                                    'bottom' :\n                                    'top';\n                            }\n                        }\n                    }\n                }\n                this.options.dataLabels = lowerDataLabelOptions;\n                if (areaProto.drawDataLabels) {\n                    areaProto.drawDataLabels.apply(this, arguments);\n                }\n            }\n            // Merge upper and lower into point.dataLabels for later destroying\n            if (upperDataLabelOptions.enabled) {\n                i = length;\n                while (i--) {\n                    point = data[i];\n                    if (point) {\n                        point.dataLabels = [\n                            point.dataLabelUpper,\n                            point.dataLabel\n                        ].filter(function (label) {\n                            return !!label;\n                        });\n                    }\n                }\n            }\n            // Reset options\n            this.options.dataLabels = dataLabelOptions;\n        }\n    }\n    alignDataLabel() {\n        columnProto.alignDataLabel.apply(this, arguments);\n    }\n    modifyMarkerSettings() {\n        const series = this, originalMarkerSettings = {\n            marker: series.options.marker,\n            symbol: series.symbol\n        };\n        if (series.options.lowMarker) {\n            const { options: { marker, lowMarker } } = series;\n            series.options.marker = merge(marker, lowMarker);\n            if (lowMarker.symbol) {\n                series.symbol = lowMarker.symbol;\n            }\n        }\n        return originalMarkerSettings;\n    }\n    restoreMarkerSettings(originalSettings) {\n        const series = this;\n        series.options.marker = originalSettings.marker;\n        series.symbol = originalSettings.symbol;\n    }\n    drawPoints() {\n        const series = this, pointLength = series.points.length;\n        let i, point;\n        const originalSettings = series.modifyMarkerSettings();\n        // Draw bottom points\n        areaProto.drawPoints.apply(series, arguments);\n        // Restore previous state\n        series.restoreMarkerSettings(originalSettings);\n        // Prepare drawing top points\n        i = 0;\n        while (i < pointLength) {\n            point = series.points[i];\n            point.graphics = point.graphics || [];\n            // Save original props to be overridden by temporary props for top\n            // points\n            point.origProps = {\n                plotY: point.plotY,\n                plotX: point.plotX,\n                isInside: point.isInside,\n                negative: point.negative,\n                zone: point.zone,\n                y: point.y\n            };\n            if (point.graphic || point.graphics[0]) {\n                point.graphics[0] = point.graphic;\n            }\n            point.graphic = point.graphics[1];\n            point.plotY = point.plotHigh;\n            if (defined(point.plotHighX)) {\n                point.plotX = point.plotHighX;\n            }\n            point.y = pick(point.high, point.origProps.y); // #15523\n            point.negative = point.y < (series.options.threshold || 0);\n            if (series.zones.length) {\n                point.zone = point.getZone();\n            }\n            if (!series.chart.polar) {\n                point.isInside = point.isTopInside = (typeof point.plotY !== 'undefined' &&\n                    point.plotY >= 0 &&\n                    point.plotY <= series.yAxis.len && // #3519\n                    point.plotX >= 0 &&\n                    point.plotX <= series.xAxis.len);\n            }\n            i++;\n        }\n        // Draw top points\n        areaProto.drawPoints.apply(series, arguments);\n        // Reset top points preliminary modifications\n        i = 0;\n        while (i < pointLength) {\n            point = series.points[i];\n            point.graphics = point.graphics || [];\n            if (point.graphic || point.graphics[1]) {\n                point.graphics[1] = point.graphic;\n            }\n            point.graphic = point.graphics[0];\n            if (point.origProps) {\n                extend(point, point.origProps);\n                delete point.origProps;\n            }\n            i++;\n        }\n    }\n    hasMarkerChanged(options, oldOptions) {\n        const lowMarker = options.lowMarker, oldMarker = oldOptions.lowMarker || {};\n        return (lowMarker && (lowMarker.enabled === false ||\n            oldMarker.symbol !== lowMarker.symbol || // #10870, #15946\n            oldMarker.height !== lowMarker.height || // #16274\n            oldMarker.width !== lowMarker.width // #16274\n        )) || super.hasMarkerChanged(options, oldOptions);\n    }\n}\n/**\n *\n *  Static Properties\n *\n */\nAreaRangeSeries.defaultOptions = merge(AreaSeries.defaultOptions, areaRangeSeriesOptions);\naddEvent(AreaRangeSeries, 'afterTranslate', function () {\n    // Set plotLow and plotHigh\n    // Rules out lollipop, but lollipop should not inherit range series in the\n    // first place\n    if (this.pointArrayMap.join(',') === 'low,high') {\n        this.points.forEach((point) => {\n            const high = point.high, plotY = point.plotY;\n            if (point.isNull) {\n                point.plotY = void 0;\n            }\n            else {\n                point.plotLow = plotY;\n                // Calculate plotHigh value based on each yAxis scale (#15752)\n                point.plotHigh = isNumber(high) ? this.yAxis.translate(this.dataModify ?\n                    this.dataModify.modifyValue(high) : high, false, true, void 0, true) : void 0;\n                if (this.dataModify) {\n                    point.yBottom = point.plotHigh;\n                }\n            }\n        });\n    }\n}, { order: 0 });\naddEvent(AreaRangeSeries, 'afterTranslate', function () {\n    this.points.forEach((point) => {\n        // Postprocessing after the PolarComposition's afterTranslate\n        if (this.chart.polar) {\n            this.highToXY(point);\n            point.plotLow = point.plotY;\n            point.tooltipPos = [\n                ((point.plotHighX || 0) + (point.plotLowX || 0)) / 2,\n                ((point.plotHigh || 0) + (point.plotLow || 0)) / 2\n            ];\n            // Put the tooltip in the middle of the range\n        }\n        else {\n            const tooltipPos = point.pos(false, point.plotLow), posHigh = point.pos(false, point.plotHigh);\n            if (tooltipPos && posHigh) {\n                tooltipPos[0] = (tooltipPos[0] + posHigh[0]) / 2;\n                tooltipPos[1] = (tooltipPos[1] + posHigh[1]) / 2;\n            }\n            point.tooltipPos = tooltipPos;\n        }\n    });\n}, { order: 3 });\nextend(AreaRangeSeries.prototype, {\n    deferTranslatePolar: true,\n    pointArrayMap: ['low', 'high'],\n    pointClass: AreaRangePoint,\n    pointValKey: 'low',\n    setStackedPoints: noop\n});\nSeriesRegistry.registerSeriesType('arearange', AreaRangeSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default AreaRangeSeries;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 788, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/AreaSplineRange/AreaSplineRangeSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport AreaRangeSeries from '../AreaRange/AreaRangeSeries.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { spline: { prototype: splineProto } } = SeriesRegistry.seriesTypes;\nimport U from '../../Core/Utilities.js';\nconst { merge, extend } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * The areasplinerange series type.\n *\n * @private\n * @class\n * @name Highcharts.seriesTypes.areasplinerange\n *\n * @augments Highcharts.Series\n */\nclass AreaSplineRangeSeries extends AreaRangeSeries {\n}\n/* *\n *\n *  Static Properties\n *\n * */\nAreaSplineRangeSeries.defaultOptions = merge(AreaRangeSeries.defaultOptions);\nextend(AreaSplineRangeSeries.prototype, {\n    getPointSpline: splineProto.getPointSpline\n});\nSeriesRegistry.registerSeriesType('areasplinerange', AreaSplineRangeSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default AreaSplineRangeSeries;\n/* *\n *\n *  API Options\n *\n * */\n/**\n * The area spline range is a cartesian series type with higher and\n * lower Y values along an X axis. The area inside the range is colored, and\n * the graph outlining the area is a smoothed spline.\n *\n * @sample {highstock|highstock} stock/demo/areasplinerange/\n *         Area spline range\n *\n * @extends   plotOptions.arearange\n * @since     2.3.0\n * @excluding step, boostThreshold, boostBlending\n * @product   highcharts highstock\n * @requires  highcharts-more\n * @apioption plotOptions.areasplinerange\n */\n/**\n * @see [fillColor](#plotOptions.areasplinerange.fillColor)\n * @see [fillOpacity](#plotOptions.areasplinerange.fillOpacity)\n *\n * @apioption plotOptions.areasplinerange.color\n */\n/**\n * @see [color](#plotOptions.areasplinerange.color)\n * @see [fillOpacity](#plotOptions.areasplinerange.fillOpacity)\n *\n * @apioption plotOptions.areasplinerange.fillColor\n */\n/**\n * @see [color](#plotOptions.areasplinerange.color)\n * @see [fillColor](#plotOptions.areasplinerange.fillColor)\n *\n * @default   0.75\n * @apioption plotOptions.areasplinerange.fillOpacity\n */\n/**\n * A `areasplinerange` series. If the [type](#series.areasplinerange.type)\n * option is not specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.areasplinerange\n * @excluding dataParser, dataURL, stack, step, boostThreshold, boostBlending\n * @product   highcharts highstock\n * @requires  highcharts-more\n * @apioption series.areasplinerange\n */\n/**\n * @see [fillColor](#series.areasplinerange.fillColor)\n * @see [fillOpacity](#series.areasplinerange.fillOpacity)\n *\n * @apioption series.areasplinerange.color\n */\n/**\n * An array of data points for the series. For the `areasplinerange`\n * series type, points can be given in the following ways:\n *\n * 1. An array of arrays with 3 or 2 values. In this case, the values correspond\n *    to `x,low,high`. If the first value is a string, it is applied as the name\n *    of the point, and the `x` value is inferred. The `x` value can also be\n *    omitted, in which case the inner arrays should be of length 2\\. Then the\n *    `x` value is automatically calculated, either starting at 0 and\n *    incremented by 1, or from `pointStart` and `pointInterval` given in the\n *    series options.\n *    ```js\n *    data: [\n *        [0, 0, 5],\n *        [1, 9, 1],\n *        [2, 5, 2]\n *    ]\n *    ```\n *\n * 2. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.areasplinerange.turboThreshold), this option is\n *    not available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        low: 5,\n *        high: 0,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        low: 4,\n *        high: 1,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n * @extends   series.arearange.data\n * @product   highcharts highstock\n * @apioption series.areasplinerange.data\n */\n/**\n * @see [color](#series.areasplinerange.color)\n * @see [fillOpacity](#series.areasplinerange.fillOpacity)\n *\n * @apioption series.areasplinerange.fillColor\n */\n/**\n * @see [color](#series.areasplinerange.color)\n * @see [fillColor](#series.areasplinerange.fillColor)\n *\n * @default   0.75\n * @apioption series.areasplinerange.fillOpacity\n */\n''; // Adds doclets above to transpiled file\n"],"names":[],"mappings":";;;;AAWA;AACA;AAEA;AAdA;;;;;;;;;GASG,GACH;;;AAGA,MAAM,EAAE,QAAQ,EAAE,WAAW,WAAW,EAAE,EAAE,GAAG,6LAAc,CAAC,WAAW;;AAEzE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,8KAAC;AAC3B;;;;GAIG,GACH;;;;;;;;CAQC,GACD,MAAM,8BAA8B,mMAAe;AACnD;AACA;;;;GAIG,GACH,sBAAsB,cAAc,GAAG,MAAM,mMAAe,CAAC,cAAc;AAC3E,OAAO,sBAAsB,SAAS,EAAE;IACpC,gBAAgB,YAAY,cAAc;AAC9C;AACA,6LAAc,CAAC,kBAAkB,CAAC,mBAAmB;uCAMtC;AACf;;;;GAIG,GACH;;;;;;;;;;;;;;CAcC,GACD;;;;;CAKC,GACD;;;;;CAKC,GACD;;;;;;CAMC,GACD;;;;;;;;;CASC,GACD;;;;;CAKC,GACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqDC,GACD;;;;;CAKC,GACD;;;;;;CAMC,GACD,IAAI,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 951, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/BoxPlot/BoxPlotSeriesDefaults.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\n/* *\n *\n *  API Options\n *\n * */\n/**\n * A box plot is a convenient way of depicting groups of data through their\n * five-number summaries: the smallest observation (sample minimum), lower\n * quartile (Q1), median (Q2), upper quartile (Q3), and largest observation\n * (sample maximum).\n *\n * @sample highcharts/demo/box-plot/\n *         Box plot\n * @sample {highcharts} highcharts/css/boxplot/\n *         Box plot in styled mode\n * @sample {highcharts} highcharts/series-scatter/jitter-boxplot\n *         Jittered scatter plot on top of a box plot\n *\n * @extends      plotOptions.column\n * @excluding    borderColor, borderRadius, borderWidth, groupZPadding,\n *               states, boostThreshold, boostBlending\n * @product      highcharts\n * @requires     highcharts-more\n * @optionparent plotOptions.boxplot\n */\nconst BoxPlotSeriesDefaults = {\n    /**\n     * @type {number|null}\n     */\n    threshold: null,\n    tooltip: {\n        pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> <b>' +\n            '{series.name}</b><br/>' +\n            'Maximum: {point.high}<br/>' +\n            'Upper quartile: {point.q3}<br/>' +\n            'Median: {point.median}<br/>' +\n            'Lower quartile: {point.q1}<br/>' +\n            'Minimum: {point.low}<br/>'\n    },\n    /**\n     * The length of the whiskers, the horizontal lines marking low and\n     * high values. It can be a numerical pixel value, or a percentage\n     * value of the box width. Set `0` to disable whiskers.\n     *\n     * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n     *         Box plot styling\n     *\n     * @type    {number|string}\n     * @since   3.0\n     * @product highcharts\n     */\n    whiskerLength: '50%',\n    /**\n     * The fill color of the box.\n     *\n     * In styled mode, the fill color can be set with the\n     * `.highcharts-boxplot-box` class.\n     *\n     * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n     *         Box plot styling\n     *\n     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @default #ffffff\n     * @since   3.0\n     * @product highcharts\n     */\n    fillColor: \"#ffffff\" /* Palette.backgroundColor */,\n    /**\n     * The width of the line surrounding the box. If any of\n     * [stemWidth](#plotOptions.boxplot.stemWidth),\n     * [medianWidth](#plotOptions.boxplot.medianWidth)\n     * or [whiskerWidth](#plotOptions.boxplot.whiskerWidth) are `null`,\n     * the lineWidth also applies to these lines.\n     *\n     * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n     *         Box plot styling\n     * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n     *         Error bar styling\n     *\n     * @since   3.0\n     * @product highcharts\n     */\n    lineWidth: 1,\n    /**\n     * The color of the median line. If `undefined`, the general series\n     * color applies.\n     *\n     * In styled mode, the median stroke width can be set with the\n     * `.highcharts-boxplot-median` class.\n     *\n     * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n     *         Box plot styling\n     * @sample {highcharts} highcharts/css/boxplot/\n     *         Box plot in styled mode\n     * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n     *         Error bar styling\n     *\n     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject}\n     * @since     3.0\n     * @product   highcharts\n     * @apioption plotOptions.boxplot.medianColor\n     */\n    /**\n     * The pixel width of the median line. If `null`, the\n     * [lineWidth](#plotOptions.boxplot.lineWidth) is used.\n     *\n     * In styled mode, the median stroke width can be set with the\n     * `.highcharts-boxplot-median` class.\n     *\n     * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n     *         Box plot styling\n     * @sample {highcharts} highcharts/css/boxplot/\n     *         Box plot in styled mode\n     *\n     * @type    {number|null}\n     * @since   3.0\n     * @product highcharts\n     */\n    medianWidth: 2,\n    /*\n    // States are not working and are removed from docs.\n    // Refer to: #2340\n    states: {\n        hover: {\n            brightness: -0.3\n        }\n    },\n    */\n    /**\n     * The color of the stem, the vertical line extending from the box to\n     * the whiskers. If `undefined`, the series color is used.\n     *\n     * In styled mode, the stem stroke can be set with the\n     * `.highcharts-boxplot-stem` class.\n     *\n     * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n     *         Box plot styling\n     * @sample {highcharts} highcharts/css/boxplot/\n     *         Box plot in styled mode\n     * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n     *         Error bar styling\n     *\n     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @since     3.0\n     * @product   highcharts\n     * @apioption plotOptions.boxplot.stemColor\n     */\n    /**\n     * The dash style of the box.\n     *\n     * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n     *         Box plot styling\n     * @sample {highcharts} highcharts/css/boxplot/\n     *         Box plot in styled mode\n     *\n     * @type      {Highcharts.DashStyleValue}\n     * @default   Solid\n     * @since 8.1.0\n     * @product   highcharts\n     * @apioption plotOptions.boxplot.boxDashStyle\n     */\n    /**\n     * The dash style of the median.\n     *\n     * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n     *         Box plot styling\n     * @sample {highcharts} highcharts/css/boxplot/\n     *         Box plot in styled mode\n     *\n     * @type      {Highcharts.DashStyleValue}\n     * @default   Solid\n     * @since 8.1.0\n     * @product   highcharts\n     * @apioption plotOptions.boxplot.medianDashStyle\n     */\n    /**\n     * The dash style of the stem, the vertical line extending from the\n     * box to the whiskers.\n     *\n     * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n     *         Box plot styling\n     * @sample {highcharts} highcharts/css/boxplot/\n     *         Box plot in styled mode\n     * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n     *         Error bar styling\n     *\n     * @type      {Highcharts.DashStyleValue}\n     * @default   Solid\n     * @since     3.0\n     * @product   highcharts\n     * @apioption plotOptions.boxplot.stemDashStyle\n     */\n    /**\n     * The dash style of the whiskers.\n     *\n     * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n     *         Box plot styling\n     * @sample {highcharts} highcharts/css/boxplot/\n     *         Box plot in styled mode\n     *\n     * @type      {Highcharts.DashStyleValue}\n     * @default   Solid\n     * @since 8.1.0\n     * @product   highcharts\n     * @apioption plotOptions.boxplot.whiskerDashStyle\n     */\n    /**\n     * The width of the stem, the vertical line extending from the box to\n     * the whiskers. If `undefined`, the width is inherited from the\n     * [lineWidth](#plotOptions.boxplot.lineWidth) option.\n     *\n     * In styled mode, the stem stroke width can be set with the\n     * `.highcharts-boxplot-stem` class.\n     *\n     * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n     *         Box plot styling\n     * @sample {highcharts} highcharts/css/boxplot/\n     *         Box plot in styled mode\n     * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n     *         Error bar styling\n     *\n     * @type      {number}\n     * @since     3.0\n     * @product   highcharts\n     * @apioption plotOptions.boxplot.stemWidth\n     */\n    /**\n     * @default   high\n     * @apioption plotOptions.boxplot.colorKey\n     */\n    /**\n     * The color of the whiskers, the horizontal lines marking low and high\n     * values. When `undefined`, the general series color is used.\n     *\n     * In styled mode, the whisker stroke can be set with the\n     * `.highcharts-boxplot-whisker` class .\n     *\n     * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n     *         Box plot styling\n     * @sample {highcharts} highcharts/css/boxplot/\n     *         Box plot in styled mode\n     *\n     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @since     3.0\n     * @product   highcharts\n     * @apioption plotOptions.boxplot.whiskerColor\n     */\n    /**\n     * The line width of the whiskers, the horizontal lines marking low and\n     * high values. When `undefined`, the general\n     * [lineWidth](#plotOptions.boxplot.lineWidth) applies.\n     *\n     * In styled mode, the whisker stroke width can be set with the\n     * `.highcharts-boxplot-whisker` class.\n     *\n     * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n     *         Box plot styling\n     * @sample {highcharts} highcharts/css/boxplot/\n     *         Box plot in styled mode\n     *\n     * @since   3.0\n     * @product highcharts\n     */\n    whiskerWidth: 2\n};\n/**\n * A `boxplot` series. If the [type](#series.boxplot.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.boxplot\n * @excluding dataParser, dataURL, marker, stack, stacking, states,\n *            boostThreshold, boostBlending\n * @product   highcharts\n * @requires  highcharts-more\n * @apioption series.boxplot\n */\n/**\n * An array of data points for the series. For the `boxplot` series\n * type, points can be given in the following ways:\n *\n * 1. An array of arrays with 6 or 5 values. In this case, the values correspond\n *    to `x,low,q1,median,q3,high`. If the first value is a string, it is\n *    applied as the name of the point, and the `x` value is inferred. The `x`\n *    value can also be omitted, in which case the inner arrays should be of\n *    length 5. Then the `x` value is automatically calculated, either starting\n *    at 0 and incremented by 1, or from `pointStart` and `pointInterval` given\n *    in the series options.\n *    ```js\n *    data: [\n *        [0, 3, 0, 10, 3, 5],\n *        [1, 7, 8, 7, 2, 9],\n *        [2, 6, 9, 5, 1, 3]\n *    ]\n *    ```\n *\n * 2. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.boxplot.turboThreshold), this option is not\n *    available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        low: 4,\n *        q1: 9,\n *        median: 9,\n *        q3: 1,\n *        high: 10,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        low: 5,\n *        q1: 7,\n *        median: 3,\n *        q3: 6,\n *        high: 2,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<Array<(number|string),number,number,number,number>|Array<(number|string),number,number,number,number,number>|*>}\n * @extends   series.line.data\n * @excluding marker\n * @product   highcharts\n * @apioption series.boxplot.data\n */\n/**\n * The `high` value for each data point, signifying the highest value\n * in the sample set. The top whisker is drawn here.\n *\n * @type      {number}\n * @product   highcharts\n * @apioption series.boxplot.data.high\n */\n/**\n * The `low` value for each data point, signifying the lowest value\n * in the sample set. The bottom whisker is drawn here.\n *\n * @type      {number}\n * @product   highcharts\n * @apioption series.boxplot.data.low\n */\n/**\n * The median for each data point. This is drawn as a line through the\n * middle area of the box.\n *\n * @type      {number}\n * @product   highcharts\n * @apioption series.boxplot.data.median\n */\n/**\n * The lower quartile for each data point. This is the bottom of the\n * box.\n *\n * @type      {number}\n * @product   highcharts\n * @apioption series.boxplot.data.q1\n */\n/**\n * The higher quartile for each data point. This is the top of the box.\n *\n * @type      {number}\n * @product   highcharts\n * @apioption series.boxplot.data.q3\n */\n/**\n * The dash style of the box.\n *\n * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n *         Box plot styling\n * @sample {highcharts} highcharts/css/boxplot/\n *         Box plot in styled mode\n *\n * @type      {Highcharts.DashStyleValue}\n * @default   Solid\n * @since 8.1.0\n * @product   highcharts\n * @apioption series.boxplot.data.boxDashStyle\n */\n/**\n * The dash style of the median.\n *\n * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n *         Box plot styling\n * @sample {highcharts} highcharts/css/boxplot/\n *         Box plot in styled mode\n *\n * @type      {Highcharts.DashStyleValue}\n * @default   Solid\n * @since 8.1.0\n * @product   highcharts\n * @apioption series.boxplot.data.medianDashStyle\n */\n/**\n * The dash style of the stem.\n *\n * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n *         Box plot styling\n * @sample {highcharts} highcharts/css/boxplot/\n *         Box plot in styled mode\n *\n * @type      {Highcharts.DashStyleValue}\n * @default   Solid\n * @since 8.1.0\n * @product   highcharts\n * @apioption series.boxplot.data.stemDashStyle\n */\n/**\n * The dash style of the whiskers.\n *\n * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n *         Box plot styling\n * @sample {highcharts} highcharts/css/boxplot/\n *         Box plot in styled mode\n *\n * @type      {Highcharts.DashStyleValue}\n * @default   Solid\n * @since 8.1.0\n * @product   highcharts\n * @apioption series.boxplot.data.whiskerDashStyle\n */\n''; // Keeps doclets above separate\n/* *\n *\n *  Default Export\n *\n * */\nexport default BoxPlotSeriesDefaults;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;GASG,GACH;AACA;;;;GAIG,GACH;;;;;;;;;;;;;;;;;;;CAmBC,GACD,MAAM,wBAAwB;IAC1B;;KAEC,GACD,WAAW;IACX,SAAS;QACL,aAAa,wDACT,2BACA,+BACA,oCACA,gCACA,oCACA;IACR;IACA;;;;;;;;;;;KAWC,GACD,eAAe;IACf;;;;;;;;;;;;;KAaC,GACD,WAAW,UAAU,2BAA2B;IAChD;;;;;;;;;;;;;;KAcC,GACD,WAAW;IACX;;;;;;;;;;;;;;;;;;KAkBC,GACD;;;;;;;;;;;;;;;KAeC,GACD,aAAa;IACb;;;;;;;;IAQA,GACA;;;;;;;;;;;;;;;;;;KAkBC,GACD;;;;;;;;;;;;;KAaC,GACD;;;;;;;;;;;;;KAaC,GACD;;;;;;;;;;;;;;;;KAgBC,GACD;;;;;;;;;;;;;KAaC,GACD;;;;;;;;;;;;;;;;;;;KAmBC,GACD;;;KAGC,GACD;;;;;;;;;;;;;;;;KAgBC,GACD;;;;;;;;;;;;;;;KAeC,GACD,cAAc;AAClB;AACA;;;;;;;;;;CAUC,GACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4DC,GACD;;;;;;;CAOC,GACD;;;;;;;CAOC,GACD;;;;;;;CAOC,GACD;;;;;;;CAOC,GACD;;;;;;CAMC,GACD;;;;;;;;;;;;;CAaC,GACD;;;;;;;;;;;;;CAaC,GACD;;;;;;;;;;;;;CAaC,GACD;;;;;;;;;;;;;CAaC,GACD,IAAI,+BAA+B;uCAMpB","ignoreList":[0]}},
    {"offset": {"line": 1368, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Column/ColumnSeriesDefaults.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\n/* *\n *\n *  API Options\n *\n * */\n/**\n * Column series display one column per value along an X axis.\n *\n * @sample {highcharts} highcharts/demo/column-basic/\n *         Column chart\n * @sample {highstock} stock/demo/column/\n *         Column chart\n *\n * @extends      plotOptions.line\n * @excluding    connectEnds, connectNulls, gapSize, gapUnit, linecap,\n *               lineWidth, marker, step, useOhlcData\n * @product      highcharts highstock\n * @optionparent plotOptions.column\n */\nconst ColumnSeriesDefaults = {\n    /**\n     * The corner radius of the border surrounding each column or bar. A number\n     * signifies pixels. A percentage string, like for example `50%`, signifies\n     * a relative size. For columns this is relative to the column width, for\n     * pies it is relative to the radius and the inner radius.\n     *\n     * @sample  {highcharts} highcharts/plotoptions/column-borderradius/\n     *          Rounded columns\n     * @sample  highcharts/plotoptions/series-border-radius\n     *          Column and pie with rounded border\n     *\n     * @type    {number|string|Highcharts.BorderRadiusOptionsObject}\n     * @product highcharts highstock gantt\n     */\n    borderRadius: 3,\n    /**\n     * When using automatic point colors pulled from the global\n     * [colors](colors) or series-specific\n     * [plotOptions.column.colors](series.colors) collections, this option\n     * determines whether the chart should receive one color per series or\n     * one color per point.\n     *\n     * In styled mode, the `colors` or `series.colors` arrays are not\n     * supported, and instead this option gives the points individual color\n     * class names on the form `highcharts-color-{n}`.\n     *\n     * @see [series colors](#plotOptions.column.colors)\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-false/\n     *         False by default\n     * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-true/\n     *         True\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     2.0\n     * @product   highcharts highstock gantt\n     * @apioption plotOptions.column.colorByPoint\n     */\n    /**\n     * A series specific or series type specific color set to apply instead\n     * of the global [colors](#colors) when [colorByPoint](\n     * #plotOptions.column.colorByPoint) is true.\n     *\n     * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}\n     * @since     3.0\n     * @product   highcharts highstock gantt\n     * @apioption plotOptions.column.colors\n     */\n    /**\n     * When `true`, the columns will center in the category, ignoring null\n     * or missing points. When `false`, space will be reserved for null or\n     * missing points.\n     *\n     * @sample {highcharts} highcharts/series-column/centerincategory/\n     *         Center in category\n     * @sample {highcharts} highcharts/series/stack-centerincategory/\n     *         Center in category, stacked and grouped\n     *\n     * @since   8.0.1\n     * @product highcharts highstock gantt\n     */\n    centerInCategory: false,\n    /**\n     * Padding between each value groups, in x axis units.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-grouppadding-default/\n     *         0.2 by default\n     * @sample {highcharts} highcharts/plotoptions/column-grouppadding-none/\n     *         No group padding - all columns are evenly spaced\n     *\n     * @product highcharts highstock gantt\n     */\n    groupPadding: 0.2,\n    /**\n     * Whether to group non-stacked columns or to let them render\n     * independent of each other. Non-grouped columns will be laid out\n     * individually and overlap each other.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-grouping-false/\n     *         Grouping disabled\n     * @sample {highstock} highcharts/plotoptions/column-grouping-false/\n     *         Grouping disabled\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     2.3.0\n     * @product   highcharts highstock gantt\n     * @apioption plotOptions.column.grouping\n     */\n    /** @ignore-option */\n    marker: null, // Point options are specified in the base options\n    /**\n     * The maximum allowed pixel width for a column, translated to the\n     * height of a bar in a bar chart. This prevents the columns from\n     * becoming too wide when there is a small number of points in the\n     * chart.\n     *\n     * @see [pointWidth](#plotOptions.column.pointWidth)\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-maxpointwidth-20/\n     *         Limited to 50\n     * @sample {highstock} highcharts/plotoptions/column-maxpointwidth-20/\n     *         Limited to 50\n     *\n     * @type      {number}\n     * @since     4.1.8\n     * @product   highcharts highstock gantt\n     * @apioption plotOptions.column.maxPointWidth\n     */\n    /**\n     * Padding between each column or bar, in x axis units.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-pointpadding-default/\n     *         0.1 by default\n     * @sample {highcharts} highcharts/plotoptions/column-pointpadding-025/\n     *          0.25\n     * @sample {highcharts} highcharts/plotoptions/column-pointpadding-none/\n     *         0 for tightly packed columns\n     *\n     * @product highcharts highstock gantt\n     */\n    pointPadding: 0.1,\n    /**\n     * A pixel value specifying a fixed width for each column or bar point.\n     * When set to `undefined`, the width is calculated from the\n     * `pointPadding` and `groupPadding`. The width effects the dimension\n     * that is not based on the point value. For column series it is the\n     * horizontal length and for bar series it is the vertical length.\n     *\n     * @see [maxPointWidth](#plotOptions.column.maxPointWidth)\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-pointwidth-20/\n     *         20px wide columns regardless of chart width or the amount of\n     *         data points\n     *\n     * @type      {number}\n     * @since     1.2.5\n     * @product   highcharts highstock gantt\n     * @apioption plotOptions.column.pointWidth\n     */\n    /**\n     * A pixel value specifying a fixed width for the column or bar.\n     * Overrides pointWidth on the series.\n     *\n     * @see [series.pointWidth](#plotOptions.column.pointWidth)\n     *\n     * @type      {number}\n     * @default   undefined\n     * @since     7.0.0\n     * @product   highcharts highstock gantt\n     * @apioption series.column.data.pointWidth\n     */\n    /**\n     * The minimal height for a column or width for a bar. By default,\n     * 0 values are not shown. To visualize a 0 (or close to zero) point,\n     * set the minimal point length to a pixel value like 3\\. In stacked\n     * column charts, minPointLength might not be respected for tightly\n     * packed values.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-minpointlength/\n     *         Zero base value\n     * @sample {highcharts} highcharts/plotoptions/column-minpointlength-pos-and-neg/\n     *         Positive and negative close to zero values\n     *\n     * @product highcharts highstock gantt\n     */\n    minPointLength: 0,\n    /**\n     * When the series contains less points than the crop threshold, all\n     * points are drawn, event if the points fall outside the visible plot\n     * area at the current zoom. The advantage of drawing all points\n     * (including markers and columns), is that animation is performed on\n     * updates. On the other hand, when the series contains more points than\n     * the crop threshold, the series data is cropped to only contain points\n     * that fall within the plot area. The advantage of cropping away\n     * invisible points is to increase performance on large series.\n     *\n     * @product highcharts highstock gantt\n     */\n    cropThreshold: 50,\n    /**\n     * The X axis range that each point is valid for. This determines the\n     * width of the column. On a categorized axis, the range will be 1\n     * by default (one category unit). On linear and datetime axes, the\n     * range will be computed as the distance between the two closest data\n     * points.\n     *\n     * The default `null` means it is computed automatically, but this\n     * option can be used to override the automatic value.\n     *\n     * This option is set by default to 1 if data sorting is enabled.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-pointrange/\n     *         Set the point range to one day on a data set with one week\n     *         between the points\n     *\n     * @type    {number|null}\n     * @since   2.3\n     * @product highcharts highstock gantt\n     */\n    pointRange: null,\n    states: {\n        /**\n         * Options for the hovered point. These settings override the normal\n         * state options when a point is moused over or touched.\n         *\n         * @extends   plotOptions.series.states.hover\n         * @excluding halo, lineWidth, lineWidthPlus, marker\n         * @product   highcharts highstock gantt\n         */\n        hover: {\n            /** @ignore-option */\n            halo: false,\n            /**\n             * A specific border color for the hovered point. Defaults to\n             * inherit the normal state border color.\n             *\n             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @product   highcharts gantt\n             * @apioption plotOptions.column.states.hover.borderColor\n             */\n            /**\n             * A specific color for the hovered point.\n             *\n             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @product   highcharts gantt\n             * @apioption plotOptions.column.states.hover.color\n             */\n            /**\n             * How much to brighten the point on interaction.\n             *\n             * In styled mode, the hover brightening is by default replaced\n             * with a fill-opacity set in the `.highcharts-point:hover`\n             * rule.\n             *\n             * @sample {highcharts} highcharts/plotoptions/column-states-hover-brightness/\n             *         Brighten by 0.5\n             *\n             * @product highcharts highstock gantt\n             */\n            brightness: 0.1\n        },\n        /**\n         * Options for the selected point. These settings override the\n         * normal state options when a point is selected.\n         *\n         * @extends   plotOptions.series.states.select\n         * @excluding halo, lineWidth, lineWidthPlus, marker\n         * @product   highcharts highstock gantt\n         */\n        select: {\n            /**\n             * A specific color for the selected point.\n             *\n             * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @default #cccccc\n             * @product highcharts highstock gantt\n             */\n            color: \"#cccccc\" /* Palette.neutralColor20 */,\n            /**\n             * A specific border color for the selected point.\n             *\n             * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @default #000000\n             * @product highcharts highstock gantt\n             */\n            borderColor: \"#000000\" /* Palette.neutralColor100 */\n        }\n    },\n    dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        /**\n         * The y position offset of the label relative to the point in\n         * pixels.\n         *\n         * @type {number}\n         */\n        y: void 0\n    },\n    // False doesn't work well: https://jsfiddle.net/highcharts/hz8fopan/14/\n    /** @ignore-option */\n    startFromThreshold: true,\n    stickyTracking: false,\n    tooltip: {\n        distance: 6\n    },\n    /**\n     * The Y axis value to serve as the base for the columns, for\n     * distinguishing between values above and below a threshold. If `null`,\n     * the columns extend from the padding Y axis minimum.\n     *\n     * @type    {number|null}\n     * @since   2.0\n     * @product highcharts\n     */\n    threshold: 0,\n    /**\n     * The width of the border surrounding each column or bar. Defaults to\n     * `1` when there is room for a border, but to `0` when the columns are\n     * so dense that a border would cover the next column.\n     *\n     * In styled mode, the stroke width can be set with the\n     * `.highcharts-point` rule.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-borderwidth/\n     *         2px black border\n     *\n     * @type      {number}\n     * @default   undefined\n     * @product   highcharts highstock gantt\n     * @apioption plotOptions.column.borderWidth\n     */\n    /**\n     * The color of the border surrounding each column or bar.\n     *\n     * In styled mode, the border stroke can be set with the\n     * `.highcharts-point` rule.\n     *\n     * @sample {highcharts} highcharts/plotoptions/column-bordercolor/\n     *         Dark gray border\n     *\n     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @default   #ffffff\n     * @product   highcharts highstock gantt\n     */\n    borderColor: \"#ffffff\" /* Palette.backgroundColor */\n};\n/**\n * A `column` series. If the [type](#series.column.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.column\n * @excluding connectNulls, dataParser, dataURL, gapSize, gapUnit, linecap,\n *            lineWidth, marker, connectEnds, step\n * @product   highcharts highstock\n * @apioption series.column\n */\n/**\n * An array of data points for the series. For the `column` series type,\n * points can be given in the following ways:\n *\n * 1. An array of numerical values. In this case, the numerical values will be\n *    interpreted as `y` options. The `x` values will be automatically\n *    calculated, either starting at 0 and incremented by 1, or from\n *    `pointStart` and `pointInterval` given in the series options. If the axis\n *    has categories, these will be used. Example:\n *    ```js\n *    data: [0, 5, 3, 5]\n *    ```\n *\n * 2. An array of arrays with 2 values. In this case, the values correspond to\n *    `x,y`. If the first value is a string, it is applied as the name of the\n *    point, and the `x` value is inferred.\n *    ```js\n *    data: [\n *        [0, 6],\n *        [1, 2],\n *        [2, 6]\n *    ]\n *    ```\n *\n * 3. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.column.turboThreshold), this option is not\n *    available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        y: 9,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        y: 6,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n * @extends   series.line.data\n * @excluding marker\n * @product   highcharts highstock\n * @apioption series.column.data\n */\n/**\n * The color of the border surrounding the column or bar.\n *\n * In styled mode, the border stroke can be set with the `.highcharts-point`\n * rule.\n *\n * @sample {highcharts} highcharts/plotoptions/column-bordercolor/\n *         Dark gray border\n *\n * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n * @product   highcharts highstock\n * @apioption series.column.data.borderColor\n */\n/**\n * The width of the border surrounding the column or bar.\n *\n * In styled mode, the stroke width can be set with the `.highcharts-point`\n * rule.\n *\n * @sample {highcharts} highcharts/plotoptions/column-borderwidth/\n *         2px black border\n *\n * @type      {number}\n * @product   highcharts highstock\n * @apioption series.column.data.borderWidth\n */\n/**\n * A name for the dash style to use for the column or bar. Overrides\n * dashStyle on the series.\n *\n * In styled mode, the stroke dash-array can be set with the same classes as\n * listed under [data.color](#series.column.data.color).\n *\n * @see [series.pointWidth](#plotOptions.column.dashStyle)\n *\n * @type      {Highcharts.DashStyleValue}\n * @apioption series.column.data.dashStyle\n */\n/**\n * A pixel value specifying a fixed width for the column or bar. Overrides\n * pointWidth on the series. The width effects the dimension that is not based\n * on the point value.\n *\n * @see [series.pointWidth](#plotOptions.column.pointWidth)\n *\n * @type      {number}\n * @apioption series.column.data.pointWidth\n */\n/**\n * @excluding halo, lineWidth, lineWidthPlus, marker\n * @product   highcharts highstock\n * @apioption series.column.states.hover\n */\n/**\n * @excluding halo, lineWidth, lineWidthPlus, marker\n * @product   highcharts highstock\n * @apioption series.column.states.select\n */\n/**\n * @extends   series.column.states\n * @product   highcharts highstock\n * @apioption series.column.data.states\n */\n''; // Keeps doclets above in JS file\n/* *\n *\n *  Default Export\n *\n * */\nexport default ColumnSeriesDefaults;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;GASG,GACH;AACA;;;;GAIG,GACH;;;;;;;;;;;;;CAaC,GACD,MAAM,uBAAuB;IACzB;;;;;;;;;;;;;KAaC,GACD,cAAc;IACd;;;;;;;;;;;;;;;;;;;;;;;KAuBC,GACD;;;;;;;;;KASC,GACD;;;;;;;;;;;;KAYC,GACD,kBAAkB;IAClB;;;;;;;;;KASC,GACD,cAAc;IACd;;;;;;;;;;;;;;;KAeC,GACD,mBAAmB,GACnB,QAAQ;IACR;;;;;;;;;;;;;;;;;KAiBC,GACD;;;;;;;;;;;KAWC,GACD,cAAc;IACd;;;;;;;;;;;;;;;;;KAiBC,GACD;;;;;;;;;;;KAWC,GACD;;;;;;;;;;;;;KAaC,GACD,gBAAgB;IAChB;;;;;;;;;;;KAWC,GACD,eAAe;IACf;;;;;;;;;;;;;;;;;;;KAmBC,GACD,YAAY;IACZ,QAAQ;QACJ;;;;;;;SAOC,GACD,OAAO;YACH,mBAAmB,GACnB,MAAM;YACN;;;;;;;aAOC,GACD;;;;;;aAMC,GACD;;;;;;;;;;;aAWC,GACD,YAAY;QAChB;QACA;;;;;;;SAOC,GACD,QAAQ;YACJ;;;;;;aAMC,GACD,OAAO,UAAU,0BAA0B;YAC3C;;;;;;aAMC,GACD,aAAa,UAAU,2BAA2B;QACtD;IACJ;IACA,YAAY;QACR,OAAO,KAAK;QACZ,eAAe,KAAK;QACpB;;;;;SAKC,GACD,GAAG,KAAK;IACZ;IACA,wEAAwE;IACxE,mBAAmB,GACnB,oBAAoB;IACpB,gBAAgB;IAChB,SAAS;QACL,UAAU;IACd;IACA;;;;;;;;KAQC,GACD,WAAW;IACX;;;;;;;;;;;;;;;KAeC,GACD;;;;;;;;;;;;KAYC,GACD,aAAa,UAAU,2BAA2B;AACtD;AACA;;;;;;;;;CASC,GACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2DC,GACD;;;;;;;;;;;;CAYC,GACD;;;;;;;;;;;;CAYC,GACD;;;;;;;;;;;CAWC,GACD;;;;;;;;;CASC,GACD;;;;CAIC,GACD;;;;CAIC,GACD;;;;CAIC,GACD,IAAI,iCAAiC;uCAMtB","ignoreList":[0]}},
    {"offset": {"line": 1832, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Column/ColumnSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport A from '../../Core/Animation/AnimationUtilities.js';\nconst { animObject } = A;\nimport Color from '../../Core/Color/Color.js';\nconst { parse: color } = Color;\nimport ColumnSeriesDefaults from './ColumnSeriesDefaults.js';\nimport H from '../../Core/Globals.js';\nconst { noop } = H;\nimport Series from '../../Core/Series/Series.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nimport U from '../../Core/Utilities.js';\nconst { clamp, crisp, defined, extend, fireEvent, isArray, isNumber, merge, pick, objectEach } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * The column series type.\n *\n * @private\n * @class\n * @name Highcharts.seriesTypes.column\n *\n * @augments Highcharts.Series\n */\nclass ColumnSeries extends Series {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * Animate the column heights one by one from zero.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#animate\n     *\n     * @param {boolean} init\n     *        Whether to initialize the animation or run it\n     */\n    animate(init) {\n        const series = this, yAxis = this.yAxis, yAxisPos = yAxis.pos, reversed = yAxis.reversed, options = series.options, { clipOffset, inverted } = this.chart, attr = {}, translateProp = inverted ?\n            'translateX' :\n            'translateY';\n        let translateStart, translatedThreshold;\n        if (init && clipOffset) {\n            attr.scaleY = 0.001;\n            translatedThreshold = clamp(yAxis.toPixels(options.threshold || 0), yAxisPos, yAxisPos + yAxis.len);\n            if (inverted) {\n                // Make sure the columns don't cover the axis line during\n                // entrance animation\n                translatedThreshold += reversed ?\n                    -Math.floor(clipOffset[0]) :\n                    Math.ceil(clipOffset[2]);\n                attr.translateX = translatedThreshold - yAxis.len;\n            }\n            else {\n                // Make sure the columns don't cover the axis line during\n                // entrance animation\n                translatedThreshold += reversed ?\n                    Math.ceil(clipOffset[0]) :\n                    -Math.floor(clipOffset[2]);\n                attr.translateY = translatedThreshold;\n            }\n            // Apply final clipping (used in Highcharts Stock) (#7083)\n            // animation is done by scaleY, so clipping is for panes\n            if (series.clipBox) {\n                series.setClip();\n            }\n            series.group.attr(attr);\n        }\n        else { // Run the animation\n            translateStart = Number(series.group.attr(translateProp));\n            series.group.animate({ scaleY: 1 }, extend(animObject(series.options.animation), {\n                // Do the scale synchronously to ensure smooth\n                // updating (#5030, #7228)\n                step: function (val, fx) {\n                    if (series.group) {\n                        attr[translateProp] = translateStart +\n                            fx.pos * (yAxisPos - translateStart);\n                        series.group.attr(attr);\n                    }\n                }\n            }));\n        }\n    }\n    /**\n     * Initialize the series. Extends the basic Series.init method by\n     * marking other series of the same type as dirty.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#init\n     */\n    init(chart, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    options) {\n        super.init.apply(this, arguments);\n        const series = this;\n        chart = series.chart;\n        // If the series is added dynamically, force redraw of other\n        // series affected by a new column\n        if (chart.hasRendered) {\n            chart.series.forEach(function (otherSeries) {\n                if (otherSeries.type === series.type) {\n                    otherSeries.isDirty = true;\n                }\n            });\n        }\n    }\n    /**\n     * Return the width and x offset of the columns adjusted for grouping,\n     * groupPadding, pointPadding, pointWidth etc.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#getColumnMetrics\n     */\n    getColumnMetrics() {\n        const series = this, options = series.options, xAxis = series.xAxis, yAxis = series.yAxis, reversedStacks = xAxis.options.reversedStacks, \n        // Keep backward compatibility: reversed xAxis had reversed\n        // stacks\n        reverseStacks = (xAxis.reversed && !reversedStacks) ||\n            (!xAxis.reversed && reversedStacks), stackGroups = {};\n        let stackKey, columnCount = 0;\n        // Get the total number of column type series. This is called on\n        // every series. Consider moving this logic to a chart.orderStacks()\n        // function and call it on init, addSeries and removeSeries\n        if (options.grouping === false) {\n            columnCount = 1;\n        }\n        else {\n            series.chart.series.forEach(function (otherSeries) {\n                const otherYAxis = otherSeries.yAxis, otherOptions = otherSeries.options;\n                let columnIndex;\n                if (otherSeries.type === series.type &&\n                    otherSeries.reserveSpace() &&\n                    yAxis.len === otherYAxis.len &&\n                    yAxis.pos === otherYAxis.pos) { // #642, #2086\n                    if (otherOptions.stacking &&\n                        otherOptions.stacking !== 'group') {\n                        stackKey = otherSeries.stackKey;\n                        if (typeof stackGroups[stackKey] ===\n                            'undefined') {\n                            stackGroups[stackKey] = columnCount++;\n                        }\n                        columnIndex = stackGroups[stackKey];\n                    }\n                    else if (otherOptions.grouping !== false) { // #1162\n                        columnIndex = columnCount++;\n                    }\n                    otherSeries.columnIndex = columnIndex;\n                }\n            });\n        }\n        const categoryWidth = Math.min(Math.abs(xAxis.transA) * ((!xAxis.brokenAxis?.hasBreaks && xAxis.ordinal?.slope) ||\n            options.pointRange ||\n            xAxis.closestPointRange ||\n            xAxis.tickInterval ||\n            1), // #2610\n        xAxis.len // #1535\n        ), groupPadding = categoryWidth * options.groupPadding, groupWidth = categoryWidth - 2 * groupPadding, pointOffsetWidth = groupWidth / (columnCount || 1), pointWidth = Math.min(options.maxPointWidth || xAxis.len, pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))), pointPadding = (pointOffsetWidth - pointWidth) / 2, \n        // #1251, #3737\n        colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0), pointXOffset = pointPadding +\n            (groupPadding +\n                colIndex * pointOffsetWidth -\n                (categoryWidth / 2)) * (reverseStacks ? -1 : 1);\n        // Save it for reading in linked series (Error bars particularly)\n        series.columnMetrics = {\n            width: pointWidth,\n            offset: pointXOffset,\n            paddedWidth: pointOffsetWidth,\n            columnCount\n        };\n        return series.columnMetrics;\n    }\n    /**\n     * Make the columns crisp. The edges are rounded to the nearest full\n     * pixel.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#crispCol\n     */\n    crispCol(x, y, width, height) {\n        const borderWidth = this.borderWidth, inverted = this.chart.inverted, bottom = crisp(y + height, borderWidth, inverted);\n        // Vertical\n        y = crisp(y, borderWidth, inverted);\n        height = bottom - y;\n        // Horizontal. We need to first compute the exact right edge, then\n        // round it and compute the width from there.\n        if (this.options.crisp) {\n            const right = crisp(x + width, borderWidth);\n            x = crisp(x, borderWidth);\n            width = right - x;\n        }\n        return { x, y, width, height };\n    }\n    /**\n     * Adjust for missing columns, according to the `centerInCategory`\n     * option. Missing columns are either single points or stacks where the\n     * point or points are either missing or null.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#adjustForMissingColumns\n     * @param {number} x\n     * The x coordinate of the column, left side\n     *\n     * @param {number} pointWidth\n     * The pointWidth, already computed upstream\n     *\n     * @param {Highcharts.ColumnPoint} point\n     * The point instance\n     *\n     * @param {Highcharts.ColumnMetricsObject} metrics\n     * The series-wide column metrics\n     *\n     * @return {number}\n     * The adjusted x position, or the original if not adjusted\n     */\n    adjustForMissingColumns(x, pointWidth, point, metrics) {\n        if (!point.isNull && metrics.columnCount > 1) {\n            const visibleSeries = this.xAxis.series\n                .filter((s) => s.visible)\n                .map((s) => s.index);\n            let indexInCategory = 0, totalInCategory = 0;\n            // Loop over all the stacks on the Y axis. When stacking is enabled,\n            // these are real point stacks. When stacking is not enabled, but\n            // `centerInCategory` is true, there is one stack handling the\n            // grouping of points in each category. This is done in the\n            // `setGroupedPoints` function.\n            objectEach(this.xAxis.stacking?.stacks, (stack) => {\n                const points = typeof point.x === 'number' ?\n                    stack[point.x.toString()]?.points :\n                    void 0, pointValues = points?.[this.index], yStackMap = {};\n                // Look for the index\n                if (points && isArray(pointValues)) {\n                    let baseIndex = this.index;\n                    // If there are multiple points with the same X then\n                    // gather all series in category, and assign index\n                    const seriesIndexes = Object\n                        .keys(points)\n                        .filter((pointKey) => \n                    // Filter out duplicate X's\n                    !pointKey.match(',') &&\n                        // Filter out null points\n                        points[pointKey] &&\n                        points[pointKey].length > 1)\n                        .map(parseFloat)\n                        .filter((index) => visibleSeries.indexOf(index) !== -1)\n                        // When the series `stack` option is defined, assign\n                        // all subsequent column of the same stack to the\n                        // same index as the base column of the stack, then\n                        // filter out the original series index so that\n                        // `seriesIndexes` is shortened to the amount of\n                        // stacks, not the amount of series (#20550).\n                        .filter((index) => {\n                        const otherOptions = this.chart.series[index]\n                            .options, yStack = otherOptions.stacking &&\n                            otherOptions.stack;\n                        if (defined(yStack)) {\n                            if (isNumber(yStackMap[yStack])) {\n                                if (baseIndex === index) {\n                                    baseIndex = yStackMap[yStack];\n                                }\n                                return false;\n                            }\n                            yStackMap[yStack] = index;\n                        }\n                        return true;\n                    })\n                        .sort((a, b) => b - a);\n                    indexInCategory = seriesIndexes.indexOf(baseIndex);\n                    totalInCategory = seriesIndexes.length;\n                }\n            });\n            indexInCategory = this.xAxis.reversed ?\n                totalInCategory - 1 - indexInCategory : indexInCategory;\n            // Compute the adjusted x position\n            const boxWidth = (totalInCategory - 1) * metrics.paddedWidth +\n                pointWidth;\n            x = (point.plotX || 0) + boxWidth / 2 - pointWidth -\n                indexInCategory * metrics.paddedWidth;\n        }\n        return x;\n    }\n    /**\n     * Translate each point to the plot area coordinate system and find\n     * shape positions\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#translate\n     */\n    translate() {\n        const series = this, chart = series.chart, options = series.options, \n        // For points whithout graphics (null points) this value is used\n        // to reserve space around the point such that:\n        //      - normal/null points are spaced similarily,\n        //      - focusborders of null points are like those of \"0\" points\n        // This ensures consistent dimensions between null/normal points.\n        dense = series.dense =\n            series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick(options.borderWidth, dense ? 0 : 1 // #3635\n        ), xAxis = series.xAxis, yAxis = series.yAxis, threshold = options.threshold, minPointLength = pick(options.minPointLength, 5), metrics = series.getColumnMetrics(), seriesPointWidth = metrics.width, seriesXOffset = series.pointXOffset = metrics.offset, dataMin = series.dataMin, dataMax = series.dataMax, translatedThreshold = series.translatedThreshold =\n            yAxis.getThreshold(threshold);\n        // Postprocessed for border width\n        let seriesBarW = series.barW =\n            Math.max(seriesPointWidth, 1 + 2 * borderWidth);\n        // When the pointPadding is 0, we want the columns to be packed\n        // tightly, so we allow individual columns to have individual sizes.\n        // When pointPadding is greater, we strive for equal-width columns\n        // (#2694).\n        if (options.pointPadding && options.crisp) {\n            seriesBarW = Math.ceil(seriesBarW);\n        }\n        Series.prototype.translate.apply(series);\n        // Record the new values\n        series.points.forEach(function (point) {\n            const yBottom = pick(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotX = point.plotX || 0, \n            // Don't draw too far outside plot area (#1303, #2241,\n            // #4264)\n            plotY = clamp(point.plotY, -safeDistance, yAxis.len + safeDistance);\n            let up, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY, pointWidth = seriesPointWidth, barX = plotX + seriesXOffset, barW = seriesBarW;\n            // Handle options.minPointLength\n            if (minPointLength && Math.abs(barH) < minPointLength) {\n                barH = minPointLength;\n                up = (!yAxis.reversed && !point.negative) ||\n                    (yAxis.reversed && point.negative);\n                // Reverse zeros if there's no positive value in the series\n                // in visible range (#7046)\n                if (isNumber(threshold) &&\n                    isNumber(dataMax) &&\n                    point.y === threshold &&\n                    dataMax <= threshold &&\n                    // And if there's room for it (#7311)\n                    (yAxis.min || 0) < threshold &&\n                    // If all points are the same value (i.e zero) not draw\n                    // as negative points (#10646), but only if there's room\n                    // for it (#14876)\n                    (dataMin !== dataMax || (yAxis.max || 0) <= threshold)) {\n                    up = !up;\n                    point.negative = !point.negative;\n                }\n                // If stacked...\n                barY = (Math.abs(barY - translatedThreshold) > minPointLength ?\n                    // ...keep position\n                    yBottom - minPointLength :\n                    // #1485, #4051\n                    translatedThreshold -\n                        (up ? minPointLength : 0));\n            }\n            // Handle point.options.pointWidth\n            // @todo Handle grouping/stacking too. Calculate offset properly\n            if (defined(point.options.pointWidth)) {\n                pointWidth = barW =\n                    Math.ceil(point.options.pointWidth);\n                barX -= Math.round((pointWidth - seriesPointWidth) / 2);\n            }\n            // Adjust for null or missing points\n            if (options.centerInCategory) {\n                barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics);\n            }\n            // Cache for access in polar\n            point.barX = barX;\n            point.pointWidth = pointWidth;\n            // Fix the tooltip on center of grouped columns (#1216, #424,\n            // #3648)\n            point.tooltipPos = chart.inverted ?\n                [\n                    clamp(yAxis.len + yAxis.pos - chart.plotLeft - plotY, yAxis.pos - chart.plotLeft, yAxis.len + yAxis.pos - chart.plotLeft),\n                    xAxis.len + xAxis.pos - chart.plotTop - barX - barW / 2,\n                    barH\n                ] :\n                [\n                    xAxis.left - chart.plotLeft + barX + barW / 2,\n                    clamp(plotY + yAxis.pos -\n                        chart.plotTop, yAxis.pos - chart.plotTop, yAxis.len + yAxis.pos - chart.plotTop),\n                    barH\n                ];\n            // Register shape type and arguments to be used in drawPoints. Allow\n            // `shapeType` defined on `pointClass` level.\n            point.shapeType = series.pointClass.prototype.shapeType ||\n                'roundedRect';\n            point.shapeArgs = series.crispCol(barX, \n            // #3169, drilldown from null must have a position to work from.\n            // #6585, dataLabel should be placed on xAxis, not floating in\n            // the middle of the chart.\n            barY, barW, point.isNull ? 0 : barH);\n        });\n        // Fire a specific event after column translate. We could instead apply\n        // all the column logic in an `afterTranslate` event handler, but there\n        // are so many other series types that use the column translation, that\n        // it is more convenient to have a specific event for it.\n        fireEvent(this, 'afterColumnTranslate');\n    }\n    /**\n     * Columns have no graph\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#drawGraph\n     */\n    drawGraph() {\n        this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data');\n    }\n    /**\n     * Get presentational attributes\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#pointAttribs\n     */\n    pointAttribs(point, state) {\n        const options = this.options, p2o = this.pointAttrToOptions || {}, strokeOption = p2o.stroke || 'borderColor', strokeWidthOption = p2o['stroke-width'] || 'borderWidth';\n        let stateOptions, zone, brightness, fill = (point && point.color) || this.color, \n        // Set to fill when borderColor null:\n        stroke = ((point && point[strokeOption]) ||\n            options[strokeOption] ||\n            fill), dashstyle = (point && point.options.dashStyle) || options.dashStyle, strokeWidth = (point && point[strokeWidthOption]) ||\n            options[strokeWidthOption] ||\n            this[strokeWidthOption] || 0, opacity = (point?.isNull && options.nullInteraction) ?\n            0 :\n            (point?.opacity ?? options.opacity ?? 1);\n        // Handle zone colors\n        if (point && this.zones.length) {\n            zone = point.getZone();\n            // When zones are present, don't use point.color (#4267).\n            // Changed order (#6527), added support for colorAxis (#10670)\n            fill = (point.options.color ||\n                (zone && (zone.color || point.nonZonedColor)) ||\n                this.color);\n            if (zone) {\n                stroke = zone.borderColor || stroke;\n                dashstyle = zone.dashStyle || dashstyle;\n                strokeWidth = zone.borderWidth || strokeWidth;\n            }\n        }\n        // Select or hover states\n        if (state && point) {\n            stateOptions = merge(options.states[state], \n            // #6401\n            point.options.states?.[state] || {});\n            brightness = stateOptions.brightness;\n            fill =\n                stateOptions.color || (typeof brightness !== 'undefined' &&\n                    color(fill)\n                        .brighten(stateOptions.brightness)\n                        .get()) || fill;\n            stroke = stateOptions[strokeOption] || stroke;\n            strokeWidth =\n                stateOptions[strokeWidthOption] || strokeWidth;\n            dashstyle = stateOptions.dashStyle || dashstyle;\n            opacity = pick(stateOptions.opacity, opacity);\n        }\n        const ret = {\n            fill: fill,\n            stroke: stroke,\n            'stroke-width': strokeWidth,\n            opacity: opacity\n        };\n        if (dashstyle) {\n            ret.dashstyle = dashstyle;\n        }\n        return ret;\n    }\n    /**\n     * Draw the columns. For bars, the series.group is rotated, so the same\n     * coordinates apply for columns and bars. This method is inherited by\n     * scatter series.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#drawPoints\n     */\n    drawPoints(points = this.points) {\n        const series = this, chart = this.chart, options = series.options, nullInteraction = options.nullInteraction, renderer = chart.renderer, animationLimit = options.animationLimit || 250;\n        let shapeArgs;\n        // Draw the columns\n        points.forEach(function (point) {\n            const plotY = point.plotY;\n            let graphic = point.graphic, hasGraphic = !!graphic, verb = graphic && chart.pointCount < animationLimit ?\n                'animate' : 'attr';\n            if (isNumber(plotY) && (point.y !== null || nullInteraction)) {\n                shapeArgs = point.shapeArgs;\n                // When updating a series between 2d and 3d or cartesian and\n                // polar, the shape type changes.\n                if (graphic && point.hasNewShapeType()) {\n                    graphic = graphic.destroy();\n                }\n                // Set starting position for point sliding animation.\n                if (series.enabledDataSorting) {\n                    point.startXPos = series.xAxis.reversed ?\n                        -(shapeArgs ? (shapeArgs.width || 0) : 0) :\n                        series.xAxis.width;\n                }\n                if (!graphic) {\n                    point.graphic = graphic =\n                        renderer[point.shapeType](shapeArgs)\n                            .add(point.group || series.group);\n                    if (graphic &&\n                        series.enabledDataSorting &&\n                        chart.hasRendered &&\n                        chart.pointCount < animationLimit) {\n                        graphic.attr({\n                            x: point.startXPos\n                        });\n                        hasGraphic = true;\n                        verb = 'animate';\n                    }\n                }\n                if (graphic && hasGraphic) { // Update\n                    graphic[verb](merge(shapeArgs));\n                }\n                // Presentational\n                if (!chart.styledMode) {\n                    graphic[verb](series.pointAttribs(point, (point.selected && 'select')))\n                        .shadow(point.allowShadow !== false && options.shadow);\n                }\n                if (graphic) {\n                    graphic.addClass(point.getClassName(), true);\n                    graphic.attr({\n                        visibility: point.visible ? 'inherit' : 'hidden'\n                    });\n                }\n            }\n            else if (graphic) {\n                point.graphic = graphic.destroy(); // #1269\n            }\n        });\n    }\n    /**\n     * Draw the tracker for a point.\n     * @private\n     */\n    drawTracker(points = this.points) {\n        const series = this, chart = series.chart, pointer = chart.pointer, onMouseOver = function (e) {\n            pointer?.normalize(e);\n            const point = pointer?.getPointFromEvent(e);\n            // Undefined on graph in scatterchart\n            if (pointer &&\n                point &&\n                series.options.enableMouseTracking &&\n                (\n                // Run point events only for points inside plot area, #21136\n                chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop, {\n                    visiblePlotOnly: true\n                }) ||\n                    pointer?.inClass(e.target, 'highcharts-data-label'))) {\n                pointer.isDirectTouch = true;\n                point.onMouseOver(e);\n            }\n        };\n        let dataLabels;\n        // Add reference to the point\n        points.forEach(function (point) {\n            dataLabels = (isArray(point.dataLabels) ?\n                point.dataLabels :\n                (point.dataLabel ? [point.dataLabel] : []));\n            if (point.graphic) {\n                point.graphic.element.point = point;\n            }\n            dataLabels.forEach(function (dataLabel) {\n                (dataLabel.div || dataLabel.element).point = point;\n            });\n        });\n        // Add the event listeners, we need to do this only once\n        if (!series._hasTracking) {\n            series.trackerGroups?.reduce((acc, key) => {\n                if (key === 'dataLabelsGroup') {\n                    acc.push(...(series.dataLabelsGroups || []));\n                }\n                else {\n                    acc.push(series[key]);\n                }\n                return acc;\n            }, []).forEach((group) => {\n                if (!group) {\n                    // Skip undefined\n                    return;\n                }\n                group.addClass('highcharts-tracker')\n                    .on('mouseover', onMouseOver)\n                    .on('mouseout', function (e) {\n                    pointer?.onTrackerMouseOut(e);\n                })\n                    .on('touchstart', onMouseOver);\n                if (!chart.styledMode && series.options.cursor) {\n                    group.css({ cursor: series.options.cursor });\n                }\n            });\n            series._hasTracking = true;\n        }\n        fireEvent(this, 'afterDrawTracker');\n    }\n    /**\n     * Remove this series from the chart\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#remove\n     */\n    remove() {\n        const series = this, chart = series.chart;\n        // Column and bar series affects other series of the same type\n        // as they are either stacked or grouped\n        if (chart.hasRendered) {\n            chart.series.forEach(function (otherSeries) {\n                if (otherSeries.type === series.type) {\n                    otherSeries.isDirty = true;\n                }\n            });\n        }\n        Series.prototype.remove.apply(series, arguments);\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nColumnSeries.defaultOptions = merge(Series.defaultOptions, ColumnSeriesDefaults);\nextend(ColumnSeries.prototype, {\n    // When tooltip is not shared, this series (and derivatives) requires\n    // direct touch/hover. KD-tree does not apply.\n    directTouch: true,\n    getSymbol: noop,\n    // Use separate negative stacks, unlike area stacks where a negative\n    // point is subtracted from previous (#1910)\n    negStacks: true,\n    trackerGroups: ['group', 'dataLabelsGroup']\n});\nSeriesRegistry.registerSeriesType('column', ColumnSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default ColumnSeries;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Adjusted width and x offset of the columns for grouping.\n *\n * @private\n * @interface Highcharts.ColumnMetricsObject\n */ /**\n* Width of the columns.\n* @name Highcharts.ColumnMetricsObject#width\n* @type {number}\n*/ /**\n* Offset of the columns.\n* @name Highcharts.ColumnMetricsObject#offset\n* @type {number}\n*/\n''; // Detach doclets above\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2397, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/BoxPlot/BoxPlotSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport BoxPlotSeriesDefaults from './BoxPlotSeriesDefaults.js';\nimport ColumnSeries from '../Column/ColumnSeries.js';\nimport H from '../../Core/Globals.js';\nconst { noop } = H;\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nimport U from '../../Core/Utilities.js';\nconst { crisp, extend, merge, pick, relativeLength } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * The boxplot series type.\n *\n * @private\n * @class\n * @name Highcharts.seriesTypes#boxplot\n *\n * @augments Highcharts.Series\n */\nclass BoxPlotSeries extends ColumnSeries {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    // Get presentational attributes\n    pointAttribs() {\n        // No attributes should be set on point.graphic which is the group\n        return {};\n    }\n    // Get an SVGPath object for both whiskers\n    getWhiskerPair(halfWidth, stemX, upperWhiskerLength, lowerWhiskerLength, point) {\n        const strokeWidth = point.whiskers.strokeWidth(), getWhisker = (xLen, yPos) => {\n            const halfLen = relativeLength(xLen, 2 * halfWidth) / 2, crispedYPos = crisp(yPos, strokeWidth);\n            return [\n                [\n                    'M',\n                    crisp(stemX - halfLen),\n                    crispedYPos\n                ],\n                [\n                    'L',\n                    crisp(stemX + halfLen),\n                    crispedYPos\n                ]\n            ];\n        };\n        return [\n            ...getWhisker(upperWhiskerLength, point.highPlot),\n            ...getWhisker(lowerWhiskerLength, point.lowPlot)\n        ];\n    }\n    // Translate data points from raw values x and y to plotX and plotY\n    translate() {\n        const series = this, yAxis = series.yAxis, pointArrayMap = series.pointArrayMap;\n        super.translate.apply(series);\n        // Do the translation on each point dimension\n        series.points.forEach(function (point) {\n            pointArrayMap.forEach(function (key) {\n                if (point[key] !== null) {\n                    point[key + 'Plot'] = yAxis.translate(point[key], 0, 1, 0, 1);\n                }\n            });\n            point.plotHigh = point.highPlot; // For data label validation\n        });\n    }\n    /**\n     * Draw the data points\n     * @private\n     */\n    drawPoints() {\n        const series = this, points = series.points, options = series.options, chart = series.chart, renderer = chart.renderer, \n        // Error bar inherits this series type but doesn't do quartiles\n        doQuartiles = series.doQuartiles !== false, whiskerLength = series.options.whiskerLength;\n        let q1Plot, q3Plot, highPlot, lowPlot, medianPlot, medianPath, boxPath, graphic, width, x, right;\n        for (const point of points) {\n            graphic = point.graphic;\n            const verb = graphic ? 'animate' : 'attr', shapeArgs = point.shapeArgs, boxAttr = {}, stemAttr = {}, whiskersAttr = {}, medianAttr = {}, color = point.color || series.color, pointWhiskerLength = (point.options.whiskerLength ||\n                whiskerLength);\n            if (typeof point.plotY !== 'undefined') {\n                // Vector coordinates\n                width = shapeArgs.width;\n                x = shapeArgs.x;\n                right = x + width;\n                q1Plot = doQuartiles ? point.q1Plot : point.lowPlot;\n                q3Plot = doQuartiles ? point.q3Plot : point.lowPlot;\n                highPlot = point.highPlot;\n                lowPlot = point.lowPlot;\n                if (!graphic) {\n                    point.graphic = graphic = renderer.g('point')\n                        .add(series.group);\n                    point.stem = renderer.path()\n                        .addClass('highcharts-boxplot-stem')\n                        .add(graphic);\n                    if (whiskerLength) {\n                        point.whiskers = renderer.path()\n                            .addClass('highcharts-boxplot-whisker')\n                            .add(graphic);\n                    }\n                    if (doQuartiles) {\n                        point.box = renderer.path(boxPath)\n                            .addClass('highcharts-boxplot-box')\n                            .add(graphic);\n                    }\n                    point.medianShape = renderer.path(medianPath)\n                        .addClass('highcharts-boxplot-median')\n                        .add(graphic);\n                }\n                if (!chart.styledMode) {\n                    // Stem attributes\n                    stemAttr.stroke =\n                        point.stemColor || options.stemColor || color;\n                    stemAttr['stroke-width'] = pick(point.stemWidth, options.stemWidth, options.lineWidth);\n                    stemAttr.dashstyle = (point.stemDashStyle ||\n                        options.stemDashStyle ||\n                        options.dashStyle);\n                    point.stem.attr(stemAttr);\n                    // Whiskers attributes\n                    if (pointWhiskerLength) {\n                        whiskersAttr.stroke = (point.whiskerColor ||\n                            options.whiskerColor ||\n                            color);\n                        whiskersAttr['stroke-width'] = pick(point.whiskerWidth, options.whiskerWidth, options.lineWidth);\n                        whiskersAttr.dashstyle = (point.whiskerDashStyle ||\n                            options.whiskerDashStyle ||\n                            options.dashStyle);\n                        point.whiskers.attr(whiskersAttr);\n                    }\n                    if (doQuartiles) {\n                        boxAttr.fill = (point.fillColor ||\n                            options.fillColor ||\n                            color);\n                        boxAttr.stroke = options.lineColor || color;\n                        boxAttr['stroke-width'] = options.lineWidth || 0;\n                        boxAttr.dashstyle = (point.boxDashStyle ||\n                            options.boxDashStyle ||\n                            options.dashStyle);\n                        point.box.attr(boxAttr);\n                    }\n                    // Median attributes\n                    medianAttr.stroke = (point.medianColor ||\n                        options.medianColor ||\n                        color);\n                    medianAttr['stroke-width'] = pick(point.medianWidth, options.medianWidth, options.lineWidth);\n                    medianAttr.dashstyle = (point.medianDashStyle ||\n                        options.medianDashStyle ||\n                        options.dashStyle);\n                    point.medianShape.attr(medianAttr);\n                }\n                let d;\n                // The stem\n                const stemX = crisp((point.plotX || 0) + (series.pointXOffset || 0) +\n                    ((series.barW || 0) / 2), point.stem.strokeWidth());\n                d = [\n                    // Stem up\n                    ['M', stemX, q3Plot],\n                    ['L', stemX, highPlot],\n                    // Stem down\n                    ['M', stemX, q1Plot],\n                    ['L', stemX, lowPlot]\n                ];\n                point.stem[verb]({ d });\n                // The box\n                if (doQuartiles) {\n                    const boxStrokeWidth = point.box.strokeWidth();\n                    q1Plot = crisp(q1Plot, boxStrokeWidth);\n                    q3Plot = crisp(q3Plot, boxStrokeWidth);\n                    x = crisp(x, boxStrokeWidth);\n                    right = crisp(right, boxStrokeWidth);\n                    d = [\n                        ['M', x, q3Plot],\n                        ['L', x, q1Plot],\n                        ['L', right, q1Plot],\n                        ['L', right, q3Plot],\n                        ['L', x, q3Plot],\n                        ['Z']\n                    ];\n                    point.box[verb]({ d });\n                }\n                // The whiskers\n                if (pointWhiskerLength) {\n                    const halfWidth = width / 2, whiskers = this.getWhiskerPair(halfWidth, stemX, (point.upperWhiskerLength ??\n                        options.upperWhiskerLength ??\n                        pointWhiskerLength), (point.lowerWhiskerLength ??\n                        options.lowerWhiskerLength ??\n                        pointWhiskerLength), point);\n                    point.whiskers[verb]({ d: whiskers });\n                }\n                // The median\n                medianPlot = crisp(point.medianPlot, point.medianShape.strokeWidth());\n                d = [\n                    ['M', x, medianPlot],\n                    ['L', right, medianPlot]\n                ];\n                point.medianShape[verb]({ d });\n            }\n        }\n    }\n    // Return a plain array for speedy calculation\n    toYData(point) {\n        return [point.low, point.q1, point.median, point.q3, point.high];\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nBoxPlotSeries.defaultOptions = merge(ColumnSeries.defaultOptions, BoxPlotSeriesDefaults);\nextend(BoxPlotSeries.prototype, {\n    // Array point configs are mapped to this\n    pointArrayMap: ['low', 'q1', 'median', 'q3', 'high'],\n    // Defines the top of the tracker\n    pointValKey: 'high',\n    // Disable data labels for box plot\n    drawDataLabels: noop,\n    setStackedPoints: noop // #3890\n});\nSeriesRegistry.registerSeriesType('boxplot', BoxPlotSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default BoxPlotSeries;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2672, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendDefaults.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *\n *  Author: Pawe Potaczek\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\n/* *\n *\n *  Constants\n *\n * */\n/**\n * The bubble legend is an additional element in legend which\n * presents the scale of the bubble series. Individual bubble ranges\n * can be defined by user or calculated from series. In the case of\n * automatically calculated ranges, a 1px margin of error is\n * permitted.\n *\n * @since        7.0.0\n * @product      highcharts highstock highmaps\n * @requires     highcharts-more\n * @optionparent legend.bubbleLegend\n */\nconst BubbleLegendDefaults = {\n    /**\n     * The color of the ranges borders, can be also defined for an\n     * individual range.\n     *\n     * @sample highcharts/bubble-legend/similartoseries/\n     *         Similar look to the bubble series\n     * @sample highcharts/bubble-legend/bordercolor/\n     *         Individual bubble border color\n     *\n     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     */\n    borderColor: void 0,\n    /**\n     * The width of the ranges borders in pixels, can be also\n     * defined for an individual range.\n     */\n    borderWidth: 2,\n    /**\n     * An additional class name to apply to the bubble legend'\n     * circle graphical elements. This option does not replace\n     * default class names of the graphical element.\n     *\n     * @sample {highcharts} highcharts/css/bubble-legend/\n     *         Styling by CSS\n     *\n     * @type {string}\n     */\n    className: void 0,\n    /**\n     * The main color of the bubble legend. Applies to ranges, if\n     * individual color is not defined.\n     *\n     * @sample highcharts/bubble-legend/similartoseries/\n     *         Similar look to the bubble series\n     * @sample highcharts/bubble-legend/color/\n     *         Individual bubble color\n     *\n     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     */\n    color: void 0,\n    /**\n     * An additional class name to apply to the bubble legend's\n     * connector graphical elements. This option does not replace\n     * default class names of the graphical element.\n     *\n     * @sample {highcharts} highcharts/css/bubble-legend/\n     *         Styling by CSS\n     *\n     * @type {string}\n     */\n    connectorClassName: void 0,\n    /**\n     * The color of the connector, can be also defined\n     * for an individual range.\n     *\n     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     */\n    connectorColor: void 0,\n    /**\n     * The length of the connectors in pixels. If labels are\n     * centered, the distance is reduced to 0.\n     *\n     * @sample highcharts/bubble-legend/connectorandlabels/\n     *         Increased connector length\n     */\n    connectorDistance: 60,\n    /**\n     * The width of the connectors in pixels.\n     *\n     * @sample highcharts/bubble-legend/connectorandlabels/\n     *         Increased connector width\n     */\n    connectorWidth: 1,\n    /**\n     * Enable or disable the bubble legend.\n     */\n    enabled: false,\n    /**\n     * Options for the bubble legend labels.\n     */\n    labels: {\n        /**\n         * An additional class name to apply to the bubble legend\n         * label graphical elements. This option does not replace\n         * default class names of the graphical element.\n         *\n         * @sample {highcharts} highcharts/css/bubble-legend/\n         *         Styling by CSS\n         *\n         * @type {string}\n         */\n        className: void 0,\n        /**\n         * Whether to allow data labels to overlap.\n         */\n        allowOverlap: false,\n        /**\n         * A format string for the bubble legend labels. Available\n         * variables are the same as for `formatter`.\n         *\n         * @sample highcharts/bubble-legend/format/\n         *         Add a unit\n         *\n         * @type {string}\n         */\n        format: '',\n        /**\n         * Available `this` properties are:\n         *\n         * - `this.value`: The bubble value.\n         *\n         * - `this.radius`: The radius of the bubble range.\n         *\n         * - `this.center`: The center y position of the range.\n         *\n         * @type {Highcharts.FormatterCallbackFunction<Highcharts.BubbleLegendFormatterContextObject>}\n         */\n        formatter: void 0,\n        /**\n         * The alignment of the labels compared to the bubble\n         * legend. Can be one of `left`, `center` or `right`.\n         *\n         * @sample highcharts/bubble-legend/connectorandlabels/\n         *         Labels on left\n         *\n         * @type {Highcharts.AlignValue}\n         */\n        align: 'right',\n        /**\n         * CSS styles for the labels.\n         *\n         * @type {Highcharts.CSSObject}\n         */\n        style: {\n            /** @ignore-option */\n            fontSize: '0.9em',\n            /** @ignore-option */\n            color: \"#000000\" /* Palette.neutralColor100 */\n        },\n        /**\n         * The x position offset of the label relative to the\n         * connector.\n         */\n        x: 0,\n        /**\n         * The y position offset of the label relative to the\n         * connector.\n         */\n        y: 0\n    },\n    /**\n     * Maximum bubble legend range size. If values for ranges are\n     * not specified, the `minSize` and the `maxSize` are calculated\n     * from bubble series.\n     */\n    maxSize: 60, // Number\n    /**\n     * Minimum bubble legend range size. If values for ranges are\n     * not specified, the `minSize` and the `maxSize` are calculated\n     * from bubble series.\n     */\n    minSize: 10, // Number\n    /**\n     * The position of the bubble legend in the legend.\n     * @sample highcharts/bubble-legend/connectorandlabels/\n     *         Bubble legend as last item in legend\n     */\n    legendIndex: 0, // Number\n    /**\n     * Options for specific range. One range consists of bubble,\n     * label and connector.\n     *\n     * @sample highcharts/bubble-legend/ranges/\n     *         Manually defined ranges\n     * @sample highcharts/bubble-legend/autoranges/\n     *         Auto calculated ranges\n     *\n     * @type {Array<*>}\n     */\n    ranges: {\n        /**\n         * Range size value, similar to bubble Z data.\n         * @type {number}\n         */\n        value: void 0,\n        /**\n         * The color of the border for individual range.\n         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         */\n        borderColor: void 0,\n        /**\n         * The color of the bubble for individual range.\n         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         */\n        color: void 0,\n        /**\n         * The color of the connector for individual range.\n         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         */\n        connectorColor: void 0\n    },\n    /**\n     * Whether the bubble legend range value should be represented\n     * by the area or the width of the bubble. The default, area,\n     * corresponds best to the human perception of the size of each\n     * bubble.\n     *\n     * @sample highcharts/bubble-legend/ranges/\n     *         Size by width\n     *\n     * @type {Highcharts.BubbleSizeByValue}\n     */\n    sizeBy: 'area',\n    /**\n     * When this is true, the absolute value of z determines the\n     * size of the bubble. This means that with the default\n     * zThreshold of 0, a bubble of value -1 will have the same size\n     * as a bubble of value 1, while a bubble of value 0 will have a\n     * smaller size according to minSize.\n     */\n    sizeByAbsoluteValue: false,\n    /**\n     * Define the visual z index of the bubble legend.\n     */\n    zIndex: 1,\n    /**\n     * Ranges with lower value than zThreshold are skipped.\n     */\n    zThreshold: 0\n};\n/* *\n *\n *  Default Export\n *\n * */\nexport default BubbleLegendDefaults;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;GAUG,GACH;AACA;;;;GAIG,GACH;;;;;;;;;;;CAWC,GACD,MAAM,uBAAuB;IACzB;;;;;;;;;;KAUC,GACD,aAAa,KAAK;IAClB;;;KAGC,GACD,aAAa;IACb;;;;;;;;;KASC,GACD,WAAW,KAAK;IAChB;;;;;;;;;;KAUC,GACD,OAAO,KAAK;IACZ;;;;;;;;;KASC,GACD,oBAAoB,KAAK;IACzB;;;;;KAKC,GACD,gBAAgB,KAAK;IACrB;;;;;;KAMC,GACD,mBAAmB;IACnB;;;;;KAKC,GACD,gBAAgB;IAChB;;KAEC,GACD,SAAS;IACT;;KAEC,GACD,QAAQ;QACJ;;;;;;;;;SASC,GACD,WAAW,KAAK;QAChB;;SAEC,GACD,cAAc;QACd;;;;;;;;SAQC,GACD,QAAQ;QACR;;;;;;;;;;SAUC,GACD,WAAW,KAAK;QAChB;;;;;;;;SAQC,GACD,OAAO;QACP;;;;SAIC,GACD,OAAO;YACH,mBAAmB,GACnB,UAAU;YACV,mBAAmB,GACnB,OAAO,UAAU,2BAA2B;QAChD;QACA;;;SAGC,GACD,GAAG;QACH;;;SAGC,GACD,GAAG;IACP;IACA;;;;KAIC,GACD,SAAS;IACT;;;;KAIC,GACD,SAAS;IACT;;;;KAIC,GACD,aAAa;IACb;;;;;;;;;;KAUC,GACD,QAAQ;QACJ;;;SAGC,GACD,OAAO,KAAK;QACZ;;;SAGC,GACD,aAAa,KAAK;QAClB;;;SAGC,GACD,OAAO,KAAK;QACZ;;;SAGC,GACD,gBAAgB,KAAK;IACzB;IACA;;;;;;;;;;KAUC,GACD,QAAQ;IACR;;;;;;KAMC,GACD,qBAAqB;IACrB;;KAEC,GACD,QAAQ;IACR;;KAEC,GACD,YAAY;AAChB;uCAMe","ignoreList":[0]}},
    {"offset": {"line": 2906, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendItem.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *\n *  Author: Pawe Potaczek\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport F from '../../Core/Templating.js';\nimport H from '../../Core/Globals.js';\nconst { noop } = H;\nimport U from '../../Core/Utilities.js';\nconst { arrayMax, arrayMin, isNumber, merge, pick, stableSort } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * BubbleLegend class.\n *\n * @private\n * @class\n * @name Highcharts.BubbleLegend\n * @param {Highcharts.LegendBubbleLegendOptions} options\n * Options of BubbleLegendItem.\n *\n * @param {Highcharts.Legend} legend\n * Legend of item.\n */\nclass BubbleLegendItem {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    constructor(options, legend) {\n        this.setState = noop;\n        this.init(options, legend);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Create basic bubbleLegend properties similar to item in legend.\n     * @private\n     */\n    init(options, legend) {\n        this.options = options;\n        this.visible = true;\n        this.chart = legend.chart;\n        this.legend = legend;\n    }\n    /**\n     * Depending on the position option, add bubbleLegend to legend items.\n     *\n     * @private\n     *\n     * @param {Array<(Highcharts.Point|Highcharts.Series)>} items\n     *        All legend items\n     */\n    addToLegend(items) {\n        // Insert bubbleLegend into legend items\n        items.splice(this.options.legendIndex, 0, this);\n    }\n    /**\n     * Calculate ranges, sizes and call the next steps of bubbleLegend\n     * creation.\n     *\n     * @private\n     *\n     * @param {Highcharts.Legend} legend\n     *        Legend instance\n     */\n    drawLegendSymbol(legend) {\n        const itemDistance = pick(legend.options.itemDistance, 20), legendItem = this.legendItem || {}, options = this.options, ranges = options.ranges, connectorDistance = options.connectorDistance;\n        let connectorSpace;\n        // Do not create bubbleLegend now if ranges or ranges values are not\n        // specified or if are empty array.\n        if (!ranges || !ranges.length || !isNumber(ranges[0].value)) {\n            legend.options.bubbleLegend.autoRanges = true;\n            return;\n        }\n        // Sort ranges to right render order\n        stableSort(ranges, function (a, b) {\n            return b.value - a.value;\n        });\n        this.ranges = ranges;\n        this.setOptions();\n        this.render();\n        // Get max label size\n        const maxLabel = this.getMaxLabelSize(), radius = this.ranges[0].radius, size = radius * 2;\n        // Space for connectors and labels.\n        connectorSpace =\n            connectorDistance - radius + maxLabel.width;\n        connectorSpace = connectorSpace > 0 ? connectorSpace : 0;\n        this.maxLabel = maxLabel;\n        this.movementX = options.labels.align === 'left' ?\n            connectorSpace : 0;\n        legendItem.labelWidth = size + connectorSpace + itemDistance;\n        legendItem.labelHeight = size + maxLabel.height / 2;\n    }\n    /**\n     * Set style options for each bubbleLegend range.\n     * @private\n     */\n    setOptions() {\n        const ranges = this.ranges, options = this.options, series = this.chart.series[options.seriesIndex], baseline = this.legend.baseline, bubbleAttribs = {\n            zIndex: options.zIndex,\n            'stroke-width': options.borderWidth\n        }, connectorAttribs = {\n            zIndex: options.zIndex,\n            'stroke-width': options.connectorWidth\n        }, labelAttribs = {\n            align: (this.legend.options.rtl ||\n                options.labels.align === 'left') ? 'right' : 'left',\n            zIndex: options.zIndex\n        }, fillOpacity = series.options.marker.fillOpacity, styledMode = this.chart.styledMode;\n        // Allow to parts of styles be used individually for range\n        ranges.forEach(function (range, i) {\n            if (!styledMode) {\n                bubbleAttribs.stroke = pick(range.borderColor, options.borderColor, series.color);\n                bubbleAttribs.fill = range.color || options.color;\n                if (!bubbleAttribs.fill) {\n                    bubbleAttribs.fill = series.color;\n                    bubbleAttribs['fill-opacity'] = fillOpacity ?? 1;\n                }\n                connectorAttribs.stroke = pick(range.connectorColor, options.connectorColor, series.color);\n            }\n            // Set options needed for rendering each range\n            ranges[i].radius = this.getRangeRadius(range.value);\n            ranges[i] = merge(ranges[i], {\n                center: (ranges[0].radius - ranges[i].radius +\n                    baseline)\n            });\n            if (!styledMode) {\n                merge(true, ranges[i], {\n                    bubbleAttribs: merge(bubbleAttribs),\n                    connectorAttribs: merge(connectorAttribs),\n                    labelAttribs: labelAttribs\n                });\n            }\n        }, this);\n    }\n    /**\n     * Calculate radius for each bubble range,\n     * used code from BubbleSeries.js 'getRadius' method.\n     *\n     * @private\n     *\n     * @param {number} value\n     *        Range value\n     *\n     * @return {number|null}\n     *         Radius for one range\n     */\n    getRangeRadius(value) {\n        const options = this.options, seriesIndex = this.options.seriesIndex, bubbleSeries = this.chart.series[seriesIndex], zMax = options.ranges[0].value, zMin = options.ranges[options.ranges.length - 1].value, minSize = options.minSize, maxSize = options.maxSize;\n        return bubbleSeries.getRadius.call(this, zMin, zMax, minSize, maxSize, value);\n    }\n    /**\n     * Render the legendItem group.\n     * @private\n     */\n    render() {\n        const legendItem = this.legendItem || {}, renderer = this.chart.renderer, zThreshold = this.options.zThreshold;\n        if (!this.symbols) {\n            this.symbols = {\n                connectors: [],\n                bubbleItems: [],\n                labels: []\n            };\n        }\n        // Nesting SVG groups to enable handleOverflow\n        legendItem.symbol = renderer.g('bubble-legend');\n        legendItem.label = renderer.g('bubble-legend-item')\n            .css(this.legend.itemStyle || {});\n        // To enable default 'hideOverlappingLabels' method\n        legendItem.symbol.translateX = 0;\n        legendItem.symbol.translateY = 0;\n        // To use handleOverflow method\n        legendItem.symbol.add(legendItem.label);\n        legendItem.label.add(legendItem.group);\n        for (const range of this.ranges) {\n            if (range.value >= zThreshold) {\n                this.renderRange(range);\n            }\n        }\n        this.hideOverlappingLabels();\n    }\n    /**\n     * Render one range, consisting of bubble symbol, connector and label.\n     *\n     * @private\n     *\n     * @param {Highcharts.LegendBubbleLegendRangesOptions} range\n     *        Range options\n     */\n    renderRange(range) {\n        const mainRange = this.ranges[0], legend = this.legend, options = this.options, labelsOptions = options.labels, chart = this.chart, bubbleSeries = chart.series[options.seriesIndex], renderer = chart.renderer, symbols = this.symbols, labels = symbols.labels, elementCenter = range.center, absoluteRadius = Math.abs(range.radius), connectorDistance = options.connectorDistance || 0, labelsAlign = labelsOptions.align, rtl = legend.options.rtl, borderWidth = options.borderWidth, connectorWidth = options.connectorWidth, posX = mainRange.radius || 0, posY = elementCenter - absoluteRadius -\n            borderWidth / 2 + connectorWidth / 2, crispMovement = (posY % 1 ? 1 : 0.5) -\n            (connectorWidth % 2 ? 0 : 0.5), styledMode = renderer.styledMode;\n        let connectorLength = rtl || labelsAlign === 'left' ?\n            -connectorDistance : connectorDistance;\n        // Set options for centered labels\n        if (labelsAlign === 'center') {\n            connectorLength = 0; // Do not use connector\n            options.connectorDistance = 0;\n            range.labelAttribs.align = 'center';\n        }\n        // Render bubble symbol\n        symbols.bubbleItems.push(renderer\n            .circle(posX, elementCenter + crispMovement, absoluteRadius)\n            .attr(styledMode ? {} : range.bubbleAttribs)\n            .addClass((styledMode ?\n            'highcharts-color-' +\n                bubbleSeries.colorIndex + ' ' :\n            '') +\n            'highcharts-bubble-legend-symbol ' +\n            (options.className || '')).add(this.legendItem.symbol));\n        // Render connector\n        symbols.connectors.push(renderer\n            .path(renderer.crispLine([\n            ['M', posX, posY],\n            ['L', posX + connectorLength, posY]\n        ], options.connectorWidth))\n            .attr((styledMode ? {} : range.connectorAttribs))\n            .addClass((styledMode ?\n            'highcharts-color-' +\n                this.options.seriesIndex + ' ' : '') +\n            'highcharts-bubble-legend-connectors ' +\n            (options.connectorClassName || '')).add(this.legendItem.symbol));\n        // Render label\n        const label = renderer\n            .text(this.formatLabel(range))\n            .attr((styledMode ? {} : range.labelAttribs))\n            .css(styledMode ? {} : labelsOptions.style)\n            .addClass('highcharts-bubble-legend-labels ' +\n            (options.labels.className || '')).add(this.legendItem.symbol);\n        // Now that the label is added we can read the bounding box and\n        // vertically align\n        const position = {\n            x: posX + connectorLength + options.labels.x,\n            y: posY + options.labels.y + label.getBBox().height * 0.4\n        };\n        label.attr(position);\n        labels.push(label);\n        // To enable default 'hideOverlappingLabels' method\n        label.placed = true;\n        label.alignAttr = position;\n    }\n    /**\n     * Get the label which takes up the most space.\n     * @private\n     */\n    getMaxLabelSize() {\n        const labels = this.symbols.labels;\n        let maxLabel, labelSize;\n        labels.forEach(function (label) {\n            labelSize = label.getBBox(true);\n            if (maxLabel) {\n                maxLabel = labelSize.width > maxLabel.width ?\n                    labelSize : maxLabel;\n            }\n            else {\n                maxLabel = labelSize;\n            }\n        });\n        return maxLabel || {};\n    }\n    /**\n     * Get formatted label for range.\n     *\n     * @private\n     *\n     * @param {Highcharts.LegendBubbleLegendRangesOptions} range\n     *        Range options\n     *\n     * @return {string}\n     *         Range label text\n     */\n    formatLabel(range) {\n        const options = this.options, formatter = options.labels.formatter, format = options.labels.format;\n        const { numberFormatter } = this.chart;\n        return format ? F.format(format, range, this.chart) :\n            formatter ? formatter.call(range) :\n                numberFormatter(range.value, 1);\n    }\n    /**\n     * By using default chart 'hideOverlappingLabels' method, hide or show\n     * labels and connectors.\n     * @private\n     */\n    hideOverlappingLabels() {\n        const chart = this.chart, allowOverlap = this.options.labels.allowOverlap, symbols = this.symbols;\n        if (!allowOverlap && symbols) {\n            chart.hideOverlappingLabels(symbols.labels);\n            // Hide or show connectors\n            symbols.labels.forEach(function (label, index) {\n                if (!label.newOpacity) {\n                    symbols.connectors[index].hide();\n                }\n                else if (label.newOpacity !== label.oldOpacity) {\n                    symbols.connectors[index].show();\n                }\n            });\n        }\n    }\n    /**\n     * Calculate ranges from created series.\n     *\n     * @private\n     *\n     * @return {Array<Highcharts.LegendBubbleLegendRangesOptions>}\n     *         Array of range objects\n     */\n    getRanges() {\n        const bubbleLegend = this.legend.bubbleLegend, series = bubbleLegend.chart.series, rangesOptions = bubbleLegend.options.ranges;\n        let ranges, zData, minZ = Number.MAX_VALUE, maxZ = -Number.MAX_VALUE;\n        series.forEach(function (s) {\n            // Find the min and max Z, like in bubble series\n            if (s.isBubble && !s.ignoreSeries) {\n                zData = s.getColumn('z').filter(isNumber);\n                if (zData.length) {\n                    minZ = pick(s.options.zMin, Math.min(minZ, Math.max(arrayMin(zData), s.options.displayNegative === false ?\n                        s.options.zThreshold :\n                        -Number.MAX_VALUE)));\n                    maxZ = pick(s.options.zMax, Math.max(maxZ, arrayMax(zData)));\n                }\n            }\n        });\n        // Set values for ranges\n        if (minZ === maxZ) {\n            // Only one range if min and max values are the same.\n            ranges = [{ value: maxZ }];\n        }\n        else {\n            ranges = [\n                { value: minZ },\n                { value: (minZ + maxZ) / 2 },\n                { value: maxZ, autoRanges: true }\n            ];\n        }\n        // Prevent reverse order of ranges after redraw\n        if (rangesOptions.length && rangesOptions[0].radius) {\n            ranges.reverse();\n        }\n        // Merge ranges values with user options\n        ranges.forEach(function (range, i) {\n            if (rangesOptions && rangesOptions[i]) {\n                ranges[i] = merge(rangesOptions[i], range);\n            }\n        });\n        return ranges;\n    }\n    /**\n     * Calculate bubble legend sizes from rendered series.\n     *\n     * @private\n     *\n     * @return {Array<number,number>}\n     *         Calculated min and max bubble sizes\n     */\n    predictBubbleSizes() {\n        const chart = this.chart, legendOptions = chart.legend.options, floating = legendOptions.floating, horizontal = legendOptions.layout === 'horizontal', lastLineHeight = horizontal ? chart.legend.lastLineHeight : 0, plotSizeX = chart.plotSizeX, plotSizeY = chart.plotSizeY, bubbleSeries = chart.series[this.options.seriesIndex], pxSizes = bubbleSeries.getPxExtremes(), minSize = Math.ceil(pxSizes.minPxSize), maxPxSize = Math.ceil(pxSizes.maxPxSize), plotSize = Math.min(plotSizeY, plotSizeX);\n        let calculatedSize, maxSize = bubbleSeries.options.maxSize;\n        // Calculate predicted max size of bubble\n        if (floating || !(/%$/.test(maxSize))) {\n            calculatedSize = maxPxSize;\n        }\n        else {\n            maxSize = parseFloat(maxSize);\n            calculatedSize = ((plotSize + lastLineHeight) * maxSize / 100) /\n                (maxSize / 100 + 1);\n            // Get maxPxSize from bubble series if calculated bubble legend\n            // size will not affect to bubbles series.\n            if ((horizontal && plotSizeY - calculatedSize >=\n                plotSizeX) || (!horizontal && plotSizeX -\n                calculatedSize >= plotSizeY)) {\n                calculatedSize = maxPxSize;\n            }\n        }\n        return [minSize, Math.ceil(calculatedSize)];\n    }\n    /**\n     * Correct ranges with calculated sizes.\n     * @private\n     */\n    updateRanges(min, max) {\n        const bubbleLegendOptions = this.legend.options.bubbleLegend;\n        bubbleLegendOptions.minSize = min;\n        bubbleLegendOptions.maxSize = max;\n        bubbleLegendOptions.ranges = this.getRanges();\n    }\n    /**\n     * Because of the possibility of creating another legend line, predicted\n     * bubble legend sizes may differ by a few pixels, so it is necessary to\n     * correct them.\n     * @private\n     */\n    correctSizes() {\n        const legend = this.legend, chart = this.chart, bubbleSeries = chart.series[this.options.seriesIndex], pxSizes = bubbleSeries.getPxExtremes(), bubbleSeriesSize = pxSizes.maxPxSize, bubbleLegendSize = this.options.maxSize;\n        if (Math.abs(Math.ceil(bubbleSeriesSize) - bubbleLegendSize) >\n            1) {\n            this.updateRanges(this.options.minSize, pxSizes.maxPxSize);\n            legend.render();\n        }\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nexport default BubbleLegendItem;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * @interface Highcharts.BubbleLegendFormatterContextObject\n */ /**\n* The center y position of the range.\n* @name Highcharts.BubbleLegendFormatterContextObject#center\n* @type {number}\n*/ /**\n* The radius of the bubble range.\n* @name Highcharts.BubbleLegendFormatterContextObject#radius\n* @type {number}\n*/ /**\n* The bubble value.\n* @name Highcharts.BubbleLegendFormatterContextObject#value\n* @type {number}\n*/\n''; // Detach doclets above\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3314, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendComposition.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *\n *  Author: Pawe Potaczek\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport BubbleLegendDefaults from './BubbleLegendDefaults.js';\nimport BubbleLegendItem from './BubbleLegendItem.js';\nimport D from '../../Core/Defaults.js';\nconst { setOptions } = D;\nimport H from '../../Core/Globals.js';\nconst { composed } = H;\nimport U from '../../Core/Utilities.js';\nconst { addEvent, objectEach, pushUnique, wrap } = U;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * If ranges are not specified, determine ranges from rendered bubble series\n * and render legend again.\n */\nfunction chartDrawChartBox(proceed, options, callback) {\n    const chart = this, legend = chart.legend, bubbleSeries = getVisibleBubbleSeriesIndex(chart) >= 0;\n    let bubbleLegendOptions, bubbleSizes, legendItem;\n    if (legend && legend.options.enabled && legend.bubbleLegend &&\n        legend.options.bubbleLegend.autoRanges && bubbleSeries) {\n        bubbleLegendOptions = legend.bubbleLegend.options;\n        bubbleSizes = legend.bubbleLegend.predictBubbleSizes();\n        legend.bubbleLegend.updateRanges(bubbleSizes[0], bubbleSizes[1]);\n        // Disable animation on init\n        if (!bubbleLegendOptions.placed) {\n            legend.group.placed = false;\n            legend.allItems.forEach((item) => {\n                legendItem = item.legendItem || {};\n                if (legendItem.group) {\n                    legendItem.group.translateY = void 0;\n                }\n            });\n        }\n        // Create legend with bubbleLegend\n        legend.render();\n        // Calculate margins after first rendering the bubble legend\n        if (!bubbleLegendOptions.placed) {\n            chart.getMargins();\n            chart.axes.forEach((axis) => {\n                axis.setScale();\n                axis.updateNames();\n                // Disable axis animation on init\n                objectEach(axis.ticks, function (tick) {\n                    tick.isNew = true;\n                    tick.isNewLabel = true;\n                });\n            });\n            chart.getMargins();\n        }\n        bubbleLegendOptions.placed = true;\n        // Call default 'drawChartBox' method.\n        proceed.call(chart, options, callback);\n        // Check bubble legend sizes and correct them if necessary.\n        legend.bubbleLegend.correctSizes();\n        // Correct items positions with different dimensions in legend.\n        retranslateItems(legend, getLinesHeights(legend));\n    }\n    else {\n        proceed.call(chart, options, callback);\n        // Allow color change on static bubble legend after click on legend\n        if (legend && legend.options.enabled && legend.bubbleLegend) {\n            legend.render();\n            retranslateItems(legend, getLinesHeights(legend));\n        }\n    }\n}\n/**\n * Compose classes for use with Bubble series.\n * @private\n *\n * @param {Highcharts.Chart} ChartClass\n * Core chart class to use with Bubble series.\n *\n * @param {Highcharts.Legend} LegendClass\n * Core legend class to use with Bubble series.\n */\nfunction compose(ChartClass, LegendClass) {\n    if (pushUnique(composed, 'Series.BubbleLegend')) {\n        setOptions({\n            // Set default bubble legend options\n            legend: {\n                bubbleLegend: BubbleLegendDefaults\n            }\n        });\n        wrap(ChartClass.prototype, 'drawChartBox', chartDrawChartBox);\n        addEvent(LegendClass, 'afterGetAllItems', onLegendAfterGetAllItems);\n        addEvent(LegendClass, 'itemClick', onLegendItemClick);\n    }\n}\n/**\n * Check if there is at least one visible bubble series.\n *\n * @private\n * @function getVisibleBubbleSeriesIndex\n * @param {Highcharts.Chart} chart\n * Chart to check.\n * @return {number}\n * First visible bubble series index\n */\nfunction getVisibleBubbleSeriesIndex(chart) {\n    const series = chart.series;\n    let i = 0;\n    while (i < series.length) {\n        if (series[i] &&\n            series[i].isBubble &&\n            series[i].visible &&\n            series[i].dataTable.rowCount) {\n            return i;\n        }\n        i++;\n    }\n    return -1;\n}\n/**\n * Calculate height for each row in legend.\n *\n * @private\n * @function getLinesHeights\n *\n * @param {Highcharts.Legend} legend\n * Legend to calculate from.\n *\n * @return {Array<Highcharts.Dictionary<number>>}\n * Informations about line height and items amount\n */\nfunction getLinesHeights(legend) {\n    const items = legend.allItems, lines = [], length = items.length;\n    let lastLine, legendItem, legendItem2, i = 0, j = 0;\n    for (i = 0; i < length; i++) {\n        legendItem = items[i].legendItem || {};\n        legendItem2 = (items[i + 1] || {}).legendItem || {};\n        if (legendItem.labelHeight) {\n            // For bubbleLegend\n            items[i].itemHeight = legendItem.labelHeight;\n        }\n        if ( // Line break\n        items[i] === items[length - 1] ||\n            legendItem.y !== legendItem2.y) {\n            lines.push({ height: 0 });\n            lastLine = lines[lines.length - 1];\n            // Find the highest item in line\n            for (j; j <= i; j++) {\n                if (items[j].itemHeight > lastLine.height) {\n                    lastLine.height = items[j].itemHeight;\n                }\n            }\n            lastLine.step = i;\n        }\n    }\n    return lines;\n}\n/**\n * Start the bubble legend creation process.\n */\nfunction onLegendAfterGetAllItems(e) {\n    const legend = this, bubbleLegend = legend.bubbleLegend, legendOptions = legend.options, options = legendOptions.bubbleLegend, bubbleSeriesIndex = getVisibleBubbleSeriesIndex(legend.chart);\n    // Remove unnecessary element\n    if (bubbleLegend && bubbleLegend.ranges && bubbleLegend.ranges.length) {\n        // Allow change the way of calculating ranges in update\n        if (options.ranges.length) {\n            options.autoRanges =\n                !!options.ranges[0].autoRanges;\n        }\n        // Update bubbleLegend dimensions in each redraw\n        legend.destroyItem(bubbleLegend);\n    }\n    // Create bubble legend\n    if (bubbleSeriesIndex >= 0 &&\n        legendOptions.enabled &&\n        options.enabled) {\n        options.seriesIndex = bubbleSeriesIndex;\n        legend.bubbleLegend = new BubbleLegendItem(options, legend);\n        legend.bubbleLegend.addToLegend(e.allItems);\n    }\n}\n/**\n * Toggle bubble legend depending on the visible status of bubble series.\n */\nfunction onLegendItemClick(e) {\n    // #14080 don't fire this code if click function is prevented\n    if (e.defaultPrevented) {\n        return false;\n    }\n    const legend = this, series = e.legendItem, chart = legend.chart, visible = series.visible;\n    let status;\n    if (legend && legend.bubbleLegend) {\n        // Temporary correct 'visible' property\n        series.visible = !visible;\n        // Save future status for getRanges method\n        series.ignoreSeries = visible;\n        // Check if at lest one bubble series is visible\n        status = getVisibleBubbleSeriesIndex(chart) >= 0;\n        // Hide bubble legend if all bubble series are disabled\n        if (legend.bubbleLegend.visible !== status) {\n            // Show or hide bubble legend\n            legend.update({\n                bubbleLegend: { enabled: status }\n            });\n            legend.bubbleLegend.visible = status; // Restore default status\n        }\n        series.visible = visible;\n    }\n}\n/**\n * Correct legend items translation in case of different elements heights.\n *\n * @private\n * @function Highcharts.Legend#retranslateItems\n *\n * @param {Highcharts.Legend} legend\n * Legend to translate in.\n *\n * @param {Array<Highcharts.Dictionary<number>>} lines\n * Informations about line height and items amount\n */\nfunction retranslateItems(legend, lines) {\n    const items = legend.allItems, rtl = legend.options.rtl;\n    let orgTranslateX, orgTranslateY, movementX, legendItem, actualLine = 0;\n    items.forEach((item, index) => {\n        legendItem = item.legendItem || {};\n        if (!legendItem.group) {\n            return;\n        }\n        orgTranslateX = legendItem.group.translateX || 0;\n        orgTranslateY = legendItem.y || 0;\n        movementX = item.movementX;\n        if (movementX || (rtl && item.ranges)) {\n            movementX = rtl ?\n                orgTranslateX - item.options.maxSize / 2 :\n                orgTranslateX + movementX;\n            legendItem.group.attr({ translateX: movementX });\n        }\n        if (index > lines[actualLine].step) {\n            actualLine++;\n        }\n        legendItem.group.attr({\n            translateY: Math.round(orgTranslateY + lines[actualLine].height / 2)\n        });\n        legendItem.y = orgTranslateY + lines[actualLine].height / 2;\n    });\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst BubbleLegendComposition = {\n    compose\n};\nexport default BubbleLegendComposition;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3575, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Bubble/BubblePoint.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport Point from '../../Core/Series/Point.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { seriesTypes: { scatter: { prototype: { pointClass: ScatterPoint } } } } = SeriesRegistry;\nimport U from '../../Core/Utilities.js';\nconst { extend } = U;\n/* *\n *\n *  Class\n *\n * */\nclass BubblePoint extends ScatterPoint {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * @private\n     */\n    haloPath(size) {\n        const computedSize = (size && this.marker ?\n            this.marker.radius ||\n                0 :\n            0) + size;\n        if (this.series.chart.inverted) {\n            const pos = this.pos() || [0, 0], { xAxis, yAxis, chart } = this.series, diameter = computedSize * 2;\n            return chart.renderer.symbols.circle((xAxis?.len || 0) - pos[1] - computedSize, (yAxis?.len || 0) - pos[0] - computedSize, diameter, diameter);\n        }\n        return Point.prototype.haloPath.call(this, \n        // #6067\n        computedSize);\n    }\n}\n/* *\n *\n *  Class Prototype\n *\n * */\nextend(BubblePoint.prototype, {\n    ttBelow: false\n});\n/* *\n *\n *  Default Export\n *\n * */\nexport default BubblePoint;\n"],"names":[],"mappings":";;;;AAWA;AACA;AAEA;AAdA;;;;;;;;;GASG,GACH;;;AAGA,MAAM,EAAE,aAAa,EAAE,SAAS,EAAE,WAAW,EAAE,YAAY,YAAY,EAAE,EAAE,EAAE,EAAE,GAAG,6LAAc;;AAEhG,MAAM,EAAE,MAAM,EAAE,GAAG,8KAAC;AACpB;;;;GAIG,GACH,MAAM,oBAAoB;IACtB;;;;OAIG,GACH,8BAA8B,GAC9B;;KAEC,GACD,SAAS,IAAI,EAAE;QACX,MAAM,eAAe,CAAC,QAAQ,IAAI,CAAC,MAAM,GACrC,IAAI,CAAC,MAAM,CAAC,MAAM,IACd,IACJ,CAAC,IAAI;QACT,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE;YAC5B,MAAM,MAAM,IAAI,CAAC,GAAG,MAAM;gBAAC;gBAAG;aAAE,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,WAAW,eAAe;YACnG,OAAO,MAAM,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,OAAO,OAAO,CAAC,IAAI,GAAG,CAAC,EAAE,GAAG,cAAc,CAAC,OAAO,OAAO,CAAC,IAAI,GAAG,CAAC,EAAE,GAAG,cAAc,UAAU;QACzI;QACA,OAAO,oLAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EACzC,QAAQ;QACR;IACJ;AACJ;AACA;;;;GAIG,GACH,OAAO,YAAY,SAAS,EAAE;IAC1B,SAAS;AACb;uCAMe","ignoreList":[0]}},
    {"offset": {"line": 3633, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Bubble/BubbleSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport BubbleLegendComposition from './BubbleLegendComposition.js';\nimport BubblePoint from './BubblePoint.js';\nimport H from '../../Core/Globals.js';\nconst { composed, noop } = H;\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { series: Series, seriesTypes: { column: { prototype: columnProto }, scatter: ScatterSeries } } = SeriesRegistry;\nimport U from '../../Core/Utilities.js';\nconst { addEvent, arrayMax, arrayMin, clamp, extend, isNumber, merge, pick, pushUnique } = U;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Add logic to pad each axis with the amount of pixels necessary to avoid the\n * bubbles to overflow.\n */\nfunction onAxisFoundExtremes() {\n    const axisLength = this.len, { coll, isXAxis, min } = this, range = (this.max || 0) - (min || 0);\n    let pxMin = 0, pxMax = axisLength, transA = axisLength / range, hasActiveSeries;\n    if (coll !== 'xAxis' && coll !== 'yAxis') {\n        return;\n    }\n    // Handle padding on the second pass, or on redraw\n    this.series.forEach((series) => {\n        if (series.bubblePadding && series.reserveSpace()) {\n            // Correction for #1673\n            this.allowZoomOutside = true;\n            hasActiveSeries = true;\n            const data = series.getColumn(isXAxis ? 'x' : 'y');\n            if (isXAxis) {\n                (series.onPoint || series).getRadii(0, 0, series);\n                if (series.onPoint) {\n                    series.radii = series.onPoint.radii;\n                }\n            }\n            if (range > 0) {\n                let i = data.length;\n                while (i--) {\n                    if (isNumber(data[i]) &&\n                        this.dataMin <= data[i] &&\n                        data[i] <= this.max) {\n                        const radius = series.radii && series.radii[i] || 0;\n                        pxMin = Math.min(((data[i] - min) * transA) - radius, pxMin);\n                        pxMax = Math.max(((data[i] - min) * transA) + radius, pxMax);\n                    }\n                }\n            }\n        }\n    });\n    // Apply the padding to the min and max properties\n    if (hasActiveSeries && range > 0 && !this.logarithmic) {\n        pxMax -= axisLength;\n        transA *= (axisLength +\n            Math.max(0, pxMin) - // #8901\n            Math.min(pxMax, axisLength)) / axisLength;\n        [\n            ['min', 'userMin', pxMin],\n            ['max', 'userMax', pxMax]\n        ].forEach((keys) => {\n            if (typeof pick(this.options[keys[0]], this[keys[1]]) === 'undefined') {\n                this[keys[0]] += keys[2] / transA;\n            }\n        });\n    }\n}\n/**\n * If a user has defined categories, it is necessary to retroactively hide any\n * ticks added by the 'onAxisFoundExtremes' function above (#21672).\n *\n * Otherwise they can show up on the axis, alongside user-defined categories.\n */\nfunction onAxisAfterRender() {\n    const { ticks, tickPositions, dataMin = 0, dataMax = 0, categories } = this, type = this.options.type;\n    if ((categories?.length || type === 'category') &&\n        this.series.find((s) => s.bubblePadding)) {\n        let tickCount = tickPositions.length;\n        while (tickCount--) {\n            const tick = ticks[tickPositions[tickCount]], pos = tick.pos || 0;\n            if (pos > dataMax || pos < dataMin) {\n                tick.label?.hide();\n            }\n        }\n    }\n}\n/* *\n *\n *  Class\n *\n * */\nclass BubbleSeries extends ScatterSeries {\n    /* *\n     *\n     *  Static Functions\n     *\n     * */\n    static compose(AxisClass, ChartClass, LegendClass) {\n        BubbleLegendComposition.compose(ChartClass, LegendClass);\n        if (pushUnique(composed, 'Series.Bubble')) {\n            addEvent(AxisClass, 'foundExtremes', onAxisFoundExtremes);\n            addEvent(AxisClass, 'afterRender', onAxisAfterRender);\n        }\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Perform animation on the bubbles\n     * @private\n     */\n    animate(init) {\n        if (!init &&\n            this.points.length < this.options.animationLimit // #8099\n        ) {\n            this.points.forEach(function (point) {\n                const { graphic, plotX = 0, plotY = 0 } = point;\n                if (graphic && graphic.width) { // URL symbols don't have width\n                    // Start values\n                    if (!this.hasRendered) {\n                        graphic.attr({\n                            x: plotX,\n                            y: plotY,\n                            width: 1,\n                            height: 1\n                        });\n                    }\n                    graphic.animate(this.markerAttribs(point), this.options.animation);\n                }\n            }, this);\n        }\n    }\n    /**\n     * Get the radius for each point based on the minSize, maxSize and each\n     * point's Z value. This must be done prior to Series.translate because\n     * the axis needs to add padding in accordance with the point sizes.\n     * @private\n     */\n    getRadii() {\n        const zData = this.getColumn('z'), yData = this.getColumn('y'), radii = [];\n        let len, i, value, zExtremes = this.chart.bubbleZExtremes;\n        const { minPxSize, maxPxSize } = this.getPxExtremes();\n        // Get the collective Z extremes of all bubblish series. The chart-level\n        // `bubbleZExtremes` are only computed once, and reset on `updatedData`\n        // in any member series.\n        if (!zExtremes) {\n            let zMin = Number.MAX_VALUE;\n            let zMax = -Number.MAX_VALUE;\n            let valid;\n            this.chart.series.forEach((otherSeries) => {\n                if (otherSeries.bubblePadding && otherSeries.reserveSpace()) {\n                    const zExtremes = (otherSeries.onPoint || otherSeries).getZExtremes();\n                    if (zExtremes) {\n                        // Changed '||' to 'pick' because min or max can be 0.\n                        // #17280\n                        zMin = Math.min(pick(zMin, zExtremes.zMin), zExtremes.zMin);\n                        zMax = Math.max(pick(zMax, zExtremes.zMax), zExtremes.zMax);\n                        valid = true;\n                    }\n                }\n            });\n            if (valid) {\n                zExtremes = { zMin, zMax };\n                this.chart.bubbleZExtremes = zExtremes;\n            }\n            else {\n                zExtremes = { zMin: 0, zMax: 0 };\n            }\n        }\n        // Set the shape type and arguments to be picked up in drawPoints\n        for (i = 0, len = zData.length; i < len; i++) {\n            value = zData[i];\n            // Separate method to get individual radius for bubbleLegend\n            radii.push(this.getRadius(zExtremes.zMin, zExtremes.zMax, minPxSize, maxPxSize, value, yData && yData[i]));\n        }\n        this.radii = radii;\n    }\n    /**\n     * Get the individual radius for one point.\n     * @private\n     */\n    getRadius(zMin, zMax, minSize, maxSize, value, yValue) {\n        const options = this.options, sizeByArea = options.sizeBy !== 'width', zThreshold = options.zThreshold;\n        let zRange = zMax - zMin, pos = 0.5;\n        // #8608 - bubble should be visible when z is undefined\n        if (yValue === null || value === null) {\n            return null;\n        }\n        if (isNumber(value)) {\n            // When sizing by threshold, the absolute value of z determines\n            // the size of the bubble.\n            if (options.sizeByAbsoluteValue) {\n                value = Math.abs(value - zThreshold);\n                zMax = zRange = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));\n                zMin = 0;\n            }\n            // Issue #4419 - if value is less than zMin, push a radius that's\n            // always smaller than the minimum size\n            if (value < zMin) {\n                return minSize / 2 - 1;\n            }\n            // Relative size, a number between 0 and 1\n            if (zRange > 0) {\n                pos = (value - zMin) / zRange;\n            }\n        }\n        if (sizeByArea && pos >= 0) {\n            pos = Math.sqrt(pos);\n        }\n        return Math.ceil(minSize + pos * (maxSize - minSize)) / 2;\n    }\n    /**\n     * Define hasData function for non-cartesian series.\n     * Returns true if the series has points at all.\n     * @private\n     */\n    hasData() {\n        return !!this.dataTable.rowCount;\n    }\n    /**\n     * @private\n     */\n    markerAttribs(point, state) {\n        const attr = super.markerAttribs(point, state), { height = 0, width = 0 } = attr;\n        // Bubble needs a specific `markerAttribs` override because the markers\n        // are rendered into the potentially inverted `series.group`. Unlike\n        // regular markers, which are rendered into the `markerGroup` (#21125).\n        return this.chart.inverted ? extend(attr, {\n            x: (point.plotX || 0) - width / 2,\n            y: (point.plotY || 0) - height / 2\n        }) : attr;\n    }\n    /**\n     * @private\n     */\n    pointAttribs(point, state) {\n        const markerOptions = this.options.marker, fillOpacity = markerOptions?.fillOpacity, attr = Series.prototype.pointAttribs.call(this, point, state);\n        attr['fill-opacity'] = fillOpacity ?? 1;\n        return attr;\n    }\n    /**\n     * Extend the base translate method to handle bubble size\n     * @private\n     */\n    translate() {\n        // Run the parent method\n        super.translate.call(this);\n        this.getRadii();\n        this.translateBubble();\n    }\n    translateBubble() {\n        const { data, options, radii } = this, { minPxSize } = this.getPxExtremes();\n        // Set the shape type and arguments to be picked up in drawPoints\n        let i = data.length;\n        while (i--) {\n            const point = data[i], radius = radii ? radii[i] : 0; // #1737\n            // Negative points means negative z values (#9728)\n            if (this.zoneAxis === 'z') {\n                point.negative = (point.z || 0) < (options.zThreshold || 0);\n            }\n            if (isNumber(radius) && radius >= minPxSize / 2) {\n                // Shape arguments\n                point.marker = extend(point.marker, {\n                    radius,\n                    width: 2 * radius,\n                    height: 2 * radius\n                });\n                // Alignment box for the data label\n                point.dlBox = {\n                    x: point.plotX - radius,\n                    y: point.plotY - radius,\n                    width: 2 * radius,\n                    height: 2 * radius\n                };\n            }\n            else { // Below zThreshold\n                // #1691\n                point.shapeArgs = point.plotY = point.dlBox = void 0;\n                point.isInside = false; // #17281\n            }\n        }\n    }\n    getPxExtremes() {\n        const smallestSize = Math.min(this.chart.plotWidth, this.chart.plotHeight);\n        const getPxSize = (length) => {\n            let isPercent;\n            if (typeof length === 'string') {\n                isPercent = /%$/.test(length);\n                length = parseInt(length, 10);\n            }\n            return isPercent ? smallestSize * length / 100 : length;\n        };\n        const minPxSize = getPxSize(pick(this.options.minSize, 8));\n        // Prioritize min size if conflict to make sure bubbles are\n        // always visible. #5873\n        const maxPxSize = Math.max(getPxSize(pick(this.options.maxSize, '20%')), minPxSize);\n        return { minPxSize, maxPxSize };\n    }\n    getZExtremes() {\n        const options = this.options, zData = this.getColumn('z').filter(isNumber);\n        if (zData.length) {\n            const zMin = pick(options.zMin, clamp(arrayMin(zData), options.displayNegative === false ?\n                (options.zThreshold || 0) :\n                -Number.MAX_VALUE, Number.MAX_VALUE));\n            const zMax = pick(options.zMax, arrayMax(zData));\n            if (isNumber(zMin) && isNumber(zMax)) {\n                return { zMin, zMax };\n            }\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.Series#searchKDTree\n     */\n    searchKDTree(point, compareX, e, suppliedPointEvaluator = noop, suppliedBSideCheckEvaluator = noop) {\n        suppliedPointEvaluator = (p1, p2, comparisonProp) => {\n            const p1Dist = p1[comparisonProp] || 0;\n            const p2Dist = p2[comparisonProp] || 0;\n            let ret, flip = false;\n            if (p1Dist === p2Dist) {\n                ret = p1.index > p2.index ? p1 : p2;\n            }\n            else if (p1Dist < 0 && p2Dist < 0) {\n                ret = (p1Dist - (p1.marker?.radius || 0) >=\n                    p2Dist - (p2.marker?.radius || 0)) ?\n                    p1 :\n                    p2;\n                flip = true;\n            }\n            else {\n                ret = p1Dist < p2Dist ? p1 : p2;\n            }\n            return [ret, flip];\n        };\n        suppliedBSideCheckEvaluator = (a, b, flip) => !flip && (a > b) || (a < b);\n        return super.searchKDTree(point, compareX, e, suppliedPointEvaluator, suppliedBSideCheckEvaluator);\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * A bubble series is a three dimensional series type where each point\n * renders an X, Y and Z value. Each points is drawn as a bubble where the\n * position along the X and Y axes mark the X and Y values, and the size of\n * the bubble relates to the Z value.\n *\n * @sample {highcharts} highcharts/demo/bubble/\n *         Bubble chart\n *\n * @extends      plotOptions.scatter\n * @excluding    cluster\n * @product      highcharts highstock\n * @requires     highcharts-more\n * @optionparent plotOptions.bubble\n */\nBubbleSeries.defaultOptions = merge(ScatterSeries.defaultOptions, {\n    dataLabels: {\n        formatter: function () {\n            const { numberFormatter } = this.series.chart;\n            const { z } = this.point;\n            return isNumber(z) ? numberFormatter(z, -1) : '';\n        },\n        inside: true,\n        verticalAlign: 'middle'\n    },\n    /**\n     * If there are more points in the series than the `animationLimit`, the\n     * animation won't run. Animation affects overall performance and\n     * doesn't work well with heavy data series.\n     *\n     * @since 6.1.0\n     */\n    animationLimit: 250,\n    /**\n     * Whether to display negative sized bubbles. The threshold is given\n     * by the [zThreshold](#plotOptions.bubble.zThreshold) option, and negative\n     * bubbles can be visualized by setting\n     * [negativeColor](#plotOptions.bubble.negativeColor).\n     *\n     * @sample {highcharts} highcharts/plotoptions/bubble-negative/\n     *         Negative bubbles\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     3.0\n     * @apioption plotOptions.bubble.displayNegative\n     */\n    /**\n     * @extends   plotOptions.series.marker\n     * @excluding enabled, enabledThreshold, height, radius, width\n     */\n    marker: {\n        lineColor: null, // Inherit from series.color\n        lineWidth: 1,\n        /**\n         * The fill opacity of the bubble markers.\n         */\n        fillOpacity: 0.5,\n        /**\n         * In bubble charts, the radius is overridden and determined based\n         * on the point's data value.\n         *\n         * @ignore-option\n         */\n        radius: null,\n        states: {\n            hover: {\n                radiusPlus: 0\n            }\n        },\n        /**\n         * A predefined shape or symbol for the marker. Possible values are\n         * \"circle\", \"square\", \"diamond\", \"triangle\" and \"triangle-down\".\n         *\n         * Additionally, the URL to a graphic can be given on the form\n         * `url(graphic.png)`. Note that for the image to be applied to\n         * exported charts, its URL needs to be accessible by the export\n         * server.\n         *\n         * Custom callbacks for symbol path generation can also be added to\n         * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then\n         * used by its method name, as shown in the demo.\n         *\n         * @sample {highcharts} highcharts/plotoptions/bubble-symbol/\n         *         Bubble chart with various symbols\n         * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/\n         *         General chart with predefined, graphic and custom markers\n         *\n         * @type  {Highcharts.SymbolKeyValue|string}\n         * @since 5.0.11\n         */\n        symbol: 'circle'\n    },\n    /**\n     * Minimum bubble size. Bubbles will automatically size between the\n     * `minSize` and `maxSize` to reflect the `z` value of each bubble.\n     * Can be either pixels (when no unit is given), or a percentage of\n     * the smallest one of the plot width and height.\n     *\n     * @sample {highcharts} highcharts/plotoptions/bubble-size/\n     *         Bubble size\n     *\n     * @type    {number|string}\n     * @since   3.0\n     * @product highcharts highstock\n     */\n    minSize: 8,\n    /**\n     * Maximum bubble size. Bubbles will automatically size between the\n     * `minSize` and `maxSize` to reflect the `z` value of each bubble.\n     * Can be either pixels (when no unit is given), or a percentage of\n     * the smallest one of the plot width and height.\n     *\n     * @sample {highcharts} highcharts/plotoptions/bubble-size/\n     *         Bubble size\n     *\n     * @type    {number|string}\n     * @since   3.0\n     * @product highcharts highstock\n     */\n    maxSize: '20%',\n    /**\n     * When a point's Z value is below the\n     * [zThreshold](#plotOptions.bubble.zThreshold)\n     * setting, this color is used.\n     *\n     * @sample {highcharts} highcharts/plotoptions/bubble-negative/\n     *         Negative bubbles\n     *\n     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @since     3.0\n     * @product   highcharts\n     * @apioption plotOptions.bubble.negativeColor\n     */\n    /**\n     * Whether the bubble's value should be represented by the area or the\n     * width of the bubble. The default, `area`, corresponds best to the\n     * human perception of the size of each bubble.\n     *\n     * @sample {highcharts} highcharts/plotoptions/bubble-sizeby/\n     *         Comparison of area and size\n     *\n     * @type       {Highcharts.BubbleSizeByValue}\n     * @default    area\n     * @since      3.0.7\n     * @apioption  plotOptions.bubble.sizeBy\n     */\n    /**\n     * When this is true, the absolute value of z determines the size of\n     * the bubble. This means that with the default `zThreshold` of 0, a\n     * bubble of value -1 will have the same size as a bubble of value 1,\n     * while a bubble of value 0 will have a smaller size according to\n     * `minSize`.\n     *\n     * @sample    {highcharts} highcharts/plotoptions/bubble-sizebyabsolutevalue/\n     *            Size by absolute value, various thresholds\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     4.1.9\n     * @product   highcharts\n     * @apioption plotOptions.bubble.sizeByAbsoluteValue\n     */\n    /**\n     * When this is true, the series will not cause the Y axis to cross\n     * the zero plane (or [threshold](#plotOptions.series.threshold) option)\n     * unless the data actually crosses the plane.\n     *\n     * For example, if `softThreshold` is `false`, a series of 0, 1, 2,\n     * 3 will make the Y axis show negative values according to the\n     * `minPadding` option. If `softThreshold` is `true`, the Y axis starts\n     * at 0.\n     *\n     * @since   4.1.9\n     * @product highcharts\n     */\n    softThreshold: false,\n    states: {\n        hover: {\n            halo: {\n                size: 5\n            }\n        }\n    },\n    tooltip: {\n        pointFormat: '({point.x}, {point.y}), Size: {point.z}'\n    },\n    turboThreshold: 0,\n    /**\n     * The minimum for the Z value range. Defaults to the highest Z value\n     * in the data.\n     *\n     * @see [zMin](#plotOptions.bubble.zMin)\n     *\n     * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/\n     *         Z has a possible range of 0-100\n     *\n     * @type      {number}\n     * @since     4.0.3\n     * @product   highcharts\n     * @apioption plotOptions.bubble.zMax\n     */\n    /**\n     * @default   z\n     * @apioption plotOptions.bubble.colorKey\n     */\n    /**\n     * The minimum for the Z value range. Defaults to the lowest Z value\n     * in the data.\n     *\n     * @see [zMax](#plotOptions.bubble.zMax)\n     *\n     * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/\n     *         Z has a possible range of 0-100\n     *\n     * @type      {number}\n     * @since     4.0.3\n     * @product   highcharts\n     * @apioption plotOptions.bubble.zMin\n     */\n    /**\n     * When [displayNegative](#plotOptions.bubble.displayNegative) is `false`,\n     * bubbles with lower Z values are skipped. When `displayNegative`\n     * is `true` and a [negativeColor](#plotOptions.bubble.negativeColor)\n     * is given, points with lower Z is colored.\n     *\n     * @sample {highcharts} highcharts/plotoptions/bubble-negative/\n     *         Negative bubbles\n     *\n     * @since   3.0\n     * @product highcharts\n     */\n    zThreshold: 0,\n    zoneAxis: 'z'\n});\nextend(BubbleSeries.prototype, {\n    alignDataLabel: columnProto.alignDataLabel,\n    applyZones: noop,\n    bubblePadding: true,\n    isBubble: true,\n    keysAffectYAxis: ['y'],\n    pointArrayMap: ['y', 'z'],\n    pointClass: BubblePoint,\n    parallelArrays: ['x', 'y', 'z'],\n    trackerGroups: ['group', 'dataLabelsGroup'],\n    specialGroup: 'group', // To allow clipping (#6296)\n    zoneAxis: 'z'\n});\n// On updated data in any series, delete the chart-level Z extremes cache\naddEvent(BubbleSeries, 'updatedData', (e) => {\n    delete e.target.chart.bubbleZExtremes;\n});\n// After removing series, delete the chart-level Z extremes cache, #17502.\naddEvent(BubbleSeries, 'remove', (e) => {\n    delete e.target.chart.bubbleZExtremes;\n});\nSeriesRegistry.registerSeriesType('bubble', BubbleSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default BubbleSeries;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * @typedef {\"area\"|\"width\"} Highcharts.BubbleSizeByValue\n */\n''; // Detach doclets above\n/* *\n *\n *  API Options\n *\n * */\n/**\n * A `bubble` series. If the [type](#series.bubble.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.bubble\n * @excluding dataParser, dataURL, legendSymbolColor, stack\n * @product   highcharts highstock\n * @requires  highcharts-more\n * @apioption series.bubble\n */\n/**\n * An array of data points for the series. For the `bubble` series type,\n * points can be given in the following ways:\n *\n * 1. An array of arrays with 3 or 2 values. In this case, the values correspond\n *    to `x,y,z`. If the first value is a string, it is applied as the name of\n *    the point, and the `x` value is inferred. The `x` value can also be\n *    omitted, in which case the inner arrays should be of length 2\\. Then the\n *    `x` value is automatically calculated, either starting at 0 and\n *    incremented by 1, or from `pointStart` and `pointInterval` given in the\n *    series options.\n *    ```js\n *    data: [\n *        [0, 1, 2],\n *        [1, 5, 5],\n *        [2, 0, 2]\n *    ]\n *    ```\n *\n * 2. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.bubble.turboThreshold), this option is not\n *    available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        y: 1,\n *        z: 1,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        y: 5,\n *        z: 4,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n * @extends   series.line.data\n * @product   highcharts\n * @apioption series.bubble.data\n */\n/**\n * @extends     series.line.data.marker\n * @excluding   enabledThreshold, height, radius, width\n * @product     highcharts\n * @apioption   series.bubble.data.marker\n */\n/**\n * The size value for each bubble. The bubbles' diameters are computed\n * based on the `z`, and controlled by series options like `minSize`,\n * `maxSize`, `sizeBy`, `zMin` and `zMax`.\n *\n * @type      {number|null}\n * @product   highcharts\n * @apioption series.bubble.data.z\n */\n/**\n * @excluding enabled, enabledThreshold, height, radius, width\n * @apioption series.bubble.marker\n */\n''; // Adds doclets above to transpiled file\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4337, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/ColumnRange/ColumnRangePoint.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { seriesTypes: { column: { prototype: { pointClass: { prototype: columnProto } } }, arearange: { prototype: { pointClass: AreaRangePoint } } } } = SeriesRegistry;\nimport U from '../../Core/Utilities.js';\nconst { extend, isNumber } = U;\n/* *\n *\n *  Class\n *\n * */\nclass ColumnRangePoint extends AreaRangePoint {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    isValid() {\n        return isNumber(this.low);\n    }\n}\nextend(ColumnRangePoint.prototype, {\n    setState: columnProto.setState\n});\n/* *\n *\n *  Default Export\n *\n * */\nexport default ColumnRangePoint;\n"],"names":[],"mappings":";;;;AAWA;AAEA;AAbA;;;;;;;;;GASG,GACH;;AAEA,MAAM,EAAE,aAAa,EAAE,QAAQ,EAAE,WAAW,EAAE,YAAY,EAAE,WAAW,WAAW,EAAE,EAAE,EAAE,EAAE,WAAW,EAAE,WAAW,EAAE,YAAY,cAAc,EAAE,EAAE,EAAE,EAAE,GAAG,6LAAc;;AAEvK,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,8KAAC;AAC9B;;;;GAIG,GACH,MAAM,yBAAyB;IAC3B;;;;OAIG,GACH,UAAU;QACN,OAAO,SAAS,IAAI,CAAC,GAAG;IAC5B;AACJ;AACA,OAAO,iBAAiB,SAAS,EAAE;IAC/B,UAAU,YAAY,QAAQ;AAClC;uCAMe","ignoreList":[0]}},
    {"offset": {"line": 4378, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/ColumnRange/ColumnRangeSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport ColumnRangePoint from './ColumnRangePoint.js';\nimport H from '../../Core/Globals.js';\nconst { noop } = H;\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { seriesTypes: { arearange: AreaRangeSeries, column: ColumnSeries, column: { prototype: columnProto } } } = SeriesRegistry;\nimport U from '../../Core/Utilities.js';\nconst { addEvent, clamp, extend, isNumber, merge, pick } = U;\n/* *\n *\n *  Constants\n *\n * */\n/**\n * The column range is a cartesian series type with higher and lower\n * Y values along an X axis. To display horizontal bars, set\n * [chart.inverted](#chart.inverted) to `true`.\n *\n * @sample {highcharts|highstock} highcharts/demo/columnrange/\n *         Inverted column range\n *\n * @extends      plotOptions.column\n * @since        2.3.0\n * @excluding    negativeColor, stacking, softThreshold, threshold\n * @product      highcharts highstock\n * @requires     highcharts-more\n * @optionparent plotOptions.columnrange\n */\nconst columnRangeOptions = {\n    borderRadius: {\n        where: 'all'\n    },\n    /**\n     * Extended data labels for range series types. Range series data labels\n     * have no `x` and `y` options. Instead, they have `xLow`, `xHigh`,\n     * `yLow` and `yHigh` options to allow the higher and lower data label\n     * sets individually.\n     *\n     * @declare   Highcharts.SeriesAreaRangeDataLabelsOptionsObject\n     * @extends   plotOptions.arearange.dataLabels\n     * @since     2.3.0\n     * @product   highcharts highstock\n     * @apioption plotOptions.columnrange.dataLabels\n     */\n    pointRange: null,\n    legendSymbol: 'rectangle',\n    /** @ignore-option */\n    marker: null,\n    states: {\n        hover: {\n            /** @ignore-option */\n            halo: false\n        }\n    }\n};\n/* *\n *\n *  Class\n *\n * */\n/**\n * The ColumnRangeSeries class\n *\n * @private\n * @class\n * @name Highcharts.seriesTypes.columnrange\n *\n * @augments Highcharts.Series\n */\nclass ColumnRangeSeries extends AreaRangeSeries {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    setOptions() {\n        // #14359 Prevent side-effect from stacking.\n        merge(true, arguments[0], { stacking: void 0 });\n        return AreaRangeSeries.prototype.setOptions.apply(this, arguments);\n    }\n    // Overrides from modules that may be loaded after this module\n    // @todo move to compositions\n    translate() {\n        return columnProto.translate.apply(this);\n    }\n    // Public crispCol(): BBoxObject {\n    //     return columnProto.crispCol.apply(this, arguments as any);\n    // }\n    // public drawPoints(): void {\n    //     return columnProto.drawPoints.apply(this, arguments as any);\n    // }\n    // public drawTracker(): void {\n    //     return columnProto.drawTracker.apply(this, arguments as any);\n    // }\n    // public getColumnMetrics(): ColumnMetricsObject {\n    //     return columnProto.getColumnMetrics.apply(this, arguments as any);\n    // }\n    pointAttribs() {\n        return columnProto.pointAttribs.apply(this, arguments);\n    }\n    // Public adjustForMissingColumns(): number {\n    //     return columnProto.adjustForMissingColumns.apply(this, arguments);\n    // }\n    // public animate(): void {\n    //     return columnProto.animate.apply(this, arguments as any);\n    // }\n    translate3dPoints() {\n        return columnProto.translate3dPoints.apply(this, arguments);\n    }\n    translate3dShapes() {\n        return columnProto.translate3dShapes.apply(this, arguments);\n    }\n    afterColumnTranslate() {\n        /**\n         * Translate data points from raw values x and y to plotX and plotY\n         * @private\n         */\n        const yAxis = this.yAxis, xAxis = this.xAxis, startAngleRad = xAxis.startAngleRad, chart = this.chart, isRadial = this.xAxis.isRadial, safeDistance = Math.max(chart.chartWidth, chart.chartHeight) + 999;\n        let height, heightDifference, start, y;\n        // eslint-disable-next-line valid-jsdoc\n        /**\n         * Don't draw too far outside plot area (#6835)\n         * @private\n         */\n        function safeBounds(pixelPos) {\n            return clamp(pixelPos, -safeDistance, safeDistance);\n        }\n        // Set plotLow and plotHigh\n        this.points.forEach((point) => {\n            const shapeArgs = point.shapeArgs || {}, minPointLength = this.options.minPointLength, plotY = point.plotY, plotHigh = yAxis.translate(point.high, 0, 1, 0, 1);\n            if (isNumber(plotHigh) && isNumber(plotY)) {\n                point.plotHigh = safeBounds(plotHigh);\n                point.plotLow = safeBounds(plotY);\n                // Adjust shape\n                y = point.plotHigh;\n                height = pick(point.rectPlotY, point.plotY) - point.plotHigh;\n                // Adjust for minPointLength\n                if (Math.abs(height) < minPointLength) {\n                    heightDifference = (minPointLength - height);\n                    height += heightDifference;\n                    y -= heightDifference / 2;\n                    // Adjust for negative ranges or reversed Y axis (#1457)\n                }\n                else if (height < 0) {\n                    height *= -1;\n                    y -= height;\n                }\n                if (isRadial && this.polar) {\n                    start = point.barX + startAngleRad;\n                    point.shapeType = 'arc';\n                    point.shapeArgs = this.polar.arc(y + height, y, start, start + point.pointWidth);\n                }\n                else {\n                    shapeArgs.height = height;\n                    shapeArgs.y = y;\n                    const { x = 0, width = 0 } = shapeArgs;\n                    // #17912, aligning column range points\n                    // merge if shapeArgs contains more properties e.g. for 3d\n                    point.shapeArgs = merge(point.shapeArgs, this.crispCol(x, y, width, height));\n                    point.tooltipPos = chart.inverted ?\n                        [\n                            yAxis.len + yAxis.pos - chart.plotLeft - y -\n                                height / 2,\n                            xAxis.len + xAxis.pos - chart.plotTop - x -\n                                width / 2,\n                            height\n                        ] : [\n                        xAxis.left - chart.plotLeft + x + width / 2,\n                        yAxis.pos - chart.plotTop + y + height / 2,\n                        height\n                    ]; // Don't inherit from column tooltip position - #3372\n                }\n            }\n        });\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nColumnRangeSeries.defaultOptions = merge(ColumnSeries.defaultOptions, AreaRangeSeries.defaultOptions, columnRangeOptions);\naddEvent(ColumnRangeSeries, 'afterColumnTranslate', function () {\n    ColumnRangeSeries.prototype.afterColumnTranslate.apply(this);\n}, { order: 5 });\nextend(ColumnRangeSeries.prototype, {\n    directTouch: true,\n    pointClass: ColumnRangePoint,\n    trackerGroups: ['group', 'dataLabelsGroup'],\n    adjustForMissingColumns: columnProto.adjustForMissingColumns,\n    animate: columnProto.animate,\n    crispCol: columnProto.crispCol,\n    drawGraph: noop,\n    drawPoints: columnProto.drawPoints,\n    getSymbol: noop,\n    drawTracker: columnProto.drawTracker,\n    getColumnMetrics: columnProto.getColumnMetrics\n});\nSeriesRegistry.registerSeriesType('columnrange', ColumnRangeSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default ColumnRangeSeries;\n/* *\n *\n *  API Options\n *\n * */\n/**\n * A `columnrange` series. If the [type](#series.columnrange.type)\n * option is not specified, it is inherited from\n * [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.columnrange\n * @excluding dataParser, dataURL, stack, stacking\n * @product   highcharts highstock\n * @requires  highcharts-more\n * @apioption series.columnrange\n */\n/**\n * An array of data points for the series. For the `columnrange` series\n * type, points can be given in the following ways:\n *\n * 1. An array of arrays with 3 or 2 values. In this case, the values correspond\n *    to `x,low,high`. If the first value is a string, it is applied as the name\n *    of the point, and the `x` value is inferred. The `x` value can also be\n *    omitted, in which case the inner arrays should be of length 2\\. Then the\n *    `x` value is automatically calculated, either starting at 0 and\n *    incremented by 1, or from `pointStart` and `pointInterval` given in the\n *    series options.\n *    ```js\n *    data: [\n *        [0, 4, 2],\n *        [1, 2, 1],\n *        [2, 9, 10]\n *    ]\n *    ```\n *\n * 2. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.columnrange.turboThreshold), this option is not\n *    available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        low: 0,\n *        high: 4,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        low: 5,\n *        high: 3,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n * @extends   series.arearange.data\n * @excluding marker\n * @product   highcharts highstock\n * @apioption series.columnrange.data\n */\n/**\n * @extends   series.columnrange.dataLabels\n * @product   highcharts highstock\n * @apioption series.columnrange.data.dataLabels\n */\n/**\n * @excluding halo, lineWidth, lineWidthPlus, marker\n * @product   highcharts highstock\n * @apioption series.columnrange.states.hover\n */\n/**\n * @excluding halo, lineWidth, lineWidthPlus, marker\n * @product   highcharts highstock\n * @apioption series.columnrange.states.select\n */\n''; // Adds doclets above into transpiled\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4671, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/ColumnPyramid/ColumnPyramidSeriesDefaults.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Sebastian Bochan\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\n/* *\n *\n *  API Options\n *\n * */\n/**\n * Column pyramid series display one pyramid per value along an X axis.\n * To display horizontal pyramids, set [chart.inverted](#chart.inverted) to\n * `true`.\n *\n * @sample {highcharts|highstock} highcharts/demo/column-pyramid/\n *         Column pyramid\n * @sample {highcharts|highstock} highcharts/plotoptions/columnpyramid-stacked/\n *         Column pyramid stacked\n * @sample {highcharts|highstock} highcharts/plotoptions/columnpyramid-inverted/\n *         Column pyramid inverted\n *\n * @extends      plotOptions.column\n * @since        7.0.0\n * @product      highcharts highstock\n * @excluding    boostThreshold, borderRadius, crisp, depth, edgeColor,\n *               edgeWidth, groupZPadding, negativeColor, softThreshold,\n *               threshold, zoneAxis, zones, boostBlending\n * @requires     highcharts-more\n * @optionparent plotOptions.columnpyramid\n */\nconst ColumnPyramidSeriesDefaults = {};\n/**\n * A `columnpyramid` series. If the [type](#series.columnpyramid.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.columnpyramid\n * @excluding connectEnds, connectNulls, dashStyle, dataParser, dataURL,\n *            gapSize, gapUnit, linecap, lineWidth, marker, step,\n *            boostThreshold, boostBlending\n * @product   highcharts highstock\n * @requires  highcharts-more\n * @apioption series.columnpyramid\n */\n/**\n * @excluding halo, lineWidth, lineWidthPlus, marker\n * @product   highcharts highstock\n * @apioption series.columnpyramid.states.hover\n */\n/**\n * @excluding halo, lineWidth, lineWidthPlus, marker\n * @product   highcharts highstock\n * @apioption series.columnpyramid.states.select\n */\n/**\n * An array of data points for the series. For the `columnpyramid` series type,\n * points can be given in the following ways:\n *\n * 1. An array of numerical values. In this case, the numerical values will be\n *    interpreted as `y` options. The `x` values will be automatically\n *    calculated, either starting at 0 and incremented by 1, or from\n *    `pointStart` and `pointInterval` given in the series options. If the axis\n *    has categories, these will be used. Example:\n *    ```js\n *    data: [0, 5, 3, 5]\n *    ```\n *\n * 2. An array of arrays with 2 values. In this case, the values correspond to\n *    `x,y`. If the first value is a string, it is applied as the name of the\n *    point, and the `x` value is inferred.\n *    ```js\n *    data: [\n *        [0, 6],\n *        [1, 2],\n *        [2, 6]\n *    ]\n *    ```\n *\n * 3. An array of objects with named values. The objects are point configuration\n *    objects as seen below. If the total number of data points exceeds the\n *    series' [turboThreshold](#series.columnpyramid.turboThreshold), this\n *    option is not available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        y: 9,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        y: 6,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n * @extends   series.line.data\n * @excluding marker\n * @product   highcharts highstock\n * @apioption series.columnpyramid.data\n */\n''; // Keeps doclets above separate\n/* *\n *\n *  Default Export\n *\n * */\nexport default ColumnPyramidSeriesDefaults;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;GASG,GACH;AACA;;;;GAIG,GACH;;;;;;;;;;;;;;;;;;;;CAoBC,GACD,MAAM,8BAA8B,CAAC;AACrC;;;;;;;;;;;CAWC,GACD;;;;CAIC,GACD;;;;CAIC,GACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0DC,GACD,IAAI,+BAA+B;uCAMpB","ignoreList":[0]}},
    {"offset": {"line": 4793, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/ColumnPyramid/ColumnPyramidSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Sebastian Bochan\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport ColumnPyramidSeriesDefaults from './ColumnPyramidSeriesDefaults.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { column: ColumnSeries } = SeriesRegistry.seriesTypes;\nimport U from '../../Core/Utilities.js';\nconst { clamp, merge, pick } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * The ColumnPyramidSeries class\n *\n * @private\n * @class\n * @name Highcharts.seriesTypes.columnpyramid\n *\n * @augments Highcharts.Series\n */\nclass ColumnPyramidSeries extends ColumnSeries {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Overrides the column translate method\n     * @private\n     */\n    translate() {\n        const series = this, chart = series.chart, options = series.options, dense = series.dense =\n            series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick(options.borderWidth, dense ? 0 : 1 // #3635\n        ), yAxis = series.yAxis, threshold = options.threshold, minPointLength = pick(options.minPointLength, 5), metrics = series.getColumnMetrics(), pointWidth = metrics.width, pointXOffset = series.pointXOffset = metrics.offset;\n        let translatedThreshold = series.translatedThreshold =\n            yAxis.getThreshold(threshold), \n        // Postprocessed for border width\n        seriesBarW = series.barW =\n            Math.max(pointWidth, 1 + 2 * borderWidth);\n        if (chart.inverted) {\n            translatedThreshold -= 0.5; // #3355\n        }\n        // When the pointPadding is 0,\n        // we want the pyramids to be packed tightly,\n        // so we allow individual pyramids to have individual sizes.\n        // When pointPadding is greater,\n        // we strive for equal-width columns (#2694).\n        if (options.pointPadding) {\n            seriesBarW = Math.ceil(seriesBarW);\n        }\n        super.translate();\n        // Record the new values\n        for (const point of series.points) {\n            const yBottom = pick(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotY = clamp(point.plotY, -safeDistance, yAxis.len + safeDistance), \n            // Don't draw too far outside plot area\n            // (#1303, #2241, #4264)\n            barW = seriesBarW / 2, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY;\n            let barX = point.plotX + pointXOffset, stackTotal, stackHeight, topXwidth, bottomXwidth, invBarPos, x1, x2, x3, x4, y1, y2;\n            // Adjust for null or missing points\n            if (options.centerInCategory) {\n                barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics);\n            }\n            point.barX = barX;\n            point.pointWidth = pointWidth;\n            // Fix the tooltip on center of grouped pyramids\n            // (#1216, #424, #3648)\n            point.tooltipPos = chart.inverted ?\n                [\n                    yAxis.len + yAxis.pos - chart.plotLeft - plotY,\n                    series.xAxis.len - barX - barW,\n                    barH\n                ] :\n                [\n                    barX + barW,\n                    plotY + yAxis.pos - chart.plotTop,\n                    barH\n                ];\n            stackTotal =\n                threshold + (point.total || point.y);\n            // Overwrite stacktotal (always 100 / -100)\n            if (options.stacking === 'percent') {\n                stackTotal =\n                    threshold + (point.y < 0) ?\n                        -100 :\n                        100;\n            }\n            // Get the highest point (if stack, extract from total)\n            const topPointY = yAxis.toPixels((stackTotal), true);\n            // Calculate height of stack (in pixels)\n            stackHeight =\n                chart.plotHeight - topPointY -\n                    (chart.plotHeight - translatedThreshold);\n            // `topXwidth` and `bottomXwidth` = width of lines from the center\n            // calculated from tanges proportion. Cannot be a NaN #12514.\n            topXwidth = stackHeight ?\n                (barW * (barY - topPointY)) / stackHeight : 0;\n            // Like topXwidth, but with height of point\n            bottomXwidth = stackHeight ?\n                (barW * (barY + barH - topPointY)) / stackHeight :\n                0;\n            /*\n                    /\\\n                   /  \\\n            x1,y1,------ x2,y1\n                /       \\\n               -----------\n            x4,y2        x3,y2\n            */\n            x1 = barX - topXwidth + barW;\n            x2 = barX + topXwidth + barW;\n            x3 = barX + bottomXwidth + barW;\n            x4 = barX - bottomXwidth + barW;\n            y1 = barY - minPointLength;\n            y2 = barY + barH;\n            if (point.y < 0) {\n                y1 = barY;\n                y2 = barY + barH + minPointLength;\n            }\n            // Inverted chart\n            if (chart.inverted) {\n                invBarPos = yAxis.width - barY;\n                stackHeight =\n                    topPointY - (yAxis.width - translatedThreshold);\n                // Proportion tanges\n                topXwidth = (barW *\n                    (topPointY - invBarPos)) / stackHeight;\n                bottomXwidth = (barW *\n                    (topPointY - (invBarPos - barH))) / stackHeight;\n                x1 = barX + barW + topXwidth; // Top bottom\n                x2 = x1 - 2 * topXwidth; // Top top\n                x3 = barX - bottomXwidth + barW; // Bottom top\n                x4 = barX + bottomXwidth + barW; // Bottom bottom\n                y1 = barY;\n                y2 = barY + barH - minPointLength;\n                if (point.y < 0) {\n                    y2 = barY + barH + minPointLength;\n                }\n            }\n            // Register shape type and arguments to be used in drawPoints\n            point.shapeType = 'path';\n            point.shapeArgs = {\n                x: x1,\n                y: y1,\n                width: x2 - x1,\n                height: barH,\n                // Path of pyramid\n                d: [\n                    ['M', x1, y1],\n                    ['L', x2, y1],\n                    ['L', x3, y2],\n                    ['L', x4, y2],\n                    ['Z']\n                ]\n            };\n        }\n    }\n}\n/* *\n *\n *  Static properties\n *\n * */\nColumnPyramidSeries.defaultOptions = merge(ColumnSeries.defaultOptions, ColumnPyramidSeriesDefaults);\nSeriesRegistry.registerSeriesType('columnpyramid', ColumnPyramidSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default ColumnPyramidSeries;\n"],"names":[],"mappings":";;;;AAWA;AACA;AAEA;AAdA;;;;;;;;;GASG,GACH;;;AAGA,MAAM,EAAE,QAAQ,YAAY,EAAE,GAAG,6LAAc,CAAC,WAAW;;AAE3D,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,8KAAC;AAChC;;;;GAIG,GACH;;;;;;;;CAQC,GACD,MAAM,4BAA4B;IAC9B;;;;OAIG,GACH;;;KAGC,GACD,YAAY;QACR,MAAM,SAAS,IAAI,EAAE,QAAQ,OAAO,KAAK,EAAE,UAAU,OAAO,OAAO,EAAE,QAAQ,OAAO,KAAK,GACrF,OAAO,iBAAiB,GAAG,OAAO,KAAK,CAAC,MAAM,GAAG,GAAG,cAAc,OAAO,WAAW,GAAG,KAAK,QAAQ,WAAW,EAAE,QAAQ,IAAI,EAAE,QAAQ;WACxI,QAAQ,OAAO,KAAK,EAAE,YAAY,QAAQ,SAAS,EAAE,iBAAiB,KAAK,QAAQ,cAAc,EAAE,IAAI,UAAU,OAAO,gBAAgB,IAAI,aAAa,QAAQ,KAAK,EAAE,eAAe,OAAO,YAAY,GAAG,QAAQ,MAAM;QAC9N,IAAI,sBAAsB,OAAO,mBAAmB,GAChD,MAAM,YAAY,CAAC,YACvB,iCAAiC;QACjC,aAAa,OAAO,IAAI,GACpB,KAAK,GAAG,CAAC,YAAY,IAAI,IAAI;QACjC,IAAI,MAAM,QAAQ,EAAE;YAChB,uBAAuB,KAAK,QAAQ;QACxC;QACA,8BAA8B;QAC9B,6CAA6C;QAC7C,4DAA4D;QAC5D,gCAAgC;QAChC,6CAA6C;QAC7C,IAAI,QAAQ,YAAY,EAAE;YACtB,aAAa,KAAK,IAAI,CAAC;QAC3B;QACA,KAAK,CAAC;QACN,wBAAwB;QACxB,KAAK,MAAM,SAAS,OAAO,MAAM,CAAE;YAC/B,MAAM,UAAU,KAAK,MAAM,OAAO,EAAE,sBAAsB,eAAe,MAAM,KAAK,GAAG,CAAC,UAAU,QAAQ,MAAM,MAAM,KAAK,EAAE,CAAC,cAAc,MAAM,GAAG,GAAG,eACxJ,uCAAuC;YACvC,wBAAwB;YACxB,OAAO,aAAa,GAAG,OAAO,KAAK,GAAG,CAAC,OAAO,UAAU,OAAO,KAAK,GAAG,CAAC,OAAO,WAAW;YAC1F,IAAI,OAAO,MAAM,KAAK,GAAG,cAAc,YAAY,aAAa,WAAW,cAAc,WAAW,IAAI,IAAI,IAAI,IAAI,IAAI;YACxH,oCAAoC;YACpC,IAAI,QAAQ,gBAAgB,EAAE;gBAC1B,OAAO,OAAO,uBAAuB,CAAC,MAAM,YAAY,OAAO;YACnE;YACA,MAAM,IAAI,GAAG;YACb,MAAM,UAAU,GAAG;YACnB,gDAAgD;YAChD,uBAAuB;YACvB,MAAM,UAAU,GAAG,MAAM,QAAQ,GAC7B;gBACI,MAAM,GAAG,GAAG,MAAM,GAAG,GAAG,MAAM,QAAQ,GAAG;gBACzC,OAAO,KAAK,CAAC,GAAG,GAAG,OAAO;gBAC1B;aACH,GACD;gBACI,OAAO;gBACP,QAAQ,MAAM,GAAG,GAAG,MAAM,OAAO;gBACjC;aACH;YACL,aACI,YAAY,CAAC,MAAM,KAAK,IAAI,MAAM,CAAC;YACvC,2CAA2C;YAC3C,IAAI,QAAQ,QAAQ,KAAK,WAAW;gBAChC,aACI,YAAY,CAAC,MAAM,CAAC,GAAG,CAAC,IACpB,CAAC,MACD;YACZ;YACA,uDAAuD;YACvD,MAAM,YAAY,MAAM,QAAQ,CAAE,YAAa;YAC/C,wCAAwC;YACxC,cACI,MAAM,UAAU,GAAG,YACf,CAAC,MAAM,UAAU,GAAG,mBAAmB;YAC/C,kEAAkE;YAClE,6DAA6D;YAC7D,YAAY,cACR,AAAC,OAAO,CAAC,OAAO,SAAS,IAAK,cAAc;YAChD,2CAA2C;YAC3C,eAAe,cACX,AAAC,OAAO,CAAC,OAAO,OAAO,SAAS,IAAK,cACrC;YACJ;;;;;;;YAOA,GACA,KAAK,OAAO,YAAY;YACxB,KAAK,OAAO,YAAY;YACxB,KAAK,OAAO,eAAe;YAC3B,KAAK,OAAO,eAAe;YAC3B,KAAK,OAAO;YACZ,KAAK,OAAO;YACZ,IAAI,MAAM,CAAC,GAAG,GAAG;gBACb,KAAK;gBACL,KAAK,OAAO,OAAO;YACvB;YACA,iBAAiB;YACjB,IAAI,MAAM,QAAQ,EAAE;gBAChB,YAAY,MAAM,KAAK,GAAG;gBAC1B,cACI,YAAY,CAAC,MAAM,KAAK,GAAG,mBAAmB;gBAClD,oBAAoB;gBACpB,YAAY,AAAC,OACT,CAAC,YAAY,SAAS,IAAK;gBAC/B,eAAe,AAAC,OACZ,CAAC,YAAY,CAAC,YAAY,IAAI,CAAC,IAAK;gBACxC,KAAK,OAAO,OAAO,WAAW,aAAa;gBAC3C,KAAK,KAAK,IAAI,WAAW,UAAU;gBACnC,KAAK,OAAO,eAAe,MAAM,aAAa;gBAC9C,KAAK,OAAO,eAAe,MAAM,gBAAgB;gBACjD,KAAK;gBACL,KAAK,OAAO,OAAO;gBACnB,IAAI,MAAM,CAAC,GAAG,GAAG;oBACb,KAAK,OAAO,OAAO;gBACvB;YACJ;YACA,6DAA6D;YAC7D,MAAM,SAAS,GAAG;YAClB,MAAM,SAAS,GAAG;gBACd,GAAG;gBACH,GAAG;gBACH,OAAO,KAAK;gBACZ,QAAQ;gBACR,kBAAkB;gBAClB,GAAG;oBACC;wBAAC;wBAAK;wBAAI;qBAAG;oBACb;wBAAC;wBAAK;wBAAI;qBAAG;oBACb;wBAAC;wBAAK;wBAAI;qBAAG;oBACb;wBAAC;wBAAK;wBAAI;qBAAG;oBACb;wBAAC;qBAAI;iBACR;YACL;QACJ;IACJ;AACJ;AACA;;;;GAIG,GACH,oBAAoB,cAAc,GAAG,MAAM,aAAa,cAAc,EAAE,mNAA2B;AACnG,6LAAc,CAAC,kBAAkB,CAAC,iBAAiB;uCAMpC","ignoreList":[0]}},
    {"offset": {"line": 4971, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/ErrorBar/ErrorBarSeriesDefaults.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\n/* *\n *\n *  API Options\n *\n * */\n/**\n * Error bars are a graphical representation of the variability of data and\n * are used on graphs to indicate the error, or uncertainty in a reported\n * measurement.\n *\n * @sample highcharts/demo/error-bar/\n *         Error bars on a column series\n * @sample highcharts/series-errorbar/on-scatter/\n *         Error bars on a scatter series\n * @sample highcharts/series-errorbar/datalabels/\n *         Error bars with data labels\n *\n * @extends      plotOptions.boxplot\n * @excluding    boostBlending, boostThreshold\n * @product      highcharts\n * @requires     highcharts-more\n * @optionparent plotOptions.errorbar\n */\nconst ErrorBarSeriesDefaults = {\n    /**\n     * The main color of the bars. This can be overridden by\n     * [stemColor](#plotOptions.errorbar.stemColor) and\n     * [whiskerColor](#plotOptions.errorbar.whiskerColor) individually.\n     *\n     * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n     *         Error bar styling\n     *\n     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @default #000000\n     * @since   3.0\n     * @product highcharts\n     */\n    color: \"#000000\" /* Palette.neutralColor100 */,\n    grouping: false,\n    /**\n     * The parent series of the error bar. The default value links it to\n     * the previous series. Otherwise, use the id of the parent series.\n     *\n     * @since   3.0\n     * @product highcharts\n     */\n    linkedTo: ':previous',\n    tooltip: {\n        pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n    },\n    /**\n     * The line width of the whiskers, the horizontal lines marking\n     * low and high values. When `null`, the general\n     * [lineWidth](#plotOptions.errorbar.lineWidth) applies.\n     *\n     * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n     *         Error bar styling\n     *\n     * @type    {number}\n     * @since   3.0\n     * @product highcharts\n     */\n    whiskerWidth: null\n};\n/**\n * A `errorbar` series. If the [type](#series.errorbar.type) option\n * is not specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.errorbar\n * @excluding dataParser, dataURL, stack, stacking, boostThreshold,\n *            boostBlending\n * @product   highcharts\n * @requires  highcharts-more\n * @apioption series.errorbar\n */\n/**\n * An array of data points for the series. For the `errorbar` series\n * type, points can be given in the following ways:\n *\n * 1. An array of arrays with 3 or 2 values. In this case, the values correspond\n *    to `x,low,high`. If the first value is a string, it is applied as the name\n *    of the point, and the `x` value is inferred. The `x` value can also be\n *    omitted, in which case the inner arrays should be of length 2\\. Then the\n *    `x` value is automatically calculated, either starting at 0 and\n *    incremented by 1, or from `pointStart` and `pointInterval` given in the\n *    series options.\n *    ```js\n *    data: [\n *        [0, 10, 2],\n *        [1, 1, 8],\n *        [2, 4, 5]\n *    ]\n *    ```\n *\n * 2. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.errorbar.turboThreshold), this option is not\n *    available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        low: 0,\n *        high: 0,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        low: 5,\n *        high: 5,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n * @extends   series.arearange.data\n * @excluding dataLabels, drilldown, marker, states\n * @product   highcharts\n * @apioption series.errorbar.data\n */\n''; // Adds doclets above to transpiled file\n/* *\n *\n *  Default Export\n *\n * */\nexport default ErrorBarSeriesDefaults;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;GASG,GACH;AACA;;;;GAIG,GACH;;;;;;;;;;;;;;;;;CAiBC,GACD,MAAM,yBAAyB;IAC3B;;;;;;;;;;;;KAYC,GACD,OAAO,UAAU,2BAA2B;IAC5C,UAAU;IACV;;;;;;KAMC,GACD,UAAU;IACV,SAAS;QACL,aAAa;IACjB;IACA;;;;;;;;;;;KAWC,GACD,cAAc;AAClB;AACA;;;;;;;;;;CAUC,GACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsDC,GACD,IAAI,wCAAwC;uCAM7B","ignoreList":[0]}},
    {"offset": {"line": 5114, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/ErrorBar/ErrorBarSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport BoxPlotSeries from '../BoxPlot/BoxPlotSeries.js';\nimport ColumnSeries from '../Column/ColumnSeries.js';\nimport ErrorBarSeriesDefaults from './ErrorBarSeriesDefaults.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { arearange: AreaRangeSeries } = SeriesRegistry.seriesTypes;\nimport U from '../../Core/Utilities.js';\nconst { addEvent, merge, extend } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * Errorbar series type\n *\n * @private\n * @class\n * @name Highcharts.seriesTypes.errorbar\n *\n * @augments Highcharts.Series\n */\nclass ErrorBarSeries extends BoxPlotSeries {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    getColumnMetrics() {\n        const series = this;\n        // Get the width and X offset, either on top of the linked series\n        // column or standalone\n        return ((series.linkedParent && series.linkedParent.columnMetrics) ||\n            ColumnSeries.prototype.getColumnMetrics.call(series));\n    }\n    drawDataLabels() {\n        const series = this, valKey = series.pointValKey;\n        if (AreaRangeSeries) {\n            AreaRangeSeries.prototype.drawDataLabels.call(series);\n            // Arearange drawDataLabels does not reset point.y to high,\n            // but to low after drawing (#4133)\n            for (const point of series.points) {\n                point.y = point[valKey];\n            }\n        }\n    }\n    toYData(point) {\n        // Return a plain array for speedy calculation\n        return [point.low, point.high];\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nErrorBarSeries.defaultOptions = merge(BoxPlotSeries.defaultOptions, ErrorBarSeriesDefaults);\naddEvent(ErrorBarSeries, 'afterTranslate', function () {\n    for (const point of this.points) {\n        point.plotLow = point.plotY;\n    }\n}, { order: 0 });\nextend(ErrorBarSeries.prototype, {\n    pointArrayMap: ['low', 'high'], // Array point configs are mapped to this\n    pointValKey: 'high', // Defines the top of the tracker\n    doQuartiles: false\n});\nSeriesRegistry.registerSeriesType('errorbar', ErrorBarSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default ErrorBarSeries;\n"],"names":[],"mappings":";;;;AAWA;AACA;AACA;AACA;AAEA;AAhBA;;;;;;;;;GASG,GACH;;;;;AAKA,MAAM,EAAE,WAAW,eAAe,EAAE,GAAG,6LAAc,CAAC,WAAW;;AAEjE,MAAM,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,8KAAC;AACrC;;;;GAIG,GACH;;;;;;;;CAQC,GACD,MAAM,uBAAuB,+LAAa;IACtC;;;;OAIG,GACH,mBAAmB;QACf,MAAM,SAAS,IAAI;QACnB,iEAAiE;QACjE,uBAAuB;QACvB,OAAQ,AAAC,OAAO,YAAY,IAAI,OAAO,YAAY,CAAC,aAAa,IAC7D,6LAAY,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC;IACrD;IACA,iBAAiB;QACb,MAAM,SAAS,IAAI,EAAE,SAAS,OAAO,WAAW;QAChD,IAAI,iBAAiB;YACjB,gBAAgB,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC;YAC9C,2DAA2D;YAC3D,mCAAmC;YACnC,KAAK,MAAM,SAAS,OAAO,MAAM,CAAE;gBAC/B,MAAM,CAAC,GAAG,KAAK,CAAC,OAAO;YAC3B;QACJ;IACJ;IACA,QAAQ,KAAK,EAAE;QACX,8CAA8C;QAC9C,OAAO;YAAC,MAAM,GAAG;YAAE,MAAM,IAAI;SAAC;IAClC;AACJ;AACA;;;;GAIG,GACH,eAAe,cAAc,GAAG,MAAM,+LAAa,CAAC,cAAc,EAAE,yMAAsB;AAC1F,SAAS,gBAAgB,kBAAkB;IACvC,KAAK,MAAM,SAAS,IAAI,CAAC,MAAM,CAAE;QAC7B,MAAM,OAAO,GAAG,MAAM,KAAK;IAC/B;AACJ,GAAG;IAAE,OAAO;AAAE;AACd,OAAO,eAAe,SAAS,EAAE;IAC7B,eAAe;QAAC;QAAO;KAAO;IAC9B,aAAa;IACb,aAAa;AACjB;AACA,6LAAc,CAAC,kBAAkB,CAAC,YAAY;uCAM/B","ignoreList":[0]}},
    {"offset": {"line": 5208, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Gauge/GaugePoint.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { series: { prototype: { pointClass: Point } } } = SeriesRegistry;\n/* *\n *\n *  Class\n *\n * */\nclass GaugePoint extends Point {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * Don't do any hover colors or anything\n     * @private\n     */\n    setState(state) {\n        this.state = state;\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nexport default GaugePoint;\n"],"names":[],"mappings":";;;;AAWA;AAXA;;;;;;;;;GASG,GACH;;AAEA,MAAM,EAAE,QAAQ,EAAE,WAAW,EAAE,YAAY,KAAK,EAAE,EAAE,EAAE,GAAG,6LAAc;AACvE;;;;GAIG,GACH,MAAM,mBAAmB;IACrB;;;;OAIG,GACH,8BAA8B,GAC9B;;;KAGC,GACD,SAAS,KAAK,EAAE;QACZ,IAAI,CAAC,KAAK,GAAG;IACjB;AACJ;uCAMe","ignoreList":[0]}},
    {"offset": {"line": 5246, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Gauge/GaugeSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport GaugePoint from './GaugePoint.js';\nimport H from '../../Core/Globals.js';\nconst { noop } = H;\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { series: Series, seriesTypes: { column: ColumnSeries } } = SeriesRegistry;\nimport U from '../../Core/Utilities.js';\nconst { clamp, isNumber, extend, merge, pick, pInt, defined } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n *\n * The `gauge` series type\n *\n * @private\n * @class\n * @name Highcharts.seriesTypes.map\n *\n * @augments Highcharts.Series\n */\nclass GaugeSeries extends Series {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * Calculate paths etc\n     * @private\n     */\n    translate() {\n        const series = this, yAxis = series.yAxis, options = series.options, center = yAxis.center;\n        series.generatePoints();\n        series.points.forEach((point) => {\n            const dialOptions = merge(options.dial, point.dial), radius = (pInt(dialOptions.radius) * center[2]) / 200, baseLength = (pInt(dialOptions.baseLength) * radius) / 100, rearLength = (pInt(dialOptions.rearLength) * radius) / 100, baseWidth = dialOptions.baseWidth, topWidth = dialOptions.topWidth;\n            let overshoot = options.overshoot, rotation = yAxis.startAngleRad + yAxis.translate(point.y, void 0, void 0, void 0, true);\n            // Handle the wrap and overshoot options\n            if (isNumber(overshoot) || options.wrap === false) {\n                overshoot = isNumber(overshoot) ?\n                    (overshoot / 180 * Math.PI) : 0;\n                rotation = clamp(rotation, yAxis.startAngleRad - overshoot, yAxis.endAngleRad + overshoot);\n            }\n            rotation = rotation * 180 / Math.PI;\n            point.shapeType = 'path';\n            const d = dialOptions.path || [\n                ['M', -rearLength, -baseWidth / 2],\n                ['L', baseLength, -baseWidth / 2],\n                ['L', radius, -topWidth / 2],\n                ['L', radius, topWidth / 2],\n                ['L', baseLength, baseWidth / 2],\n                ['L', -rearLength, baseWidth / 2],\n                ['Z']\n            ];\n            point.shapeArgs = {\n                d,\n                translateX: center[0],\n                translateY: center[1],\n                rotation: rotation\n            };\n            // Positions for data label\n            point.plotX = center[0];\n            point.plotY = center[1];\n            if (defined(point.y) && yAxis.max - yAxis.min) {\n                point.percentage =\n                    (point.y - yAxis.min) / (yAxis.max - yAxis.min) * 100;\n            }\n        });\n    }\n    /**\n     * Draw the points where each point is one needle\n     * @private\n     */\n    drawPoints() {\n        const series = this, chart = series.chart, center = series.yAxis.center, pivot = series.pivot, options = series.options, pivotOptions = options.pivot, renderer = chart.renderer;\n        series.points.forEach((point) => {\n            const graphic = point.graphic, shapeArgs = point.shapeArgs, d = shapeArgs.d, dialOptions = merge(options.dial, point.dial); // #1233\n            if (graphic) {\n                graphic.animate(shapeArgs);\n                shapeArgs.d = d; // Animate alters it\n            }\n            else {\n                point.graphic =\n                    renderer[point.shapeType](shapeArgs)\n                        .addClass('highcharts-dial')\n                        .add(series.group);\n            }\n            // Presentational attributes\n            if (!chart.styledMode) {\n                point.graphic[graphic ? 'animate' : 'attr']({\n                    stroke: dialOptions.borderColor,\n                    'stroke-width': dialOptions.borderWidth,\n                    fill: dialOptions.backgroundColor\n                });\n            }\n        });\n        // Add or move the pivot\n        if (pivot) {\n            pivot.animate({\n                translateX: center[0],\n                translateY: center[1]\n            });\n        }\n        else if (pivotOptions) {\n            series.pivot =\n                renderer.circle(0, 0, pivotOptions.radius)\n                    .attr({\n                    zIndex: 2\n                })\n                    .addClass('highcharts-pivot')\n                    .translate(center[0], center[1])\n                    .add(series.group);\n            // Presentational attributes\n            if (!chart.styledMode) {\n                series.pivot.attr({\n                    fill: pivotOptions.backgroundColor,\n                    stroke: pivotOptions.borderColor,\n                    'stroke-width': pivotOptions.borderWidth\n                });\n            }\n        }\n    }\n    /**\n     * Animate the arrow up from startAngle\n     * @private\n     */\n    animate(init) {\n        const series = this;\n        if (!init) {\n            series.points.forEach((point) => {\n                const graphic = point.graphic;\n                if (graphic) {\n                    // Start value\n                    graphic.attr({\n                        rotation: series.yAxis.startAngleRad * 180 / Math.PI\n                    });\n                    // Animate\n                    graphic.animate({\n                        rotation: point.shapeArgs.rotation\n                    }, series.options.animation);\n                }\n            });\n        }\n    }\n    /**\n     * @private\n     */\n    render() {\n        this.group = this.plotGroup('group', 'series', this.visible ? 'inherit' : 'hidden', this.options.zIndex, this.chart.seriesGroup);\n        Series.prototype.render.call(this);\n        this.group.clip(this.chart.clipRect);\n    }\n    /**\n     * Extend the basic setData method by running processData and generatePoints\n     * immediately, in order to access the points from the legend.\n     * @private\n     */\n    setData(data, redraw) {\n        Series.prototype.setData.call(this, data, false);\n        this.processData();\n        this.generatePoints();\n        if (pick(redraw, true)) {\n            this.chart.redraw();\n        }\n    }\n    /**\n     * Define hasData function for non-cartesian series.\n     * Returns true if the series has points at all.\n     * @private\n     */\n    hasData() {\n        return !!this.points.length; // != 0\n    }\n}\n/* *\n *\n *  Static properties\n *\n * */\n/**\n * Gauges are circular plots displaying one or more values with a dial\n * pointing to values along the perimeter.\n *\n * @sample highcharts/demo/gauge-speedometer/\n *         Gauge chart\n *\n * @extends      plotOptions.line\n * @excluding    animationLimit, boostThreshold, colorAxis, colorKey,\n *               connectEnds, connectNulls, cropThreshold, dashStyle,\n *               dragDrop, findNearestPointBy, getExtremesFromAll, marker,\n *               negativeColor, pointPlacement, shadow, softThreshold,\n *               stacking, states, step, threshold, turboThreshold, xAxis,\n *               zoneAxis, zones, dataSorting, boostBlending\n * @product      highcharts\n * @requires     highcharts-more\n * @optionparent plotOptions.gauge\n */\nGaugeSeries.defaultOptions = merge(Series.defaultOptions, {\n    /**\n     * When this option is `true`, the dial will wrap around the axes.\n     * For instance, in a full-range gauge going from 0 to 360, a value\n     * of 400 will point to 40\\. When `wrap` is `false`, the dial stops\n     * at 360.\n     *\n     * @see [overshoot](#plotOptions.gauge.overshoot)\n     *\n     * @type      {boolean}\n     * @default   true\n     * @since     3.0\n     * @product   highcharts\n     * @apioption plotOptions.gauge.wrap\n     */\n    /**\n     * Data labels for the gauge. For gauges, the data labels are\n     * enabled by default and shown in a bordered box below the point.\n     *\n     * @since   2.3.0\n     * @product highcharts\n     */\n    dataLabels: {\n        borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n        borderRadius: 3,\n        borderWidth: 1,\n        crop: false,\n        defer: false,\n        enabled: true,\n        verticalAlign: 'top',\n        y: 15,\n        zIndex: 2\n    },\n    /**\n     * Options for the dial or arrow pointer of the gauge.\n     *\n     * In styled mode, the dial is styled with the\n     * `.highcharts-gauge-series .highcharts-dial` rule.\n     *\n     * @sample {highcharts} highcharts/css/gauge/\n     *         Styled mode\n     *\n     * @type    {*}\n     * @since   2.3.0\n     * @product highcharts\n     */\n    dial: {\n        /**\n         * The background or fill color of the gauge's dial.\n         *\n         * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n         *         Dial options demonstrated\n         *\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @default   #000000\n         * @since     2.3.0\n         * @product   highcharts\n         * @apioption plotOptions.gauge.dial.backgroundColor\n         */\n        backgroundColor: \"#000000\" /* Palette.neutralColor100 */,\n        /**\n         * The length of the dial's base part, relative to the total\n         * radius or length of the dial.\n         *\n         * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n         *         Dial options demonstrated\n         *\n         * @type      {string}\n         * @default   70%\n         * @since     2.3.0\n         * @product   highcharts\n         * @apioption plotOptions.gauge.dial.baseLength\n         */\n        baseLength: '70%',\n        /**\n         * The pixel width of the base of the gauge dial. The base is\n         * the part closest to the pivot, defined by baseLength.\n         *\n         * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n         *         Dial options demonstrated\n         *\n         * @type      {number}\n         * @default   3\n         * @since     2.3.0\n         * @product   highcharts\n         * @apioption plotOptions.gauge.dial.baseWidth\n         */\n        baseWidth: 3,\n        /**\n         * The border color or stroke of the gauge's dial. By default,\n         * the borderWidth is 0, so this must be set in addition to a\n         * custom border color.\n         *\n         * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n         *         Dial options demonstrated\n         *\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @default   #cccccc\n         * @since     2.3.0\n         * @product   highcharts\n         * @apioption plotOptions.gauge.dial.borderColor\n         */\n        borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n        /**\n         * The width of the gauge dial border in pixels.\n         *\n         * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n         *         Dial options demonstrated\n         *\n         * @type      {number}\n         * @default   0\n         * @since     2.3.0\n         * @product   highcharts\n         * @apioption plotOptions.gauge.dial.borderWidth\n         */\n        borderWidth: 0,\n        /**\n         * An array with an SVG path for the custom dial.\n         *\n         * @sample {highcharts} highcharts/plotoptions/gauge-path/\n         *         Dial options demonstrated\n         *\n         * @type      {Highcharts.SVGPathArray}\n         * @since 10.2.0\n         * @product   highcharts\n         * @apioption plotOptions.gauge.dial.path\n         */\n        /**\n         * The radius or length of the dial, in percentages relative to\n         * the radius of the gauge itself.\n         *\n         * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n         *         Dial options demonstrated\n         *\n         * @type      {string}\n         * @default   80%\n         * @since     2.3.0\n         * @product   highcharts\n         * @apioption plotOptions.gauge.dial.radius\n         */\n        radius: '80%',\n        /**\n         * The length of the dial's rear end, the part that extends out\n         * on the other side of the pivot. Relative to the dial's\n         * length.\n         *\n         * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n         *         Dial options demonstrated\n         *\n         * @type      {string}\n         * @default   10%\n         * @since     2.3.0\n         * @product   highcharts\n         * @apioption plotOptions.gauge.dial.rearLength\n         */\n        rearLength: '10%',\n        /**\n         * The width of the top of the dial, closest to the perimeter.\n         * The pivot narrows in from the base to the top.\n         *\n         * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n         *         Dial options demonstrated\n         *\n         * @type      {number}\n         * @default   1\n         * @since     2.3.0\n         * @product   highcharts\n         * @apioption plotOptions.gauge.dial.topWidth\n         */\n        topWidth: 1\n    },\n    /**\n     * Allow the dial to overshoot the end of the perimeter axis by\n     * this many degrees. Say if the gauge axis goes from 0 to 60, a\n     * value of 100, or 1000, will show 5 degrees beyond the end of the\n     * axis when this option is set to 5.\n     *\n     * @see [wrap](#plotOptions.gauge.wrap)\n     *\n     * @sample {highcharts} highcharts/plotoptions/gauge-overshoot/\n     *         Allow 5 degrees overshoot\n     *\n     * @type      {number}\n     * @since     3.0.10\n     * @product   highcharts\n     * @apioption plotOptions.gauge.overshoot\n     */\n    /**\n     * Options for the pivot or the center point of the gauge.\n     *\n     * In styled mode, the pivot is styled with the\n     * `.highcharts-gauge-series .highcharts-pivot` rule.\n     *\n     * @sample {highcharts} highcharts/css/gauge/\n     *         Styled mode\n     *\n     * @type    {*}\n     * @since   2.3.0\n     * @product highcharts\n     */\n    pivot: {\n        /**\n         * The pixel radius of the pivot.\n         *\n         * @sample {highcharts} highcharts/plotoptions/gauge-pivot/\n         *         Pivot options demonstrated\n         *\n         * @type      {number}\n         * @default   5\n         * @since     2.3.0\n         * @product   highcharts\n         * @apioption plotOptions.gauge.pivot.radius\n         */\n        radius: 5,\n        /**\n         * The border or stroke width of the pivot.\n         *\n         * @sample {highcharts} highcharts/plotoptions/gauge-pivot/\n         *         Pivot options demonstrated\n         *\n         * @type      {number}\n         * @default   0\n         * @since     2.3.0\n         * @product   highcharts\n         * @apioption plotOptions.gauge.pivot.borderWidth\n         */\n        borderWidth: 0,\n        /**\n         * The border or stroke color of the pivot. In able to change\n         * this, the borderWidth must also be set to something other\n         * than the default 0.\n         *\n         * @sample {highcharts} highcharts/plotoptions/gauge-pivot/\n         *         Pivot options demonstrated\n         *\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @default   #cccccc\n         * @since     2.3.0\n         * @product   highcharts\n         * @apioption plotOptions.gauge.pivot.borderColor\n         */\n        borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n        /**\n         * The background color or fill of the pivot.\n         *\n         * @sample {highcharts} highcharts/plotoptions/gauge-pivot/\n         *         Pivot options demonstrated\n         *\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @default   #000000\n         * @since     2.3.0\n         * @product   highcharts\n         * @apioption plotOptions.gauge.pivot.backgroundColor\n         */\n        backgroundColor: \"#000000\" /* Palette.neutralColor100 */\n    },\n    tooltip: {\n        headerFormat: ''\n    },\n    /**\n     * Whether to display this particular series or series type in the\n     * legend. Defaults to false for gauge series.\n     *\n     * @since   2.3.0\n     * @product highcharts\n     */\n    showInLegend: false\n    // Prototype members\n});\nextend(GaugeSeries.prototype, {\n    // `chart.angular` will be set to true when a gauge series is present, and\n    // this will be used on the axes\n    angular: true,\n    directTouch: true, // #5063\n    drawGraph: noop,\n    drawTracker: ColumnSeries.prototype.drawTracker,\n    fixedBox: true,\n    forceDL: true,\n    noSharedTooltip: true,\n    pointClass: GaugePoint,\n    trackerGroups: ['group', 'dataLabelsGroup']\n});\nSeriesRegistry.registerSeriesType('gauge', GaugeSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default GaugeSeries;\n/* *\n *\n *  API options\n *\n * */\n/**\n * A `gauge` series. If the [type](#series.gauge.type) option is not\n * specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.gauge\n * @excluding animationLimit, boostThreshold, connectEnds, connectNulls,\n *            cropThreshold, dashStyle, dataParser, dataURL, findNearestPointBy,\n *            getExtremesFromAll, marker, negativeColor, pointPlacement, shadow,\n *            softThreshold, stack, stacking, states, step, threshold,\n *            turboThreshold, zoneAxis, zones, dataSorting, boostBlending\n * @product   highcharts\n * @requires  highcharts-more\n * @apioption series.gauge\n */\n/**\n * An array of data points for the series. For the `gauge` series type,\n * points can be given in the following ways:\n *\n * 1. An array of numerical values. In this case, the numerical values will be\n *    interpreted as `y` options. Example:\n *    ```js\n *    data: [0, 5, 3, 5]\n *    ```\n *\n * 2. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.gauge.turboThreshold), this option is not\n *    available.\n *    ```js\n *    data: [{\n *        y: 6,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        y: 8,\n *        name: \"Point1\",\n *       color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * The typical gauge only contains a single data value.\n *\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<number|null|*>}\n * @extends   series.line.data\n * @excluding drilldown, marker, x\n * @product   highcharts\n * @apioption series.gauge.data\n */\n''; // Adds the doclets above in the transpiled file\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5793, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/DragNodesComposition.js"],"sourcesContent":["/* *\n *\n *  Networkgraph series\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Pawe Fus\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport H from '../Core/Globals.js';\nconst { composed } = H;\nimport U from '../Core/Utilities.js';\nconst { addEvent, pushUnique } = U;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * @private\n */\nfunction compose(ChartClass) {\n    if (pushUnique(composed, 'DragNodes')) {\n        addEvent(ChartClass, 'load', onChartLoad);\n    }\n}\n/**\n * Draggable mode:\n * @private\n */\nfunction onChartLoad() {\n    const chart = this;\n    let mousedownUnbinder, mousemoveUnbinder, mouseupUnbinder, point;\n    if (chart.container) {\n        mousedownUnbinder = addEvent(chart.container, 'mousedown', (event) => {\n            if (mousemoveUnbinder) {\n                mousemoveUnbinder();\n            }\n            if (mouseupUnbinder) {\n                mouseupUnbinder();\n            }\n            point = chart.hoverPoint;\n            if (point &&\n                point.series &&\n                point.series.hasDraggableNodes &&\n                point.series.options.draggable) {\n                point.series.onMouseDown(point, event);\n                mousemoveUnbinder = addEvent(chart.container, 'mousemove', (e) => (point &&\n                    point.series &&\n                    point.series.onMouseMove(point, e)));\n                mouseupUnbinder = addEvent(chart.container.ownerDocument, 'mouseup', (e) => {\n                    mousemoveUnbinder();\n                    mouseupUnbinder();\n                    return point &&\n                        point.series &&\n                        point.series.onMouseUp(point, e);\n                });\n            }\n        });\n    }\n    addEvent(chart, 'destroy', function () {\n        mousedownUnbinder();\n    });\n}\n/**\n * Mouse down action, initializing drag&drop mode.\n *\n * @private\n * @param {Highcharts.Point} point\n *        The point that event occurred.\n * @param {Highcharts.PointerEventObject} event\n *        Browser event, before normalization.\n */\nfunction onMouseDown(point, event) {\n    const { panKey } = this.chart.options.chart, panKeyPressed = panKey && event[`${panKey}Key`];\n    if (panKeyPressed) {\n        return;\n    }\n    const normalizedEvent = this.chart.pointer?.normalize(event) || event;\n    point.fixedPosition = {\n        chartX: normalizedEvent.chartX,\n        chartY: normalizedEvent.chartY,\n        plotX: point.plotX,\n        plotY: point.plotY\n    };\n    point.inDragMode = true;\n}\n/**\n * Mouse move action during drag&drop.\n *\n * @private\n *\n * @param {Highcharts.Point} point\n *        The point that event occurred.\n * @param {global.Event} event\n *        Browser event, before normalization.\n */\nfunction onMouseMove(point, event) {\n    if (point.fixedPosition && point.inDragMode) {\n        const series = this, chart = series.chart, normalizedEvent = chart.pointer?.normalize(event) || event, diffX = point.fixedPosition.chartX - normalizedEvent.chartX, diffY = point.fixedPosition.chartY - normalizedEvent.chartY, graphLayoutsLookup = chart.graphLayoutsLookup;\n        let newPlotX, newPlotY;\n        // At least 5px to apply change (avoids simple click):\n        if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {\n            newPlotX = point.fixedPosition.plotX - diffX;\n            newPlotY = point.fixedPosition.plotY - diffY;\n            if (chart.isInsidePlot(newPlotX, newPlotY)) {\n                point.plotX = newPlotX;\n                point.plotY = newPlotY;\n                point.hasDragged = true;\n                this.redrawHalo(point);\n                graphLayoutsLookup.forEach((layout) => {\n                    layout.restartSimulation();\n                });\n            }\n        }\n    }\n}\n/**\n * Mouse up action, finalizing drag&drop.\n *\n * @private\n * @param {Highcharts.Point} point\n *        The point that event occurred.\n */\nfunction onMouseUp(point) {\n    if (point.fixedPosition) {\n        if (point.hasDragged) {\n            if (this.layout.enableSimulation) {\n                this.layout.start();\n            }\n            else {\n                this.chart.redraw();\n            }\n        }\n        point.inDragMode = point.hasDragged = false;\n        if (!this.options.fixedDraggable) {\n            delete point.fixedPosition;\n        }\n    }\n}\n/**\n * Redraw halo on mousemove during the drag&drop action.\n *\n * @private\n * @param {Highcharts.Point} point\n *        The point that should show halo.\n */\nfunction redrawHalo(point) {\n    if (point && this.halo) {\n        this.halo.attr({\n            d: point.haloPath(this.options.states.hover.halo.size)\n        });\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst DragNodesComposition = {\n    compose,\n    onMouseDown,\n    onMouseMove,\n    onMouseUp,\n    redrawHalo\n};\nexport default DragNodesComposition;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5957, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/GraphLayoutComposition.js"],"sourcesContent":["/* *\n *\n *  Networkgraph series\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Pawe Fus\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport A from '../Core/Animation/AnimationUtilities.js';\nconst { setAnimation } = A;\nimport H from '../Core/Globals.js';\nconst { composed } = H;\nimport U from '../Core/Utilities.js';\nconst { addEvent, pushUnique } = U;\n/* *\n *\n *  Constants\n *\n * */\nconst integrations = {};\nconst layouts = {};\n/* *\n *\n *  Functions\n *\n * */\n/**\n * @private\n */\nfunction compose(ChartClass) {\n    if (pushUnique(composed, 'GraphLayout')) {\n        addEvent(ChartClass, 'afterPrint', onChartAfterPrint);\n        addEvent(ChartClass, 'beforePrint', onChartBeforePrint);\n        addEvent(ChartClass, 'predraw', onChartPredraw);\n        addEvent(ChartClass, 'render', onChartRender);\n    }\n}\n/**\n * Re-enable simulation after print.\n * @private\n */\nfunction onChartAfterPrint() {\n    if (this.graphLayoutsLookup) {\n        this.graphLayoutsLookup.forEach((layout) => {\n            // Return to default simulation\n            layout.updateSimulation();\n        });\n        this.redraw();\n    }\n}\n/**\n * Disable simulation before print if enabled.\n * @private\n */\nfunction onChartBeforePrint() {\n    if (this.graphLayoutsLookup) {\n        this.graphLayoutsLookup.forEach((layout) => {\n            layout.updateSimulation(false);\n        });\n        this.redraw();\n    }\n}\n/**\n * Clear previous layouts.\n * @private\n */\nfunction onChartPredraw() {\n    if (this.graphLayoutsLookup) {\n        this.graphLayoutsLookup.forEach((layout) => {\n            layout.stop();\n        });\n    }\n}\n/**\n * @private\n */\nfunction onChartRender() {\n    let systemsStable, afterRender = false;\n    const layoutStep = (layout) => {\n        if (layout.maxIterations-- &&\n            isFinite(layout.temperature) &&\n            !layout.isStable() &&\n            !layout.enableSimulation) {\n            // Hook similar to build-in addEvent, but instead of\n            // creating whole events logic, use just a function.\n            // It's faster which is important for rAF code.\n            // Used e.g. in packed-bubble series for bubble radius\n            // calculations\n            if (layout.beforeStep) {\n                layout.beforeStep();\n            }\n            layout.step();\n            systemsStable = false;\n            afterRender = true;\n        }\n    };\n    // Don't animate layout when series is dragged\n    if (this.graphLayoutsLookup && !this.pointer?.hasDragged) {\n        setAnimation(false, this);\n        // Start simulation\n        this.graphLayoutsLookup.forEach((layout) => layout.start());\n        // Just one sync step, to run different layouts similar to\n        // async mode.\n        while (!systemsStable) {\n            systemsStable = true;\n            this.graphLayoutsLookup.forEach(layoutStep);\n        }\n        if (afterRender) {\n            this.series.forEach((series) => {\n                if (series && series.layout) {\n                    series.render();\n                }\n            });\n        }\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst GraphLayoutComposition = {\n    compose,\n    integrations,\n    layouts\n};\nexport default GraphLayoutComposition;\n"],"names":[],"mappings":";;;;AAaA;AAEA;AAEA;AAjBA;;;;;;;;;;;GAWG,GACH;;AAEA,MAAM,EAAE,YAAY,EAAE,GAAG,oMAAC;;AAE1B,MAAM,EAAE,QAAQ,EAAE,GAAG,4KAAC;;AAEtB,MAAM,EAAE,QAAQ,EAAE,UAAU,EAAE,GAAG,8KAAC;AAClC;;;;GAIG,GACH,MAAM,eAAe,CAAC;AACtB,MAAM,UAAU,CAAC;AACjB;;;;GAIG,GACH;;CAEC,GACD,SAAS,QAAQ,UAAU;IACvB,IAAI,WAAW,UAAU,gBAAgB;QACrC,SAAS,YAAY,cAAc;QACnC,SAAS,YAAY,eAAe;QACpC,SAAS,YAAY,WAAW;QAChC,SAAS,YAAY,UAAU;IACnC;AACJ;AACA;;;CAGC,GACD,SAAS;IACL,IAAI,IAAI,CAAC,kBAAkB,EAAE;QACzB,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;YAC7B,+BAA+B;YAC/B,OAAO,gBAAgB;QAC3B;QACA,IAAI,CAAC,MAAM;IACf;AACJ;AACA;;;CAGC,GACD,SAAS;IACL,IAAI,IAAI,CAAC,kBAAkB,EAAE;QACzB,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;YAC7B,OAAO,gBAAgB,CAAC;QAC5B;QACA,IAAI,CAAC,MAAM;IACf;AACJ;AACA;;;CAGC,GACD,SAAS;IACL,IAAI,IAAI,CAAC,kBAAkB,EAAE;QACzB,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;YAC7B,OAAO,IAAI;QACf;IACJ;AACJ;AACA;;CAEC,GACD,SAAS;IACL,IAAI,eAAe,cAAc;IACjC,MAAM,aAAa,CAAC;QAChB,IAAI,OAAO,aAAa,MACpB,SAAS,OAAO,WAAW,KAC3B,CAAC,OAAO,QAAQ,MAChB,CAAC,OAAO,gBAAgB,EAAE;YAC1B,oDAAoD;YACpD,oDAAoD;YACpD,+CAA+C;YAC/C,sDAAsD;YACtD,eAAe;YACf,IAAI,OAAO,UAAU,EAAE;gBACnB,OAAO,UAAU;YACrB;YACA,OAAO,IAAI;YACX,gBAAgB;YAChB,cAAc;QAClB;IACJ;IACA,8CAA8C;IAC9C,IAAI,IAAI,CAAC,kBAAkB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,YAAY;QACtD,aAAa,OAAO,IAAI;QACxB,mBAAmB;QACnB,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,SAAW,OAAO,KAAK;QACxD,0DAA0D;QAC1D,cAAc;QACd,MAAO,CAAC,cAAe;YACnB,gBAAgB;YAChB,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC;QACpC;QACA,IAAI,aAAa;YACb,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;gBACjB,IAAI,UAAU,OAAO,MAAM,EAAE;oBACzB,OAAO,MAAM;gBACjB;YACJ;QACJ;IACJ;AACJ;AACA;;;;GAIG,GACH,MAAM,yBAAyB;IAC3B;IACA;IACA;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 6088, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubblePoint.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Grzegorz Blachlinski, Sebastian Bochan\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport Chart from '../../Core/Chart/Chart.js';\nimport Point from '../../Core/Series/Point.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { seriesTypes: { bubble: { prototype: { pointClass: BubblePoint } } } } = SeriesRegistry;\n/* *\n *\n *  Class\n *\n * */\nclass PackedBubblePoint extends BubblePoint {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * Destroy point.\n     * Then remove point from the layout.\n     * @private\n     */\n    destroy() {\n        if (this.series?.layout) {\n            this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);\n        }\n        return Point.prototype.destroy.apply(this, arguments);\n    }\n    firePointEvent() {\n        const series = this.series, seriesOptions = series.options;\n        if (this.isParentNode && seriesOptions.parentNode) {\n            const temp = seriesOptions.allowPointSelect;\n            seriesOptions.allowPointSelect = (seriesOptions.parentNode.allowPointSelect);\n            Point.prototype.firePointEvent.apply(this, arguments);\n            seriesOptions.allowPointSelect = temp;\n        }\n        else {\n            Point.prototype.firePointEvent.apply(this, arguments);\n        }\n    }\n    select() {\n        const point = this, series = this.series, chart = series.chart;\n        if (point.isParentNode) {\n            chart.getSelectedPoints = chart.getSelectedParentNodes;\n            Point.prototype.select.apply(this, arguments);\n            chart.getSelectedPoints = Chart.prototype.getSelectedPoints;\n        }\n        else {\n            Point.prototype.select.apply(this, arguments);\n        }\n    }\n    setState(state, move) {\n        if (this?.graphic?.parentGroup?.element) {\n            super.setState(state, move);\n        }\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nexport default PackedBubblePoint;\n"],"names":[],"mappings":";;;;AAWA;AACA;AACA;AAbA;;;;;;;;;GASG,GACH;;;;AAIA,MAAM,EAAE,aAAa,EAAE,QAAQ,EAAE,WAAW,EAAE,YAAY,WAAW,EAAE,EAAE,EAAE,EAAE,GAAG,6LAAc;AAC9F;;;;GAIG,GACH,MAAM,0BAA0B;IAC5B;;;;OAIG,GACH,8BAA8B,GAC9B;;;;KAIC,GACD,UAAU;QACN,IAAI,IAAI,CAAC,MAAM,EAAE,QAAQ;YACrB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,2BAA2B,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK;QACjF;QACA,OAAO,oLAAK,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE;IAC/C;IACA,iBAAiB;QACb,MAAM,SAAS,IAAI,CAAC,MAAM,EAAE,gBAAgB,OAAO,OAAO;QAC1D,IAAI,IAAI,CAAC,YAAY,IAAI,cAAc,UAAU,EAAE;YAC/C,MAAM,OAAO,cAAc,gBAAgB;YAC3C,cAAc,gBAAgB,GAAI,cAAc,UAAU,CAAC,gBAAgB;YAC3E,oLAAK,CAAC,SAAS,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,EAAE;YAC3C,cAAc,gBAAgB,GAAG;QACrC,OACK;YACD,oLAAK,CAAC,SAAS,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,EAAE;QAC/C;IACJ;IACA,SAAS;QACL,MAAM,QAAQ,IAAI,EAAE,SAAS,IAAI,CAAC,MAAM,EAAE,QAAQ,OAAO,KAAK;QAC9D,IAAI,MAAM,YAAY,EAAE;YACpB,MAAM,iBAAiB,GAAG,MAAM,sBAAsB;YACtD,oLAAK,CAAC,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE;YACnC,MAAM,iBAAiB,GAAG,mLAAK,CAAC,SAAS,CAAC,iBAAiB;QAC/D,OACK;YACD,oLAAK,CAAC,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE;QACvC;IACJ;IACA,SAAS,KAAK,EAAE,IAAI,EAAE;QAClB,IAAI,IAAI,EAAE,SAAS,aAAa,SAAS;YACrC,KAAK,CAAC,SAAS,OAAO;QAC1B;IACJ;AACJ;uCAMe","ignoreList":[0]}},
    {"offset": {"line": 6160, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubbleSeriesDefaults.js"],"sourcesContent":["/* *\n *\n *  Imports\n *\n * */\nimport U from '../../Core/Utilities.js';\nconst { isNumber } = U;\n/* *\n *\n *  Constants\n *\n * */\n/**\n * A packed bubble series is a two dimensional series type, where each point\n * renders a value in X, Y position. Each point is drawn as a bubble\n * where the bubbles don't overlap with each other and the radius\n * of the bubble relates to the value.\n *\n * @sample highcharts/demo/packed-bubble/\n *         Packed bubble chart\n * @sample highcharts/demo/packed-bubble-split/\n *         Split packed bubble chart\n *\n * @extends      plotOptions.bubble\n * @excluding    boostThreshold, boostBlending,connectEnds, connectNulls,\n *               cropThreshold, dataSorting, dragDrop, jitter,\n *               legendSymbolColor, keys, pointPlacement, sizeByAbsoluteValue,\n *               step, xAxis, yAxis, zMax, zMin\n * @product      highcharts\n * @since        7.0.0\n * @requires     highcharts-more\n * @optionparent plotOptions.packedbubble\n *\n * @private\n */\nconst PackedBubbleSeriesDefaults = {\n    /**\n     * Minimum bubble size. Bubbles will automatically size between the\n     * `minSize` and `maxSize` to reflect the value of each bubble.\n     * Can be either pixels (when no unit is given), or a percentage of\n     * the smallest one of the plot width and height, divided by the square\n     * root of total number of points.\n     *\n     * @sample highcharts/plotoptions/bubble-size/\n     *         Bubble size\n     *\n     * @type {number|string}\n     *\n     * @private\n     */\n    minSize: '10%',\n    /**\n     * Maximum bubble size. Bubbles will automatically size between the\n     * `minSize` and `maxSize` to reflect the value of each bubble.\n     * Can be either pixels (when no unit is given), or a percentage of\n     * the smallest one of the plot width and height, divided by the square\n     * root of total number of points.\n     *\n     * @sample highcharts/plotoptions/bubble-size/\n     *         Bubble size\n     *\n     * @type {number|string}\n     *\n     * @private\n     */\n    maxSize: '50%',\n    sizeBy: 'area',\n    zoneAxis: 'y',\n    crisp: false,\n    tooltip: {\n        pointFormat: 'Value: {point.value}'\n    },\n    /**\n     * Flag to determine if nodes are draggable or not. Available for\n     * graph with useSimulation set to true only.\n     *\n     * @since 7.1.0\n     *\n     * @private\n     */\n    draggable: true,\n    /**\n     * An option is giving a possibility to choose between using simulation\n     * for calculating bubble positions. These reflects in both animation\n     * and final position of bubbles. Simulation is also adding options to\n     * the series graph based on used layout. In case of big data sets, with\n     * any performance issues, it is possible to disable animation and pack\n     * bubble in a simple circular way.\n     *\n     * @sample highcharts/series-packedbubble/spiral/\n     *         useSimulation set to false\n     *\n     * @since 7.1.0\n     *\n     * @private\n     */\n    useSimulation: true,\n    /**\n     * Series options for parent nodes.\n     *\n     * @since 8.1.1\n     *\n     * @private\n     */\n    parentNode: {\n        /**\n         * Allow this series' parent nodes to be selected\n         * by clicking on the graph.\n         *\n         * @since 8.1.1\n         */\n        allowPointSelect: false\n    },\n    /**\n     *\n     * @declare Highcharts.SeriesPackedBubbleDataLabelsOptionsObject\n     *\n     * @private\n     */\n    dataLabels: {\n        /**\n         * The\n         * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)\n         * specifying what to show for _node_ in the networkgraph. In v7.0\n         * defaults to `{key}`, since v7.1 defaults to `undefined` and\n         * `formatter` is used instead.\n         *\n         * @type      {string}\n         * @since     7.0.0\n         * @apioption plotOptions.packedbubble.dataLabels.format\n         */\n        // eslint-disable-next-line valid-jsdoc\n        /**\n         * Callback JavaScript function to format the data label for a node.\n         * Note that if a `format` is defined, the format takes precedence\n         * and the formatter is ignored.\n         *\n         * @since 7.0.0\n         */\n        formatter: function () {\n            const { numberFormatter } = this.series.chart;\n            const { value } = this.point;\n            return isNumber(value) ? numberFormatter(value, -1) : '';\n        },\n        /**\n         * @type      {string}\n         * @since     7.1.0\n         * @apioption plotOptions.packedbubble.dataLabels.parentNodeFormat\n         */\n        // eslint-disable-next-line valid-jsdoc\n        /**\n         * @since 7.1.0\n         */\n        parentNodeFormatter: function () {\n            return this.name || '';\n        },\n        /**\n         * @sample {highcharts} highcharts/demo/packed-bubble-project-status/\n         *         Dashboard with dataLabels on parentNodes\n         *\n         * @declare Highcharts.SeriesPackedBubbleDataLabelsTextPathOptionsObject\n         * @since   7.1.0\n         */\n        parentNodeTextPath: {\n            /**\n             * Presentation attributes for the text path.\n             *\n             * @type      {Highcharts.SVGAttributes}\n             * @since     7.1.0\n             * @apioption plotOptions.packedbubble.dataLabels.attributes\n             */\n            /**\n             * Enable or disable `textPath` option for link's or marker's\n             * data labels.\n             *\n             * @since 7.1.0\n             */\n            enabled: true\n        },\n        /**\n         * Options for a _node_ label text which should follow marker's\n         * shape.\n         *\n         * **Note:** Only SVG-based renderer supports this option.\n         *\n         * @extends   plotOptions.series.dataLabels.textPath\n         * @apioption plotOptions.packedbubble.dataLabels.textPath\n         */\n        padding: 0,\n        style: {\n            transition: 'opacity 2000ms'\n        }\n    },\n    /**\n     * Options for layout algorithm when simulation is enabled. Inside there\n     * are options to change the speed, padding, initial bubbles positions\n     * and more.\n     *\n     * @extends   plotOptions.networkgraph.layoutAlgorithm\n     * @excluding approximation, attractiveForce, repulsiveForce, theta\n     * @since     7.1.0\n     *\n     * @private\n     */\n    layoutAlgorithm: {\n        /**\n         * Initial layout algorithm for positioning nodes. Can be one of\n         * the built-in options (\"circle\", \"random\") or a function where\n         * positions should be set on each node (`this.nodes`) as\n         * `node.plotX` and `node.plotY`.\n         *\n         * @sample highcharts/series-networkgraph/initial-positions/\n         *         Initial positions with callback\n         *\n         * @type {\"circle\"|\"random\"|Function}\n         */\n        initialPositions: 'circle',\n        /**\n         * @sample highcharts/series-packedbubble/initial-radius/\n         *         Initial radius set to 200\n         *\n         * @extends   plotOptions.networkgraph.layoutAlgorithm.initialPositionRadius\n         * @excluding states\n         */\n        initialPositionRadius: 20,\n        /**\n         * The distance between two bubbles, when the algorithm starts to\n         * treat two bubbles as overlapping. The `bubblePadding` is also the\n         * expected distance between all the bubbles on simulation end.\n         */\n        bubblePadding: 5,\n        /**\n         * Whether bubbles should interact with their parentNode to keep\n         * them inside.\n         */\n        parentNodeLimit: false,\n        /**\n         * Whether series should interact with each other or not. When\n         * `parentNodeLimit` is set to true, thi option should be set to\n         * false to avoid sticking points in wrong series parentNode.\n         */\n        seriesInteraction: true,\n        /**\n         * In case of split series, this option allows user to drag and\n         * drop points between series, for changing point related series.\n         *\n         * @sample highcharts/demo/packed-bubble-project-status/\n         *         Example of drag'n drop bubbles for bubble kanban\n         */\n        dragBetweenSeries: false,\n        /**\n         * Layout algorithm options for parent nodes.\n         *\n         * @extends   plotOptions.networkgraph.layoutAlgorithm\n         * @excluding approximation, attractiveForce, enableSimulation,\n         *            repulsiveForce, theta\n         */\n        parentNodeOptions: {\n            maxIterations: 400,\n            gravitationalConstant: 0.03,\n            maxSpeed: 50,\n            initialPositionRadius: 100,\n            seriesInteraction: true,\n            /**\n             * Styling options for parentNodes markers. Similar to\n             * line.marker options.\n             *\n             * @sample highcharts/series-packedbubble/parentnode-style/\n             *         Bubble size\n             *\n             * @extends   plotOptions.series.marker\n             * @excluding states\n             */\n            marker: {\n                fillColor: null,\n                fillOpacity: 1,\n                lineWidth: null,\n                lineColor: null,\n                symbol: 'circle'\n            }\n        },\n        enableSimulation: true,\n        /**\n         * Type of the algorithm used when positioning bubbles.\n         * @ignore-option\n         */\n        type: 'packedbubble',\n        /**\n         * Integration type. Integration determines how forces are applied\n         * on particles. The `packedbubble` integration is based on\n         * the networkgraph `verlet` integration, where the new position\n         * is based on a previous position without velocity:\n         * `newPosition += previousPosition - newPosition`.\n         *\n         * @sample highcharts/series-networkgraph/forces/\n         *\n         * @ignore-option\n         */\n        integration: 'packedbubble',\n        maxIterations: 1000,\n        /**\n         * Whether to split series into individual groups or to mix all\n         * series together.\n         *\n         * @since   7.1.0\n         * @default false\n         */\n        splitSeries: false,\n        /**\n         * Max speed that node can get in one iteration. In terms of\n         * simulation, it's a maximum translation (in pixels) that a node\n         * can move (in both, x and y, dimensions). While `friction` is\n         * applied on all nodes, max speed is applied only for nodes that\n         * move very fast, for example small or disconnected ones.\n         *\n         * @see [layoutAlgorithm.integration](#series.networkgraph.layoutAlgorithm.integration)\n         *\n         * @see [layoutAlgorithm.friction](#series.networkgraph.layoutAlgorithm.friction)\n         */\n        maxSpeed: 5,\n        gravitationalConstant: 0.01,\n        friction: -0.981\n    },\n    stickyTracking: false\n};\n/* *\n *\n *  Default Export\n *\n * */\nexport default PackedBubbleSeriesDefaults;\n/* *\n *\n *  API Options\n *\n * */\n/**\n * A `packedbubble` series. If the [type](#series.packedbubble.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @type      {Object}\n * @extends   series,plotOptions.packedbubble\n * @excluding cropThreshold, dataParser, dataSorting, dataURL, dragDrop, stack,\n *            boostThreshold, boostBlending\n * @product   highcharts\n * @requires  highcharts-more\n * @apioption series.packedbubble\n */\n/**\n * An array of data points for the series. For the `packedbubble` series type,\n * points can be given in the following ways:\n *\n * 1.  An array of `values`.\n *\n *  ```js\n *     data: [5, 1, 20]\n *  ```\n *\n * 2.  An array of objects with named values. The objects are point\n * configuration objects as seen below. If the total number of data points\n * exceeds the series' [turboThreshold](#series.packedbubble.turboThreshold),\n * this option is not available.\n *\n *  ```js\n *     data: [{\n *         value: 1,\n *         name: \"Point2\",\n *         color: \"#00FF00\"\n *     }, {\n *         value: 5,\n *         name: \"Point1\",\n *         color: \"#FF00FF\"\n *     }]\n *  ```\n *\n * @type      {Array<Object|Array>}\n * @extends   series.line.data\n * @excluding marker, x, y\n * @sample    {highcharts} highcharts/series/data-array-of-objects/\n *            Config objects\n * @product   highcharts\n * @apioption series.packedbubble.data\n */\n/**\n * @type      {Highcharts.SeriesPackedBubbleDataLabelsOptionsObject|Array<Highcharts.SeriesPackedBubbleDataLabelsOptionsObject>}\n * @product   highcharts\n * @apioption series.packedbubble.data.dataLabels\n */\n/**\n * @excluding enabled,enabledThreshold,height,radius,width\n * @product   highcharts\n * @apioption series.packedbubble.marker\n */\n''; // Adds doclets above to transpiled file\n"],"names":[],"mappings":";;;;AAAA;;;;GAIG,GACH;;AACA,MAAM,EAAE,QAAQ,EAAE,GAAG,8KAAC;AACtB;;;;GAIG,GACH;;;;;;;;;;;;;;;;;;;;;;CAsBC,GACD,MAAM,6BAA6B;IAC/B;;;;;;;;;;;;;KAaC,GACD,SAAS;IACT;;;;;;;;;;;;;KAaC,GACD,SAAS;IACT,QAAQ;IACR,UAAU;IACV,OAAO;IACP,SAAS;QACL,aAAa;IACjB;IACA;;;;;;;KAOC,GACD,WAAW;IACX;;;;;;;;;;;;;;KAcC,GACD,eAAe;IACf;;;;;;KAMC,GACD,YAAY;QACR;;;;;SAKC,GACD,kBAAkB;IACtB;IACA;;;;;KAKC,GACD,YAAY;QACR;;;;;;;;;;SAUC,GACD,uCAAuC;QACvC;;;;;;SAMC,GACD,WAAW;YACP,MAAM,EAAE,eAAe,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK;YAC7C,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,KAAK;YAC5B,OAAO,SAAS,SAAS,gBAAgB,OAAO,CAAC,KAAK;QAC1D;QACA;;;;SAIC,GACD,uCAAuC;QACvC;;SAEC,GACD,qBAAqB;YACjB,OAAO,IAAI,CAAC,IAAI,IAAI;QACxB;QACA;;;;;;SAMC,GACD,oBAAoB;YAChB;;;;;;aAMC,GACD;;;;;aAKC,GACD,SAAS;QACb;QACA;;;;;;;;SAQC,GACD,SAAS;QACT,OAAO;YACH,YAAY;QAChB;IACJ;IACA;;;;;;;;;;KAUC,GACD,iBAAiB;QACb;;;;;;;;;;SAUC,GACD,kBAAkB;QAClB;;;;;;SAMC,GACD,uBAAuB;QACvB;;;;SAIC,GACD,eAAe;QACf;;;SAGC,GACD,iBAAiB;QACjB;;;;SAIC,GACD,mBAAmB;QACnB;;;;;;SAMC,GACD,mBAAmB;QACnB;;;;;;SAMC,GACD,mBAAmB;YACf,eAAe;YACf,uBAAuB;YACvB,UAAU;YACV,uBAAuB;YACvB,mBAAmB;YACnB;;;;;;;;;aASC,GACD,QAAQ;gBACJ,WAAW;gBACX,aAAa;gBACb,WAAW;gBACX,WAAW;gBACX,QAAQ;YACZ;QACJ;QACA,kBAAkB;QAClB;;;SAGC,GACD,MAAM;QACN;;;;;;;;;;SAUC,GACD,aAAa;QACb,eAAe;QACf;;;;;;SAMC,GACD,aAAa;QACb;;;;;;;;;;SAUC,GACD,UAAU;QACV,uBAAuB;QACvB,UAAU,CAAC;IACf;IACA,gBAAgB;AACpB;uCAMe;AACf;;;;GAIG,GACH;;;;;;;;;;;CAWC,GACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCC,GACD;;;;CAIC,GACD;;;;CAIC,GACD,IAAI,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 6522, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Networkgraph/VerletIntegration.js"],"sourcesContent":["/* *\n *\n *  Networkgraph series\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Pawe Fus\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Attractive force.\n *\n * In Verlet integration, force is applied on a node immediately to it's\n * `plotX` and `plotY` position.\n *\n * @private\n * @param {Highcharts.Point} link\n *        Link that connects two nodes\n * @param {number} force\n *        Force calculated in `repulsiveForceFunction`\n * @param {Highcharts.PositionObject} distanceXY\n *        Distance between two nodes e.g. `{x, y}`\n */\nfunction attractive(link, force, distanceXY) {\n    const massFactor = link.getMass(), translatedX = -distanceXY.x * force * this.diffTemperature, translatedY = -distanceXY.y * force * this.diffTemperature;\n    if (!link.fromNode.fixedPosition) {\n        link.fromNode.plotX -=\n            translatedX * massFactor.fromNode / link.fromNode.degree;\n        link.fromNode.plotY -=\n            translatedY * massFactor.fromNode / link.fromNode.degree;\n    }\n    if (!link.toNode.fixedPosition) {\n        link.toNode.plotX +=\n            translatedX * massFactor.toNode / link.toNode.degree;\n        link.toNode.plotY +=\n            translatedY * massFactor.toNode / link.toNode.degree;\n    }\n}\n/**\n * Attractive force function. Can be replaced by API's\n * `layoutAlgorithm.attractiveForce`\n *\n * @private\n * @param {number} d current distance between two nodes\n * @param {number} k expected distance between two nodes\n * @return {number} force\n */\nfunction attractiveForceFunction(d, k) {\n    // Used in API:\n    return (k - d) / d;\n}\n/**\n * Barycenter force. Calculate and applys barycenter forces on the\n * nodes. Making them closer to the center of their barycenter point.\n *\n * In Verlet integration, force is applied on a node immediately to it's\n * `plotX` and `plotY` position.\n *\n * @private\n */\nfunction barycenter() {\n    const gravitationalConstant = this.options.gravitationalConstant || 0, xFactor = (this.barycenter.xFactor -\n        (this.box.left + this.box.width) / 2) * gravitationalConstant, yFactor = (this.barycenter.yFactor -\n        (this.box.top + this.box.height) / 2) * gravitationalConstant;\n    this.nodes.forEach(function (node) {\n        if (!node.fixedPosition) {\n            node.plotX -=\n                xFactor / node.mass / node.degree;\n            node.plotY -=\n                yFactor / node.mass / node.degree;\n        }\n    });\n}\n/**\n * Estiamte the best possible distance between two nodes, making graph\n * readable.\n * @private\n */\nfunction getK(layout) {\n    return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.5);\n}\n/**\n * Integration method.\n *\n * In Verlet integration, forces are applied on node immediately to it's\n * `plotX` and `plotY` position.\n *\n * Verlet without velocity:\n *\n *    x(n+1) = 2 * x(n) - x(n-1) + A(T) * deltaT ^ 2\n *\n * where:\n *     - x(n+1) - new position\n *     - x(n) - current position\n *     - x(n-1) - previous position\n *\n * Assuming A(t) = 0 (no acceleration) and (deltaT = 1) we get:\n *\n *     x(n+1) = x(n) + (x(n) - x(n-1))\n *\n * where:\n *     - (x(n) - x(n-1)) - position change\n *\n * TO DO:\n * Consider Verlet with velocity to support additional\n * forces. Or even Time-Corrected Verlet by Jonathan\n * \"lonesock\" Dummer\n *\n * @private\n * @param {Highcharts.NetworkgraphLayout} layout layout object\n * @param {Highcharts.Point} node node that should be translated\n */\nfunction integrate(layout, node) {\n    const friction = -layout.options.friction, maxSpeed = layout.options.maxSpeed, prevX = node.prevX, prevY = node.prevY, \n    // Apply friction:\n    frictionX = ((node.plotX + node.dispX -\n        prevX) * friction), frictionY = ((node.plotY + node.dispY -\n        prevY) * friction), abs = Math.abs, signX = abs(frictionX) / (frictionX || 1), // Need to deal with 0\n    signY = abs(frictionY) / (frictionY || 1), \n    // Apply max speed:\n    diffX = signX * Math.min(maxSpeed, Math.abs(frictionX)), diffY = signY * Math.min(maxSpeed, Math.abs(frictionY));\n    // Store for the next iteration:\n    node.prevX = node.plotX + node.dispX;\n    node.prevY = node.plotY + node.dispY;\n    // Update positions:\n    node.plotX += diffX;\n    node.plotY += diffY;\n    node.temperature = layout.vectorLength({\n        x: diffX,\n        y: diffY\n    });\n}\n/**\n * Repulsive force.\n *\n * In Verlet integration, force is applied on a node immediately to it's\n * `plotX` and `plotY` position.\n *\n * @private\n * @param {Highcharts.Point} node\n *        Node that should be translated by force.\n * @param {number} force\n *        Force calculated in `repulsiveForceFunction`\n * @param {Highcharts.PositionObject} distanceXY\n *        Distance between two nodes e.g. `{x, y}`\n */\nfunction repulsive(node, force, distanceXY) {\n    const factor = force * this.diffTemperature / node.mass / node.degree;\n    if (!node.fixedPosition) {\n        node.plotX += distanceXY.x * factor;\n        node.plotY += distanceXY.y * factor;\n    }\n}\n/**\n * Repulsive force function. Can be replaced by API's\n * `layoutAlgorithm.repulsiveForce`\n *\n * @private\n * @param {number} d current distance between two nodes\n * @param {number} k expected distance between two nodes\n * @return {number} force\n */\nfunction repulsiveForceFunction(d, k) {\n    // Used in API:\n    return (k - d) / d * (k > d ? 1 : 0); // Force only for close nodes\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst VerletIntegration = {\n    attractive,\n    attractiveForceFunction,\n    barycenter,\n    getK,\n    integrate,\n    repulsive,\n    repulsiveForceFunction\n};\nexport default VerletIntegration;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6697, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubbleIntegration.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Grzegorz Blachlinski, Sebastian Bochan\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport H from '../../Core/Globals.js';\nconst { noop } = H;\nimport VerletIntegration from '../Networkgraph/VerletIntegration.js';\n/* *\n *\n *  Functions\n *\n * */\n/**\n * @private\n */\nfunction barycenter() {\n    const layout = this, gravitationalConstant = layout.options.gravitationalConstant || 0, box = layout.box, nodes = layout.nodes, nodeCountSqrt = Math.sqrt(nodes.length);\n    let centerX, centerY;\n    for (const node of nodes) {\n        if (!node.fixedPosition) {\n            const massTimesNodeCountSqrt = node.mass * nodeCountSqrt, plotX = node.plotX || 0, plotY = node.plotY || 0, series = node.series, parentNode = series.parentNode;\n            if (this.resolveSplitSeries(node) &&\n                parentNode &&\n                !node.isParentNode) {\n                centerX = parentNode.plotX || 0;\n                centerY = parentNode.plotY || 0;\n            }\n            else {\n                centerX = box.width / 2;\n                centerY = box.height / 2;\n            }\n            node.plotX = plotX - ((plotX - centerX) *\n                gravitationalConstant /\n                massTimesNodeCountSqrt);\n            node.plotY = plotY - ((plotY - centerY) *\n                gravitationalConstant /\n                massTimesNodeCountSqrt);\n            if (series.chart.hoverPoint === node &&\n                // If redrawHalo exists we know its a draggable series and any\n                // halo present should be redrawn to update its visual position\n                series.redrawHalo && series.halo) {\n                series.redrawHalo(node);\n            }\n        }\n    }\n}\n/**\n * @private\n */\nfunction repulsive(node, force, distanceXY, repNode) {\n    const factor = (force * this.diffTemperature / node.mass /\n        node.degree), x = distanceXY.x * factor, y = distanceXY.y * factor;\n    if (!node.fixedPosition) {\n        node.plotX += x;\n        node.plotY += y;\n    }\n    if (!repNode.fixedPosition) {\n        repNode.plotX -= x;\n        repNode.plotY -= y;\n    }\n}\n/**\n * @private\n */\nfunction repulsiveForceFunction(d, k, node, repNode) {\n    return Math.min(d, (node.marker.radius +\n        repNode.marker.radius) / 2);\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst PackedBubbleIntegration = {\n    barycenter,\n    getK: noop,\n    integrate: VerletIntegration.integrate,\n    repulsive,\n    repulsiveForceFunction\n};\nexport default PackedBubbleIntegration;\n"],"names":[],"mappings":";;;;AAWA;AAEA;AAbA;;;;;;;;;GASG,GACH;;AAEA,MAAM,EAAE,IAAI,EAAE,GAAG,4KAAC;;AAElB;;;;GAIG,GACH;;CAEC,GACD,SAAS;IACL,MAAM,SAAS,IAAI,EAAE,wBAAwB,OAAO,OAAO,CAAC,qBAAqB,IAAI,GAAG,MAAM,OAAO,GAAG,EAAE,QAAQ,OAAO,KAAK,EAAE,gBAAgB,KAAK,IAAI,CAAC,MAAM,MAAM;IACtK,IAAI,SAAS;IACb,KAAK,MAAM,QAAQ,MAAO;QACtB,IAAI,CAAC,KAAK,aAAa,EAAE;YACrB,MAAM,yBAAyB,KAAK,IAAI,GAAG,eAAe,QAAQ,KAAK,KAAK,IAAI,GAAG,QAAQ,KAAK,KAAK,IAAI,GAAG,SAAS,KAAK,MAAM,EAAE,aAAa,OAAO,UAAU;YAChK,IAAI,IAAI,CAAC,kBAAkB,CAAC,SACxB,cACA,CAAC,KAAK,YAAY,EAAE;gBACpB,UAAU,WAAW,KAAK,IAAI;gBAC9B,UAAU,WAAW,KAAK,IAAI;YAClC,OACK;gBACD,UAAU,IAAI,KAAK,GAAG;gBACtB,UAAU,IAAI,MAAM,GAAG;YAC3B;YACA,KAAK,KAAK,GAAG,QAAS,CAAC,QAAQ,OAAO,IAClC,wBACA;YACJ,KAAK,KAAK,GAAG,QAAS,CAAC,QAAQ,OAAO,IAClC,wBACA;YACJ,IAAI,OAAO,KAAK,CAAC,UAAU,KAAK,QAC5B,8DAA8D;YAC9D,+DAA+D;YAC/D,OAAO,UAAU,IAAI,OAAO,IAAI,EAAE;gBAClC,OAAO,UAAU,CAAC;YACtB;QACJ;IACJ;AACJ;AACA;;CAEC,GACD,SAAS,UAAU,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,OAAO;IAC/C,MAAM,SAAU,QAAQ,IAAI,CAAC,eAAe,GAAG,KAAK,IAAI,GACpD,KAAK,MAAM,EAAG,IAAI,WAAW,CAAC,GAAG,QAAQ,IAAI,WAAW,CAAC,GAAG;IAChE,IAAI,CAAC,KAAK,aAAa,EAAE;QACrB,KAAK,KAAK,IAAI;QACd,KAAK,KAAK,IAAI;IAClB;IACA,IAAI,CAAC,QAAQ,aAAa,EAAE;QACxB,QAAQ,KAAK,IAAI;QACjB,QAAQ,KAAK,IAAI;IACrB;AACJ;AACA;;CAEC,GACD,SAAS,uBAAuB,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO;IAC/C,OAAO,KAAK,GAAG,CAAC,GAAG,CAAC,KAAK,MAAM,CAAC,MAAM,GAClC,QAAQ,MAAM,CAAC,MAAM,IAAI;AACjC;AACA;;;;GAIG,GACH,MAAM,0BAA0B;IAC5B;IACA,MAAM;IACN,WAAW,wMAAiB,CAAC,SAAS;IACtC;IACA;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 6779, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Networkgraph/EulerIntegration.js"],"sourcesContent":["/* *\n *\n *  Networkgraph series\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Pawe Fus\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Attractive force.\n *\n * In Euler integration, force is stored in a node, not changing it's\n * position. Later, in `integrate()` forces are applied on nodes.\n *\n * @private\n * @param {Highcharts.Point} link\n *        Link that connects two nodes\n * @param {number} force\n *        Force calculated in `repulsiveForceFunction`\n * @param {Highcharts.PositionObject} distanceXY\n *        Distance between two nodes e.g. `{x, y}`\n * @param {number} distanceR\n     */\nfunction attractive(link, force, distanceXY, distanceR) {\n    const massFactor = link.getMass(), translatedX = (distanceXY.x / distanceR) * force, translatedY = (distanceXY.y / distanceR) * force;\n    if (!link.fromNode.fixedPosition) {\n        link.fromNode.dispX -=\n            translatedX * massFactor.fromNode / link.fromNode.degree;\n        link.fromNode.dispY -=\n            translatedY * massFactor.fromNode / link.fromNode.degree;\n    }\n    if (!link.toNode.fixedPosition) {\n        link.toNode.dispX +=\n            translatedX * massFactor.toNode / link.toNode.degree;\n        link.toNode.dispY +=\n            translatedY * massFactor.toNode / link.toNode.degree;\n    }\n}\n/**\n * Attractive force function. Can be replaced by API's\n * `layoutAlgorithm.attractiveForce`\n *\n * Other forces that can be used:\n *\n * basic, not recommended:\n *    `function (d, k) { return d / k }`\n *\n * @private\n * @param {number} d current distance between two nodes\n * @param {number} k expected distance between two nodes\n * @return {number} force\n */\nfunction attractiveForceFunction(d, k) {\n    return d * d / k;\n}\n/**\n * Barycenter force. Calculate and applys barycenter forces on the\n * nodes. Making them closer to the center of their barycenter point.\n *\n * In Euler integration, force is stored in a node, not changing it's\n * position. Later, in `integrate()` forces are applied on nodes.\n *\n * @private\n */\nfunction barycenter() {\n    const gravitationalConstant = this.options.gravitationalConstant, xFactor = this.barycenter.xFactor, yFactor = this.barycenter.yFactor;\n    this.nodes.forEach(function (node) {\n        if (!node.fixedPosition) {\n            const degree = node.getDegree(), phi = degree * (1 + degree / 2);\n            node.dispX += ((xFactor - node.plotX) *\n                gravitationalConstant *\n                phi / node.degree);\n            node.dispY += ((yFactor - node.plotY) *\n                gravitationalConstant *\n                phi / node.degree);\n        }\n    });\n}\n/**\n * Estimate the best possible distance between two nodes, making graph\n * readable.\n * @private\n */\nfunction getK(layout) {\n    return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.3);\n}\n/**\n * Integration method.\n *\n * In Euler integration, force were stored in a node, not changing it's\n * position. Now, in the integrator method, we apply changes.\n *\n * Euler:\n *\n * Basic form: `x(n+1) = x(n) + v(n)`\n *\n * With Rengoild-Fruchterman we get:\n * `x(n+1) = x(n) + v(n) / length(v(n)) * min(v(n), temperature(n))`\n * where:\n * - `x(n+1)`: next position\n * - `x(n)`: current position\n * - `v(n)`: velocity (comes from net force)\n * - `temperature(n)`: current temperature\n *\n * Known issues:\n * Oscillations when force vector has the same magnitude but opposite\n * direction in the next step. Potentially solved by decreasing force by\n * `v * (1 / node.degree)`\n *\n * Note:\n * Actually `min(v(n), temperature(n))` replaces simulated annealing.\n *\n * @private\n * @param {Highcharts.NetworkgraphLayout} layout\n *        Layout object\n * @param {Highcharts.Point} node\n *        Node that should be translated\n */\nfunction integrate(layout, node) {\n    node.dispX +=\n        node.dispX * layout.options.friction;\n    node.dispY +=\n        node.dispY * layout.options.friction;\n    const distanceR = node.temperature = layout.vectorLength({\n        x: node.dispX,\n        y: node.dispY\n    });\n    if (distanceR !== 0) {\n        node.plotX += (node.dispX / distanceR *\n            Math.min(Math.abs(node.dispX), layout.temperature));\n        node.plotY += (node.dispY / distanceR *\n            Math.min(Math.abs(node.dispY), layout.temperature));\n    }\n}\n/**\n * Repulsive force.\n *\n * @private\n * @param {Highcharts.Point} node\n *        Node that should be translated by force.\n * @param {number} force\n *        Force calculated in `repulsiveForceFunction`\n * @param {Highcharts.PositionObject} distanceXY\n *        Distance between two nodes e.g. `{x, y}`\n */\nfunction repulsive(node, force, distanceXY, distanceR) {\n    node.dispX +=\n        (distanceXY.x / distanceR) * force / node.degree;\n    node.dispY +=\n        (distanceXY.y / distanceR) * force / node.degree;\n}\n/**\n * Repulsive force function. Can be replaced by API's\n * `layoutAlgorithm.repulsiveForce`.\n *\n * Other forces that can be used:\n *\n * basic, not recommended:\n *    `function (d, k) { return k / d }`\n *\n * standard:\n *    `function (d, k) { return k * k / d }`\n *\n * grid-variant:\n *    `function (d, k) { return k * k / d * (2 * k - d > 0 ? 1 : 0) }`\n *\n * @private\n * @param {number} d current distance between two nodes\n * @param {number} k expected distance between two nodes\n * @return {number} force\n */\nfunction repulsiveForceFunction(d, k) {\n    return k * k / d;\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst EulerIntegration = {\n    attractive,\n    attractiveForceFunction,\n    barycenter,\n    getK,\n    integrate,\n    repulsive,\n    repulsiveForceFunction\n};\nexport default EulerIntegration;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6962, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Networkgraph/QuadTreeNode.js"],"sourcesContent":["/* *\n *\n *  Networkgraph series\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Pawe Fus\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\n/* *\n *\n *  Class\n *\n * */\n/**\n * The QuadTree node class. Used in Networkgraph chart as a base for Barnes-Hut\n * approximation.\n *\n * @private\n * @class\n * @name Highcharts.QuadTreeNode\n *\n * @param {Highcharts.Dictionary<number>} box\n *        Available space for the node\n */\nclass QuadTreeNode {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    constructor(box) {\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        /**\n         * Read only. If QuadTreeNode is an external node, Point is stored in\n         * `this.body`.\n         *\n         * @name Highcharts.QuadTreeNode#body\n         * @type {boolean|Highcharts.Point}\n         */\n        this.body = false;\n        /**\n         * Read only. Internal nodes when created are empty to reserve the\n         * space. If Point is added to this QuadTreeNode, QuadTreeNode is no\n         * longer empty.\n         *\n         * @name Highcharts.QuadTreeNode#isEmpty\n         * @type {boolean}\n         */\n        this.isEmpty = false;\n        /**\n         * Read only. Flag to determine if QuadTreeNode is internal (and has\n         * subnodes with mass and central position) or external (bound to\n         * Point).\n         *\n         * @name Highcharts.QuadTreeNode#isInternal\n         * @type {boolean}\n         */\n        this.isInternal = false;\n        /**\n         * Read only. Array of subnodes. Empty if QuadTreeNode has just one\n         * Point. When added another Point to this QuadTreeNode, array is\n         * filled with four subnodes.\n         *\n         * @name Highcharts.QuadTreeNode#nodes\n         * @type {Array<Highcharts.QuadTreeNode>}\n         */\n        this.nodes = [];\n        /**\n         * Read only. The available space for node.\n         *\n         * @name Highcharts.QuadTreeNode#box\n         * @type {Highcharts.Dictionary<number>}\n         */\n        this.box = box;\n        /**\n         * Read only. The minium of width and height values.\n         *\n         * @name Highcharts.QuadTreeNode#boxSize\n         * @type {number}\n         */\n        this.boxSize = Math.min(box.width, box.height);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * When inserting another node into the box, that already hove one node,\n     * divide the available space into another four quadrants.\n     *\n     * Indexes of quadrants are:\n     * ```\n     * -------------               -------------\n     * |           |               |     |     |\n     * |           |               |  0  |  1  |\n     * |           |   divide()    |     |     |\n     * |     1     | ----------->  -------------\n     * |           |               |     |     |\n     * |           |               |  3  |  2  |\n     * |           |               |     |     |\n     * -------------               -------------\n     * ```\n     */\n    divideBox() {\n        const halfWidth = this.box.width / 2, halfHeight = this.box.height / 2;\n        // Top left\n        this.nodes[0] = new QuadTreeNode({\n            left: this.box.left,\n            top: this.box.top,\n            width: halfWidth,\n            height: halfHeight\n        });\n        // Top right\n        this.nodes[1] = new QuadTreeNode({\n            left: this.box.left + halfWidth,\n            top: this.box.top,\n            width: halfWidth,\n            height: halfHeight\n        });\n        // Bottom right\n        this.nodes[2] = new QuadTreeNode({\n            left: this.box.left + halfWidth,\n            top: this.box.top + halfHeight,\n            width: halfWidth,\n            height: halfHeight\n        });\n        // Bottom left\n        this.nodes[3] = new QuadTreeNode({\n            left: this.box.left,\n            top: this.box.top + halfHeight,\n            width: halfWidth,\n            height: halfHeight\n        });\n    }\n    /**\n     * Determine which of the quadrants should be used when placing node in\n     * the QuadTree. Returned index is always in range `< 0 , 3 >`.\n     * @private\n     */\n    getBoxPosition(point) {\n        const left = point.plotX < this.box.left + this.box.width / 2, top = point.plotY < this.box.top + this.box.height / 2;\n        let index;\n        if (left) {\n            if (top) {\n                // Top left\n                index = 0;\n            }\n            else {\n                // Bottom left\n                index = 3;\n            }\n        }\n        else {\n            if (top) {\n                // Top right\n                index = 1;\n            }\n            else {\n                // Bottom right\n                index = 2;\n            }\n        }\n        return index;\n    }\n    /**\n     * Insert recursively point(node) into the QuadTree. If the given\n     * quadrant is already occupied, divide it into smaller quadrants.\n     *\n     * @param {Highcharts.Point} point\n     *        Point/node to be inserted\n     * @param {number} depth\n     *        Max depth of the QuadTree\n     */\n    insert(point, depth) {\n        let newQuadTreeNode;\n        if (this.isInternal) {\n            // Internal node:\n            this.nodes[this.getBoxPosition(point)].insert(point, depth - 1);\n        }\n        else {\n            this.isEmpty = false;\n            if (!this.body) {\n                // First body in a quadrant:\n                this.isInternal = false;\n                this.body = point;\n            }\n            else {\n                if (depth) {\n                    // Every other body in a quadrant:\n                    this.isInternal = true;\n                    this.divideBox();\n                    // Reinsert main body only once:\n                    if (this.body !== true) {\n                        this.nodes[this.getBoxPosition(this.body)]\n                            .insert(this.body, depth - 1);\n                        this.body = true;\n                    }\n                    // Add second body:\n                    this.nodes[this.getBoxPosition(point)]\n                        .insert(point, depth - 1);\n                }\n                else {\n                    // We are below max allowed depth. That means either:\n                    // - really huge number of points\n                    // - falling two points into exactly the same position\n                    // In this case, create another node in the QuadTree.\n                    //\n                    // Alternatively we could add some noise to the\n                    // position, but that could result in different\n                    // rendered chart in exporting.\n                    newQuadTreeNode = new QuadTreeNode({\n                        top: point.plotX || NaN,\n                        left: point.plotY || NaN,\n                        // Width/height below 1px\n                        width: 0.1,\n                        height: 0.1\n                    });\n                    newQuadTreeNode.body = point;\n                    newQuadTreeNode.isInternal = false;\n                    this.nodes.push(newQuadTreeNode);\n                }\n            }\n        }\n    }\n    /**\n     * Each quad node requires it's mass and center position. That mass and\n     * position is used to imitate real node in the layout by approximation.\n     */\n    updateMassAndCenter() {\n        let mass = 0, plotX = 0, plotY = 0;\n        if (this.isInternal) {\n            // Calculate weightened mass of the quad node:\n            for (const pointMass of this.nodes) {\n                if (!pointMass.isEmpty) {\n                    mass += pointMass.mass;\n                    plotX += pointMass.plotX * pointMass.mass;\n                    plotY += pointMass.plotY * pointMass.mass;\n                }\n            }\n            plotX /= mass;\n            plotY /= mass;\n        }\n        else if (this.body) {\n            // Just one node, use coordinates directly:\n            mass = this.body.mass;\n            plotX = this.body.plotX;\n            plotY = this.body.plotY;\n        }\n        // Store details:\n        this.mass = mass;\n        this.plotX = plotX;\n        this.plotY = plotY;\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nexport default QuadTreeNode;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;GAWG,GACH;AACA;;;;GAIG,GACH;;;;;;;;;;CAUC,GACD,MAAM;IACF;;;;OAIG,GACH,YAAY,GAAG,CAAE;QACb;;;;WAIG,GACH;;;;;;SAMC,GACD,IAAI,CAAC,IAAI,GAAG;QACZ;;;;;;;SAOC,GACD,IAAI,CAAC,OAAO,GAAG;QACf;;;;;;;SAOC,GACD,IAAI,CAAC,UAAU,GAAG;QAClB;;;;;;;SAOC,GACD,IAAI,CAAC,KAAK,GAAG,EAAE;QACf;;;;;SAKC,GACD,IAAI,CAAC,GAAG,GAAG;QACX;;;;;SAKC,GACD,IAAI,CAAC,OAAO,GAAG,KAAK,GAAG,CAAC,IAAI,KAAK,EAAE,IAAI,MAAM;IACjD;IACA;;;;OAIG,GACH;;;;;;;;;;;;;;;;KAgBC,GACD,YAAY;QACR,MAAM,YAAY,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,GAAG,aAAa,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG;QACrE,WAAW;QACX,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG,IAAI,aAAa;YAC7B,MAAM,IAAI,CAAC,GAAG,CAAC,IAAI;YACnB,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG;YACjB,OAAO;YACP,QAAQ;QACZ;QACA,YAAY;QACZ,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG,IAAI,aAAa;YAC7B,MAAM,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG;YACtB,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG;YACjB,OAAO;YACP,QAAQ;QACZ;QACA,eAAe;QACf,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG,IAAI,aAAa;YAC7B,MAAM,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG;YACtB,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG;YACpB,OAAO;YACP,QAAQ;QACZ;QACA,cAAc;QACd,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG,IAAI,aAAa;YAC7B,MAAM,IAAI,CAAC,GAAG,CAAC,IAAI;YACnB,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG;YACpB,OAAO;YACP,QAAQ;QACZ;IACJ;IACA;;;;KAIC,GACD,eAAe,KAAK,EAAE;QAClB,MAAM,OAAO,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,GAAG,MAAM,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG;QACpH,IAAI;QACJ,IAAI,MAAM;YACN,IAAI,KAAK;gBACL,WAAW;gBACX,QAAQ;YACZ,OACK;gBACD,cAAc;gBACd,QAAQ;YACZ;QACJ,OACK;YACD,IAAI,KAAK;gBACL,YAAY;gBACZ,QAAQ;YACZ,OACK;gBACD,eAAe;gBACf,QAAQ;YACZ;QACJ;QACA,OAAO;IACX;IACA;;;;;;;;KAQC,GACD,OAAO,KAAK,EAAE,KAAK,EAAE;QACjB,IAAI;QACJ,IAAI,IAAI,CAAC,UAAU,EAAE;YACjB,iBAAiB;YACjB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,QAAQ;QACjE,OACK;YACD,IAAI,CAAC,OAAO,GAAG;YACf,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gBACZ,4BAA4B;gBAC5B,IAAI,CAAC,UAAU,GAAG;gBAClB,IAAI,CAAC,IAAI,GAAG;YAChB,OACK;gBACD,IAAI,OAAO;oBACP,kCAAkC;oBAClC,IAAI,CAAC,UAAU,GAAG;oBAClB,IAAI,CAAC,SAAS;oBACd,gCAAgC;oBAChC,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM;wBACpB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,CACrC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ;wBAC/B,IAAI,CAAC,IAAI,GAAG;oBAChB;oBACA,mBAAmB;oBACnB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,CACjC,MAAM,CAAC,OAAO,QAAQ;gBAC/B,OACK;oBACD,qDAAqD;oBACrD,iCAAiC;oBACjC,sDAAsD;oBACtD,qDAAqD;oBACrD,EAAE;oBACF,+CAA+C;oBAC/C,+CAA+C;oBAC/C,+BAA+B;oBAC/B,kBAAkB,IAAI,aAAa;wBAC/B,KAAK,MAAM,KAAK,IAAI;wBACpB,MAAM,MAAM,KAAK,IAAI;wBACrB,yBAAyB;wBACzB,OAAO;wBACP,QAAQ;oBACZ;oBACA,gBAAgB,IAAI,GAAG;oBACvB,gBAAgB,UAAU,GAAG;oBAC7B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBACpB;YACJ;QACJ;IACJ;IACA;;;KAGC,GACD,sBAAsB;QAClB,IAAI,OAAO,GAAG,QAAQ,GAAG,QAAQ;QACjC,IAAI,IAAI,CAAC,UAAU,EAAE;YACjB,8CAA8C;YAC9C,KAAK,MAAM,aAAa,IAAI,CAAC,KAAK,CAAE;gBAChC,IAAI,CAAC,UAAU,OAAO,EAAE;oBACpB,QAAQ,UAAU,IAAI;oBACtB,SAAS,UAAU,KAAK,GAAG,UAAU,IAAI;oBACzC,SAAS,UAAU,KAAK,GAAG,UAAU,IAAI;gBAC7C;YACJ;YACA,SAAS;YACT,SAAS;QACb,OACK,IAAI,IAAI,CAAC,IAAI,EAAE;YAChB,2CAA2C;YAC3C,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI;YACrB,QAAQ,IAAI,CAAC,IAAI,CAAC,KAAK;YACvB,QAAQ,IAAI,CAAC,IAAI,CAAC,KAAK;QAC3B;QACA,iBAAiB;QACjB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,KAAK,GAAG;IACjB;AACJ;uCAMe","ignoreList":[0]}},
    {"offset": {"line": 7210, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Networkgraph/QuadTree.js"],"sourcesContent":["/* *\n *\n *  Networkgraph series\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Pawe Fus\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport QuadTreeNode from './QuadTreeNode.js';\n/* *\n *\n *  Class\n *\n * */\n/**\n * The QuadTree class. Used in Networkgraph chart as a base for Barnes-Hut\n * approximation.\n *\n * @private\n * @class\n * @name Highcharts.QuadTree\n *\n * @param {number} x\n *        Left position of the plotting area\n * @param {number} y\n *        Top position of the plotting area\n * @param {number} width\n *        Width of the plotting area\n * @param {number} height\n *        Height of the plotting area\n */\nclass QuadTree {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    constructor(x, y, width, height) {\n        // Boundary rectangle:\n        this.box = {\n            left: x,\n            top: y,\n            width: width,\n            height: height\n        };\n        this.maxDepth = 25;\n        this.root = new QuadTreeNode(this.box);\n        this.root.isInternal = true;\n        this.root.isRoot = true;\n        this.root.divideBox();\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Calculate mass of the each QuadNode in the tree.\n     */\n    calculateMassAndCenter() {\n        this.visitNodeRecursive(null, null, function (node) {\n            node.updateMassAndCenter();\n        });\n    }\n    /**\n     * Insert nodes into the QuadTree\n     *\n     * @param {Array<Highcharts.Point>} points\n     *        Points as nodes\n     */\n    insertNodes(points) {\n        for (const point of points) {\n            this.root.insert(point, this.maxDepth);\n        }\n    }\n    /**\n     * Depth first treversal (DFS). Using `before` and `after` callbacks,\n     * we can get two results: preorder and postorder traversals, reminder:\n     *\n     * ```\n     *     (a)\n     *     / \\\n     *   (b) (c)\n     *   / \\\n     * (d) (e)\n     * ```\n     *\n     * DFS (preorder): `a -> b -> d -> e -> c`\n     *\n     * DFS (postorder): `d -> e -> b -> c -> a`\n     *\n     * @param {Highcharts.QuadTreeNode|null} node\n     *        QuadTree node\n     * @param {Function} [beforeCallback]\n     *        Function to be called before visiting children nodes.\n     * @param {Function} [afterCallback]\n     *        Function to be called after visiting children nodes.\n     */\n    visitNodeRecursive(node, beforeCallback, afterCallback) {\n        let goFurther;\n        if (!node) {\n            node = this.root;\n        }\n        if (node === this.root && beforeCallback) {\n            goFurther = beforeCallback(node);\n        }\n        if (goFurther === false) {\n            return;\n        }\n        for (const qtNode of node.nodes) {\n            if (qtNode.isInternal) {\n                if (beforeCallback) {\n                    goFurther = beforeCallback(qtNode);\n                }\n                if (goFurther === false) {\n                    continue;\n                }\n                this.visitNodeRecursive(qtNode, beforeCallback, afterCallback);\n            }\n            else if (qtNode.body) {\n                if (beforeCallback) {\n                    beforeCallback(qtNode.body);\n                }\n            }\n            if (afterCallback) {\n                afterCallback(qtNode);\n            }\n        }\n        if (node === this.root && afterCallback) {\n            afterCallback(node);\n        }\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nexport default QuadTree;\n"],"names":[],"mappings":";;;;AAaA;AAbA;;;;;;;;;;;GAWG,GACH;;AAEA;;;;GAIG,GACH;;;;;;;;;;;;;;;;CAgBC,GACD,MAAM;IACF;;;;OAIG,GACH,YAAY,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,CAAE;QAC7B,sBAAsB;QACtB,IAAI,CAAC,GAAG,GAAG;YACP,MAAM;YACN,KAAK;YACL,OAAO;YACP,QAAQ;QACZ;QACA,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,IAAI,GAAG,IAAI,mMAAY,CAAC,IAAI,CAAC,GAAG;QACrC,IAAI,CAAC,IAAI,CAAC,UAAU,GAAG;QACvB,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG;QACnB,IAAI,CAAC,IAAI,CAAC,SAAS;IACvB;IACA;;;;OAIG,GACH;;KAEC,GACD,yBAAyB;QACrB,IAAI,CAAC,kBAAkB,CAAC,MAAM,MAAM,SAAU,IAAI;YAC9C,KAAK,mBAAmB;QAC5B;IACJ;IACA;;;;;KAKC,GACD,YAAY,MAAM,EAAE;QAChB,KAAK,MAAM,SAAS,OAAQ;YACxB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,IAAI,CAAC,QAAQ;QACzC;IACJ;IACA;;;;;;;;;;;;;;;;;;;;;;KAsBC,GACD,mBAAmB,IAAI,EAAE,cAAc,EAAE,aAAa,EAAE;QACpD,IAAI;QACJ,IAAI,CAAC,MAAM;YACP,OAAO,IAAI,CAAC,IAAI;QACpB;QACA,IAAI,SAAS,IAAI,CAAC,IAAI,IAAI,gBAAgB;YACtC,YAAY,eAAe;QAC/B;QACA,IAAI,cAAc,OAAO;YACrB;QACJ;QACA,KAAK,MAAM,UAAU,KAAK,KAAK,CAAE;YAC7B,IAAI,OAAO,UAAU,EAAE;gBACnB,IAAI,gBAAgB;oBAChB,YAAY,eAAe;gBAC/B;gBACA,IAAI,cAAc,OAAO;oBACrB;gBACJ;gBACA,IAAI,CAAC,kBAAkB,CAAC,QAAQ,gBAAgB;YACpD,OACK,IAAI,OAAO,IAAI,EAAE;gBAClB,IAAI,gBAAgB;oBAChB,eAAe,OAAO,IAAI;gBAC9B;YACJ;YACA,IAAI,eAAe;gBACf,cAAc;YAClB;QACJ;QACA,IAAI,SAAS,IAAI,CAAC,IAAI,IAAI,eAAe;YACrC,cAAc;QAClB;IACJ;AACJ;uCAMe","ignoreList":[0]}},
    {"offset": {"line": 7349, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Networkgraph/ReingoldFruchtermanLayout.js"],"sourcesContent":["/* *\n *\n *  Networkgraph series\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Pawe Fus\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport EulerIntegration from './EulerIntegration.js';\nimport H from '../../Core/Globals.js';\nconst { win } = H;\nimport GraphLayout from '../GraphLayoutComposition.js';\nimport QuadTree from './QuadTree.js';\nimport U from '../../Core/Utilities.js';\nconst { clamp, defined, isFunction, fireEvent, pick } = U;\nimport VerletIntegration from './VerletIntegration.js';\n/* *\n *\n *  Class\n *\n * */\n/**\n * Reingold-Fruchterman algorithm from\n * \"Graph Drawing by Force-directed Placement\" paper.\n * @private\n */\nclass ReingoldFruchtermanLayout {\n    constructor() {\n        /* *\n         *\n         *  Static Functions\n         *\n         * */\n        this.box = {};\n        this.currentStep = 0;\n        this.initialRendering = true;\n        this.links = [];\n        this.nodes = [];\n        this.series = [];\n        this.simulation = false;\n    }\n    static compose(ChartClass) {\n        GraphLayout.compose(ChartClass);\n        GraphLayout.integrations.euler = EulerIntegration;\n        GraphLayout.integrations.verlet = VerletIntegration;\n        GraphLayout.layouts['reingold-fruchterman'] =\n            ReingoldFruchtermanLayout;\n    }\n    init(options) {\n        this.options = options;\n        this.nodes = [];\n        this.links = [];\n        this.series = [];\n        this.box = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        };\n        this.setInitialRendering(true);\n        this.integration =\n            GraphLayout.integrations[options.integration];\n        this.enableSimulation = options.enableSimulation;\n        this.attractiveForce = pick(options.attractiveForce, this.integration.attractiveForceFunction);\n        this.repulsiveForce = pick(options.repulsiveForce, this.integration.repulsiveForceFunction);\n        this.approximation = options.approximation;\n    }\n    updateSimulation(enable) {\n        this.enableSimulation = pick(enable, this.options.enableSimulation);\n    }\n    start() {\n        const layout = this, series = this.series, options = this.options;\n        layout.currentStep = 0;\n        layout.forces = series[0] && series[0].forces || [];\n        layout.chart = series[0] && series[0].chart;\n        if (layout.initialRendering) {\n            layout.initPositions();\n            // Render elements in initial positions:\n            series.forEach(function (s) {\n                s.finishedAnimating = true; // #13169\n                s.render();\n            });\n        }\n        layout.setK();\n        layout.resetSimulation(options);\n        if (layout.enableSimulation) {\n            layout.step();\n        }\n    }\n    step() {\n        const anyLayout = this, allSeries = this.series;\n        // Algorithm:\n        this.currentStep++;\n        if (this.approximation === 'barnes-hut') {\n            this.createQuadTree();\n            this.quadTree.calculateMassAndCenter();\n        }\n        for (const forceName of this.forces || []) {\n            anyLayout[forceName + 'Forces'](this.temperature);\n        }\n        // Limit to the plotting area and cool down:\n        this.applyLimits();\n        // Cool down the system:\n        this.temperature = this.coolDown(this.startTemperature, this.diffTemperature, this.currentStep);\n        this.prevSystemTemperature = this.systemTemperature;\n        this.systemTemperature = this.getSystemTemperature();\n        if (this.enableSimulation) {\n            for (const series of allSeries) {\n                // Chart could be destroyed during the simulation\n                if (series.chart) {\n                    series.render();\n                }\n            }\n            if (this.maxIterations-- &&\n                isFinite(this.temperature) &&\n                !this.isStable()) {\n                if (this.simulation) {\n                    win.cancelAnimationFrame(this.simulation);\n                }\n                this.simulation = win.requestAnimationFrame(() => this.step());\n            }\n            else {\n                this.simulation = false;\n                this.series.forEach((s) => {\n                    fireEvent(s, 'afterSimulation');\n                });\n            }\n        }\n    }\n    stop() {\n        if (this.simulation) {\n            win.cancelAnimationFrame(this.simulation);\n        }\n    }\n    setArea(x, y, w, h) {\n        this.box = {\n            left: x,\n            top: y,\n            width: w,\n            height: h\n        };\n    }\n    setK() {\n        // Optimal distance between nodes,\n        // available space around the node:\n        this.k = this.options.linkLength || this.integration.getK(this);\n    }\n    addElementsToCollection(elements, collection) {\n        for (const element of elements) {\n            if (collection.indexOf(element) === -1) {\n                collection.push(element);\n            }\n        }\n    }\n    removeElementFromCollection(element, collection) {\n        const index = collection.indexOf(element);\n        if (index !== -1) {\n            collection.splice(index, 1);\n        }\n    }\n    clear() {\n        this.nodes.length = 0;\n        this.links.length = 0;\n        this.series.length = 0;\n        this.resetSimulation();\n    }\n    resetSimulation() {\n        this.forcedStop = false;\n        this.systemTemperature = 0;\n        this.setMaxIterations();\n        this.setTemperature();\n        this.setDiffTemperature();\n    }\n    restartSimulation() {\n        if (!this.simulation) {\n            // When dragging nodes, we don't need to calculate\n            // initial positions and rendering nodes:\n            this.setInitialRendering(false);\n            // Start new simulation:\n            if (!this.enableSimulation) {\n                // Run only one iteration to speed things up:\n                this.setMaxIterations(1);\n            }\n            else {\n                this.start();\n            }\n            if (this.chart) {\n                this.chart.redraw();\n            }\n            // Restore defaults:\n            this.setInitialRendering(true);\n        }\n        else {\n            // Extend current simulation:\n            this.resetSimulation();\n        }\n    }\n    setMaxIterations(maxIterations) {\n        this.maxIterations = pick(maxIterations, this.options.maxIterations);\n    }\n    setTemperature() {\n        this.temperature = this.startTemperature =\n            Math.sqrt(this.nodes.length);\n    }\n    setDiffTemperature() {\n        this.diffTemperature = this.startTemperature /\n            (this.options.maxIterations + 1);\n    }\n    setInitialRendering(enable) {\n        this.initialRendering = enable;\n    }\n    createQuadTree() {\n        this.quadTree = new QuadTree(this.box.left, this.box.top, this.box.width, this.box.height);\n        this.quadTree.insertNodes(this.nodes);\n    }\n    initPositions() {\n        const initialPositions = this.options.initialPositions;\n        if (isFunction(initialPositions)) {\n            initialPositions.call(this);\n            for (const node of this.nodes) {\n                if (!defined(node.prevX)) {\n                    node.prevX = node.plotX;\n                }\n                if (!defined(node.prevY)) {\n                    node.prevY = node.plotY;\n                }\n                node.dispX = 0;\n                node.dispY = 0;\n            }\n        }\n        else if (initialPositions === 'circle') {\n            this.setCircularPositions();\n        }\n        else {\n            this.setRandomPositions();\n        }\n    }\n    setCircularPositions() {\n        const box = this.box, nodes = this.nodes, nodesLength = nodes.length + 1, angle = 2 * Math.PI / nodesLength, rootNodes = nodes.filter(function (node) {\n            return node.linksTo.length === 0;\n        }), visitedNodes = {}, radius = this.options.initialPositionRadius, addToNodes = (node) => {\n            for (const link of node.linksFrom || []) {\n                if (!visitedNodes[link.toNode.id]) {\n                    visitedNodes[link.toNode.id] = true;\n                    sortedNodes.push(link.toNode);\n                    addToNodes(link.toNode);\n                }\n            }\n        };\n        let sortedNodes = [];\n        // Start with identified root nodes an sort the nodes by their\n        // hierarchy. In trees, this ensures that branches don't cross\n        // eachother.\n        for (const rootNode of rootNodes) {\n            sortedNodes.push(rootNode);\n            addToNodes(rootNode);\n        }\n        // Cyclic tree, no root node found\n        if (!sortedNodes.length) {\n            sortedNodes = nodes;\n            // Dangling, cyclic trees\n        }\n        else {\n            for (const node of nodes) {\n                if (sortedNodes.indexOf(node) === -1) {\n                    sortedNodes.push(node);\n                }\n            }\n        }\n        let node;\n        // Initial positions are laid out along a small circle, appearing\n        // as a cluster in the middle\n        for (let i = 0, iEnd = sortedNodes.length; i < iEnd; ++i) {\n            node = sortedNodes[i];\n            node.plotX = node.prevX = pick(node.plotX, box.width / 2 + radius * Math.cos(i * angle));\n            node.plotY = node.prevY = pick(node.plotY, box.height / 2 + radius * Math.sin(i * angle));\n            node.dispX = 0;\n            node.dispY = 0;\n        }\n    }\n    setRandomPositions() {\n        const box = this.box, nodes = this.nodes, nodesLength = nodes.length + 1, \n        /**\n         * Return a repeatable, quasi-random number based on an integer\n         * input. For the initial positions\n         * @private\n         */\n        unrandom = (n) => {\n            let rand = n * n / Math.PI;\n            rand = rand - Math.floor(rand);\n            return rand;\n        };\n        let node;\n        // Initial positions:\n        for (let i = 0, iEnd = nodes.length; i < iEnd; ++i) {\n            node = nodes[i];\n            node.plotX = node.prevX = pick(node.plotX, box.width * unrandom(i));\n            node.plotY = node.prevY = pick(node.plotY, box.height * unrandom(nodesLength + i));\n            node.dispX = 0;\n            node.dispY = 0;\n        }\n    }\n    force(name, ...args) {\n        this.integration[name].apply(this, args);\n    }\n    barycenterForces() {\n        this.getBarycenter();\n        this.force('barycenter');\n    }\n    getBarycenter() {\n        let systemMass = 0, cx = 0, cy = 0;\n        for (const node of this.nodes) {\n            cx += node.plotX * node.mass;\n            cy += node.plotY * node.mass;\n            systemMass += node.mass;\n        }\n        this.barycenter = {\n            x: cx,\n            y: cy,\n            xFactor: cx / systemMass,\n            yFactor: cy / systemMass\n        };\n        return this.barycenter;\n    }\n    barnesHutApproximation(node, quadNode) {\n        const distanceXY = this.getDistXY(node, quadNode), distanceR = this.vectorLength(distanceXY);\n        let goDeeper, force;\n        if (node !== quadNode && distanceR !== 0) {\n            if (quadNode.isInternal) {\n                // Internal node:\n                if (quadNode.boxSize / distanceR <\n                    this.options.theta &&\n                    distanceR !== 0) {\n                    // Treat as an external node:\n                    force = this.repulsiveForce(distanceR, this.k);\n                    this.force('repulsive', node, force * quadNode.mass, distanceXY, distanceR);\n                    goDeeper = false;\n                }\n                else {\n                    // Go deeper:\n                    goDeeper = true;\n                }\n            }\n            else {\n                // External node, direct force:\n                force = this.repulsiveForce(distanceR, this.k);\n                this.force('repulsive', node, force * quadNode.mass, distanceXY, distanceR);\n            }\n        }\n        return goDeeper;\n    }\n    repulsiveForces() {\n        if (this.approximation === 'barnes-hut') {\n            for (const node of this.nodes) {\n                this.quadTree.visitNodeRecursive(null, (quadNode) => (this.barnesHutApproximation(node, quadNode)));\n            }\n        }\n        else {\n            let force, distanceR, distanceXY;\n            for (const node of this.nodes) {\n                for (const repNode of this.nodes) {\n                    if (\n                    // Node cannot repulse itself:\n                    node !== repNode &&\n                        // Only close nodes affect each other:\n                        // layout.getDistR(node, repNode) < 2 * k &&\n                        // Not dragged:\n                        !node.fixedPosition) {\n                        distanceXY = this.getDistXY(node, repNode);\n                        distanceR = this.vectorLength(distanceXY);\n                        if (distanceR !== 0) {\n                            force = this.repulsiveForce(distanceR, this.k);\n                            this.force('repulsive', node, force * repNode.mass, distanceXY, distanceR);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    attractiveForces() {\n        let distanceXY, distanceR, force;\n        for (const link of this.links) {\n            if (link.fromNode && link.toNode) {\n                distanceXY = this.getDistXY(link.fromNode, link.toNode);\n                distanceR = this.vectorLength(distanceXY);\n                if (distanceR !== 0) {\n                    force = this.attractiveForce(distanceR, this.k);\n                    this.force('attractive', link, force, distanceXY, distanceR);\n                }\n            }\n        }\n    }\n    applyLimits() {\n        const nodes = this.nodes;\n        for (const node of nodes) {\n            if (node.fixedPosition) {\n                continue;\n            }\n            this.integration.integrate(this, node);\n            this.applyLimitBox(node, this.box);\n            // Reset displacement:\n            node.dispX = 0;\n            node.dispY = 0;\n        }\n    }\n    /**\n     * External box that nodes should fall. When hitting an edge, node\n     * should stop or bounce.\n     * @private\n     */\n    applyLimitBox(node, box) {\n        const radius = node.radius;\n        /*\n        TO DO: Consider elastic collision instead of stopping.\n        o' means end position when hitting plotting area edge:\n\n        - \"inelastic\":\n        o\n            \\\n        ______\n        |  o'\n        |   \\\n        |    \\\n\n        - \"elastic\"/\"bounced\":\n        o\n            \\\n        ______\n        |  ^\n        | / \\\n        |o'  \\\n\n        Euler sample:\n        if (plotX < 0) {\n            plotX = 0;\n            dispX *= -1;\n        }\n\n        if (plotX > box.width) {\n            plotX = box.width;\n            dispX *= -1;\n        }\n\n        */\n        // Limit X-coordinates:\n        node.plotX = clamp(node.plotX, box.left + radius, box.width - radius);\n        // Limit Y-coordinates:\n        node.plotY = clamp(node.plotY, box.top + radius, box.height - radius);\n    }\n    /**\n     * From \"A comparison of simulated annealing cooling strategies\" by\n     * Nourani and Andresen work.\n     * @private\n     */\n    coolDown(temperature, temperatureStep, currentStep) {\n        // Logarithmic:\n        /*\n        return Math.sqrt(this.nodes.length) -\n            Math.log(\n                currentStep * layout.diffTemperature\n            );\n        */\n        // Exponential:\n        /*\n        let alpha = 0.1;\n        layout.temperature = Math.sqrt(layout.nodes.length) *\n            Math.pow(alpha, layout.diffTemperature);\n        */\n        // Linear:\n        return temperature - temperatureStep * currentStep;\n    }\n    isStable() {\n        return Math.abs(this.systemTemperature -\n            this.prevSystemTemperature) < 0.00001 || this.temperature <= 0;\n    }\n    getSystemTemperature() {\n        let value = 0;\n        for (const node of this.nodes) {\n            value += node.temperature;\n        }\n        return value;\n    }\n    vectorLength(vector) {\n        return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n    }\n    getDistR(nodeA, nodeB) {\n        const distance = this.getDistXY(nodeA, nodeB);\n        return this.vectorLength(distance);\n    }\n    getDistXY(nodeA, nodeB) {\n        const xDist = nodeA.plotX - nodeB.plotX, yDist = nodeA.plotY - nodeB.plotY;\n        return {\n            x: xDist,\n            y: yDist,\n            absX: Math.abs(xDist),\n            absY: Math.abs(yDist)\n        };\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nexport default ReingoldFruchtermanLayout;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7837, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubbleLayout.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Grzegorz Blachlinski, Sebastian Bochan\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport GraphLayout from '../GraphLayoutComposition.js';\nimport PackedBubbleIntegration from './PackedBubbleIntegration.js';\nimport ReingoldFruchtermanLayout from '../Networkgraph/ReingoldFruchtermanLayout.js';\nimport U from '../../Core/Utilities.js';\nconst { addEvent, defined, pick } = U;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * @private\n */\nfunction chartGetSelectedParentNodes() {\n    const allSeries = this.series, selectedParentsNodes = [];\n    allSeries.forEach((series) => {\n        if (series.parentNode && series.parentNode.selected) {\n            selectedParentsNodes.push(series.parentNode);\n        }\n    });\n    return selectedParentsNodes;\n}\n/**\n * Remove accumulated data points to redistribute all of them again\n * (i.e after hiding series by legend)\n * @private\n */\nfunction onChartBeforeRedraw() {\n    if (this.allDataPoints) {\n        delete this.allDataPoints;\n    }\n}\n/* *\n *\n *  Class\n *\n * */\nclass PackedBubbleLayout extends ReingoldFruchtermanLayout {\n    constructor() {\n        /* *\n         *\n         *  Static Functions\n         *\n         * */\n        super(...arguments);\n        this.index = NaN;\n        this.nodes = [];\n        this.series = [];\n    }\n    static compose(ChartClass) {\n        ReingoldFruchtermanLayout.compose(ChartClass);\n        GraphLayout.integrations.packedbubble = PackedBubbleIntegration;\n        GraphLayout.layouts.packedbubble = PackedBubbleLayout;\n        const chartProto = ChartClass.prototype;\n        if (!chartProto.getSelectedParentNodes) {\n            addEvent(ChartClass, 'beforeRedraw', onChartBeforeRedraw);\n            chartProto.getSelectedParentNodes = chartGetSelectedParentNodes;\n        }\n        if (!chartProto.allParentNodes) {\n            chartProto.allParentNodes = [];\n        }\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    beforeStep() {\n        if (this.options.marker) {\n            this.series.forEach((series) => {\n                if (series) {\n                    series.calculateParentRadius();\n                }\n            });\n        }\n    }\n    // #14439, new stable check.\n    isStable() {\n        const tempDiff = Math.abs(this.prevSystemTemperature -\n            this.systemTemperature);\n        const upScaledTemperature = 10 * this.systemTemperature /\n            Math.sqrt(this.nodes.length);\n        return Math.abs(upScaledTemperature) < 1 &&\n            tempDiff < 0.00001 ||\n            this.temperature <= 0;\n    }\n    setCircularPositions() {\n        const layout = this, box = layout.box, nodes = [\n            ...layout.nodes,\n            ...layout?.chart?.allParentNodes || []\n        ], nodesLength = nodes.length + 1, angle = 2 * Math.PI / nodesLength, radius = layout.options.initialPositionRadius;\n        let centerX, centerY, index = 0;\n        for (const node of nodes) {\n            if (this.resolveSplitSeries(node) &&\n                !node.isParentNode) {\n                centerX = node.series.parentNode.plotX;\n                centerY = node.series.parentNode.plotY;\n            }\n            else {\n                centerX = box.width / 2;\n                centerY = box.height / 2;\n            }\n            node.plotX = node.prevX = pick(node.plotX, centerX +\n                radius * Math.cos(node.index || index * angle));\n            node.plotY = node.prevY = pick(node.plotY, centerY +\n                radius * Math.sin(node.index || index * angle));\n            node.dispX = 0;\n            node.dispY = 0;\n            index++;\n        }\n    }\n    repulsiveForces() {\n        const layout = this, { options, k } = layout, { bubblePadding = 0, seriesInteraction } = options, nodes = [\n            ...layout.nodes,\n            ...layout?.chart?.allParentNodes || []\n        ];\n        for (const node of nodes) {\n            const nodeSeries = node.series, fixedPosition = node.fixedPosition, paddedNodeRadius = ((node.marker?.radius || 0) +\n                bubblePadding);\n            node.degree = node.mass;\n            node.neighbours = 0;\n            for (const repNode of nodes) {\n                const repNodeSeries = repNode.series;\n                if (\n                // Node cannot repulse itself:\n                node !== repNode &&\n                    // Not dragged:\n                    !fixedPosition &&\n                    (seriesInteraction || nodeSeries === repNodeSeries) &&\n                    // Avoiding collision of parentNodes and parented points\n                    !(nodeSeries === repNodeSeries &&\n                        (repNode.isParentNode || node.isParentNode))) {\n                    const distanceXY = layout.getDistXY(node, repNode), distanceR = (layout.vectorLength(distanceXY) -\n                        (paddedNodeRadius + (repNode.marker?.radius || 0)));\n                    let forceTimesMass;\n                    // TODO padding configurable\n                    if (distanceR < 0) {\n                        node.degree += 0.01;\n                        forceTimesMass = (layout.repulsiveForce(-distanceR / Math.sqrt(++(node.neighbours)), k, node, repNode) *\n                            repNode.mass);\n                    }\n                    layout.force('repulsive', node, forceTimesMass || 0, distanceXY, repNode, distanceR);\n                }\n            }\n        }\n    }\n    resolveSplitSeries(node) {\n        const specificSeriesOpt = node\n            .series\n            ?.options\n            ?.layoutAlgorithm\n            ?.splitSeries;\n        return (!defined(specificSeriesOpt) &&\n            node.series.chart\n                ?.options\n                ?.plotOptions\n                ?.packedbubble\n                ?.layoutAlgorithm\n                ?.splitSeries) ||\n            specificSeriesOpt ||\n            false;\n    }\n    applyLimitBox(node, box) {\n        const layout = this, factor = 0.01;\n        let distanceXY, distanceR;\n        // `parentNodeLimit` should be used together with seriesInteraction:\n        // false\n        if (this.resolveSplitSeries(node) &&\n            !node.isParentNode &&\n            layout.options.parentNodeLimit) {\n            distanceXY = layout.getDistXY(node, node.series.parentNode);\n            distanceR = (node.series.parentNodeRadius -\n                node.marker.radius -\n                layout.vectorLength(distanceXY));\n            if (distanceR < 0 &&\n                distanceR > -2 * node.marker.radius) {\n                node.plotX -= distanceXY.x * factor;\n                node.plotY -= distanceXY.y * factor;\n            }\n        }\n        super.applyLimitBox(node, box);\n    }\n}\n/* *\n *\n *  Registry\n *\n * */\nGraphLayout.layouts.packedbubble = PackedBubbleLayout;\n/* *\n *\n *  Default Export\n *\n * */\nexport default PackedBubbleLayout;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8009, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/SimulationSeriesUtilities.js"],"sourcesContent":["/* *\n *\n *\n * */\n'use strict';\nimport U from '../Core/Utilities.js';\nconst { syncTimeout } = U;\nimport A from '../Core/Animation/AnimationUtilities.js';\nconst { animObject } = A;\n/**\n * Create a setTimeout for the first drawDataLabels()\n * based on the dataLabels.animation.defer value\n * for series which have enabled simulation.\n * @private\n */\nfunction initDataLabelsDefer() {\n    const dlOptions = this.options.dataLabels;\n    // Method drawDataLabels() fires for the first time after\n    // dataLabels.animation.defer time unless\n    // the dataLabels.animation = false or dataLabels.defer = false\n    // or if the simulation is disabled\n    if (!dlOptions?.defer ||\n        !this.options.layoutAlgorithm?.enableSimulation) {\n        this.deferDataLabels = false;\n    }\n    else {\n        syncTimeout(() => {\n            this.deferDataLabels = false;\n        }, dlOptions ? animObject(dlOptions.animation).defer : 0);\n    }\n}\n/**\n * Initialize the SVG group for the DataLabels with correct opacities\n * and correct styles so that the animation for the series that have\n * simulation enabled works fine.\n * @private\n */\nfunction initDataLabels() {\n    const series = this, dlOptions = series.options.dataLabels;\n    if (!series.dataLabelsGroup) {\n        // Those series support only one group of data labels (index 0)\n        const dataLabelsGroup = this.initDataLabelsGroup(0, dlOptions);\n        // Apply the dataLabels.style not only to the\n        // individual dataLabels but also to the entire group\n        if (!series.chart.styledMode && dlOptions?.style) {\n            dataLabelsGroup.css(dlOptions.style);\n        }\n        // Initialize the opacity of the group to 0 (start of animation)\n        dataLabelsGroup.attr({ opacity: 0 });\n        if (series.visible) { // #2597, #3023, #3024\n            // #19663, initial data labels animation\n            if (series.options.animation && dlOptions?.animation) {\n                dataLabelsGroup.animate({ opacity: 1 }, dlOptions.animation);\n            }\n            else {\n                dataLabelsGroup.attr({ opacity: 1 });\n            }\n            dataLabelsGroup.show();\n        }\n        return dataLabelsGroup;\n    }\n    // Place it on first and subsequent (redraw) calls\n    series.dataLabelsGroup.attr({\n        opacity: 1,\n        ...this.getPlotBox('data-labels')\n    });\n    return series.dataLabelsGroup;\n}\nconst DataLabelsDeferUtils = {\n    initDataLabels,\n    initDataLabelsDefer\n};\nexport default DataLabelsDeferUtils;\n"],"names":[],"mappings":";;;;AAKA;AAEA;AAPA;;;GAGG,GACH;;AAEA,MAAM,EAAE,WAAW,EAAE,GAAG,8KAAC;;AAEzB,MAAM,EAAE,UAAU,EAAE,GAAG,oMAAC;AACxB;;;;;CAKC,GACD,SAAS;IACL,MAAM,YAAY,IAAI,CAAC,OAAO,CAAC,UAAU;IACzC,yDAAyD;IACzD,yCAAyC;IACzC,+DAA+D;IAC/D,mCAAmC;IACnC,IAAI,CAAC,WAAW,SACZ,CAAC,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE,kBAAkB;QACjD,IAAI,CAAC,eAAe,GAAG;IAC3B,OACK;QACD,YAAY;YACR,IAAI,CAAC,eAAe,GAAG;QAC3B,GAAG,YAAY,WAAW,UAAU,SAAS,EAAE,KAAK,GAAG;IAC3D;AACJ;AACA;;;;;CAKC,GACD,SAAS;IACL,MAAM,SAAS,IAAI,EAAE,YAAY,OAAO,OAAO,CAAC,UAAU;IAC1D,IAAI,CAAC,OAAO,eAAe,EAAE;QACzB,+DAA+D;QAC/D,MAAM,kBAAkB,IAAI,CAAC,mBAAmB,CAAC,GAAG;QACpD,6CAA6C;QAC7C,qDAAqD;QACrD,IAAI,CAAC,OAAO,KAAK,CAAC,UAAU,IAAI,WAAW,OAAO;YAC9C,gBAAgB,GAAG,CAAC,UAAU,KAAK;QACvC;QACA,gEAAgE;QAChE,gBAAgB,IAAI,CAAC;YAAE,SAAS;QAAE;QAClC,IAAI,OAAO,OAAO,EAAE;YAChB,wCAAwC;YACxC,IAAI,OAAO,OAAO,CAAC,SAAS,IAAI,WAAW,WAAW;gBAClD,gBAAgB,OAAO,CAAC;oBAAE,SAAS;gBAAE,GAAG,UAAU,SAAS;YAC/D,OACK;gBACD,gBAAgB,IAAI,CAAC;oBAAE,SAAS;gBAAE;YACtC;YACA,gBAAgB,IAAI;QACxB;QACA,OAAO;IACX;IACA,kDAAkD;IAClD,OAAO,eAAe,CAAC,IAAI,CAAC;QACxB,SAAS;QACT,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc;IACrC;IACA,OAAO,OAAO,eAAe;AACjC;AACA,MAAM,uBAAuB;IACzB;IACA;AACJ;uCACe","ignoreList":[0]}},
    {"offset": {"line": 8092, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubbleSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Grzegorz Blachlinski, Sebastian Bochan\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport Color from '../../Core/Color/Color.js';\nconst { parse: color } = Color;\nimport DragNodesComposition from '../DragNodesComposition.js';\nimport GraphLayout from '../GraphLayoutComposition.js';\nimport H from '../../Core/Globals.js';\nconst { noop } = H;\nimport PackedBubblePoint from './PackedBubblePoint.js';\nimport PackedBubbleSeriesDefaults from './PackedBubbleSeriesDefaults.js';\nimport PackedBubbleLayout from './PackedBubbleLayout.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { series: { prototype: seriesProto }, seriesTypes: { bubble: BubbleSeries } } = SeriesRegistry;\nimport D from '../SimulationSeriesUtilities.js';\nconst { initDataLabels, initDataLabelsDefer } = D;\nimport U from '../../Core/Utilities.js';\nconst { addEvent, clamp, defined, extend, fireEvent, isArray, isNumber, merge, pick } = U;\nimport SVGElement from '../../Core/Renderer/SVG/SVGElement.js';\nimport TextPath from '../../Extensions/TextPath.js';\nTextPath.compose(SVGElement);\n/* *\n *\n *  Class\n *\n * */\n/**\n * @private\n * @class\n * @name Highcharts.seriesTypes.packedbubble\n *\n * @extends Highcharts.Series\n */\nclass PackedBubbleSeries extends BubbleSeries {\n    constructor() {\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        super(...arguments);\n        this.parentNodeMass = 0;\n        this.deferDataLabels = true;\n        /* eslint-enable valid-jsdoc */\n    }\n    /* *\n     *\n     *  Static Functions\n     *\n     * */\n    static compose(AxisClass, ChartClass, LegendClass) {\n        BubbleSeries.compose(AxisClass, ChartClass, LegendClass);\n        DragNodesComposition.compose(ChartClass);\n        PackedBubbleLayout.compose(ChartClass);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * Create a single array of all points from all series\n     * @private\n     */\n    accumulateAllPoints() {\n        const chart = this.chart, allDataPoints = [];\n        for (const series of chart.series) {\n            if (series.is('packedbubble') && // #13574\n                series.reserveSpace()) {\n                const valueData = series.getColumn('value');\n                // Add data to array only if series is visible\n                for (let j = 0; j < valueData.length; j++) {\n                    allDataPoints.push([\n                        null, null,\n                        valueData[j],\n                        series.index,\n                        j,\n                        {\n                            id: j,\n                            marker: {\n                                radius: 0\n                            }\n                        }\n                    ]);\n                }\n            }\n        }\n        return allDataPoints;\n    }\n    /**\n     * Adding the basic layout to series points.\n     * @private\n     */\n    addLayout() {\n        const layoutOptions = this.options.layoutAlgorithm =\n            this.options.layoutAlgorithm || {}, layoutType = layoutOptions.type || 'packedbubble', chartOptions = this.chart.options.chart;\n        let graphLayoutsStorage = this.chart.graphLayoutsStorage, graphLayoutsLookup = this.chart.graphLayoutsLookup, layout;\n        if (!graphLayoutsStorage) {\n            this.chart.graphLayoutsStorage = graphLayoutsStorage = {};\n            this.chart.graphLayoutsLookup = graphLayoutsLookup = [];\n        }\n        layout = graphLayoutsStorage[layoutType];\n        if (!layout) {\n            layoutOptions.enableSimulation =\n                !defined(chartOptions.forExport) ?\n                    layoutOptions.enableSimulation :\n                    !chartOptions.forExport;\n            graphLayoutsStorage[layoutType] = layout =\n                new GraphLayout.layouts[layoutType]();\n            layout.init(layoutOptions);\n            graphLayoutsLookup.splice(layout.index, 0, layout);\n        }\n        this.layout = layout;\n        this.points.forEach((node) => {\n            node.mass = 2;\n            node.degree = 1;\n            node.collisionNmb = 1;\n        });\n        layout.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight);\n        layout.addElementsToCollection([this], layout.series);\n        layout.addElementsToCollection(this.points, layout.nodes);\n    }\n    /**\n     * Function responsible for adding series layout, used for parent nodes.\n     * @private\n     */\n    addSeriesLayout() {\n        const layoutOptions = this.options.layoutAlgorithm =\n            this.options.layoutAlgorithm || {}, layoutType = (layoutOptions.type || 'packedbubble'), graphLayoutsStorage = this.chart.graphLayoutsStorage, graphLayoutsLookup = this.chart.graphLayoutsLookup, parentNodeOptions = merge(layoutOptions, layoutOptions.parentNodeOptions, {\n            enableSimulation: this.layout.options.enableSimulation\n        });\n        let seriesLayout = graphLayoutsStorage[layoutType + '-series'];\n        if (!seriesLayout) {\n            graphLayoutsStorage[layoutType + '-series'] = seriesLayout =\n                new GraphLayout.layouts[layoutType]();\n            seriesLayout.init(parentNodeOptions);\n            graphLayoutsLookup.splice(seriesLayout.index, 0, seriesLayout);\n        }\n        this.parentNodeLayout = seriesLayout;\n        this.createParentNodes();\n    }\n    /**\n     * The function responsible for calculating the parent node radius\n     * based on the total surface of inside-bubbles and the group BBox\n     * @private\n     */\n    calculateParentRadius() {\n        const bBox = this.seriesBox(), parentPadding = 20, minParentRadius = 20;\n        this.parentNodeRadius = clamp(Math.sqrt(2 * this.parentNodeMass / Math.PI) + parentPadding, minParentRadius, bBox ?\n            Math.max(Math.sqrt(Math.pow(bBox.width, 2) +\n                Math.pow(bBox.height, 2)) / 2 + parentPadding, minParentRadius) :\n            Math.sqrt(2 * this.parentNodeMass / Math.PI) + parentPadding);\n        if (this.parentNode) {\n            this.parentNode.marker.radius =\n                this.parentNode.radius = this.parentNodeRadius;\n        }\n    }\n    /**\n     * Calculate min and max bubble value for radius calculation.\n     * @private\n     */\n    calculateZExtremes() {\n        const chart = this.chart, allSeries = chart.series;\n        let zMin = this.options.zMin, zMax = this.options.zMax, valMin = Infinity, valMax = -Infinity;\n        if (zMin && zMax) {\n            return [zMin, zMax];\n        }\n        // It is needed to deal with null and undefined values\n        allSeries.forEach((series) => {\n            series.getColumn('value').forEach((y) => {\n                if (defined(y)) {\n                    if (y > valMax) {\n                        valMax = y;\n                    }\n                    if (y < valMin) {\n                        valMin = y;\n                    }\n                }\n            });\n        });\n        zMin = pick(zMin, valMin);\n        zMax = pick(zMax, valMax);\n        return [zMin, zMax];\n    }\n    /**\n     * Check if two bubbles overlaps.\n     * @private\n     */\n    checkOverlap(bubble1, bubble2) {\n        const diffX = bubble1[0] - bubble2[0], // Diff of X center values\n        diffY = bubble1[1] - bubble2[1], // Diff of Y center values\n        sumRad = bubble1[2] + bubble2[2]; // Sum of bubble radius\n        return (Math.sqrt(diffX * diffX + diffY * diffY) -\n            Math.abs(sumRad)) < -0.001;\n    }\n    /**\n     * Creating parent nodes for split series, in which all the bubbles\n     * are rendered.\n     * @private\n     */\n    createParentNodes() {\n        const PackedBubblePoint = this.pointClass, chart = this.chart, parentNodeLayout = this.parentNodeLayout, layoutOptions = this.layout.options;\n        let nodeAdded, parentNode = this.parentNode, parentMarkerOptions = {\n            radius: this.parentNodeRadius,\n            lineColor: this.color,\n            fillColor: color(this.color).brighten(0.4).get()\n        };\n        if (layoutOptions.parentNodeOptions) {\n            parentMarkerOptions = merge(layoutOptions.parentNodeOptions.marker || {}, parentMarkerOptions);\n        }\n        this.parentNodeMass = 0;\n        this.points.forEach((p) => {\n            this.parentNodeMass +=\n                Math.PI * Math.pow(p.marker.radius, 2);\n        });\n        this.calculateParentRadius();\n        parentNodeLayout.nodes\n            .forEach((node) => {\n            if (node.seriesIndex === this.index) {\n                nodeAdded = true;\n            }\n        });\n        parentNodeLayout.setArea(0, 0, chart.plotWidth, chart.plotHeight);\n        if (!nodeAdded) {\n            if (!parentNode) {\n                parentNode = new PackedBubblePoint(this, {\n                    mass: this.parentNodeRadius / 2,\n                    marker: parentMarkerOptions,\n                    dataLabels: {\n                        inside: false\n                    },\n                    states: {\n                        normal: {\n                            marker: parentMarkerOptions\n                        },\n                        hover: {\n                            marker: parentMarkerOptions\n                        }\n                    },\n                    dataLabelOnNull: true,\n                    degree: this.parentNodeRadius,\n                    isParentNode: true,\n                    seriesIndex: this.index\n                });\n                this.chart.allParentNodes.push(parentNode);\n            }\n            if (this.parentNode) {\n                parentNode.plotX = this.parentNode.plotX;\n                parentNode.plotY = this.parentNode.plotY;\n            }\n            this.parentNode = parentNode;\n            parentNodeLayout.addElementsToCollection([this], parentNodeLayout.series);\n            parentNodeLayout.addElementsToCollection([parentNode], parentNodeLayout.nodes);\n        }\n    }\n    /**\n     * Function responsible for adding all the layouts to the chart.\n     * @private\n     */\n    deferLayout() {\n        // TODO split layouts to independent methods\n        const layoutOptions = this.options.layoutAlgorithm;\n        if (!this.visible) {\n            return;\n        }\n        // Layout is using nodes for position calculation\n        this.addLayout();\n        if (layoutOptions.splitSeries) {\n            this.addSeriesLayout();\n        }\n    }\n    destroy() {\n        // Remove the series from all layouts series collections #11469\n        if (this.chart.graphLayoutsLookup) {\n            this.chart.graphLayoutsLookup.forEach((layout) => {\n                layout.removeElementFromCollection(this, layout.series);\n            }, this);\n        }\n        if (this.parentNode &&\n            this.parentNodeLayout) {\n            this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes);\n            if (this.parentNode.dataLabel) {\n                this.parentNode.dataLabel =\n                    this.parentNode.dataLabel.destroy();\n            }\n        }\n        seriesProto.destroy.apply(this, arguments);\n    }\n    /**\n     * Packedbubble has two separate collections of nodes if split, render\n     * dataLabels for both sets:\n     * @private\n     */\n    drawDataLabels() {\n        // We defer drawing the dataLabels\n        // until dataLabels.animation.defer time passes\n        if (this.deferDataLabels) {\n            return;\n        }\n        seriesProto.drawDataLabels.call(this, this.points);\n        // Render parentNode labels:\n        if (this.parentNode) {\n            this.parentNode.formatPrefix = 'parentNode';\n            seriesProto.drawDataLabels.call(this, [this.parentNode]);\n        }\n    }\n    /**\n     * Create Background/Parent Nodes for split series.\n     * @private\n     */\n    drawGraph() {\n        // If the series is not using layout, don't add parent nodes\n        if (!this.layout || !this.layout.options.splitSeries) {\n            return;\n        }\n        const chart = this.chart, nodeMarker = this.layout.options.parentNodeOptions.marker, parentOptions = {\n            fill: (nodeMarker.fillColor ||\n                color(this.color).brighten(0.4).get()),\n            opacity: nodeMarker.fillOpacity,\n            stroke: nodeMarker.lineColor || this.color,\n            'stroke-width': pick(nodeMarker.lineWidth, this.options.lineWidth)\n        };\n        let parentAttribs = {};\n        // Create the group for parent Nodes if doesn't exist\n        // If exists it will only be adjusted to the updated plot size (#12063)\n        this.parentNodesGroup = this.plotGroup('parentNodesGroup', 'parentNode', this.visible ? 'inherit' : 'hidden', 0.1, chart.seriesGroup);\n        this.group?.attr({\n            zIndex: 2\n        });\n        this.calculateParentRadius();\n        if (this.parentNode &&\n            defined(this.parentNode.plotX) &&\n            defined(this.parentNode.plotY) &&\n            defined(this.parentNodeRadius)) {\n            parentAttribs = merge({\n                x: this.parentNode.plotX -\n                    this.parentNodeRadius,\n                y: this.parentNode.plotY -\n                    this.parentNodeRadius,\n                width: this.parentNodeRadius * 2,\n                height: this.parentNodeRadius * 2\n            }, parentOptions);\n            if (!this.parentNode.graphic) {\n                this.graph = this.parentNode.graphic =\n                    chart.renderer.symbol(parentOptions.symbol)\n                        .add(this.parentNodesGroup);\n            }\n            this.parentNode.graphic.attr(parentAttribs);\n        }\n    }\n    drawTracker() {\n        const parentNode = this.parentNode;\n        // Chart = series.chart,\n        // pointer = chart.pointer,\n        // onMouseOver = function (e: PointerEvent): void {\n        //     const point = pointer.getPointFromEvent(e);\n        //     // undefined on graph in scatterchart\n        //     if (typeof point !== 'undefined') {\n        //         pointer.isDirectTouch = true;\n        //         point.onMouseOver(e);\n        //     }\n        // };\n        let dataLabels;\n        super.drawTracker();\n        // Add reference to the point\n        if (parentNode) {\n            dataLabels = (isArray(parentNode.dataLabels) ?\n                parentNode.dataLabels :\n                (parentNode.dataLabel ? [parentNode.dataLabel] : []));\n            if (parentNode.graphic) {\n                parentNode.graphic.element.point = parentNode;\n            }\n            dataLabels.forEach((dataLabel) => {\n                (dataLabel.div || dataLabel.element).point = parentNode;\n            });\n        }\n    }\n    /**\n     * Calculate radius of bubbles in series.\n     * @private\n     */\n    getPointRadius() {\n        const chart = this.chart, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, seriesOptions = this.options, useSimulation = seriesOptions.useSimulation, smallestSize = Math.min(plotWidth, plotHeight), extremes = {}, radii = [], allDataPoints = chart.allDataPoints || [], allDataPointsLength = allDataPoints.length;\n        let minSize, maxSize, value, radius;\n        ['minSize', 'maxSize'].forEach((prop) => {\n            const length = parseInt(seriesOptions[prop], 10), isPercent = /%$/.test(seriesOptions[prop]);\n            extremes[prop] = isPercent ?\n                smallestSize * length / 100 :\n                length * Math.sqrt(allDataPointsLength);\n        });\n        chart.minRadius = minSize = extremes.minSize /\n            Math.sqrt(allDataPointsLength);\n        chart.maxRadius = maxSize = extremes.maxSize /\n            Math.sqrt(allDataPointsLength);\n        const zExtremes = useSimulation ?\n            this.calculateZExtremes() :\n            [minSize, maxSize];\n        allDataPoints.forEach((point, i) => {\n            value = useSimulation ?\n                clamp(point[2], zExtremes[0], zExtremes[1]) :\n                point[2];\n            radius = this.getRadius(zExtremes[0], zExtremes[1], minSize, maxSize, value);\n            if (radius === 0) {\n                radius = null;\n            }\n            allDataPoints[i][2] = radius;\n            radii.push(radius);\n        });\n        this.radii = radii;\n    }\n    init() {\n        seriesProto.init.apply(this, arguments);\n        initDataLabelsDefer.call(this);\n        /* eslint-disable no-invalid-this */\n        // When one series is modified, the others need to be recomputed\n        this.eventsToUnbind.push(addEvent(this, 'updatedData', function () {\n            this.chart.series.forEach((s) => {\n                if (s.type === this.type) {\n                    s.isDirty = true;\n                }\n            }, this);\n        }));\n        /* eslint-enable no-invalid-this */\n        return this;\n    }\n    /**\n     * Mouse up action, finalizing drag&drop.\n     * @private\n     * @param {Highcharts.Point} point The point that event occurred.\n     */\n    onMouseUp(dnPoint) {\n        const point = dnPoint;\n        if (point.fixedPosition && !point.removed) {\n            const layout = this.layout, parentNodeLayout = this.parentNodeLayout;\n            let distanceXY, distanceR;\n            if (!point.isParentNode &&\n                parentNodeLayout &&\n                layout.options.dragBetweenSeries) {\n                parentNodeLayout.nodes.forEach((node) => {\n                    if (point && point.marker &&\n                        node !== point.series.parentNode) {\n                        distanceXY = layout.getDistXY(point, node);\n                        distanceR = (layout.vectorLength(distanceXY) -\n                            node.marker.radius -\n                            point.marker.radius);\n                        if (distanceR < 0) {\n                            node.series.addPoint(merge(point.options, {\n                                plotX: point.plotX,\n                                plotY: point.plotY\n                            }), false);\n                            layout.removeElementFromCollection(point, layout.nodes);\n                            point.remove();\n                        }\n                    }\n                });\n            }\n            DragNodesComposition.onMouseUp.apply(this, arguments);\n        }\n    }\n    /**\n     * This is the main function responsible\n     * for positioning all of the bubbles\n     * allDataPoints - bubble array, in format [pixel x value,\n     * pixel y value, radius,\n     * related series index, related point index]\n     * @private\n     * @param {Array<Highcharts.PackedBubbleData>} allDataPoints All points from all series\n     * @return {Array<Highcharts.PackedBubbleData>} Positions of all bubbles\n     */\n    placeBubbles(allDataPoints) {\n        const checkOverlap = this.checkOverlap, positionBubble = this.positionBubble, bubblePos = [];\n        let stage = 1, j = 0, k = 0, calculatedBubble, arr = [], i;\n        // Sort all points\n        const sortedArr = allDataPoints.sort((a, b) => b[2] - a[2]);\n        if (sortedArr.length) {\n            // Create first bubble in the middle of the chart\n            bubblePos.push([\n                [\n                    0, // Starting in 0,0 coordinates\n                    0,\n                    sortedArr[0][2], // Radius\n                    sortedArr[0][3], // Series index\n                    sortedArr[0][4]\n                ] // Point index\n            ]); // 0 level bubble\n            if (sortedArr.length > 1) {\n                bubblePos.push([\n                    [\n                        0,\n                        (0 - sortedArr[1][2] -\n                            sortedArr[0][2]),\n                        // Move bubble above first one\n                        sortedArr[1][2],\n                        sortedArr[1][3],\n                        sortedArr[1][4]\n                    ]\n                ]); // 1 level 1st bubble\n                // first two already positioned so starting from 2\n                for (i = 2; i < sortedArr.length; i++) {\n                    sortedArr[i][2] = sortedArr[i][2] || 1;\n                    // In case if radius is calculated as 0.\n                    calculatedBubble = positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]); // Calculate initial bubble position\n                    if (checkOverlap(calculatedBubble, bubblePos[stage][0])) {\n                        /* If new bubble is overlapping with first bubble\n                            * in current level (stage)\n                            */\n                        bubblePos.push([]);\n                        k = 0;\n                        /* Reset index of bubble, used for\n                            * positioning the bubbles around it,\n                            * we are starting from first bubble in next\n                            * stage because we are changing level to higher\n                            */\n                        bubblePos[stage + 1].push(positionBubble(bubblePos[stage][j], bubblePos[stage][0], sortedArr[i]));\n                        // (last bubble, 1. from curr stage, new bubble)\n                        stage++; // The new level is created, above current\n                        j = 0; // Set the index of bubble in curr level to 0\n                    }\n                    else if (stage > 1 &&\n                        bubblePos[stage - 1][k + 1] &&\n                        checkOverlap(calculatedBubble, bubblePos[stage - 1][k + 1])) {\n                        /* If new bubble is overlapping with one of the prev\n                            * stage bubbles, it means that - bubble, used for\n                            * positioning the bubbles around it has changed\n                            * so we need to recalculate it\n                            */\n                        k++;\n                        bubblePos[stage].push(positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]));\n                        // (last bubble, prev stage bubble, new bubble)\n                        j++;\n                    }\n                    else { // Simply add calculated bubble\n                        j++;\n                        bubblePos[stage].push(calculatedBubble);\n                    }\n                }\n            }\n            this.chart.stages = bubblePos;\n            // It may not be necessary but adding it just in case -\n            // it is containing all of the bubble levels\n            this.chart.rawPositions =\n                []\n                    .concat.apply([], bubblePos);\n            // Bubble positions merged into one array\n            this.resizeRadius();\n            arr = this.chart.rawPositions;\n        }\n        return arr;\n    }\n    /**\n     * Function that checks for a parentMarker and sets the correct opacity.\n     * @private\n     * @param {Highcharts.Pack} point\n     * Candidate point for opacity correction.\n     * @param {string} [state]\n     * The point state, can be either `hover`, `select` or 'normal'. If\n     * undefined, normal state is assumed.\n     *\n     * @return {Highcharts.SVGAttributes}\n     * The presentational attributes to be set on the point.\n     */\n    pointAttribs(point, state) {\n        const options = this.options, hasParentMarker = point && point.isParentNode;\n        let markerOptions = options.marker;\n        if (hasParentMarker &&\n            options.layoutAlgorithm &&\n            options.layoutAlgorithm.parentNodeOptions) {\n            markerOptions = options.layoutAlgorithm.parentNodeOptions.marker;\n        }\n        const fillOpacity = markerOptions.fillOpacity, attr = seriesProto.pointAttribs.call(this, point, state);\n        if (fillOpacity !== 1) {\n            attr['fill-opacity'] = fillOpacity;\n        }\n        return attr;\n    }\n    /**\n     * Function that is adding one bubble based on positions and sizes of\n     * two other bubbles, lastBubble is the last added bubble, newOrigin is\n     * the bubble for positioning new bubbles. nextBubble is the currently\n     * added bubble for which we are calculating positions\n     * @private\n     * @param {Array<number>} lastBubble The closest last bubble\n     * @param {Array<number>} newOrigin New bubble\n     * @param {Array<number>} nextBubble The closest next bubble\n     * @return {Array<number>} Bubble with correct positions\n     */\n    positionBubble(lastBubble, newOrigin, nextBubble) {\n        const sqrt = Math.sqrt, asin = Math.asin, acos = Math.acos, pow = Math.pow, abs = Math.abs, distance = sqrt(// Dist between lastBubble and newOrigin\n        pow((lastBubble[0] - newOrigin[0]), 2) +\n            pow((lastBubble[1] - newOrigin[1]), 2)), alfa = acos(\n        // From cosinus theorem: alfa is an angle used for\n        // calculating correct position\n        (pow(distance, 2) +\n            pow(nextBubble[2] + newOrigin[2], 2) -\n            pow(nextBubble[2] + lastBubble[2], 2)) / (2 * (nextBubble[2] + newOrigin[2]) * distance)), beta = asin(// From sinus theorem.\n        abs(lastBubble[0] - newOrigin[0]) /\n            distance), \n        // Providing helping variables, related to angle between\n        // lastBubble and newOrigin\n        gamma = (lastBubble[1] - newOrigin[1]) < 0 ? 0 : Math.PI, \n        // If new origin y is smaller than last bubble y value\n        // (2 and 3 quarter),\n        // add Math.PI to final angle\n        delta = (lastBubble[0] - newOrigin[0]) *\n            (lastBubble[1] - newOrigin[1]) < 0 ?\n            1 : -1, // (1st and 3rd quarter)\n        finalAngle = gamma + alfa + beta * delta, cosA = Math.cos(finalAngle), sinA = Math.sin(finalAngle), posX = newOrigin[0] + (newOrigin[2] + nextBubble[2]) * sinA, \n        // Center of new origin + (radius1 + radius2) * sinus A\n        posY = newOrigin[1] - (newOrigin[2] + nextBubble[2]) * cosA;\n        return [\n            posX,\n            posY,\n            nextBubble[2],\n            nextBubble[3],\n            nextBubble[4]\n        ]; // The same as described before\n    }\n    render() {\n        const dataLabels = [];\n        seriesProto.render.apply(this, arguments);\n        // #10823 - dataLabels should stay visible\n        // when enabled allowOverlap.\n        if (!this.options.dataLabels.allowOverlap) {\n            this.data.forEach((point) => {\n                if (isArray(point.dataLabels)) {\n                    point.dataLabels.forEach((dataLabel) => {\n                        dataLabels.push(dataLabel);\n                    });\n                }\n            });\n            // Only hide overlapping dataLabels for layouts that\n            // use simulation. Spiral packedbubble don't need\n            // additional dataLabel hiding on every simulation step\n            if (this.options.useSimulation) {\n                this.chart.hideOverlappingLabels(dataLabels);\n            }\n        }\n    }\n    /**\n     * The function responsible for resizing the bubble radius.\n     * In shortcut: it is taking the initially\n     * calculated positions of bubbles. Then it is calculating the min max\n     * of both dimensions, creating something in shape of bBox.\n     * The comparison of bBox and the size of plotArea\n     * (later it may be also the size set by customer) is giving the\n     * value how to recalculate the radius so it will match the size\n     * @private\n     */\n    resizeRadius() {\n        const chart = this.chart, positions = chart.rawPositions, min = Math.min, max = Math.max, plotLeft = chart.plotLeft, plotTop = chart.plotTop, chartHeight = chart.plotHeight, chartWidth = chart.plotWidth;\n        let minX, maxX, minY, maxY, radius;\n        minX = minY = Number.POSITIVE_INFINITY; // Set initial values\n        maxX = maxY = Number.NEGATIVE_INFINITY;\n        for (const position of positions) {\n            radius = position[2];\n            minX = min(minX, position[0] - radius);\n            // (x center-radius) is the min x value used by specific bubble\n            maxX = max(maxX, position[0] + radius);\n            minY = min(minY, position[1] - radius);\n            maxY = max(maxY, position[1] + radius);\n        }\n        const bBox = [maxX - minX, maxY - minY], spaceRatio = [\n            (chartWidth - plotLeft) / bBox[0],\n            (chartHeight - plotTop) / bBox[1]\n        ], smallerDimension = min.apply([], spaceRatio);\n        if (Math.abs(smallerDimension - 1) > 1e-10) {\n            // If bBox is considered not the same width as possible size\n            for (const position of positions) {\n                position[2] *= smallerDimension;\n            }\n            this.placeBubbles(positions);\n        }\n        else {\n            /** If no radius recalculation is needed, we need to position\n             * the whole bubbles in center of chart plotarea\n             * for this, we are adding two parameters,\n             * diffY and diffX, that are related to differences\n             * between the initial center and the bounding box\n             */\n            chart.diffY = chartHeight / 2 +\n                plotTop - minY - (maxY - minY) / 2;\n            chart.diffX = chartWidth / 2 +\n                plotLeft - minX - (maxX - minX) / 2;\n        }\n    }\n    /**\n     * The function responsible for calculating series bubble' s bBox.\n     * Needed because of exporting failure when useSimulation\n     * is set to false\n     * @private\n     */\n    seriesBox() {\n        const chart = this.chart, data = this.data, max = Math.max, min = Math.min, bBox = [\n            chart.plotLeft,\n            chart.plotLeft + chart.plotWidth,\n            chart.plotTop,\n            chart.plotTop + chart.plotHeight\n        ];\n        let radius;\n        data.forEach((p) => {\n            if (defined(p.plotX) &&\n                defined(p.plotY) &&\n                p.marker.radius) {\n                radius = p.marker.radius;\n                bBox[0] = min(bBox[0], p.plotX - radius);\n                bBox[1] = max(bBox[1], p.plotX + radius);\n                bBox[2] = min(bBox[2], p.plotY - radius);\n                bBox[3] = max(bBox[3], p.plotY + radius);\n            }\n        });\n        return isNumber(bBox.width / bBox.height) ?\n            bBox :\n            null;\n    }\n    /**\n     * Needed because of z-indexing issue if point is added in series.group\n     * @private\n     */\n    setVisible() {\n        const series = this;\n        seriesProto.setVisible.apply(series, arguments);\n        if (series.parentNodeLayout && series.graph) {\n            if (series.visible) {\n                series.graph.show();\n                if (series.parentNode.dataLabel) {\n                    series.parentNode.dataLabel.show();\n                }\n            }\n            else {\n                series.graph.hide();\n                series.parentNodeLayout.removeElementFromCollection(series.parentNode, series.parentNodeLayout.nodes);\n                if (series.parentNode.dataLabel) {\n                    series.parentNode.dataLabel.hide();\n                }\n            }\n        }\n        else if (series.layout) {\n            if (series.visible) {\n                series.layout.addElementsToCollection(series.points, series.layout.nodes);\n            }\n            else {\n                series.points.forEach((node) => {\n                    series.layout.removeElementFromCollection(node, series.layout.nodes);\n                });\n            }\n        }\n    }\n    /**\n     * Extend the base translate method to handle bubble size,\n     * and correct positioning them.\n     * @private\n     */\n    translate() {\n        const chart = this.chart, data = this.data, index = this.index, useSimulation = this.options.useSimulation;\n        let point, radius, positions;\n        this.generatePoints();\n        // Merged data is an array with all of the data from all series\n        if (!defined(chart.allDataPoints)) {\n            chart.allDataPoints = this.accumulateAllPoints();\n            // Calculate radius for all added data\n            this.getPointRadius();\n        }\n        // After getting initial radius, calculate bubble positions\n        if (useSimulation) {\n            positions = chart.allDataPoints;\n        }\n        else {\n            positions = this.placeBubbles(chart.allDataPoints);\n            this.options.draggable = false;\n        }\n        // Set the shape and arguments to be picked up in drawPoints\n        for (const position of positions) {\n            if (position[3] === index) {\n                // Update the series points with the val from positions\n                // array\n                point = data[position[4]];\n                radius = pick(position[2], void 0);\n                if (!useSimulation) {\n                    point.plotX = (position[0] - chart.plotLeft +\n                        chart.diffX);\n                    point.plotY = (position[1] - chart.plotTop +\n                        chart.diffY);\n                }\n                if (isNumber(radius)) {\n                    point.marker = extend(point.marker, {\n                        radius,\n                        width: 2 * radius,\n                        height: 2 * radius\n                    });\n                    point.radius = radius;\n                }\n            }\n        }\n        if (useSimulation) {\n            this.deferLayout();\n        }\n        fireEvent(this, 'afterTranslate');\n    }\n}\nPackedBubbleSeries.defaultOptions = merge(BubbleSeries.defaultOptions, PackedBubbleSeriesDefaults);\nextend(PackedBubbleSeries.prototype, {\n    pointClass: PackedBubblePoint,\n    axisTypes: [],\n    directTouch: true,\n    forces: ['barycenter', 'repulsive'],\n    hasDraggableNodes: true,\n    invertible: false,\n    isCartesian: false,\n    noSharedTooltip: true,\n    pointArrayMap: ['value'],\n    pointValKey: 'value',\n    requireSorting: false,\n    trackerGroups: ['group', 'dataLabelsGroup', 'parentNodesGroup'],\n    initDataLabels: initDataLabels,\n    alignDataLabel: seriesProto.alignDataLabel,\n    indexateNodes: noop,\n    onMouseDown: DragNodesComposition.onMouseDown,\n    onMouseMove: DragNodesComposition.onMouseMove,\n    redrawHalo: DragNodesComposition.redrawHalo,\n    searchPoint: noop // Solving #12287\n});\nSeriesRegistry.registerSeriesType('packedbubble', PackedBubbleSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default PackedBubbleSeries;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8870, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Polygon/PolygonSeriesDefaults.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\n/* *\n *\n *  API Options\n *\n * */\n/**\n * A polygon series can be used to draw any freeform shape in the cartesian\n * coordinate system. A fill is applied with the `color` option, and\n * stroke is applied through `lineWidth` and `lineColor` options.\n *\n * @sample {highcharts} highcharts/demo/polygon/\n *         Polygon\n * @sample {highstock} highcharts/demo/polygon/\n *         Polygon\n *\n * @extends      plotOptions.scatter\n * @since        4.1.0\n * @excluding    jitter, softThreshold, threshold, cluster, boostThreshold,\n *               boostBlending\n * @product      highcharts highstock\n * @requires     highcharts-more\n * @optionparent plotOptions.polygon\n */\nconst PolygonSeriesDefaults = {\n    marker: {\n        enabled: false,\n        states: {\n            hover: {\n                enabled: false\n            }\n        }\n    },\n    stickyTracking: false,\n    tooltip: {\n        followPointer: true,\n        pointFormat: ''\n    },\n    trackByArea: true,\n    legendSymbol: 'rectangle'\n};\n/**\n * A `polygon` series. If the [type](#series.polygon.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.polygon\n * @excluding dataParser, dataURL, stack, boostThreshold, boostBlending\n * @product   highcharts highstock\n * @requires  highcharts-more\n * @apioption series.polygon\n */\n/**\n * An array of data points for the series. For the `polygon` series\n * type, points can be given in the following ways:\n *\n * 1. An array of numerical values. In this case, the numerical values will be\n *    interpreted as `y` options. The `x` values will be automatically\n *    calculated, either starting at 0 and incremented by 1, or from\n *    `pointStart` and `pointInterval` given in the series options. If the axis\n *    has categories, these will be used. Example:\n *    ```js\n *    data: [0, 5, 3, 5]\n *    ```\n *\n * 2. An array of arrays with 2 values. In this case, the values correspond to\n *    `x,y`. If the first value is a string, it is applied as the name of the\n *    point, and the `x` value is inferred.\n *    ```js\n *    data: [\n *        [0, 10],\n *        [1, 3],\n *        [2, 1]\n *    ]\n *    ```\n *\n * 3. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.polygon.turboThreshold), this option is not\n *    available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        y: 1,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        y: 8,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n * @extends   series.line.data\n * @product   highcharts highstock\n * @apioption series.polygon.data\n */\n''; // Keeps doclets above separate\n/* *\n *\n *  Default Export\n *\n * */\nexport default PolygonSeriesDefaults;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;GASG,GACH;AACA;;;;GAIG,GACH;;;;;;;;;;;;;;;;;CAiBC,GACD,MAAM,wBAAwB;IAC1B,QAAQ;QACJ,SAAS;QACT,QAAQ;YACJ,OAAO;gBACH,SAAS;YACb;QACJ;IACJ;IACA,gBAAgB;IAChB,SAAS;QACL,eAAe;QACf,aAAa;IACjB;IACA,aAAa;IACb,cAAc;AAClB;AACA;;;;;;;;;CASC,GACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0DC,GACD,IAAI,+BAA+B;uCAMpB","ignoreList":[0]}},
    {"offset": {"line": 8995, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Polygon/PolygonSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport H from '../../Core/Globals.js';\nconst { noop } = H;\nimport PolygonSeriesDefaults from './PolygonSeriesDefaults.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { area: AreaSeries, line: LineSeries, scatter: ScatterSeries } = SeriesRegistry.seriesTypes;\nimport U from '../../Core/Utilities.js';\nconst { extend, merge } = U;\n/* *\n *\n *  Class\n *\n * */\nclass PolygonSeries extends ScatterSeries {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    getGraphPath() {\n        const graphPath = LineSeries.prototype.getGraphPath.call(this);\n        let i = graphPath.length + 1;\n        // Close all segments\n        while (i--) {\n            if ((i === graphPath.length || graphPath[i][0] === 'M') && i > 0) {\n                graphPath.splice(i, 0, ['Z']);\n            }\n        }\n        this.areaPath = graphPath;\n        return graphPath;\n    }\n    drawGraph() {\n        // Hack into the fill logic in area.drawGraph\n        this.options.fillColor = this.color;\n        AreaSeries.prototype.drawGraph.call(this);\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nPolygonSeries.defaultOptions = merge(ScatterSeries.defaultOptions, PolygonSeriesDefaults);\nextend(PolygonSeries.prototype, {\n    type: 'polygon',\n    drawTracker: LineSeries.prototype.drawTracker,\n    setStackedPoints: noop // No stacking points on polygons (#5310)\n});\nSeriesRegistry.registerSeriesType('polygon', PolygonSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default PolygonSeries;\n"],"names":[],"mappings":";;;;AAWA;AAEA;AACA;AAEA;AAhBA;;;;;;;;;GASG,GACH;;AAEA,MAAM,EAAE,IAAI,EAAE,GAAG,4KAAC;;;AAGlB,MAAM,EAAE,MAAM,UAAU,EAAE,MAAM,UAAU,EAAE,SAAS,aAAa,EAAE,GAAG,6LAAc,CAAC,WAAW;;AAEjG,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,8KAAC;AAC3B;;;;GAIG,GACH,MAAM,sBAAsB;IACxB;;;;OAIG,GACH,eAAe;QACX,MAAM,YAAY,WAAW,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI;QAC7D,IAAI,IAAI,UAAU,MAAM,GAAG;QAC3B,qBAAqB;QACrB,MAAO,IAAK;YACR,IAAI,CAAC,MAAM,UAAU,MAAM,IAAI,SAAS,CAAC,EAAE,CAAC,EAAE,KAAK,GAAG,KAAK,IAAI,GAAG;gBAC9D,UAAU,MAAM,CAAC,GAAG,GAAG;oBAAC;iBAAI;YAChC;QACJ;QACA,IAAI,CAAC,QAAQ,GAAG;QAChB,OAAO;IACX;IACA,YAAY;QACR,6CAA6C;QAC7C,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,IAAI,CAAC,KAAK;QACnC,WAAW,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI;IAC5C;AACJ;AACA;;;;GAIG,GACH,cAAc,cAAc,GAAG,MAAM,cAAc,cAAc,EAAE,uMAAqB;AACxF,OAAO,cAAc,SAAS,EAAE;IAC5B,MAAM;IACN,aAAa,WAAW,SAAS,CAAC,WAAW;IAC7C,kBAAkB,KAAK,yCAAyC;AACpE;AACA,6LAAc,CAAC,kBAAkB,CAAC,WAAW;uCAM9B","ignoreList":[0]}},
    {"offset": {"line": 9065, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/PolarComposition.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport A from '../Core/Animation/AnimationUtilities.js';\nconst { animObject } = A;\nimport BorderRadius from '../Extensions/BorderRadius.js';\nconst { optionsToObject } = BorderRadius;\nimport D from '../Core/Defaults.js';\nconst { defaultOptions } = D;\nimport H from '../Core/Globals.js';\nconst { composed } = H;\nimport Series from '../Core/Series/Series.js';\nimport Pane from '../Extensions/Pane/Pane.js';\nimport RadialAxis from '../Core/Axis/RadialAxis.js';\nimport U from '../Core/Utilities.js';\nconst { addEvent, defined, find, isNumber, isObject, merge, pick, pushUnique, relativeLength, splat, uniqueKey, wrap } = U;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * @private\n */\nfunction clipCircle(renderer, x, y, r, innerR) {\n    const id = uniqueKey(), clipPath = renderer.createElement('clipPath').attr({\n        id: id\n    }).add(renderer.defs), wrapper = innerR ?\n        renderer.arc(x, y, r, innerR, 0, 2 * Math.PI).add(clipPath) :\n        renderer.circle(x, y, r).add(clipPath);\n    wrapper.id = id;\n    wrapper.clipPath = clipPath;\n    return wrapper;\n}\n/**\n * Find correct align and vertical align based on an angle in polar chart\n * @private\n */\nfunction findAlignments(angle, options) {\n    let align, verticalAlign;\n    if (options.align === null) {\n        if (angle > 20 && angle < 160) {\n            align = 'left'; // Right hemisphere\n        }\n        else if (angle > 200 && angle < 340) {\n            align = 'right'; // Left hemisphere\n        }\n        else {\n            align = 'center'; // Top or bottom\n        }\n        options.align = align;\n    }\n    if (options.verticalAlign === null) {\n        if (angle < 45 || angle > 315) {\n            verticalAlign = 'bottom'; // Top part\n        }\n        else if (angle > 135 && angle < 225) {\n            verticalAlign = 'top'; // Bottom part\n        }\n        else {\n            verticalAlign = 'middle'; // Left or right\n        }\n        options.verticalAlign = verticalAlign;\n    }\n    return options;\n}\n/**\n * #6212 Calculate connectors for spline series in polar chart.\n * @private\n * @param {boolean} calculateNeighbours\n *        Check if connectors should be calculated for neighbour points as\n *        well allows short recurrence\n */\nfunction getConnectors(segment, index, calculateNeighbours, connectEnds) {\n    const smoothing = 1.5, denom = smoothing + 1, addedNumber = connectEnds ? 1 : 0;\n    let i, leftContX, leftContY, rightContX, rightContY, jointAngle;\n    // Calculate final index of points depending on the initial index value.\n    // Because of calculating neighbours, index may be outside segment\n    // array.\n    if (index >= 0 && index <= segment.length - 1) {\n        i = index;\n    }\n    else if (index < 0) {\n        i = segment.length - 1 + index;\n    }\n    else {\n        i = 0;\n    }\n    // 1 means control points midway between points, 2 means 1/3 from\n    // the point, 3 is 1/4 etc;\n    const prevPointInd = ((i - 1 < 0) ? segment.length - (1 + addedNumber) : i - 1), nextPointInd = (i + 1 > segment.length - 1) ? addedNumber : i + 1, previousPoint = segment[prevPointInd], nextPoint = segment[nextPointInd], previousX = previousPoint.plotX, previousY = previousPoint.plotY, nextX = nextPoint.plotX, nextY = nextPoint.plotY, plotX = segment[i].plotX, // Actual point\n    plotY = segment[i].plotY;\n    leftContX = (smoothing * plotX + previousX) / denom;\n    leftContY = (smoothing * plotY + previousY) / denom;\n    rightContX = (smoothing * plotX + nextX) / denom;\n    rightContY = (smoothing * plotY + nextY) / denom;\n    // Distance left control point\n    const dLControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2)), dRControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2)), leftContAngle = Math.atan2(leftContY - plotY, leftContX - plotX), rightContAngle = Math.atan2(rightContY - plotY, rightContX - plotX);\n    jointAngle = (Math.PI / 2) + ((leftContAngle + rightContAngle) / 2);\n    // Ensure the right direction, jointAngle should be in the same quadrant\n    // as leftContAngle\n    if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {\n        jointAngle -= Math.PI;\n    }\n    // Find the corrected control points for a spline straight through the\n    // point\n    leftContX = plotX + Math.cos(jointAngle) * dLControlPoint;\n    leftContY = plotY + Math.sin(jointAngle) * dLControlPoint;\n    rightContX = plotX + Math.cos(Math.PI + jointAngle) * dRControlPoint;\n    rightContY = plotY + Math.sin(Math.PI + jointAngle) * dRControlPoint;\n    // Push current point's connectors into returned object\n    const ret = {\n        rightContX: rightContX,\n        rightContY: rightContY,\n        leftContX: leftContX,\n        leftContY: leftContY,\n        plotX: plotX,\n        plotY: plotY\n    };\n    // Calculate connectors for previous and next point and push them inside\n    // returned object\n    if (calculateNeighbours) {\n        ret.prevPointCont = getConnectors(segment, prevPointInd, false, connectEnds);\n    }\n    return ret;\n}\n/**\n *\n */\nfunction onChartAfterDrawChartBox() {\n    (this.pane || []).forEach((pane) => {\n        pane.render();\n    });\n}\n/**\n * If polar has polygonal grid lines, force start and endOnTick on radial axis\n * @private\n */\nfunction onChartAfterInit(event) {\n    const xAxis = event.args[0].xAxis, yAxis = event.args[0].yAxis, chart = event.args[0].chart;\n    if (xAxis && yAxis) {\n        if (yAxis.gridLineInterpolation === 'polygon') {\n            xAxis.startOnTick = true;\n            xAxis.endOnTick = true;\n        }\n        else if (xAxis.gridLineInterpolation === 'polygon' &&\n            chart.inverted) {\n            yAxis.startOnTick = true;\n            yAxis.endOnTick = true;\n        }\n    }\n}\n/**\n *\n */\nfunction onChartCreateAxes() {\n    if (!this.pane) {\n        this.pane = [];\n    }\n    this.options.pane = splat(this.options.pane || {});\n    splat(this.userOptions.pane || {}).forEach((paneOptions) => {\n        new Pane(// eslint-disable-line no-new\n        paneOptions, this);\n    }, this);\n}\n/**\n * Get selection dimensions\n * @private\n */\nfunction onPointerGetSelectionBox(event) {\n    const marker = event.args.marker, xAxis = this.chart.xAxis[0], yAxis = this.chart.yAxis[0], inverted = this.chart.inverted, radialAxis = inverted ? yAxis : xAxis, linearAxis = inverted ? xAxis : yAxis;\n    if (this.chart.polar) {\n        event.preventDefault();\n        const start = (marker.attr ? marker.attr('start') : marker.start) - radialAxis.startAngleRad, r = (marker.attr ? marker.attr('r') : marker.r), end = (marker.attr ? marker.attr('end') : marker.end) - radialAxis.startAngleRad, innerR = (marker.attr ? marker.attr('innerR') : marker.innerR);\n        event.result.x = start + radialAxis.pos;\n        event.result.width = end - start;\n        // `innerR` goes from pane's center but `toValue` computes values from\n        // top\n        event.result.y = linearAxis.len + linearAxis.pos - r;\n        event.result.height = r - innerR;\n    }\n}\n/**\n * Get attrs for Polar selection marker\n * @private\n */\nfunction onPointerGetSelectionMarkerAttrs(event) {\n    const chart = this.chart;\n    if (chart.polar && chart.hoverPane && chart.hoverPane.axis) {\n        event.preventDefault();\n        const center = chart.hoverPane.center, mouseDownX = chart.mouseDownX || 0, mouseDownY = chart.mouseDownY || 0, chartY = event.args.chartY, chartX = event.args.chartX, fullCircle = Math.PI * 2, startAngleRad = chart.hoverPane.axis.startAngleRad, endAngleRad = chart.hoverPane.axis.endAngleRad, linearAxis = chart.inverted ? chart.xAxis[0] : chart.yAxis[0], attrs = {};\n        let shapeType = 'arc';\n        attrs.x = center[0] + chart.plotLeft;\n        attrs.y = center[1] + chart.plotTop;\n        // Adjust the width of the selection marker\n        if (this.zoomHor) {\n            const paneRadRange = startAngleRad > 0 ?\n                endAngleRad - startAngleRad :\n                Math.abs(startAngleRad) + Math.abs(endAngleRad);\n            let startAngle = Math.atan2(mouseDownY - chart.plotTop - center[1], mouseDownX - chart.plotLeft - center[0]) - startAngleRad, endAngle = Math.atan2(chartY - chart.plotTop - center[1], chartX - chart.plotLeft - center[0]) - startAngleRad;\n            attrs.r = center[2] / 2;\n            attrs.innerR = center[3] / 2;\n            if (startAngle <= 0) {\n                startAngle += fullCircle;\n            }\n            if (endAngle <= 0) {\n                endAngle += fullCircle;\n            }\n            if (endAngle < startAngle) {\n                // Swapping angles\n                endAngle = [startAngle, startAngle = endAngle][0];\n            }\n            // If pane is not a full circle we need to let users zoom to the min\n            // We do this by swapping angles after pointer crosses\n            // middle angle (swapAngle) of the missing slice of the pane\n            if (paneRadRange < fullCircle) {\n                const swapAngle = endAngleRad + (fullCircle - paneRadRange) / 2;\n                if (startAngleRad + endAngle > swapAngle) {\n                    endAngle = startAngle;\n                    startAngle = startAngleRad <= 0 ? startAngleRad : 0;\n                }\n            }\n            const start = attrs.start =\n                Math.max(startAngle + startAngleRad, startAngleRad), end = attrs.end =\n                Math.min(endAngle + startAngleRad, endAngleRad);\n            // Adjust the selection shape for polygon grid lines\n            if (linearAxis.options.gridLineInterpolation === 'polygon') {\n                const radialAxis = chart.hoverPane.axis, min = start - radialAxis.startAngleRad + radialAxis.pos, max = end - start;\n                let path = linearAxis.getPlotLinePath({\n                    value: linearAxis.max\n                }), pathStart = radialAxis.toValue(min), pathEnd = radialAxis.toValue(min + max);\n                if (pathStart < radialAxis.getExtremes().min) {\n                    const { min, max } = radialAxis.getExtremes();\n                    pathStart = max - (min - pathStart);\n                }\n                if (pathEnd < radialAxis.getExtremes().min) {\n                    const { min, max } = radialAxis.getExtremes();\n                    pathEnd = max - (min - pathEnd);\n                }\n                if (pathEnd < pathStart) {\n                    // Swapping angles\n                    pathEnd = [pathStart, pathStart = pathEnd][0];\n                }\n                // Get trimmed path\n                path = trimPath(path, pathStart, pathEnd, radialAxis);\n                // Add center to the path\n                path.push([\n                    'L', center[0] + chart.plotLeft,\n                    chart.plotTop + center[1]\n                ]);\n                attrs.d = path;\n                shapeType = 'path';\n            }\n        }\n        // Adjust the height of the selection marker\n        if (this.zoomVert) {\n            const linearAxis = chart.inverted ? chart.xAxis[0] : chart.yAxis[0];\n            let innerR = Math.sqrt(Math.pow(mouseDownX - chart.plotLeft - center[0], 2) +\n                Math.pow(mouseDownY - chart.plotTop - center[1], 2)), r = Math.sqrt(Math.pow(chartX - chart.plotLeft - center[0], 2) +\n                Math.pow(chartY - chart.plotTop - center[1], 2));\n            if (r < innerR) {\n                // Swapping angles\n                innerR = [r, r = innerR][0];\n            }\n            if (r > center[2] / 2) {\n                r = center[2] / 2;\n            }\n            if (innerR < center[3] / 2) {\n                innerR = center[3] / 2;\n            }\n            if (!this.zoomHor) {\n                attrs.start = startAngleRad;\n                attrs.end = endAngleRad;\n            }\n            attrs.r = r;\n            attrs.innerR = innerR;\n            if (linearAxis.options.gridLineInterpolation === 'polygon') {\n                const end = linearAxis.toValue(linearAxis.len + linearAxis.pos - innerR), start = linearAxis.toValue(linearAxis.len + linearAxis.pos - r), path = linearAxis.getPlotLinePath({\n                    value: start\n                }).concat(linearAxis.getPlotLinePath({\n                    value: end,\n                    reverse: true\n                }));\n                attrs.d = path;\n                shapeType = 'path';\n            }\n        }\n        if (this.zoomHor &&\n            this.zoomVert &&\n            linearAxis.options.gridLineInterpolation === 'polygon') {\n            const radialAxis = chart.hoverPane.axis, start = attrs.start || 0, end = attrs.end || 0, min = start - radialAxis.startAngleRad + radialAxis.pos, max = end - start, pathStart = radialAxis.toValue(min), pathEnd = radialAxis.toValue(min + max);\n            // Trim path\n            if (attrs.d instanceof Array) {\n                let innerPath = attrs.d.slice(0, attrs.d.length / 2), outerPath = attrs.d.slice(attrs.d.length / 2, attrs.d.length);\n                outerPath = [...outerPath].reverse();\n                const radialAxis = chart.hoverPane.axis;\n                innerPath = trimPath(innerPath, pathStart, pathEnd, radialAxis);\n                outerPath = trimPath(outerPath, pathStart, pathEnd, radialAxis);\n                if (outerPath) {\n                    (outerPath[0][0]) = 'L';\n                }\n                outerPath = [...outerPath].reverse();\n                attrs.d = innerPath.concat(outerPath);\n                shapeType = 'path';\n            }\n        }\n        event.attrs = attrs;\n        event.shapeType = shapeType;\n    }\n}\n/**\n * @private\n */\nfunction onSeriesAfterInit() {\n    const chart = this.chart;\n    if (chart.polar) {\n        this.polar = new PolarAdditions(this);\n        // Add flags that identifies radial inverted series\n        if (chart.inverted) {\n            this.isRadialSeries = true;\n            if (this.is('column')) {\n                this.isRadialBar = true;\n            }\n        }\n    }\n}\n/**\n * Apply conditional rounding to polar bars\n */\nfunction onSeriesAfterColumnTranslate() {\n    const { chart, options, yAxis } = this;\n    if (options.borderRadius &&\n        chart.polar &&\n        chart.inverted) {\n        const seriesDefault = defaultOptions.plotOptions?.[this.type]\n            ?.borderRadius, { scope, where = 'end' } = optionsToObject(options.borderRadius, isObject(seriesDefault) ? seriesDefault : {});\n        for (const point of this.points) {\n            const { shapeArgs } = point;\n            if (point.shapeType === 'arc' && shapeArgs) {\n                let brStart = where === 'all', brEnd = true;\n                if (options.stacking && scope === 'stack') {\n                    brStart = point.stackY === point.y && where === 'all',\n                        brEnd = point.stackY === point.stackTotal;\n                }\n                if (yAxis.reversed) {\n                    [brStart, brEnd] = [brEnd, brStart];\n                }\n                shapeArgs.brStart = brStart;\n                shapeArgs.brEnd = brEnd;\n            }\n        }\n    }\n}\n/**\n * Extend translate. The plotX and plotY values are computed as if the polar\n * chart were a cartesian plane, where plotX denotes the angle in radians\n * and (yAxis.len - plotY) is the pixel distance from center.\n * @private\n */\nfunction onSeriesAfterTranslate() {\n    if (this.chart.polar && this.xAxis) {\n        const series = this, { xAxis, yAxis } = series, chart = series.chart;\n        // Prepare k-d-tree handling. It searches by angle (clientX) in\n        // case of shared tooltip, and by two dimensional distance in case\n        // of non-shared.\n        series.kdByAngle = chart.tooltip && chart.tooltip.shared;\n        if (series.kdByAngle || chart.inverted) {\n            series.searchPoint = searchPointByAngleOrInverted;\n        }\n        else {\n            series.options.findNearestPointBy = 'xy';\n        }\n        const points = series.points;\n        let i = points.length;\n        while (i--) {\n            // Translate plotX, plotY from angle and radius to true plot\n            // coordinates\n            if (!series.is('column') && !series.is('columnrange')) {\n                series.polar.toXY(points[i]);\n            }\n            // Treat points below Y axis min as null (#10082)\n            if (!chart.hasParallelCoordinates &&\n                !series.yAxis.reversed) {\n                if (pick(points[i].y, Number.MIN_VALUE) < yAxis.min ||\n                    points[i].x < xAxis.min ||\n                    points[i].x > xAxis.max) {\n                    // Destroy markers\n                    points[i].isNull = true;\n                    // Destroy column's graphic\n                    points[i].plotY = NaN;\n                }\n                else {\n                    // Restore isNull flag\n                    points[i].isNull =\n                        points[i].isValid && !points[i].isValid();\n                }\n            }\n        }\n        // Perform clip after render\n        if (!this.hasClipCircleSetter) {\n            this.hasClipCircleSetter = !!series.eventsToUnbind.push(addEvent(series, 'afterRender', function () {\n                let circ;\n                if (chart.polar && this.options.clip !== false) {\n                    // For clipping purposes there is a need for\n                    // coordinates from the absolute center\n                    circ = this.yAxis.pane.center;\n                    if (!this.clipCircle) {\n                        this.clipCircle = clipCircle(chart.renderer, circ[0], circ[1], circ[2] / 2, circ[3] / 2);\n                    }\n                    else {\n                        this.clipCircle.animate({\n                            x: circ[0],\n                            y: circ[1],\n                            r: circ[2] / 2,\n                            innerR: circ[3] / 2\n                        });\n                    }\n                    this.group.clip(this.clipCircle);\n                    this.setClip = H.noop;\n                }\n            }));\n        }\n    }\n}\n/**\n * Search a k-d tree by the point angle (used for shared tooltips in polar) or\n * the inverted point.\n * charts\n * @private\n */\nfunction searchPointByAngleOrInverted(e) {\n    const series = this, chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis, center = xAxis.pane && xAxis.pane.center, plotX = e.chartX - (center && center[0] || 0) - chart.plotLeft, plotY = e.chartY - (center && center[1] || 0) - chart.plotTop;\n    const searchKDTreePoint = chart.inverted ? {\n        clientX: e.chartX - yAxis.pos,\n        plotY: e.chartY - xAxis.pos\n    } : {\n        clientX: 180 + (Math.atan2(plotX, plotY) * (-180 / Math.PI))\n    };\n    return series.searchKDTree(searchKDTreePoint);\n}\n/**\n * Trim polygonal path\n * @private\n */\nfunction trimPath(path, start, end, radialAxis) {\n    const tickInterval = radialAxis.tickInterval, ticks = radialAxis.tickPositions;\n    let lastTick = find(ticks, (tick) => tick >= end), firstTick = find([...ticks].reverse(), (tick) => tick <= start);\n    if (!defined(lastTick)) {\n        lastTick = ticks[ticks.length - 1];\n    }\n    if (!defined(firstTick)) {\n        firstTick = ticks[0];\n        lastTick += tickInterval;\n        path[0][0] = 'L';\n        // To do: figure out why -3 or -2\n        path.unshift(path[path.length - 3]);\n    }\n    path = path.slice(ticks.indexOf(firstTick), ticks.indexOf(lastTick) + 1);\n    path[0][0] = 'M';\n    return path;\n}\n/**\n * Extend chart.get to also search in panes. Used internally in\n * responsiveness and chart.update.\n * @private\n */\nfunction wrapChartGet(proceed, id) {\n    return find(this.pane || [], (pane) => (\n    // @todo remove id or define id type:\n    pane.options.id === id)) || proceed.call(this, id);\n}\n/**\n * Align column data labels outside the columns. #1199.\n * @private\n */\nfunction wrapColumnSeriesAlignDataLabel(proceed, point, dataLabel, options, alignTo, isNew) {\n    const chart = this.chart, inside = pick(options.inside, !!this.options.stacking);\n    let angle, shapeArgs, labelPos;\n    if (chart.polar) {\n        angle = point.rectPlotX / Math.PI * 180;\n        if (!chart.inverted) {\n            // Align nicely outside the perimeter of the columns\n            options = findAlignments(angle, options);\n        }\n        else { // Required corrections for data labels of inverted bars\n            // The plotX and plotY are correctly set therefore they\n            // don't need to be swapped (inverted argument is false)\n            this.forceDL = chart.isInsidePlot(point.plotX, point.plotY);\n            // Checks if labels should be positioned inside\n            if (inside && point.shapeArgs) {\n                shapeArgs = point.shapeArgs;\n                // Calculates pixel positions for a data label to be\n                // inside\n                labelPos =\n                    this.yAxis.postTranslate(\n                    // Angle\n                    ((shapeArgs.start || 0) + (shapeArgs.end || 0)) / 2 -\n                        this\n                            .xAxis.startAngleRad, \n                    // Radius\n                    point.barX +\n                        point.pointWidth / 2);\n                alignTo = merge(alignTo, {\n                    x: labelPos.x - chart.plotLeft,\n                    y: labelPos.y - chart.plotTop\n                });\n            }\n            else if (point.tooltipPos) {\n                alignTo = merge(alignTo, {\n                    x: point.tooltipPos[0],\n                    y: point.tooltipPos[1]\n                });\n            }\n            options.align = pick(options.align, 'center');\n            options.verticalAlign =\n                pick(options.verticalAlign, 'middle');\n        }\n        Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n        // Hide label of a point (only inverted) that is outside the\n        // visible y range\n        if (this.isRadialBar && point.shapeArgs &&\n            point.shapeArgs.start === point.shapeArgs.end) {\n            dataLabel.hide();\n        }\n        else {\n            dataLabel.show();\n        }\n    }\n    else {\n        proceed.call(this, point, dataLabel, options, alignTo, isNew);\n    }\n}\n/**\n * Extend the column prototype's translate method\n * @private\n */\nfunction onAfterColumnTranslate() {\n    const series = this, options = series.options, stacking = options.stacking, chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis, reversed = yAxis.reversed, center = yAxis.center, startAngleRad = xAxis.startAngleRad, endAngleRad = xAxis.endAngleRad, visibleRange = endAngleRad - startAngleRad;\n    let threshold = options.threshold, thresholdAngleRad = 0, points, point, i, yMin, yMax, start = 0, end = 0, tooltipPos, pointX, pointY, stackValues, stack, barX, innerR, r;\n    // Postprocess plot coordinates\n    if (xAxis.isRadial) {\n        points = series.points;\n        i = points.length;\n        yMin = yAxis.translate(yAxis.min);\n        yMax = yAxis.translate(yAxis.max);\n        threshold = options.threshold || 0;\n        if (chart.inverted) {\n            // Finding a correct threshold\n            if (isNumber(threshold)) {\n                thresholdAngleRad = yAxis.translate(threshold);\n                // Checks if threshold is outside the visible range\n                if (defined(thresholdAngleRad)) {\n                    if (thresholdAngleRad < 0) {\n                        thresholdAngleRad = 0;\n                    }\n                    else if (thresholdAngleRad > visibleRange) {\n                        thresholdAngleRad = visibleRange;\n                    }\n                    // Adding start angle offset\n                    series.translatedThreshold =\n                        thresholdAngleRad + startAngleRad;\n                }\n            }\n        }\n        while (i--) {\n            point = points[i];\n            barX = point.barX;\n            pointX = point.x;\n            pointY = point.y;\n            point.shapeType = 'arc';\n            if (chart.inverted) {\n                point.plotY = yAxis.translate(pointY);\n                if (stacking && yAxis.stacking) {\n                    stack = yAxis.stacking.stacks[(pointY < 0 ? '-' : '') +\n                        series.stackKey];\n                    if (series.visible && stack && stack[pointX]) {\n                        if (!point.isNull) {\n                            stackValues = stack[pointX].points[series.getStackIndicator(void 0, pointX, series.index).key];\n                            // Translating to radial values\n                            start = yAxis.translate(stackValues[0]);\n                            end = yAxis.translate(stackValues[1]);\n                            // If starting point is beyond the\n                            // range, set it to 0\n                            if (defined(start)) {\n                                start = U.clamp(start, 0, visibleRange);\n                            }\n                        }\n                    }\n                }\n                else {\n                    // Initial start and end angles for radial bar\n                    start = thresholdAngleRad;\n                    end = point.plotY;\n                }\n                if (start > end) {\n                    // Swapping start and end\n                    end = [start, start = end][0];\n                }\n                // Prevent from rendering point outside the\n                // acceptable circular range\n                if (!reversed) {\n                    if (start < yMin) {\n                        start = yMin;\n                    }\n                    else if (end > yMax) {\n                        end = yMax;\n                    }\n                    else if (end < yMin || start > yMax) {\n                        start = end = 0;\n                    }\n                }\n                else {\n                    if (end > yMin) {\n                        end = yMin;\n                    }\n                    else if (start < yMax) {\n                        start = yMax;\n                    }\n                    else if (start > yMin || end < yMax) {\n                        start = end = visibleRange;\n                    }\n                }\n                if (yAxis.min > yAxis.max) {\n                    start = end = reversed ? visibleRange : 0;\n                }\n                start += startAngleRad;\n                end += startAngleRad;\n                if (center) {\n                    point.barX = barX += center[3] / 2;\n                }\n                // In case when radius, inner radius or both are negative, a\n                // point is rendered but partially or as a center point\n                innerR = Math.max(barX, 0);\n                r = Math.max(barX + point.pointWidth, 0);\n                // Handle border radius\n                const brOption = options.borderRadius, brValue = typeof brOption === 'object' ?\n                    brOption.radius : brOption, borderRadius = relativeLength(brValue || 0, r - innerR);\n                point.shapeArgs = {\n                    x: center[0],\n                    y: center[1],\n                    r,\n                    innerR,\n                    start,\n                    end,\n                    borderRadius\n                };\n                // Fade out the points if not inside the polar \"plot area\"\n                point.opacity = start === end ? 0 : void 0;\n                // A correct value for stacked or not fully visible\n                // point\n                point.plotY = (defined(series.translatedThreshold) &&\n                    (start < series.translatedThreshold ? start : end)) -\n                    startAngleRad;\n                // Non-inverted polar columns\n            }\n            else {\n                start = barX + startAngleRad;\n                point.shapeArgs = series.polar.arc(point.yBottom, point.plotY, start, start + point.pointWidth);\n                // Disallow border radius on polar columns for now. It would\n                // take some refactoring to work with the `scope` and the\n                // `where` options. Those options would require that only\n                // individual corners be rounded, in practice individual calls\n                // to applyBorderRadius from the extended `arc` function. That\n                // would be a viable solution, though it would not be perfect\n                // until we implemented rounding that included the lower points\n                // in the stack, like we have for cartesian column.\n                point.shapeArgs.borderRadius = 0;\n            }\n            // Provided a correct coordinates for the tooltip\n            series.polar.toXY(point);\n            if (chart.inverted) {\n                tooltipPos = yAxis.postTranslate(point.rectPlotY, barX + point.pointWidth / 2);\n                point.tooltipPos = [\n                    tooltipPos.x - chart.plotLeft,\n                    tooltipPos.y - chart.plotTop\n                ];\n            }\n            else {\n                point.tooltipPos = [point.plotX, point.plotY];\n            }\n            if (center) {\n                point.ttBelow = point.plotY > center[1];\n            }\n        }\n    }\n}\n/**\n * Extend getSegmentPath to allow connecting ends across 0 to provide a\n * closed circle in line-like series.\n * @private\n */\nfunction wrapLineSeriesGetGraphPath(proceed, points) {\n    const series = this;\n    let firstValid, popLastPoint;\n    // Connect the path\n    if (this.chart.polar) {\n        points = points || this.points;\n        // Append first valid point in order to connect the ends\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].isNull) {\n                firstValid = i;\n                break;\n            }\n        }\n        /**\n         * Polar charts only. Whether to connect the ends of a line series\n         * plot across the extremes.\n         *\n         * @sample {highcharts} highcharts/plotoptions/line-connectends-false/\n         *         Do not connect\n         *\n         * @type      {boolean}\n         * @since     2.3.0\n         * @product   highcharts\n         * @apioption plotOptions.series.connectEnds\n         */\n        if (this.options.connectEnds !== false &&\n            typeof firstValid !== 'undefined') {\n            this.connectEnds = true; // Re-used in splines\n            points.splice(points.length, 0, points[firstValid]);\n            popLastPoint = true;\n        }\n        // For area charts, pseudo points are added to the graph, now we\n        // need to translate these\n        points.forEach((point) => {\n            if (typeof point.polarPlotY === 'undefined') {\n                series.polar.toXY(point);\n            }\n        });\n    }\n    // Run uber method\n    const ret = proceed.apply(this, [].slice.call(arguments, 1));\n    // #6212 points.splice method is adding points to an array. In case of\n    // areaspline getGraphPath method is used two times and in both times\n    // points are added to an array. That is why points.pop is used, to get\n    // unmodified points.\n    if (popLastPoint) {\n        points.pop();\n    }\n    return ret;\n}\n/**\n * Extend getCoordinates to prepare for polar axis values\n * @private\n */\nfunction wrapPointerGetCoordinates(proceed, e) {\n    const chart = this.chart;\n    let ret = {\n        xAxis: [],\n        yAxis: []\n    };\n    if (chart.polar) {\n        chart.axes.forEach((axis) => {\n            // Skip colorAxis\n            if (axis.coll === 'colorAxis') {\n                return;\n            }\n            const isXAxis = axis.isXAxis, center = axis.center, x = e.chartX - center[0] - chart.plotLeft, y = e.chartY - center[1] - chart.plotTop;\n            ret[isXAxis ? 'xAxis' : 'yAxis'].push({\n                axis: axis,\n                value: axis.translate(isXAxis ?\n                    Math.PI - Math.atan2(x, y) : // Angle\n                    // distance from center\n                    Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), true)\n            });\n        });\n    }\n    else {\n        ret = proceed.call(this, e);\n    }\n    return ret;\n}\n/**\n * Prevent zooming on mobile devices\n * @private\n */\nfunction wrapPointerPinch(proceed, e) {\n    if (this.chart.polar) {\n        return;\n    }\n    proceed.call(this, e);\n}\n/**\n * Define the animate method for regular series\n * @private\n */\nfunction wrapSeriesAnimate(proceed, init) {\n    const series = this, chart = this.chart, group = this.group, markerGroup = this.markerGroup, center = this.xAxis && this.xAxis.center, plotLeft = chart.plotLeft, plotTop = chart.plotTop;\n    let animation = this.options.animation, attribs, paneInnerR, graphic, shapeArgs, r, innerR;\n    // Specific animation for polar charts\n    if (chart.polar) {\n        if (series.isRadialBar) {\n            if (!init) {\n                // Run the pie animation for radial bars\n                series.startAngleRad = pick(series.translatedThreshold, series.xAxis.startAngleRad);\n                H.seriesTypes.pie.prototype.animate.call(series, init);\n            }\n        }\n        else {\n            animation = animObject(animation);\n            // A different animation needed for column like series\n            if (series.is('column')) {\n                if (!init) {\n                    paneInnerR = center[3] / 2;\n                    series.points.forEach((point) => {\n                        graphic = point.graphic;\n                        shapeArgs = point.shapeArgs;\n                        r = shapeArgs && shapeArgs.r;\n                        innerR = shapeArgs && shapeArgs.innerR;\n                        if (graphic && shapeArgs) {\n                            // Start values\n                            graphic.attr({\n                                r: paneInnerR,\n                                innerR: paneInnerR\n                            });\n                            // Animate\n                            graphic.animate({\n                                r: r,\n                                innerR: innerR\n                            }, series.options.animation);\n                        }\n                    });\n                }\n            }\n            else {\n                // Initialize the animation\n                if (init) {\n                    // Scale down the group and place it in the center\n                    attribs = {\n                        translateX: center[0] + plotLeft,\n                        translateY: center[1] + plotTop,\n                        scaleX: 0.001,\n                        scaleY: 0.001\n                    };\n                    group.attr(attribs);\n                    if (markerGroup) {\n                        markerGroup.attr(attribs);\n                    }\n                    // Run the animation\n                }\n                else {\n                    attribs = {\n                        translateX: plotLeft,\n                        translateY: plotTop,\n                        scaleX: 1,\n                        scaleY: 1\n                    };\n                    group.animate(attribs, animation);\n                    if (markerGroup) {\n                        markerGroup.animate(attribs, animation);\n                    }\n                }\n            }\n        }\n        // For non-polar charts, revert to the basic animation\n    }\n    else {\n        proceed.call(this, init);\n    }\n}\n/**\n * Overridden method for calculating a spline from one point to the next\n * @private\n */\nfunction wrapSplineSeriesGetPointSpline(proceed, segment, point, i) {\n    let ret, connectors;\n    if (this.chart.polar) {\n        // `moveTo` or `lineTo`\n        if (!i) {\n            ret = ['M', point.plotX, point.plotY];\n        }\n        else { // Curve from last point to this\n            connectors = getConnectors(segment, i, true, this.connectEnds);\n            const rightContX = connectors.prevPointCont &&\n                connectors.prevPointCont.rightContX;\n            const rightContY = connectors.prevPointCont &&\n                connectors.prevPointCont.rightContY;\n            ret = [\n                'C',\n                isNumber(rightContX) ? rightContX : connectors.plotX,\n                isNumber(rightContY) ? rightContY : connectors.plotY,\n                isNumber(connectors.leftContX) ?\n                    connectors.leftContX :\n                    connectors.plotX,\n                isNumber(connectors.leftContY) ?\n                    connectors.leftContY :\n                    connectors.plotY,\n                connectors.plotX,\n                connectors.plotY\n            ];\n        }\n    }\n    else {\n        ret = proceed.call(this, segment, point, i);\n    }\n    return ret;\n}\n/**\n * Extend the point pos method to calculate point positions for the polar chart.\n * @private\n */\nfunction wrapPointPos(proceed, chartCoordinates, plotY = this.plotY) {\n    if (!this.destroyed) {\n        const { plotX, series } = this, { chart } = series;\n        if (chart.polar &&\n            isNumber(plotX) &&\n            isNumber(plotY)) {\n            return [\n                plotX + (chartCoordinates ? chart.plotLeft : 0),\n                plotY + (chartCoordinates ? chart.plotTop : 0)\n            ];\n        }\n        return proceed.call(this, chartCoordinates, plotY);\n    }\n}\n/* *\n *\n *  Class\n *\n * */\n/**\n * Extensions for polar charts. Additionally, much of the geometry required\n * for polar charts is gathered in RadialAxes.js.\n * @private\n */\nclass PolarAdditions {\n    /* *\n     *\n     *  Static Functions\n     *\n     * */\n    static compose(AxisClass, ChartClass, PointerClass, SeriesClass, TickClass, PointClass, AreaSplineRangeSeriesClass, ColumnSeriesClass, LineSeriesClass, SplineSeriesClass) {\n        Pane.compose(ChartClass, PointerClass, SeriesClass);\n        RadialAxis.compose(AxisClass, TickClass);\n        if (pushUnique(composed, 'Polar')) {\n            const chartProto = ChartClass.prototype, pointProto = PointClass.prototype, pointerProto = PointerClass.prototype, seriesProto = SeriesClass.prototype;\n            addEvent(ChartClass, 'afterDrawChartBox', onChartAfterDrawChartBox);\n            addEvent(ChartClass, 'createAxes', onChartCreateAxes);\n            addEvent(ChartClass, 'init', onChartAfterInit);\n            wrap(chartProto, 'get', wrapChartGet);\n            wrap(pointerProto, 'getCoordinates', wrapPointerGetCoordinates);\n            wrap(pointerProto, 'pinch', wrapPointerPinch);\n            addEvent(PointerClass, 'getSelectionMarkerAttrs', onPointerGetSelectionMarkerAttrs);\n            addEvent(PointerClass, 'getSelectionBox', onPointerGetSelectionBox);\n            addEvent(SeriesClass, 'afterInit', onSeriesAfterInit);\n            addEvent(SeriesClass, 'afterColumnTranslate', onSeriesAfterColumnTranslate, {\n                // After columnrange and polar column modifications\n                order: 9\n            });\n            addEvent(SeriesClass, 'afterTranslate', onSeriesAfterTranslate, { order: 2 } // Run after translation of ||-coords\n            );\n            addEvent(SeriesClass, 'afterColumnTranslate', onAfterColumnTranslate, { order: 4 });\n            wrap(seriesProto, 'animate', wrapSeriesAnimate);\n            wrap(pointProto, 'pos', wrapPointPos);\n            if (ColumnSeriesClass) {\n                const columnProto = ColumnSeriesClass.prototype;\n                wrap(columnProto, 'alignDataLabel', wrapColumnSeriesAlignDataLabel);\n                wrap(columnProto, 'animate', wrapSeriesAnimate);\n            }\n            if (LineSeriesClass) {\n                const lineProto = LineSeriesClass.prototype;\n                wrap(lineProto, 'getGraphPath', wrapLineSeriesGetGraphPath);\n            }\n            if (SplineSeriesClass) {\n                const splineProto = SplineSeriesClass.prototype;\n                wrap(splineProto, 'getPointSpline', wrapSplineSeriesGetPointSpline);\n                if (AreaSplineRangeSeriesClass) {\n                    const areaSplineRangeProto = AreaSplineRangeSeriesClass.prototype;\n                    // #6430 Areasplinerange series use unwrapped getPointSpline\n                    // method, so we need to set this method again.\n                    areaSplineRangeProto.getPointSpline =\n                        splineProto.getPointSpline;\n                }\n            }\n        }\n    }\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    constructor(series) {\n        this.series = series;\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    arc(low, high, start, end) {\n        const series = this.series, center = series.xAxis.center, len = series.yAxis.len, paneInnerR = center[3] / 2;\n        let r = len - high + paneInnerR, innerR = len - pick(low, len) + paneInnerR;\n        // Prevent columns from shooting through the pane's center\n        if (series.yAxis.reversed) {\n            if (r < 0) {\n                r = paneInnerR;\n            }\n            if (innerR < 0) {\n                innerR = paneInnerR;\n            }\n        }\n        // Return a new shapeArgs\n        return {\n            x: center[0],\n            y: center[1],\n            r: r,\n            innerR: innerR,\n            start: start,\n            end: end\n        };\n    }\n    /**\n     * Translate a point's plotX and plotY from the internal angle and radius\n     * measures to true plotX, plotY coordinates\n     * @private\n     */\n    toXY(point) {\n        const series = this.series, chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis, plotX = point.plotX, inverted = chart.inverted, pointY = point.y;\n        let plotY = point.plotY, radius = inverted ? plotX : yAxis.len - plotY, clientX;\n        // Corrected y position of inverted series other than column\n        if (inverted && series && !series.isRadialBar) {\n            point.plotY = plotY =\n                isNumber(pointY) ? yAxis.translate(pointY) : 0;\n        }\n        // Save rectangular plotX, plotY for later computation\n        point.rectPlotX = plotX;\n        point.rectPlotY = plotY;\n        if (yAxis.center) {\n            radius += yAxis.center[3] / 2;\n        }\n        // Find the polar plotX and plotY. Avoid setting plotX and plotY to NaN\n        // when plotY is undefined (#15438)\n        if (isNumber(plotY)) {\n            const xy = inverted ? yAxis.postTranslate(plotY, radius) :\n                xAxis.postTranslate(plotX, radius);\n            point.plotX = point.polarPlotX = xy.x - chart.plotLeft;\n            point.plotY = point.polarPlotY = xy.y - chart.plotTop;\n        }\n        // If shared tooltip, record the angle in degrees in order to align X\n        // points. Otherwise, use a standard k-d tree to get the nearest point\n        // in two dimensions.\n        if (series.kdByAngle) {\n            clientX = ((plotX / Math.PI * 180) + xAxis.pane.options.startAngle) % 360;\n            if (clientX < 0) { // #2665\n                clientX += 360;\n            }\n            point.clientX = clientX;\n        }\n        else {\n            point.clientX = point.plotX;\n        }\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nexport default PolarAdditions;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10065, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Waterfall/WaterfallPoint.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\nimport ColumnSeries from '../Column/ColumnSeries.js';\nimport Point from '../../Core/Series/Point.js';\nimport U from '../../Core/Utilities.js';\nconst { isNumber } = U;\n/* *\n *\n *  Class\n *\n * */\nclass WaterfallPoint extends ColumnSeries.prototype.pointClass {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    getClassName() {\n        let className = Point.prototype.getClassName.call(this);\n        if (this.isSum) {\n            className += ' highcharts-sum';\n        }\n        else if (this.isIntermediateSum) {\n            className += ' highcharts-intermediate-sum';\n        }\n        return className;\n    }\n    // Pass the null test in ColumnSeries.translate.\n    isValid() {\n        return (isNumber(this.y) ||\n            this.isSum ||\n            Boolean(this.isIntermediateSum));\n    }\n}\n/* *\n *\n *  Export\n *\n * */\nexport default WaterfallPoint;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;GASG,GACH;AACA;AACA;;;;AACA,MAAM,EAAE,QAAQ,EAAE,GAAG,8KAAC;AACtB;;;;GAIG,GACH,MAAM,uBAAuB,6LAAY,CAAC,SAAS,CAAC,UAAU;IAC1D;;;;OAIG,GACH,eAAe;QACX,IAAI,YAAY,oLAAK,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI;QACtD,IAAI,IAAI,CAAC,KAAK,EAAE;YACZ,aAAa;QACjB,OACK,IAAI,IAAI,CAAC,iBAAiB,EAAE;YAC7B,aAAa;QACjB;QACA,OAAO;IACX;IACA,gDAAgD;IAChD,UAAU;QACN,OAAQ,SAAS,IAAI,CAAC,CAAC,KACnB,IAAI,CAAC,KAAK,IACV,QAAQ,IAAI,CAAC,iBAAiB;IACtC;AACJ;uCAMe","ignoreList":[0]}},
    {"offset": {"line": 10113, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Waterfall/WaterfallSeriesDefaults.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\n/* *\n *\n *  API Options\n *\n * */\n/**\n * A waterfall chart displays sequentially introduced positive or negative\n * values in cumulative columns.\n *\n * @sample highcharts/demo/waterfall/\n *         Waterfall chart\n * @sample highcharts/plotoptions/waterfall-inverted/\n *         Horizontal (inverted) waterfall\n * @sample highcharts/plotoptions/waterfall-stacked/\n *         Stacked waterfall chart\n *\n * @extends      plotOptions.column\n * @excluding    boostThreshold, boostBlending\n * @product      highcharts\n * @requires     highcharts-more\n * @optionparent plotOptions.waterfall\n */\nconst WaterfallSeriesDefaults = {\n    /**\n     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @apioption plotOptions.waterfall.color\n     */\n    /**\n     * The color used specifically for positive point columns. When not\n     * specified, the general series color is used.\n     *\n     * In styled mode, the waterfall colors can be set with the\n     * `.highcharts-point-negative`, `.highcharts-sum` and\n     * `.highcharts-intermediate-sum` classes.\n     *\n     * @sample {highcharts} highcharts/demo/waterfall/\n     *         Waterfall\n     *\n     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @product   highcharts\n     * @apioption plotOptions.waterfall.upColor\n     */\n    dataLabels: {\n        inside: true\n    },\n    /**\n     * The width of the line connecting waterfall columns.\n     *\n     * @product highcharts\n     */\n    lineWidth: 1,\n    /**\n     * The color of the line that connects columns in a waterfall series.\n     *\n     * In styled mode, the stroke can be set with the `.highcharts-graph`\n     * class.\n     *\n     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @since   3.0\n     * @product highcharts\n     */\n    lineColor: \"#333333\" /* Palette.neutralColor80 */,\n    /**\n     * A name for the dash style to use for the line connecting the columns\n     * of the waterfall series. Possible values: Dash, DashDot, Dot,\n     * LongDash, LongDashDot, LongDashDotDot, ShortDash, ShortDashDot,\n     * ShortDashDotDot, ShortDot, Solid\n     *\n     * In styled mode, the stroke dash-array can be set with the\n     * `.highcharts-graph` class.\n     *\n     * @type    {Highcharts.DashStyleValue}\n     * @since   3.0\n     * @product highcharts\n     */\n    dashStyle: 'Dot',\n    /**\n     * The color of the border of each waterfall column.\n     *\n     * In styled mode, the border stroke can be set with the\n     * `.highcharts-point` class.\n     *\n     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @since   3.0\n     * @product highcharts\n     */\n    borderColor: \"#333333\" /* Palette.neutralColor80 */,\n    states: {\n        hover: {\n            lineWidthPlus: 0 // #3126\n        }\n    }\n};\n/**\n * A `waterfall` series. If the [type](#series.waterfall.type) option\n * is not specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.waterfall\n * @excluding dataParser, dataURL, boostThreshold, boostBlending\n * @product   highcharts\n * @requires  highcharts-more\n * @apioption series.waterfall\n */\n/**\n * An array of data points for the series. For the `waterfall` series\n * type, points can be given in the following ways:\n *\n * 1. An array of numerical values. In this case, the numerical values will be\n *    interpreted as `y` options. The `x` values will be automatically\n *    calculated, either starting at 0 and incremented by 1, or from\n *    `pointStart` and `pointInterval` given in the series options. If the axis\n *    has categories, these will be used. Example:\n *    ```js\n *    data: [0, 5, 3, 5]\n *    ```\n *\n * 2. An array of arrays with 2 values. In this case, the values correspond to\n *    `x,y`. If the first value is a string, it is applied as the name of the\n *    point, and the `x` value is inferred.\n *    ```js\n *    data: [\n *        [0, 7],\n *        [1, 8],\n *        [2, 3]\n *    ]\n *    ```\n *\n * 3. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.waterfall.turboThreshold), this option is not\n *    available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        y: 8,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        y: 8,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n * @extends   series.line.data\n * @excluding marker\n * @product   highcharts\n * @apioption series.waterfall.data\n */\n/**\n * When this property is true, the points acts as a summary column for\n * the values added or subtracted since the last intermediate sum,\n * or since the start of the series. The `y` value is ignored.\n *\n * @sample {highcharts} highcharts/demo/waterfall/\n *         Waterfall\n *\n * @type      {boolean}\n * @default   false\n * @product   highcharts\n * @apioption series.waterfall.data.isIntermediateSum\n */\n/**\n * When this property is true, the point display the total sum across\n * the entire series. The `y` value is ignored.\n *\n * @sample {highcharts} highcharts/demo/waterfall/\n *         Waterfall\n *\n * @type      {boolean}\n * @default   false\n * @product   highcharts\n * @apioption series.waterfall.data.isSum\n */\n''; // Adds doclets above to transpiled file\n/* *\n *\n *  Default Export\n *\n * */\nexport default WaterfallSeriesDefaults;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;GASG,GACH;AACA;;;;GAIG,GACH;;;;;;;;;;;;;;;;CAgBC,GACD,MAAM,0BAA0B;IAC5B;;;KAGC,GACD;;;;;;;;;;;;;;KAcC,GACD,YAAY;QACR,QAAQ;IACZ;IACA;;;;KAIC,GACD,WAAW;IACX;;;;;;;;;KASC,GACD,WAAW,UAAU,0BAA0B;IAC/C;;;;;;;;;;;;KAYC,GACD,WAAW;IACX;;;;;;;;;KASC,GACD,aAAa,UAAU,0BAA0B;IACjD,QAAQ;QACJ,OAAO;YACH,eAAe,EAAE,QAAQ;QAC7B;IACJ;AACJ;AACA;;;;;;;;;CASC,GACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2DC,GACD;;;;;;;;;;;;CAYC,GACD;;;;;;;;;;;CAWC,GACD,IAAI,wCAAwC;uCAM7B","ignoreList":[0]}},
    {"offset": {"line": 10309, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Jelly/node_modules/highcharts/es-modules/Series/Waterfall/WaterfallSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2026 Highsoft AS\n *  Author: Torstein Honsi\n *\n *  A commercial license may be required depending on use.\n *  See www.highcharts.com/license\n *\n *\n * */\n'use strict';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { column: ColumnSeries, line: LineSeries } = SeriesRegistry.seriesTypes;\nimport U from '../../Core/Utilities.js';\nconst { addEvent, arrayMax, arrayMin, correctFloat, crisp, extend, isNumber, merge, objectEach, pick } = U;\nimport WaterfallAxis from '../../Core/Axis/WaterfallAxis.js';\nimport WaterfallPoint from './WaterfallPoint.js';\nimport WaterfallSeriesDefaults from './WaterfallSeriesDefaults.js';\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Returns true if the key is a direct property of the object.\n * @private\n * @param {*} obj\n * Object with property to test\n * @param {string} key\n * Property key to test\n * @return {boolean}\n * Whether it is a direct property\n */\nfunction ownProp(obj, key) {\n    return Object.hasOwnProperty.call(obj, key);\n}\n/* *\n *\n *  Class\n *\n * */\n/**\n * Waterfall series type.\n *\n * @private\n */\nclass WaterfallSeries extends ColumnSeries {\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    // After generating points, set y-values for all sums.\n    generatePoints() {\n        // Parent call:\n        ColumnSeries.prototype.generatePoints.apply(this);\n        const processedYData = this.getColumn('y', true);\n        for (let i = 0, len = this.points.length; i < len; i++) {\n            const point = this.points[i], y = processedYData[i];\n            // Override point value for sums. #3710 Update point does not\n            // propagate to sum\n            if (isNumber(y) && (point.isIntermediateSum || point.isSum)) {\n                point.y = correctFloat(y);\n            }\n        }\n    }\n    // Call default processData then override yData to reflect waterfall's\n    // extremes on yAxis\n    processData(force) {\n        const series = this, options = series.options, yData = series.getColumn('y'), \n        // #3710 Update point does not propagate to sum\n        points = options.data, dataLength = yData.length, threshold = options.threshold || 0;\n        let point, subSum, sum, dataMin, dataMax, y;\n        sum = subSum = dataMin = dataMax = 0;\n        for (let i = 0; i < dataLength; i++) {\n            y = yData[i];\n            point = points?.[i] || {};\n            if (y === 'sum' || point.isSum) {\n                yData[i] = correctFloat(sum);\n            }\n            else if (y === 'intermediateSum' ||\n                point.isIntermediateSum) {\n                yData[i] = correctFloat(subSum);\n                subSum = 0;\n            }\n            else {\n                sum += y;\n                subSum += y;\n            }\n            dataMin = Math.min(sum, dataMin);\n            dataMax = Math.max(sum, dataMax);\n        }\n        super.processData.call(this, force);\n        // Record extremes only if stacking was not set:\n        if (!options.stacking) {\n            series.dataMin = dataMin + threshold;\n            series.dataMax = dataMax;\n        }\n        return;\n    }\n    // Return y value or string if point is sum\n    toYData(pt) {\n        if (pt.isSum) {\n            return 'sum';\n        }\n        if (pt.isIntermediateSum) {\n            return 'intermediateSum';\n        }\n        return pt.y;\n    }\n    // Postprocess mapping between options and SVG attributes\n    pointAttribs(point, state) {\n        const upColor = this.options.upColor;\n        // Set or reset up color (#3710, update to negative)\n        if (upColor && !point.options.color && isNumber(point.y)) {\n            point.color = point.y > 0 ? upColor : void 0;\n        }\n        const attr = ColumnSeries.prototype.pointAttribs.call(this, point, state);\n        // The dashStyle option in waterfall applies to the graph, not\n        // the points\n        delete attr.dashstyle;\n        return attr;\n    }\n    // Return an empty path initially, because we need to know the stroke-width\n    // in order to set the final path.\n    getGraphPath() {\n        return this.graph?.pathArray || [['M', 0, 0]];\n    }\n    // Draw columns' connector lines\n    getCrispPath() {\n        const // Skip points where Y is not a number (#18636)\n        data = this.points.filter((d) => isNumber(d.y)), yAxis = this.yAxis, length = data.length, graphLineWidth = this.graph?.strokeWidth() || 0, reversedXAxis = this.xAxis.reversed, reversedYAxis = this.yAxis.reversed, stacking = this.options.stacking, path = [];\n        for (let i = 1; i < length; i++) {\n            if (!( // Skip lines that would pass over the null point (#18636)\n            this.options.connectNulls ||\n                isNumber(this.data[data[i].index - 1].y))) {\n                continue;\n            }\n            const box = data[i].box, prevPoint = data[i - 1], prevY = prevPoint.y || 0, prevBox = data[i - 1].box;\n            if (!box || !prevBox) {\n                continue;\n            }\n            const prevStack = yAxis.waterfall?.stacks[this.stackKey], isPos = prevY > 0 ? -prevBox.height : 0;\n            if (prevStack && prevBox && box) {\n                const prevStackX = prevStack[i - 1];\n                // Y position of the connector is different when series are\n                // stacked, yAxis is reversed and it also depends on point's\n                // value\n                let yPos;\n                if (stacking) {\n                    yPos = crisp(yAxis.translate(prevStackX.connectorThreshold || 0, false, true, false, true) +\n                        (reversedYAxis ? isPos : 0), graphLineWidth);\n                }\n                else {\n                    yPos = crisp(prevBox.y + (prevPoint.minPointLengthOffset || 0), graphLineWidth);\n                }\n                path.push([\n                    'M',\n                    (prevBox.x || 0) + (reversedXAxis ?\n                        0 :\n                        (prevBox.width || 0)),\n                    yPos\n                ], [\n                    'L',\n                    (box.x || 0) + (reversedXAxis ?\n                        (box.width || 0) :\n                        0),\n                    yPos\n                ]);\n            }\n            if (prevBox &&\n                path.length &&\n                ((!stacking && prevY < 0 && !reversedYAxis) ||\n                    (prevY > 0 && reversedYAxis))) {\n                const nextLast = path[path.length - 2];\n                if (nextLast && typeof nextLast[2] === 'number') {\n                    nextLast[2] += prevBox.height || 0;\n                }\n                const last = path[path.length - 1];\n                if (last && typeof last[2] === 'number') {\n                    last[2] += prevBox.height || 0;\n                }\n            }\n        }\n        return path;\n    }\n    // The graph is initially drawn with an empty definition, then updated with\n    // crisp rendering.\n    drawGraph() {\n        LineSeries.prototype.drawGraph.call(this);\n        this.graph?.animate({\n            d: this.getCrispPath()\n        });\n    }\n    // Waterfall has stacking along the x-values too.\n    setStackedPoints(axis) {\n        const series = this, options = series.options, waterfallStacks = axis.waterfall?.stacks, seriesThreshold = options.threshold || 0, stackKey = series.stackKey, xData = series.getColumn('x'), yData = series.getColumn('y'), xLength = xData.length;\n        let stackThreshold = seriesThreshold, interSum = stackThreshold, actualStackX, totalYVal = 0, actualSum = 0, prevSum = 0, statesLen, posTotal, negTotal, xPoint, yVal, x, alreadyChanged, changed;\n        // Function responsible for calculating correct values for stackState\n        // array of each stack item. The arguments are: firstS - the value for\n        // the first state, nextS - the difference between the previous and the\n        // newest state, sInx - counter used in the for that updates each state\n        // when necessary, sOff - offset that must be added to each state when\n        // they need to be updated (if point isn't a total sum)\n        // eslint-disable-next-line require-jsdoc\n        const calculateStackState = (firstS, nextS, sInx, sOff) => {\n            if (actualStackX) {\n                if (!statesLen) {\n                    actualStackX.stackState[0] = firstS;\n                    statesLen = actualStackX.stackState.length;\n                }\n                else {\n                    for (sInx; sInx < statesLen; sInx++) {\n                        actualStackX.stackState[sInx] += sOff;\n                    }\n                }\n                actualStackX.stackState.push(actualStackX.stackState[statesLen - 1] + nextS);\n            }\n        };\n        if (axis.stacking && waterfallStacks) {\n            // Code responsible for creating stacks for waterfall series\n            if (series.reserveSpace()) {\n                changed = waterfallStacks.changed;\n                alreadyChanged = waterfallStacks.alreadyChanged;\n                // In case of a redraw, stack for each x value must be emptied\n                // (only for the first series in a specific stack) and\n                // recalculated once more\n                if (alreadyChanged &&\n                    alreadyChanged.indexOf(stackKey) < 0) {\n                    changed = true;\n                }\n                if (!waterfallStacks[stackKey]) {\n                    waterfallStacks[stackKey] = {};\n                }\n                const actualStack = waterfallStacks[stackKey];\n                if (actualStack) {\n                    for (let i = 0; i < xLength; i++) {\n                        x = xData[i];\n                        if (!actualStack[x] || changed) {\n                            actualStack[x] = {\n                                negTotal: 0,\n                                posTotal: 0,\n                                stackTotal: 0,\n                                threshold: 0,\n                                stateIndex: 0,\n                                stackState: [],\n                                label: ((changed &&\n                                    actualStack[x]) ?\n                                    actualStack[x].label :\n                                    void 0)\n                            };\n                        }\n                        actualStackX = actualStack[x];\n                        yVal = yData[i];\n                        if (yVal >= 0) {\n                            actualStackX.posTotal += yVal;\n                        }\n                        else {\n                            actualStackX.negTotal += yVal;\n                        }\n                        // Points do not exist yet, so raw data is used\n                        xPoint = options.data[i];\n                        posTotal = actualStackX.absolutePos =\n                            actualStackX.posTotal;\n                        negTotal = actualStackX.absoluteNeg =\n                            actualStackX.negTotal;\n                        actualStackX.stackTotal = posTotal + negTotal;\n                        statesLen = actualStackX.stackState.length;\n                        if (xPoint?.isIntermediateSum) {\n                            calculateStackState(prevSum, actualSum, 0, prevSum);\n                            prevSum = actualSum;\n                            actualSum = seriesThreshold;\n                            // Swapping values\n                            stackThreshold ^= interSum;\n                            interSum ^= stackThreshold;\n                            stackThreshold ^= interSum;\n                        }\n                        else if (xPoint?.isSum) {\n                            calculateStackState(seriesThreshold, totalYVal, statesLen, 0);\n                            stackThreshold = seriesThreshold;\n                        }\n                        else {\n                            calculateStackState(stackThreshold, yVal, 0, totalYVal);\n                            if (xPoint) {\n                                totalYVal += yVal;\n                                actualSum += yVal;\n                            }\n                        }\n                        actualStackX.stateIndex++;\n                        actualStackX.threshold = stackThreshold;\n                        stackThreshold += actualStackX.stackTotal;\n                    }\n                }\n                waterfallStacks.changed = false;\n                if (!waterfallStacks.alreadyChanged) {\n                    waterfallStacks.alreadyChanged = [];\n                }\n                waterfallStacks.alreadyChanged.push(stackKey);\n            }\n        }\n    }\n    // Extremes for a non-stacked series are recorded in processData.\n    // In case of stacking, use Series.stackedYData to calculate extremes.\n    getExtremes() {\n        const stacking = this.options.stacking, yAxis = this.yAxis, waterfallStacks = yAxis.waterfall?.stacks;\n        let stackedYNeg, stackedYPos;\n        if (stacking && waterfallStacks) {\n            stackedYNeg = this.stackedYNeg = [];\n            stackedYPos = this.stackedYPos = [];\n            // The visible y range can be different when stacking is set to\n            // overlap and different when it's set to normal\n            if (stacking === 'overlap') {\n                objectEach(waterfallStacks[this.stackKey], function (stackX) {\n                    stackedYNeg.push(arrayMin(stackX.stackState));\n                    stackedYPos.push(arrayMax(stackX.stackState));\n                });\n            }\n            else {\n                objectEach(waterfallStacks[this.stackKey], function (stackX) {\n                    stackedYNeg.push(stackX.negTotal + stackX.threshold);\n                    stackedYPos.push(stackX.posTotal + stackX.threshold);\n                });\n            }\n            return {\n                dataMin: arrayMin(stackedYNeg),\n                dataMax: arrayMax(stackedYPos)\n            };\n        }\n        // When not stacking, data extremes have already been computed in the\n        // processData function.\n        return {\n            dataMin: this.dataMin,\n            dataMax: this.dataMax\n        };\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nWaterfallSeries.defaultOptions = merge(ColumnSeries.defaultOptions, WaterfallSeriesDefaults);\nWaterfallSeries.compose = WaterfallAxis.compose;\nextend(WaterfallSeries.prototype, {\n    pointValKey: 'y',\n    // Property needed to prevent lines between the columns from disappearing\n    // when negativeColor is used.\n    showLine: true,\n    pointClass: WaterfallPoint\n});\n// Translate data points from raw values\naddEvent(WaterfallSeries, 'afterColumnTranslate', function () {\n    const series = this, { options, points, yAxis } = series, minPointLength = pick(options.minPointLength, 5), halfMinPointLength = minPointLength / 2, threshold = options.threshold || 0, stacking = options.stacking, actualStack = yAxis.waterfall?.stacks[series.stackKey], processedYData = series.getColumn('y', true);\n    let previousIntermediate = threshold, previousY = threshold, y, total, yPos, hPos;\n    for (let i = 0; i < points.length; i++) {\n        const point = points[i], yValue = processedYData[i], shapeArgs = point.shapeArgs, box = extend({\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        }, shapeArgs || {});\n        point.box = box;\n        const range = [0, yValue], pointY = point.y || 0;\n        // Code responsible for correct positions of stacked points\n        // starts here\n        if (stacking) {\n            if (actualStack) {\n                const actualStackX = actualStack[i];\n                if (stacking === 'overlap') {\n                    total =\n                        actualStackX.stackState[actualStackX.stateIndex--];\n                    y = pointY >= 0 ? total : total - pointY;\n                    if (ownProp(actualStackX, 'absolutePos')) {\n                        delete actualStackX.absolutePos;\n                    }\n                    if (ownProp(actualStackX, 'absoluteNeg')) {\n                        delete actualStackX.absoluteNeg;\n                    }\n                }\n                else {\n                    if (pointY >= 0) {\n                        total = actualStackX.threshold +\n                            actualStackX.posTotal;\n                        actualStackX.posTotal -= pointY;\n                        y = total;\n                    }\n                    else {\n                        total = actualStackX.threshold +\n                            actualStackX.negTotal;\n                        actualStackX.negTotal -= pointY;\n                        y = total - pointY;\n                    }\n                    if (!actualStackX.posTotal) {\n                        if (isNumber(actualStackX.absolutePos) &&\n                            ownProp(actualStackX, 'absolutePos')) {\n                            actualStackX.posTotal =\n                                actualStackX.absolutePos;\n                            delete actualStackX.absolutePos;\n                        }\n                    }\n                    if (!actualStackX.negTotal) {\n                        if (isNumber(actualStackX.absoluteNeg) &&\n                            ownProp(actualStackX, 'absoluteNeg')) {\n                            actualStackX.negTotal =\n                                actualStackX.absoluteNeg;\n                            delete actualStackX.absoluteNeg;\n                        }\n                    }\n                }\n                if (!point.isSum) {\n                    // The connectorThreshold property is later used in\n                    // getCrispPath function to draw a connector line in a\n                    // correct place\n                    actualStackX.connectorThreshold =\n                        actualStackX.threshold + actualStackX.stackTotal;\n                }\n                if (yAxis.reversed) {\n                    yPos = (pointY >= 0) ? (y - pointY) : (y + pointY);\n                    hPos = y;\n                }\n                else {\n                    yPos = y;\n                    hPos = y - pointY;\n                }\n                point.below = yPos <= threshold;\n                box.y = yAxis.translate(yPos, false, true, false, true);\n                box.height = Math.abs(box.y -\n                    yAxis.translate(hPos, false, true, false, true));\n                const dummyStackItem = yAxis.waterfall?.dummyStackItem;\n                if (dummyStackItem) {\n                    dummyStackItem.x = i;\n                    dummyStackItem.label = actualStack[i].label;\n                    dummyStackItem.setOffset(series.pointXOffset || 0, series.barW || 0, series.stackedYNeg[i], series.stackedYPos[i], void 0, this.xAxis);\n                }\n            }\n        }\n        else {\n            // Up points\n            y = Math.max(previousY, previousY + pointY) + range[0];\n            box.y = yAxis.translate(y, false, true, false, true);\n            // Sum points\n            if (point.isSum) {\n                box.y = yAxis.translate(range[1], false, true, false, true);\n                box.height = Math.min(yAxis.translate(range[0], false, true, false, true), yAxis.len) - box.y; // #4256\n                point.below = range[1] <= threshold;\n            }\n            else if (point.isIntermediateSum) {\n                if (pointY >= 0) {\n                    yPos = range[1] + previousIntermediate;\n                    hPos = previousIntermediate;\n                }\n                else {\n                    yPos = previousIntermediate;\n                    hPos = range[1] + previousIntermediate;\n                }\n                if (yAxis.reversed) {\n                    // Swapping values\n                    yPos ^= hPos;\n                    hPos ^= yPos;\n                    yPos ^= hPos;\n                }\n                box.y = yAxis.translate(yPos, false, true, false, true);\n                box.height = Math.abs(box.y -\n                    Math.min(yAxis.translate(hPos, false, true, false, true), yAxis.len));\n                previousIntermediate += range[1];\n                point.below = yPos <= threshold;\n                // If it's not the sum point, update previous stack end position\n                // and get shape height (#3886)\n            }\n            else {\n                box.height = yValue > 0 ?\n                    yAxis.translate(previousY, false, true, false, true) - box.y :\n                    yAxis.translate(previousY, false, true, false, true) - yAxis.translate(previousY - yValue, false, true, false, true);\n                previousY += yValue;\n                point.below = previousY < threshold;\n            }\n            // #3952 Negative sum or intermediate sum not rendered correctly\n            if (box.height < 0) {\n                box.y += box.height;\n                box.height *= -1;\n            }\n        }\n        point.plotY = box.y;\n        point.yBottom = box.y + box.height;\n        if (box.height <= minPointLength && !point.isNull) {\n            box.height = minPointLength;\n            box.y -= halfMinPointLength;\n            point.yBottom = box.y + box.height;\n            point.plotY = box.y;\n            if (pointY < 0) {\n                point.minPointLengthOffset = -halfMinPointLength;\n            }\n            else {\n                point.minPointLengthOffset = halfMinPointLength;\n            }\n        }\n        else {\n            // #8024, empty gaps in the line for null data\n            if (point.isNull) {\n                box.width = 0;\n            }\n            point.minPointLengthOffset = 0;\n        }\n        // Correct tooltip placement (#3014)\n        const tooltipY = point.plotY + (point.negative ? box.height : 0);\n        if (point.below) { // #15334\n            point.plotY += box.height;\n        }\n        if (point.tooltipPos) {\n            if (series.chart.inverted) {\n                point.tooltipPos[0] = yAxis.len - tooltipY;\n            }\n            else {\n                point.tooltipPos[1] = tooltipY;\n            }\n        }\n        // Check point position after recalculation (#16788)\n        point.isInside = this.isPointInside(point);\n        // Crisp vector coordinates\n        const crispBottom = crisp(point.yBottom, series.borderWidth);\n        box.y = crisp(box.y, series.borderWidth);\n        box.height = crispBottom - box.y;\n        merge(true, point.shapeArgs, box);\n    }\n}, { order: 2 });\nSeriesRegistry.registerSeriesType('waterfall', WaterfallSeries);\n/* *\n *\n * Export\n *\n * */\nexport default WaterfallSeries;\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}